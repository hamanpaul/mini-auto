/*

Copyright (c) 2008 Mars Semiconductor Corp.

Module Name:

	usbvc.c

Abstract:

   	USB Video Class routine.

Environment:

    	ARM RealView Developer Suite

Revision History:

	2005/08/26	David Tsai	Create

*/

#include "general.h"

#include "task.h"
#include "board.h"
#include "usb.h"
#include "usbvc.h"
#include "usbreg.h"
#include "usbdev.h"
#include "usbapievt.h"
#include "usbintevt.h"
#include "sysapi.h"
#include "rfiuapi.h"
#include "uiapi.h"
#include "encrptyapi.h"
#include "MemoryPool.h"

#if USB2WIFI_SUPPORT
#define MAX_AV_CH 4
#define header_size 26
#define INT_IRQ_MASK_USB		0x00002000
#define INT_IRQ_INPUT_USB		0x00002000
#define mENABLE_USB_IRQ     {OS_ENTER_CRITICAL();   IntIrqMask&=~INT_IRQ_MASK_USB;  OS_EXIT_CRITICAL();}
#define USB_CONTROL_PIPE_SET_COMMAND_DONE	(DeviceCXConfigFIFOEmpS|=1)	
/*
 *********************************************************************************************************
 * Function prototype
 *********************************************************************************************************
 */

s32 usbVcInit(void);
void usbVcTask(void*);

/*
 *********************************************************************************************************
 * Constant
 *********************************************************************************************************
 */

/* define debug print */
//#define usbVcDebugPrint 			printf
static unsigned char MPEG4_NoCam_QVGA[] =    
{
    0x00,0x00,0x01,0xB6,0x10,0x00,0x18,0x34,0x60,0xAA,0x6D,
    0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,
    0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,
    0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,
    0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,
    0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,
    0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,
    0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,
    0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,
    0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,
    0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,
    0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,
    0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,
    0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,
    0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,
    0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,
    0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,
    0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,
    0x7F,0x1B,0x6D,0xFC,0x56,0xD8,0xD4,0x14,0xA0,0xC0,0xA7,0x06,0x05,0x31,0x78,0x38,
    0x10,0x81,0xE0,0xFF,0xDD,0x06,0x58,0x11,0x01,0x80,0xB0,0x3C,0x2F,0xFE,0x2C,0x08,
    0x20,0xE0,0x55,0x83,0x15,0x03,0x07,0x42,0x08,0x76,0x04,0x83,0xD3,0xDF,0x4B,0x60,
    0xD5,0x03,0xE0,0xA5,0x07,0x80,0xFE,0x34,0x10,0x83,0xE0,0x60,0x36,0x5E,0x08,0x80,
    0x8A,0x39,0x0F,0x81,0x96,0x04,0x26,0x54,0x88,0x05,0x83,0x90,0x60,0xE9,0x86,0xF9,
    0xC1,0xCF,0x86,0xFC,0xEF,0x56,0xE9,0xD0,0x94,0x0C,0x90,0x1E,0x07,0xFA,0x10,0x62,
    0xD6,0x41,0xE0,0x7F,0xC1,0x07,0x83,0x80,0x64,0x15,0x5F,0x1C,0x03,0xC1,0xC0,0x52,
    0x0E,0x05,0x38,0x82,0xA8,0xB0,0x1E,0x0E,0x01,0xB0,0x56,0x83,0x22,0x0F,0xC6,0xE1,
    0xE1,0xB2,0xB0,0xB3,0xDF,0x00,0x00,0x99,0xCC,0xA4,0x15,0x4C,0xF2,0x50,0x82,0x10,
    0x87,0x5F,0x8D,0x0F,0x44,0x71,0x28,0x7C,0xDD,0xC2,0xD9,0xE4,0xA3,0xF5,0x4A,0xBF,
    0x7D,0x6E,0xC5,0x33,0x1B,0xFE,0x5B,0x96,0xE6,0xC5,0x28,0xBB,0x29,0x32,0xA1,0x04,
    0x7F,0x5A,0x04,0x01,0x1C,0x4B,0x1E,0x33,0x96,0xF8,0x20,0x0F,0xC7,0xE5,0xC9,0xFC,
    0x58,0xCF,0xBB,0x85,0xDF,0x65,0x53,0x38,0x37,0x69,0xBC,0x1B,0x7F,0x06,0xFE,0xD8,
    0x6E,0x3F,0xE9,0x6C,0x60,0x0C,0x5C,0x10,0xD5,0x8E,0xC1,0x98,0x1F,0x04,0x30,0x86,
    0x9F,0x2B,0x77,0x07,0xBF,0x4A,0x97,0xE2,0x02,0xAF,0x4F,0x2A,0x1F,0xA5,0xF1,0x6E,
    0x96,0x46,0x98,0xF6,0x79,0x86,0xA2,0x9D,0xE4,0x9C,0x8A,0x75,0x0B,0xD8,0x28,0x42,
    0x0E,0xE8,0x29,0x04,0xB1,0xE8,0x29,0x04,0x71,0x2B,0x53,0xB1,0xAA,0xBD,0xE2,0xF8,
    0x3F,0x11,0xAA,0x46,0xBF,0x52,0xA4,0x1C,0xE7,0xD5,0x97,0xFC,0x19,0x46,0x68,0x7C,
    0xD8,0xD9,0x9D,0xE8,0x7B,0x8A,0x03,0xDD,0x16,0x7D,0x2D,0xC0,0x28,0x84,0x96,0x41,
    0xE0,0x60,0x3B,0x2E,0x12,0xC1,0x42,0x3B,0x1F,0x08,0x20,0xCB,0x82,0x28,0xF4,0x11,
    0x44,0xA0,0x53,0x03,0xC1,0xFF,0xD2,0xCB,0x0C,0x03,0x15,0x8F,0xB4,0x19,0x40,0xD8,
    0x70,0xD0,0x79,0xA0,0x5C,0x3C,0xD0,0x56,0x9F,0x17,0x83,0x80,0x3C,0x0E,0x0E,0x7C,
    0xA8,0x18,0x11,0x44,0x60,0xFD,0x91,0x00,0x70,0xC0,0x32,0x94,0x83,0x96,0xC0,0xDC,
    0xCD,0x4C,0x59,0xE1,0xCA,0x9F,0x87,0xF9,0xFF,0x6B,0x0A,0x25,0x1C,0xCF,0xE5,0xCE,
    0xA9,0x77,0xC5,0x6C,0x5E,0x33,0xF8,0x28,0x41,0x01,0x8F,0xFD,0xA6,0xC0,0x3C,0x20,
    0x34,0xDB,0x5B,0xBE,0x6D,0xAF,0x89,0x25,0xD9,0xFF,0x7F,0x2A,0x8D,0xCD,0xCD,0x67,
    0xB9,0xB9,0x56,0xDC,0xAB,0xCA,0x47,0xF1,0x1B,0x24,0xA9,0x3A,0xA2,0xF6,0xB1,0x5A,
    0x45,0x6C,0x27,0x55,0xFE,0xA8,0x65,0x53,0x78,0xCB,0x5A,0xA3,0x6E,0x6A,0x8F,0xFA,
    0xDC,0xBC,0xD9,0x72,0xF2,0xAD,0xB2,0xC2,0x34,0x7E,0x96,0xC1,0xCA,0x10,0x80,0xE8,
    0x3C,0x07,0xF0,0x60,0x1A,0xAB,0x52,0x88,0x49,0xC0,0xDA,0xAF,0x33,0x55,0x6F,0xC7,
    0x00,0xA2,0x60,0x0C,0xE6,0x7B,0xF7,0x38,0xAF,0xCD,0x68,0xD9,0xBC,0xBD,0xE7,0x17,
    0x47,0xD3,0xE1,0x70,0x18,0xB8,0x18,0x7E,0x07,0x59,0x03,0xAD,0x83,0x78,0x1B,0xED,
    0x67,0x84,0xBF,0x63,0x63,0x86,0x47,0x03,0x85,0x7F,0x56,0xD7,0x55,0xEB,0x4C,0xE2,
    0xA9,0x4B,0xB7,0x34,0xBA,0xD6,0x53,0x27,0x6A,0x2A,0x62,0xB0,0xAA,0x2E,0x9F,0x53,
    0xF8,0x5B,0xEF,0x00,0x00,0x9B,0x4C,0xA4,0x15,0x4C,0x3C,0x02,0x88,0x19,0xB6,0xF4,
    0x21,0x83,0x0F,0xFC,0x01,0xA2,0x1A,0x66,0x07,0xC2,0x40,0x41,0x83,0xE1,0x2A,0xA5,
    0xA3,0xE1,0xF7,0x9A,0x95,0x38,0x43,0x82,0x04,0x6F,0x8C,0x0E,0x76,0xB4,0x93,0x00,
    0xBE,0xFF,0xFC,0x6A,0xE8,0x72,0xF0,0x9A,0xA9,0x3A,0xA2,0xF6,0xB1,0x5A,0x45,0x6C,
    0x27,0x55,0xFE,0xA8,0x65,0x53,0x78,0xCB,0x5A,0xA3,0x6E,0x6A,0x8F,0xFA,0xDC,0xBC,
    0xD9,0x72,0xF2,0xAD,0xB2,0xC2,0x3F,0xA5,0xB3,0x09,0x42,0x08,0x42,0x1D,0x7E,0x34,
    0x3D,0x11,0xC4,0xA1,0xF3,0x77,0x0B,0x67,0x92,0x8F,0xD5,0x2A,0xFD,0xF5,0xBB,0x14,
    0xCC,0x6F,0xF9,0x6E,0x5B,0x9B,0x14,0xA2,0xEC,0xA4,0xC5,0xC0,0xDA,0xA0,0xF8,0x14,
    0xE1,0xFB,0x00,0x88,0x20,0x01,0xB0,0x45,0x1C,0xE0,0x7C,0x1F,0x28,0x1C,0x87,0xE2,
    0x0F,0x4B,0x04,0x02,0xC0,0xF4,0x72,0xA5,0x42,0x82,0xBE,0x9E,0xFA,0x5B,0x0F,0x40,
    0x70,0x18,0x10,0x41,0x56,0x0A,0x50,0x86,0x25,0x09,0x69,0xC0,0xE2,0x40,0x84,0x90,
    0x1B,0xA0,0xDC,0x1E,0x8E,0x44,0x00,0x36,0x20,0x0F,0x7C,0xC2,0x60,0x62,0xB6,0x4B,
    0xEA,0x66,0xC7,0x29,0xB7,0x5B,0x03,0x19,0x0B,0x78,0x5B,0x85,0x5D,0x70,0x47,0xF8,
    0xFC,0x7C,0xD2,0x40,0x6E,0xB6,0x5E,0x9B,0xC3,0xEB,0x9E,0xF8,0x29,0xFE,0xAD,0xAC,
    0x48,0x58,0xCF,0x07,0x1F,0x0F,0xEE,0x8E,0x14,0x36,0xA7,0x0B,0x35,0x4F,0x35,0x4E,
    0x73,0xA7,0xFE,0x23,0x76,0x5C,0x24,0x89,0x42,0x59,0x68,0x32,0x81,0xD8,0xF8,0x7A,
    0x38,0x50,0x39,0x05,0x32,0x56,0x13,0x96,0x16,0xA9,0x50,0x5A,0x20,0x6E,0xA8,0x52,
    0xA3,0x54,0x75,0x1A,0x8B,0xC2,0x22,0x9F,0x4B,0x61,0x80,0x18,0x4B,0x12,0xCB,0xC2,
    0x10,0x36,0x09,0x23,0xB1,0xD3,0x61,0xF2,0x55,0x40,0xA6,0x1C,0x36,0x58,0xD7,0xF8,
    0x39,0x1D,0xA6,0x63,0x4A,0x99,0xCF,0xFA,0xF7,0xDF,0xD8,0xBE,0x54,0x7D,0x8B,0x9D,
    0x0F,0x49,0x87,0x60,0xF0,0x1F,0xBA,0xEA,0xA5,0x42,0x3E,0x40,0x53,0x8F,0xAB,0x4D,
    0x0F,0x73,0x07,0x00,0x81,0x40,0xDA,0x6B,0x91,0x5C,0x82,0x02,0xA2,0xC1,0xED,0x10,
    0x7C,0x0C,0x81,0x85,0x09,0x57,0x51,0xEE,0x36,0x7B,0xE9,0x6C,0x28,0x03,0x08,0x40,
    0xCA,0xE8,0x33,0x23,0xC5,0x7A,0x9F,0xCC,0x30,0x3B,0x1F,0x33,0x31,0x5F,0x95,0x0E,
    0x47,0x15,0xA6,0x7B,0xA9,0x99,0xC1,0xCA,0x95,0x0A,0x54,0x32,0xD5,0xF0,0x82,0xCE,
    0xF5,0x55,0x6E,0xA8,0x8D,0xFB,0x1C,0x68,0x18,0x0E,0x09,0x20,0xA1,0x12,0xC1,0x83,
    0xF0,0x70,0x06,0x8E,0xC7,0xC3,0xD1,0xC0,0x37,0x00,0xD0,0x29,0x92,0x80,0x72,0x72,
    0xC2,0xD0,0x53,0x88,0x25,0xA0,0xC0,0xA6,0xDD,0x50,0xA5,0x43,0x4A,0x03,0xF4,0x7C,
    0xA3,0x84,0x42,0xDF,0x7F,0x00,0x00,0x9C,0xCC,0xA4,0x15,0x4C,0xF2,0x50,0x82,0x10,
    0x87,0x5F,0x8D,0x0F,0x44,0x71,0x28,0x7C,0xDD,0xC2,0xD9,0xE4,0xA3,0xF5,0x4A,0xBF,
    0x7D,0x6E,0xC5,0x33,0x1B,0xFE,0x5B,0x96,0xE6,0xC5,0x28,0xBB,0x29,0x31,0x4F,0x7F,
    0xCC,0xFB,0xCD,0xB5,0xFC,0x6D,0xA6,0xF2,0x7F,0xDF,0xF6,0xCD,0xF7,0xFD,0xB1,0x4E,
    0x7F,0x36,0x2D,0xB9,0xB1,0x7C,0xD8,0xB5,0x87,0x7E,0x96,0xC6,0x00,0xE0,0x50,0x82,
    0x01,0x66,0x37,0x40,0x3C,0x20,0x0E,0x37,0x77,0xD8,0xD8,0x30,0xE4,0xB8,0xB3,0x7E,
    0xD4,0xF6,0xB7,0x93,0x47,0x3C,0xBB,0xE8,0xDB,0x57,0xF9,0x17,0x91,0xBF,0x74,0x3B,
    0x72,0x49,0x02,0x08,0x42,0x1D,0xFE,0xB4,0x3C,0x11,0xC4,0xA1,0xFB,0x73,0x0B,0x6F,
    0x92,0x0F,0xD5,0x2B,0xFC,0xF4,0xB2,0x5D,0xB8,0xD7,0xF6,0xCC,0xEE,0xE4,0x52,0x8B,
    0xB6,0x13,0xFC,0x46,0xE0,0xBC,0x49,0x12,0x84,0xA2,0xC0,0x65,0x23,0xB1,0xF0,0xF0,
    0x72,0xA4,0x70,0x0A,0x74,0xAC,0x26,0x1C,0xA8,0xE2,0x92,0xC1,0x07,0x71,0x4A,0x85,
    0x38,0xA7,0x88,0x94,0xCE,0x91,0x94,0xF8,0xDB,0x6F,0xE3,0x6D,0xBF,0x8C,0x15,0x4D,
    0xBF,0x8D,0xB6,0xFE,0xC1,0xAA,0x0F,0x01,0xFB,0x38,0x3C,0x24,0x06,0xA0,0xF1,0x1F,
    0xEE,0x83,0xE6,0x40,0x3E,0x0A,0xDF,0xFF,0xCD,0x7B,0xED,0xB7,0xFC,0x69,0xA6,0xB3,
    0x7F,0xFF,0xFF,0x66,0x7B,0xDE,0xC8,0xA7,0x7F,0xFD,0xAB,0x66,0x64,0x5F,0x76,0xAD,
    0x22,0xEF,0x28,0x0F,0x01,0xFB,0xD8,0x90,0x25,0x89,0x60,0xE0,0x40,0x06,0x50,0x3A,
    0x1F,0x8F,0x47,0x00,0xC2,0x08,0xE4,0x14,0xC9,0x19,0x4E,0x58,0xA4,0x18,0xB1,0x41,
    0x68,0x81,0x9A,0xA1,0x4A,0x8D,0x51,0xD1,0xBF,0x29,0xA7,0x9B,0x08,0x29,0x3E,0x3B,
    0x08,0x42,0x38,0xF1,0xAB,0x91,0xB1,0xF8,0x94,0x3F,0x49,0xEB,0xFE,0xCF,0x4F,0xAB,
    0x55,0xF6,0xB2,0xED,0x93,0x6A,0x89,0x74,0xAF,0x99,0x6F,0x10,0x3F,0xEC,0x1F,0x82,
    0x00,0x30,0x21,0x26,0x05,0x63,0x23,0xD0,0x66,0xC4,0x9F,0xE2,0x31,0xF8,0x94,0x98,
    0x4A,0x2E,0x2E,0x67,0xAB,0xC1,0xC2,0xA1,0xDD,0xA5,0xFE,0x2C,0x94,0x71,0xF1,0xC8,
    0xDF,0xF9,0xBB,0x81,0xE5,0x30,0x25,0x06,0x08,0x0A,0xDB,0xA0,0xC9,0x81,0x80,0xEA,
    0x4B,0xA0,0xCB,0x30,0x23,0x36,0xAF,0xDE,0xE6,0x2C,0xCA,0x71,0x20,0x4B,0xF3,0x3A,
    0xA7,0x8A,0x6A,0x9C,0x2E,0x55,0x39,0x6D,0x90,0xB0,0xAA,0x4B,0xBA,0x7C,0x5E,0x07,
    0xBE,0x0C,0x3F,0x06,0x69,0x50,0xEC,0xB8,0x7C,0x0C,0x99,0x90,0x65,0x3F,0x67,0xF8,
    0x0C,0x08,0xA0,0xC0,0x88,0x9D,0x3A,0xB6,0x3D,0x70,0xB1,0x96,0x18,0x56,0xD6,0x6B,
    0x09,0xD8,0x10,0x58,0x54,0x9D,0x20,0x7B,0xF2,0xE5,0x39,0xFD,0xAD,0x25,0xC6,0x72,
    0x85,0xC5,0xC1,0x84,0x80,0x80,0x10,0xD3,0x02,0x10,0x30,0x41,0x69,0x38,0x8C,0x25,
    0xAA,0x6D,0x28,0x40,0x9E,0x49,0xE6,0x47,0xC9,0xDA,0xFA,0x7F,0x82,0x98,0x20,0xC5,
    0x0A,0xB3,0xFE,0x95,0x9D,0xEF,0xFD,0x14,0x7B,0xB7,0xBF,0xC8,0x85,0xDE,0x00,0x00,
    0x9F,0x0C,0xB0,0xE5,0xE0,0x3A,0x23,0x84,0x31,0x20,0x03,0x01,0x87,0x89,0xB7,0x13,
    0x24,0x03,0x61,0xF5,0x2B,0xDE,0x0F,0xD2,0x8F,0x44,0x9F,0xB6,0xC6,0xA5,0xB3,0x2D,
    0x89,0x95,0x55,0x79,0xC6,0x33,0x3E,0x1E,0xE5,0x4F,0xA3,0x9F,0x87,0xD8,0x01,0x40,
    0xB5,0x06,0x6C,0x0F,0x24,0x04,0x20,0x60,0x51,0x0F,0x44,0x84,0x99,0x80,0x63,0x04,
    0x80,0xFD,0xB9,0x8A,0x2A,0x54,0xA0,0xC3,0x91,0xD4,0x65,0x2F,0xFB,0xBF,0xAA,0x59,
    0xB1,0x15,0xFE,0x8E,0x3C,0xA1,0x56,0x51,0xC7,0xBD,0x1C,0x15,0xC1,0xE0,0x60,0x61,
    0xA5,0xE0,0xC2,0x31,0x72,0x5F,0x24,0x64,0x7C,0x08,0x65,0xC0,0xC3,0x94,0xAA,0xD3,
    0x36,0x99,0xB8,0xAC,0x77,0x03,0xFF,0xE4,0x55,0xAD,0x5C,0xA9,0x71,0x90,0x34,0x99,
    0x8A,0x25,0x7B,0x20,0xE2,0xEE,0xFC,0x0C,0x74,0x7F,0xA9,0xCC,0x1B,0x57,0xF0,0x43,
    0x03,0xA0,0xF0,0x10,0x38,0x8F,0x53,0x0F,0x44,0x21,0x2F,0x02,0x1A,0xAD,0x1F,0x0F,
    0x23,0x5A,0xA8,0xBE,0x8F,0xC7,0x7E,0x4C,0x5E,0x24,0x7E,0x0F,0xC4,0x06,0xF0,0x0D,
    0xEE,0xEF,0x94,0x87,0xFA,0x1E,0xCD,0x6D,0x86,0x59,0xEE,0x4B,0x7C,0x2C,0xFB,0x1C,
    0x03,0xC2,0x41,0x3A,0x0F,0xAB,0xFE,0x08,0xDC,0xBC,0x18,0x21,0x0F,0x87,0xC0,0xC1,
    0x0B,0x01,0x4A,0xDA,0xB4,0xF4,0x49,0xD4,0xC3,0xE4,0xA5,0x9E,0x6D,0xAA,0x3C,0x2C,
    0x1D,0x97,0xAA,0x8D,0x45,0x15,0x26,0x32,0xA6,0x17,0x2B,0xC2,0xD0,0x56,0xF2,0x27,
    0x53,0xCB,0xBE,0x23,0x28,0x0C,0x38,0x12,0xC1,0xE0,0x60,0x89,0x06,0x2C,0x06,0x50,
    0x3F,0x06,0x52,0x0F,0x0B,0x00,0xB8,0x22,0x32,0x0A,0x70,0x78,0x3F,0xF2,0x44,0x10,
    0x60,0xE9,0x40,0x82,0x0C,0x88,0x0C,0x8D,0x83,0xA2,0xB2,0x20,0x96,0x01,0xE3,0xE1,
    0xFB,0x60,0xF0,0x10,0x3A,0xB4,0x3C,0xF1,0x72,0x7F,0x8F,0xC1,0x81,0x10,0x14,0x1E,
    0x05,0x36,0x2A,0x6F,0x52,0x96,0xB4,0xD8,0x90,0x39,0xC0,0xFA,0x4A,0xDA,0x9F,0x28,
    0xD2,0xDC,0x51,0xDC,0x51,0x7A,0x89,0xFF,0x64,0x07,0xE2,0x18,0xFD,0x50,0x3C,0x04,
    0x11,0x21,0x01,0x43,0x3B,0x68,0xED,0x3F,0xC4,0x66,0xDB,0xDF,0xB6,0x39,0x83,0xEC,
    0x4A,0x23,0xD1,0xC7,0xB6,0x6C,0x2A,0x1C,0x0F,0xBC,0x5C,0x59,0xAA,0x7C,0x0A,0xAB,
    0xF5,0x4A,0x39,0x61,0xE3,0xE2,0x48,0x30,0x40,0x1F,0x0F,0x81,0x84,0x85,0x40,0xA5,
    0xC1,0xFA,0x7D,0x1F,0xD4,0xC2,0x50,0xFD,0xBF,0x6C,0x68,0x11,0x2F,0x84,0xBF,0xB5,
    0x04,0x0F,0x64,0x83,0x9F,0x6B,0x00,0x8B,0xE0,0x56,0xEB,0x2D,0xC6,0xC7,0x1F,0x05,
    0x67,0x84,0x18,0x0C,0x16,0x0C,0xBC,0x0A,0x40,0x6E,0x83,0xC0,0x40,0xE6,0x3A,0x1E,
    0x08,0xEC,0x83,0x80,0x31,0x58,0xF9,0x94,0xE5,0xF9,0xA2,0x38,0x30,0x18,0x69,0xA5,
    0x60,0xCA,0x47,0x7E,0x63,0xC3,0xD0,0xFE,0x4D,0x69,0x84,0xF8,0x5E,0xA2,0x6A,0xDF,
    0x97,0xED,0x37,0x91,0x90,0x64,0x41,0x78,0x62,0x03,0xAA,0xC1,0x84,0x76,0x01,0x8B,
    0x95,0x0E,0x84,0x95,0x42,0x53,0x40,0x19,0x30,0x78,0xD7,0x87,0xFE,0x4E,0x24,0x7D,
    0x58,0xFD,0x56,0x73,0xE3,0xC5,0x59,0x58,0x1D,0xB7,0x15,0xE4,0x98,0xC7,0xF3,0x4B,
    0x93,0x08,0x3A,0xC2,0x61,0xCB,0x6D,0xEF,0x81,0x17,0x45,0xBE,0x00,0x00,0x9F,0xCC,
    0x94,0x2A,0x03,0x02,0x90,0x1E,0x0E,0x04,0xF0,0x3C,0x0F,0x11,0xFF,0x48,0x3C,0x5F,
    0xFC,0x20,0xC6,0x42,0xAB,0x06,0x05,0x20,0x3C,0x1C,0x09,0xE0,0x78,0x1E,0x23,0xFE,
    0x90,0x78,0xBF,0xF8,0x41,0x8C,0xBF,0x98,0x1E,0x80,0xC9,0x01,0x80,0xE8,0x3C,0x0C,
    0x07,0xE2,0x53,0x23,0xA0,0x60,0xF8,0x1B,0xA3,0x91,0xFF,0xCB,0xC7,0x20,0xDD,0x03,
    0x5C,0x2D,0x61,0x53,0x05,0x8A,0x01,0x4C,0xAF,0xBC,0x0F,0xBA,0xA5,0x48,0x8A,0x89,
    0x6E,0xBC,0x40,0x0C,0xA9,0x20,0x41,0x04,0x30,0x61,0x27,0xE0,0xC5,0xE3,0xF1,0xD3,
    0x22,0x42,0x41,0x02,0xA7,0x61,0x4B,0x1F,0x8D,0x2B,0x8C,0x8F,0x01,0x8B,0x07,0xCD,
    0x30,0xDB,0x23,0x8A,0xAC,0x18,0x3C,0xA0,0x6F,0xE5,0xEC,0x7B,0x5A,0xB7,0xC1,0xD3,
    0x11,0x3B,0x47,0x82,0x18,0x3C,0x04,0x0F,0x63,0xE1,0xF8,0xE8,0x10,0x8B,0xDA,0x1E,
    0x97,0x27,0x1F,0x37,0x42,0x0A,0xBF,0xCF,0x25,0x54,0xDA,0xAF,0xDF,0x52,0xE1,0xD6,
    0x4F,0xCC,0x6E,0x65,0xB9,0x6E,0x6C,0x52,0x8B,0xB2,0x93,0x04,0x7F,0xB1,0x80,0x84,
    0x0C,0x91,0x50,0x33,0x60,0xC9,0xC1,0x87,0xE0,0xAB,0x65,0x96,0x92,0x0F,0x04,0x71,
    0xEF,0x41,0x13,0xF9,0xE5,0x75,0x3A,0x71,0x25,0x38,0x80,0x05,0xD5,0x2B,0xF5,0x62,
    0x79,0x52,0xB2,0xD1,0xB6,0xA9,0x10,0x39,0xD8,0x5A,0x7A,0x81,0x93,0x7F,0xE0,0xA0,
    0x04,0x30,0x61,0x0D,0xA1,0xF7,0xF7,0x5A,0x08,0x41,0x00,0x10,0xFE,0xC7,0x95,0xED,
    0xBE,0x67,0xE1,0x00,0x7F,0x90,0xBB,0xE9,0x71,0xA1,0xC4,0xFE,0xC8,0xA6,0x5D,0xC2,
    0xCB,0xC6,0xD9,0x9E,0x2C,0x2D,0x78,0x78,0x06,0x12,0x07,0xC3,0xF4,0x80,0x86,0x0C,
    0x10,0x5B,0x4E,0x5C,0x9D,0x53,0x49,0x42,0x0C,0xFA,0x4F,0xB2,0xA9,0xB6,0xBC,0x9F,
    0xC0,0xAB,0x08,0x34,0xB5,0x56,0xFE,0x48,0xCE,0x73,0xFE,0xAA,0x7D,0xD9,0xCF,0xE5,
    0x11,0x5C,0x3A,0x05,0x00,0x20,0x0F,0xD9,0x06,0x1F,0x83,0x09,0x70,0x7A,0x3C,0x12,
    0xD3,0x09,0x42,0x1A,0x60,0x51,0xA4,0x85,0xF5,0x33,0x6C,0x7B,0xFE,0x1E,0x88,0xED,
    0x72,0xA6,0x56,0xDB,0x55,0x8D,0xDD,0x61,0x4F,0xDA,0x0E,0xE5,0x91,0x4F,0x34,0xC7,
    0xDB,0x06,0x12,0x81,0x84,0x81,0xF0,0x32,0x71,0xF0,0xF4,0x21,0x84,0x31,0xE8,0x96,
    0x39,0x06,0x2D,0xFB,0x00,0xAC,0xFB,0x45,0xBB,0xF1,0xC3,0x49,0xD9,0x56,0xAD,0x94,
    0xED,0x27,0xAC,0xEB,0x35,0x3C,0x41,0x96,0x5C,0xDD,0xDD,0x6C,0x72,0x0C,0x70,0x5E,
    0x0C,0x07,0x35,0x2E,0xB2,0x0D,0xA0,0xC0,0x78,0x4B,0x6F,0x5B,0x49,0x89,0x84,0xB6,
    0x94,0xB0,0xDA,0xC9,0x2E,0x2B,0x06,0x2C,0x1D,0xC2,0xE1,0xCB,0x1D,0x50,0x9E,0xA5,
    0x0F,0xFC,0xA7,0x9E,0xF7,0xDA,0xBF,0x03,0x4A,0x53,0x80,0xD1,0x80,0x85,0xA0,0xC1,
    0x04,0x18,0x42,0x83,0xD1,0x09,0x80,0x40,0xD1,0x25,0xA6,0x74,0x0D,0xAA,0xFB,0x09,
    0x15,0x8F,0x52,0x63,0x25,0xB1,0x8D,0x4F,0x1B,0x1E,0x07,0xB7,0x15,0xAA,0x55,0xC0,
    0x53,0x27,0xD5,0x4A,0xFC,0x0C,0x54,0xAD,0x43,0x01,0xEB,0x40,0xB3,0x14,0x03,0x02,
    0x90,0x1B,0x07,0xA2,0x50,0x37,0x40,0x3C,0x0E,0xF9,0x9F,0x08,0xE2,0x59,0x57,0xA2,
    0x7D,0x52,0xAC,0x0D,0x36,0x58,0x95,0x96,0x55,0x82,0xB7,0x68,0x82,0x5E,0xAE,0xE0,
    0xE7,0xC9,0x5A,0xC4,0xAA,0xB5,0x25,0x52,0x0C,0x8F,0x5D,0xEF,0x00,0x00,0xA0,0xCC,
    0xB1,0xF8,0x28,0x01,0x92,0x09,0x41,0x0C,0x19,0x38,0x07,0x80,0x62,0xB6,0x47,0xF8,
    0x90,0x48,0x06,0x1C,0x88,0x1F,0x63,0xEC,0x45,0x7A,0x0A,0x61,0x25,0xA2,0xEF,0x0E,
    0x77,0x55,0x7F,0xD7,0xBE,0xFD,0xBF,0x50,0xD6,0x77,0x51,0x72,0x1C,0x17,0x81,0xF1,
    0x20,0x18,0x14,0xE0,0xC2,0x18,0x8C,0x0C,0x3E,0xFA,0x76,0x5A,0x11,0x82,0x10,0xF8,
    0xB8,0x4A,0x4D,0x61,0x5B,0x61,0xF2,0xA0,0x81,0x83,0xB6,0x7F,0x65,0x06,0x5A,0x0F,
    0xD2,0xC8,0x1F,0x6A,0xBC,0x63,0x33,0x98,0xAA,0xEA,0xAF,0x88,0x0A,0x0C,0x8B,0x53,
    0xA6,0x06,0x4A,0x0C,0xC0,0x31,0x78,0x1D,0x11,0xC4,0x60,0x39,0xA2,0x48,0x30,0xE7,
    0x47,0xFF,0x69,0xBC,0x1F,0x0F,0xC7,0xA9,0x01,0x10,0x7A,0x3F,0x05,0x3C,0x5C,0xBA,
    0xB5,0x7C,0x9F,0xD5,0xA9,0xEF,0xFB,0xF5,0x65,0xEC,0x9F,0x6B,0xEC,0x32,0x64,0xA0,
    0x06,0x84,0x20,0x66,0xD8,0x10,0xC4,0x20,0x60,0x86,0x21,0x0F,0x35,0xB1,0xEB,0x22,
    0x50,0xE9,0x38,0x92,0x5D,0x1A,0xBF,0xFA,0x41,0xDD,0x2E,0x68,0x7C,0x9D,0x30,0x30,
    0xE3,0x41,0x80,0xC8,0x1A,0x6D,0x8D,0x8D,0x5C,0xF6,0xAB,0x2F,0x62,0xC4,0xBF,0xFB,
    0x69,0x94,0x34,0x2D,0xF9,0x6C,0x10,0x44,0x6A,0x0F,0x01,0x03,0x88,0x06,0x81,0xE1,
    0x24,0x20,0x27,0x4E,0xDA,0x45,0x79,0xF1,0x05,0xA6,0x55,0xF8,0x41,0x4F,0x15,0x33,
    0xEA,0x3D,0x48,0xD9,0x61,0x76,0x31,0x13,0x2B,0x61,0xB4,0xC3,0x8A,0x58,0xDF,0xFC,
    0xAE,0x6B,0x3C,0xCF,0xB4,0xC3,0xC1,0x30,0xB0,0x31,0x60,0x36,0x83,0x01,0xF0,0x51,
    0x8F,0x95,0x80,0x78,0x40,0x4E,0x23,0x01,0xE1,0xF6,0xF3,0xEC,0x33,0xE4,0xEA,0xBD,
    0x12,0x16,0xB2,0xAC,0xB2,0x44,0xEC,0xAA,0x6D,0x94,0xE5,0xE5,0x9E,0x1F,0x25,0x2F,
    0x1E,0x7B,0x14,0x40,0xF9,0xBD,0x6B,0xCA,0x3C,0x61,0xFD,0x86,0xA0,0x60,0x52,0x83,
    0xC1,0xC0,0x9E,0x07,0xC1,0xE2,0x20,0x19,0x07,0x8B,0xFF,0x84,0x18,0xC0,0xA8,0x1B,
    0x01,0xE0,0xE0,0x37,0x04,0x20,0x78,0x78,0x0A,0xC4,0x20,0x78,0xB8,0x05,0xC0,0x62,
    0x40,0xC0,0x75,0x32,0xB2,0xF0,0x65,0x42,0x1A,0xA4,0x8A,0x99,0x4A,0xAF,0xE0,0xAA,
    0x2C,0x61,0x53,0x5A,0xCB,0x3A,0xA0,0x49,0x2E,0xDD,0x51,0xEF,0x4B,0xB7,0x99,0x2E,
    0xDE,0x45,0xA4,0xAF,0x06,0x06,0x03,0x2B,0x06,0x1D,0xA6,0x03,0x83,0xE1,0x08,0x4A,
    0x06,0x1E,0x08,0xE9,0x95,0x97,0x0F,0x95,0x0F,0x81,0xBA,0xC8,0xF8,0x76,0x95,0x66,
    0x12,0x07,0xC3,0x96,0x93,0x03,0x71,0x8C,0xF3,0x2A,0x66,0x33,0xE1,0xCF,0xD3,0xB5,
    0x9C,0x2C,0xFB,0x4C,0xF4,0xFF,0xBF,0x00,0x00,0xA1,0x8C,0xB6,0x0C,0x24,0x03,0xC1,
    0xFF,0x26,0x0C,0x94,0x1E,0x23,0xFD,0x30,0x78,0xBF,0xF5,0x41,0x65,0x40,0xF0,0x10,
    0x48,0xFF,0xCD,0x78,0x1B,0x5B,0x6F,0xF8,0xD3,0x4D,0x60,0x8D,0xF6,0xDB,0xFE,0xCC,
    0xF7,0xBD,0x90,0x47,0xDD,0xFF,0xF7,0x56,0xCC,0xC8,0xBE,0xED,0x5A,0x11,0x89,0x01,
    0x80,0x38,0x19,0x20,0xF4,0x0F,0x68,0xF4,0x20,0x80,0x78,0x3C,0x1F,0xFB,0xA3,0xBE,
    0xF9,0x45,0x64,0x3F,0x6D,0xA6,0xAB,0x63,0x95,0x7A,0xAD,0x5E,0x37,0xF6,0x19,0x64,
    0x7E,0xCC,0x69,0xBA,0x05,0xEF,0xA7,0xB2,0x88,0x25,0xAA,0xD9,0x68,0x58,0x3D,0x06,
    0x00,0xE0,0x40,0x08,0x60,0xC0,0x68,0x18,0x76,0x3C,0x4E,0x3E,0x4E,0x3A,0x6C,0x47,
    0x12,0x98,0x48,0x92,0x89,0x69,0x93,0xA4,0xF6,0xFF,0xEA,0x84,0x36,0xBB,0xDF,0xB5,
    0xDB,0x9E,0xAC,0xF8,0x72,0x59,0x9B,0x72,0x54,0x4B,0xBB,0xEC,0x34,0x08,0x00,0xC0,
    0x84,0x98,0x15,0x8C,0x8F,0x41,0x9B,0x12,0x7F,0x88,0xC7,0xE2,0x52,0x61,0x28,0xB8,
    0xB9,0x9E,0xAF,0x07,0x0A,0x87,0x76,0x97,0xF8,0xB2,0x51,0xC7,0xC7,0x23,0x7F,0xE6,
    0xEE,0x07,0x94,0xC0,0x50,0x07,0x80,0x82,0x55,0x5B,0x75,0x50,0x06,0xA4,0xBA,0x0C,
    0xB3,0x0C,0x8F,0x15,0xFB,0xDC,0x8B,0x32,0x9F,0x13,0xF9,0x9D,0x53,0xC5,0x35,0x4E,
    0x17,0x2A,0x9C,0xB6,0xC8,0x58,0x55,0x25,0xDD,0xAF,0x17,0x81,0xEF,0x83,0x0F,0xC1,
    0x9A,0x54,0x3B,0x2E,0x1F,0x03,0x26,0x64,0x19,0x4F,0xD9,0xFE,0x03,0x02,0x28,0x30,
    0x22,0x27,0x4E,0xAD,0x8F,0x5C,0x2C,0x65,0x86,0x15,0xB5,0x9A,0xC2,0x76,0x04,0x16,
    0x15,0x27,0x48,0x1E,0xFC,0xB9,0x4E,0x7F,0x6B,0x49,0x71,0x9C,0xA1,0x72,0x20,0xF0,
    0x10,0x42,0x89,0x02,0x58,0x94,0x0E,0x04,0x10,0x65,0x23,0xA1,0xF8,0xF0,0x72,0x0C,
    0x20,0x0E,0x01,0x4E,0x91,0x94,0xC5,0xAA,0x01,0x8B,0x54,0x96,0x08,0x39,0x8A,0x54,
    0x29,0xC5,0x3C,0xEF,0x14,0xCE,0x91,0xFD,0x8F,0x01,0x82,0x00,0x30,0x42,0x1F,0x03,
    0x68,0xF8,0x7E,0x3D,0x12,0xD5,0xA7,0x69,0xA6,0x92,0xC4,0x8A,0xA0,0xF9,0xB6,0xB3,
    0xE5,0xB8,0xD4,0x6D,0x5D,0x66,0x32,0x91,0x98,0xA3,0x8C,0xA6,0x1C,0x28,0xDE,0xF4,
    0x41,0x53,0x06,0xD5,0xE5,0x41,0x0C,0x7C,0xC0,0x30,0x1C,0x06,0x4E,0x0A,0x01,0x0C,
    0xB9,0x8D,0xA2,0x50,0x1A,0x6B,0x35,0x48,0x7D,0xBB,0xFA,0xA9,0x80,0x61,0xC0,0x92,
    0x59,0xE6,0x81,0x10,0x18,0x3D,0xD1,0xF7,0xD8,0x4A,0x5A,0xDF,0x3C,0xC8,0x96,0x9F,
    0xED,0xDD,0xB0,0xB5,0xA3,0x01,0x2C,0x1E,0x02,0x07,0xB1,0xF0,0xFC,0x74,0x08,0x45,
    0xED,0x0F,0x4B,0x93,0x8F,0x9B,0xA1,0x05,0x5F,0xE7,0x92,0xAA,0x6D,0x57,0xEF,0xA9,
    0x70,0xEB,0x27,0xE6,0x37,0x32,0xDC,0xB7,0x36,0x29,0x45,0xD9,0x49,0x98,0x3C,0x07,
    0xF0,0x69,0x07,0xCC,0x83,0x66,0xA7,0x57,0x73,0x12,0x8F,0x92,0xAA,0xA3,0xAA,0x06,
    0x27,0xFF,0xF6,0x7F,0x1A,0x65,0x36,0x5D,0x85,0xBB,0x9A,0xAA,0xFD,0x3F,0xDA,0x62,
    0xCB,0x69,0x77,0x9B,0xDE,0xE3,0x0F,0xF7,0x00,0x00,0xA2,0x4C,0x95,0x50,0x3A,0xA0,
    0x18,0x4B,0x06,0x05,0x0A,0x40,0x80,0x0A,0xDD,0x11,0x82,0x12,0x95,0x45,0xFC,0x0F,
    0xF5,0xA0,0x60,0x31,0x75,0x91,0x2E,0xDC,0x81,0xF5,0x2E,0x0F,0xD5,0x96,0x04,0x0D,
    0x4F,0x9A,0xBE,0xE2,0xA6,0xF1,0xBF,0xF5,0x81,0x60,0x29,0x45,0x40,0xF0,0x10,0x43,
    0x81,0xE8,0xA8,0x42,0x4E,0x07,0xFE,0xD0,0x32,0xE2,0x5B,0x35,0x85,0x5F,0xA3,0x8A,
    0x0F,0x05,0x00,0xBA,0x6B,0xCA,0x59,0xC0,0x32,0xD0,0xE4,0x7E,0x20,0xE3,0x39,0xBB,
    0x0B,0x41,0x11,0x36,0x96,0x2D,0x9F,0x16,0xBF,0x8D,0xB6,0xFE,0x36,0xDB,0xF8,0xC1,
    0x54,0xDB,0xF8,0xDB,0x6F,0xE3,0x6D,0xBF,0x8D,0xB6,0xFE,0x2B,0x6C,0x1B,0x5A,0x07,
    0x41,0x81,0x46,0x23,0x81,0xD0,0x50,0xA4,0x04,0x24,0xE2,0x0A,0xA1,0x08,0x47,0x4E,
    0xA8,0xB0,0x70,0x01,0x9E,0x10,0x1A,0x04,0x54,0xBE,0x4D,0x8A,0x4B,0xFD,0x9B,0xF2,
    0xA5,0x5B,0x3B,0xDF,0xE9,0x50,0x7B,0x7B,0x4E,0xFD,0x2D,0x92,0x00,0xC0,0x61,0xF8,
    0x36,0x8E,0x81,0x42,0x98,0x14,0x40,0xC3,0xF6,0xB3,0xA3,0xFD,0x91,0xA5,0x7A,0xD7,
    0xB1,0x9C,0xFA,0x79,0x20,0xF8,0xB3,0x44,0xA9,0x4B,0x93,0xA6,0xFB,0x38,0x1F,0x77,
    0x3D,0xDF,0x2B,0x6F,0x6B,0x29,0x64,0x4D,0xAD,0x38,0x90,0x37,0x81,0x4A,0x07,0xC4,
    0xB0,0x61,0x24,0x14,0x61,0x08,0xBC,0xBC,0x72,0x3A,0x1E,0x03,0x01,0xB0,0x44,0x54,
    0x1F,0x24,0xC2,0xC0,0x34,0x10,0xD8,0x4C,0xC0,0x19,0xF3,0x18,0xCE,0xA8,0x63,0x77,
    0x03,0xDF,0xEF,0x51,0xEF,0x74,0xEF,0xD8,0xC0,0x0E,0x84,0x25,0x40,0x1A,0x24,0x27,
    0x10,0x92,0xEB,0x3E,0x54,0x94,0x70,0x5B,0xAA,0xAE,0x63,0x70,0x40,0x57,0xE5,0x71,
    0x45,0xFF,0x9B,0xC1,0xBB,0x53,0xBD,0xF5,0x5B,0xA8,0x4E,0x87,0x5C,0x07,0x80,0x82,
    0x44,0x0E,0x0E,0x59,0xBF,0x12,0x44,0x7D,0x55,0x4B,0x00,0xD7,0xB0,0x11,0x3C,0xDB,
    0x45,0x40,0x64,0x41,0x66,0xAA,0xFE,0x2B,0x2D,0xD5,0xFC,0x58,0xA9,0x30,0xE2,0x15,
    0x51,0x06,0x83,0x1D,0x09,0x45,0xE2,0x48,0x94,0x25,0x16,0x03,0x29,0x1D,0x8F,0x87,
    0x83,0x95,0x23,0x80,0x53,0xA5,0x61,0x30,0xE5,0x47,0x14,0x96,0x08,0x3B,0x8A,0x54,
    0x29,0xC5,0x3C,0x44,0xA6,0x74,0x8C,0x20,0x2A,0x4E,0xA8,0xBD,0xAC,0x56,0x91,0x5B,
    0x09,0xD5,0x7F,0xAA,0x19,0x54,0xDE,0x32,0xD6,0xA8,0xDB,0x9A,0xA3,0xFE,0xB7,0x2F,
    0x36,0x5C,0xBC,0xAB,0x6C,0xB0,0x8F,0xEA,0x08,0x43,0xE1,0xF2,0x41,0x29,0x23,0x03,
    0xE1,0xF3,0x18,0xA9,0x22,0xAC,0x2C,0x69,0xAF,0x22,0x91,0x1A,0x1E,0xDD,0xDD,0xB6,
    0xEF,0xFF,0xB6,0xFD,0xBF,0xDD,0xFF,0xF7,0x7F,0xB5,0xE5,0xD5,0x2F,0x12,0x44,0xA1,
    0x28,0xB0,0x19,0x48,0xEC,0x7C,0x3C,0x1C,0xA9,0x1C,0x02,0x9D,0x2B,0x09,0x87,0x2A,
    0x38,0xA4,0xB0,0x41,0xDC,0x52,0xA1,0x4E,0x29,0xE2,0x25,0x33,0xA4,0x6B,0x2A,0x4E,
    0xA8,0xBD,0xAC,0x56,0x91,0x5B,0x09,0xD5,0x7F,0xAA,0x19,0x54,0xDE,0x32,0xD6,0xA8,
    0xDB,0x9A,0xA3,0xFE,0xB7,0x2F,0x36,0x5C,0xBC,0xAB,0x6C,0xB0,0x8F,0xDF,0x00,0x00,
    0xA5,0x0C,0x88,0x0A,0xA6,0x30,0x56,0x01,0xE0,0x70,0xB9,0xBD,0x54,0x94,0x20,0x88,
    0xC9,0x95,0xFB,0x85,0xAC,0x2B,0x1D,0xA4,0x61,0x9C,0x53,0x26,0xC5,0x3E,0xFB,0x73,
    0x67,0x72,0xCD,0x9D,0x8B,0xCB,0x1E,0x2F,0xF8,0x8D,0x8C,0x01,0xC0,0x1E,0x07,0x00,
    0xD8,0x29,0x81,0x81,0x14,0x46,0x04,0x51,0x04,0x0D,0x02,0x20,0x32,0x94,0x80,0x6C,
    0x3F,0x52,0x58,0x1F,0x08,0x03,0x92,0xD1,0x04,0xB4,0x3C,0x1C,0x71,0x4A,0x92,0xAE,
    0x1F,0x17,0xFD,0x2D,0x8D,0x81,0xAB,0x65,0xEA,0x81,0x00,0x21,0xA7,0x1D,0x25,0x05,
    0x32,0x54,0x83,0xE6,0x4B,0xDA,0x56,0x20,0x79,0x5F,0x01,0x4D,0x00,0xDE,0xF8,0x70,
    0xCF,0x7C,0x0C,0xBF,0xBD,0xAA,0x94,0xD9,0x4B,0x0B,0x4B,0x64,0xB7,0x0F,0x0F,0xC1,
    0x93,0x03,0x32,0x5E,0x3D,0x06,0x1F,0x0E,0xC0,0xF8,0xEE,0x02,0x29,0x78,0x40,0x06,
    0x1C,0x8E,0x6F,0x7C,0xC0,0x2A,0xC1,0x11,0x34,0x1D,0xE2,0xCC,0x2A,0xCF,0x26,0x0F,
    0x19,0xC4,0xCB,0x7B,0xE1,0xD0,0x83,0x7B,0x76,0x98,0xFA,0x5B,0x80,0x60,0x3C,0x0C,
    0x5E,0x3F,0x06,0x67,0xC2,0x48,0x37,0x53,0x26,0x61,0xB1,0xE6,0xA4,0xE6,0xA4,0x1C,
    0xE7,0xBF,0xE4,0xB1,0x9E,0x4A,0xD3,0x7F,0x66,0xCD,0xF5,0x4D,0xB4,0xB4,0x73,0xCD,
    0x9F,0x90,0xB3,0x0B,0x14,0x8B,0x46,0x00,0xC0,0xA0,0x05,0x18,0x06,0x83,0x51,0xF8,
    0x1F,0x56,0x24,0x8F,0x72,0xA4,0x49,0x8C,0x0E,0x07,0x5E,0x2E,0x55,0xEF,0x67,0xC7,
    0xED,0xB7,0xB9,0xBE,0x67,0x20,0x1B,0x50,0x9B,0xC9,0x35,0x8C,0xF3,0x3F,0x66,0xFE,
    0x32,0xA7,0xFF,0x2D,0xF7,0x4C,0xFD,0x2D,0x84,0xD5,0x60,0x1E,0x07,0x0B,0x9B,0xD5,
    0x49,0x42,0x08,0x8C,0x99,0x5F,0xB8,0x5A,0xC2,0xB1,0xDA,0x46,0x19,0xC5,0x32,0x6C,
    0x53,0xEF,0xB7,0x36,0x77,0x2C,0xD9,0xD8,0xBC,0xB1,0xF2,0x10,0x7E,0xAD,0xA1,0x08,
    0x47,0x6D,0x27,0xF1,0xA4,0xAD,0x09,0x43,0xFF,0xA6,0x6F,0xFA,0xC6,0x7B,0xCA,0xF1,
    0x57,0xF5,0xAF,0xFF,0x53,0x83,0x15,0x66,0x67,0xF9,0x77,0x55,0xD1,0x02,0x40,0x2E,
    0x54,0x7F,0xE9,0x6C,0x7E,0x0C,0x3E,0x08,0x23,0xBD,0x00,0xE4,0xA3,0xD0,0x6D,0x11,
    0xC4,0xAD,0xAD,0x09,0x7B,0xE0,0x53,0xE0,0xFC,0x0F,0x54,0x8D,0x2A,0x1C,0x17,0x0E,
    0x33,0xEA,0xC4,0x8F,0x82,0x9B,0x34,0x41,0x6F,0x4A,0xBF,0xA2,0x08,0x7B,0x88,0x34,
    0x2E,0x19,0x83,0x0F,0x01,0x81,0x04,0x18,0x11,0x41,0x8B,0x41,0xC0,0x86,0x9C,0x03,
    0x84,0x60,0xF8,0x11,0x01,0x10,0x0C,0x82,0xA8,0x41,0x1C,0x81,0xB1,0x04,0x1C,0x0A,
    0xB2,0xFF,0x96,0x96,0x16,0x34,0x1D,0x71,0x41,0x69,0x5F,0x54,0xBB,0xDF,0x00,0x00,
    0xA6,0x8C,0x8C,0x15,0x4D,0xBF,0x8D,0xB6,0xFE,0x1B,0x0D,0x00,0xC3,0xF0,0x64,0xDF,
    0x06,0x57,0xE1,0xE3,0x40,0xC1,0xFE,0x8E,0x9A,0x2E,0xD6,0x7F,0xBE,0x0F,0xAA,0x7F,
    0x2B,0xFF,0xE7,0xB3,0xDB,0xB8,0x08,0xA9,0xA4,0xD5,0x52,0x37,0x33,0x69,0x6D,0xE2,
    0xBF,0xF1,0x47,0x68,0x5A,0xC2,0xBF,0xC2,0x0B,0xA9,0x95,0x34,0x5C,0xA9,0x52,0x45,
    0x58,0x58,0xA9,0x33,0x0D,0x2A,0x63,0x3B,0xBA,0xA1,0xA6,0x32,0x7B,0xD8,0xA7,0x6D,
    0xDB,0xCC,0x92,0x77,0x6D,0xDA,0x86,0xD7,0xA2,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,
    0x60,0xAA,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x3B,0x07,0x52,0x40,
    0x61,0xE8,0x3C,0x0C,0x08,0xA0,0xA5,0x06,0x1E,0x83,0xC1,0x40,0x36,0x0C,0xA4,0x19,
    0x48,0x07,0xA7,0x07,0x84,0xFF,0xC4,0x11,0x07,0x00,0x88,0x3D,0x12,0xC1,0xE1,0xA0,
    0x0F,0x56,0xA5,0x48,0x7E,0x1B,0x71,0x42,0x13,0xEC,0x26,0x83,0x09,0x03,0xE1,0xFA,
    0x40,0x43,0x06,0x08,0x2D,0xA7,0x2E,0x4E,0xA9,0xA4,0xA1,0x06,0x7D,0x27,0xD9,0x54,
    0xDB,0x5E,0x4F,0xE0,0x55,0x84,0x1A,0x5A,0xAB,0x7F,0x24,0x67,0x39,0xFF,0x55,0x3E,
    0xEC,0xE7,0xF2,0x88,0xAE,0xFA,0x0A,0x0F,0x81,0x81,0x14,0x18,0x20,0x83,0x0F,0xC0,
    0xF0,0x06,0xD1,0x09,0x91,0x28,0x46,0x1F,0x07,0xDF,0xC4,0xE5,0x9F,0x6D,0x50,0xE0,
    0x46,0x4F,0xF4,0xEA,0x01,0x4F,0xF0,0x34,0xD2,0x76,0x55,0x8F,0x6E,0xA6,0x06,0x5A,
    0x29,0x63,0x37,0xB5,0x8F,0x81,0xA6,0x7E,0x64,0xA8,0x30,0x90,0x0F,0x07,0xFC,0x98,
    0x32,0x50,0x78,0x8F,0xF4,0xC1,0xE2,0xFF,0xD5,0x05,0x90,0x47,0x06,0x50,0x31,0x70,
    0x90,0x25,0xA6,0x06,0x00,0xF0,0x6F,0x97,0xAB,0x1D,0x0F,0xD8,0x48,0xAC,0x18,0x15,
    0x62,0x02,0x56,0x52,0x33,0xE5,0x4C,0x96,0x81,0xF5,0x4D,0xF8,0x70,0xCE,0xE4,0xF7,
    0xCB,0x7D,0x2F,0xFC,0xA3,0x6A,0x9C,0xEE,0xC3,0x9F,0x61,0xDD,0xA1,0xE8,0x42,0x10,
    0xC4,0x71,0x2C,0x49,0x06,0x67,0xE1,0x06,0xD4,0xBB,0x5B,0xCC,0x08,0x11,0x36,0xD2,
    0xDD,0xD1,0xB1,0x68,0x96,0xAF,0x4B,0x13,0x26,0x6A,0x46,0x13,0x31,0x31,0xBA,0x58,
    0xA2,0x0E,0x7D,0x18,0xE0,0x5E,0x14,0x01,0xE0,0x20,0x7F,0x1F,0xD0,0x70,0x21,0x84,
    0x11,0x28,0xB9,0x94,0xE0,0xC0,0xA6,0xD4,0xC9,0xC7,0xEA,0x95,0x27,0x2C,0xBF,0xEF,
    0x87,0xE9,0x18,0x54,0xCB,0x6A,0x0A,0xB1,0x38,0x22,0x36,0xA1,0x38,0x81,0xCF,0x37,
    0x79,0xD5,0x31,0xA6,0x02,0xC0,0xBB,0x41,0x44,0x01,0xE0,0xC9,0x02,0x0A,0xB2,0xC0,
    0x6F,0x30,0x0D,0xA1,0x09,0x5B,0x36,0x30,0x20,0x8E,0xBC,0x10,0xF7,0x52,0x7B,0xF9,
    0xFC,0xA5,0xAD,0x2A,0xAC,0x89,0x43,0xF1,0x03,0xE2,0x06,0xEF,0xD5,0x62,0x66,0xDB,
    0x2D,0xD8,0xA8,0xBF,0xCC,0x35,0x4C,0x05,0xC0,0x60,0x0C,0x68,0x49,0xFB,0x61,0x04,
    0x76,0x23,0x82,0x80,0x7C,0x01,0x8A,0x41,0x11,0x50,0xF3,0xCA,0x80,0xF2,0xA0,0x85,
    0xB2,0x73,0x74,0x7F,0x98,0x1E,0x41,0xDF,0xD8,0xFE,0xC2,0xEF,0xDA,0x9F,0xFF,0x6A,
    0xB7,0xD8,0xC5,0x03,0x1B,0x82,0xCF,0x7F,0x00,0x00,0xA9,0xCC,0xB1,0xE8,0x41,0x80,
    0xC0,0x70,0x18,0x0D,0x88,0xED,0xA5,0x12,0x41,0x04,0x47,0x6D,0x28,0x96,0x3F,0x2F,
    0x1C,0x80,0x73,0x03,0xC6,0x87,0xCC,0x07,0xE9,0xFF,0xA0,0x88,0xA4,0x7B,0x76,0xA5,
    0xDF,0x5E,0xD0,0x53,0xAA,0x06,0x2A,0x67,0xDF,0xF5,0xF0,0x25,0xC0,0x30,0x8C,0xAD,
    0xB8,0xAC,0x18,0x76,0x90,0x0E,0x68,0xFC,0x3E,0x64,0x14,0x41,0x0D,0x58,0xEB,0xDC,
    0x80,0xC5,0xB5,0xB4,0xDA,0x58,0x21,0x6A,0x94,0xD1,0x4C,0x1F,0xE6,0x17,0xFE,0x71,
    0x25,0xE5,0x67,0xEB,0x4B,0x67,0x8F,0x40,0x42,0x48,0x0C,0xC8,0x30,0xE8,0x7A,0x25,
    0xE3,0x40,0xCA,0x81,0x83,0xF4,0xA5,0x58,0x90,0x76,0x0C,0x38,0x2F,0x1E,0xB4,0xAA,
    0xE7,0x7A,0xC8,0xF9,0x3A,0xAC,0x96,0xB0,0x94,0xB9,0x96,0xFC,0xDF,0xB3,0xEC,0x37,
    0xDA,0xD0,0x82,0xA2,0xAA,0x65,0x20,0xB4,0x90,0x30,0xE8,0x78,0x0C,0xDE,0x04,0x30,
    0x52,0x89,0x6D,0x8E,0x84,0xB5,0x42,0x49,0x78,0x20,0x04,0x1F,0xA6,0x4E,0x94,0x79,
    0x4B,0xBC,0xD8,0x41,0x56,0x9D,0x33,0x2D,0x70,0x0D,0xB4,0xD1,0x72,0x9D,0x56,0x1E,
    0x96,0x5E,0x35,0xC9,0x56,0x2C,0x8F,0xFB,0x1D,0x02,0x17,0x81,0x87,0xCC,0xC2,0xC0,
    0x51,0xA7,0x00,0xF2,0xE5,0x75,0x9F,0xF1,0x58,0xFA,0x26,0xA3,0xCF,0x2A,0x8D,0x4B,
    0x82,0x0C,0x10,0x12,0x97,0x88,0x3A,0xD9,0x6E,0x01,0x86,0x37,0x17,0x6B,0xBC,0x0F,
    0x75,0xC1,0x20,0x10,0x7F,0x00,0x38,0x1E,0x02,0x07,0x51,0x28,0xB8,0x21,0x09,0x38,
    0x3B,0x48,0x3D,0x4E,0x0A,0x6A,0x25,0xB5,0x9F,0x4D,0x5B,0x48,0x95,0xB1,0x2C,0x76,
    0xDE,0x67,0xA3,0x36,0xB1,0xBD,0xF0,0x37,0x12,0xB4,0xCD,0xD0,0xF0,0x3F,0x61,0xB6,
    0xB3,0x6D,0x82,0xC0,0xB6,0x07,0xC7,0xA0,0xCC,0x88,0xE3,0xC6,0xC7,0x41,0x0C,0x18,
    0x20,0x02,0x9C,0x43,0xC0,0x60,0x31,0x40,0x3E,0x04,0x22,0xFD,0x6E,0x30,0xC7,0x41,
    0x86,0xCD,0xA4,0xCE,0x08,0x20,0xA7,0x52,0x9E,0x2B,0x4C,0x94,0x18,0x70,0xDE,0x6E,
    0xF8,0x1B,0x9A,0xC3,0x74,0x2D,0x2B,0xA0,0xC1,0x00,0x4B,0xD0,0x60,0x0E,0xF0,0x1E,
    0xDF,0xEE,0x84,0x16,0x13,0x83,0x02,0x2B,0x49,0xB5,0x2E,0x54,0xCD,0x2B,0x0F,0x70,
    0x19,0x47,0xBF,0x7C,0xA3,0x30,0x11,0x1B,0xFD,0x51,0x9B,0x18,0x06,0x03,0x7F,0xFB,
    0x60,0x8A,0x06,0xB6,0x99,0xFB,0x0F,0xFF,0x07,0x81,0x80,0xF4,0x18,0x0D,0x07,0x9A,
    0x08,0x3A,0x08,0x2A,0x3D,0xDB,0xBE,0x1D,0x78,0x20,0x16,0xD6,0xE0,0xE6,0x72,0x7D,
    0xB2,0xF5,0x18,0xC2,0x9C,0xF7,0xD4,0xF5,0xB6,0xE4,0x6E,0xF9,0xAC,0xDA,0xD1,0x80,
    0x48,0x83,0x08,0x43,0xF4,0xA2,0x58,0x33,0x01,0x09,0x28,0xFD,0x9D,0x4E,0x9F,0x71,
    0x3E,0x6B,0x3F,0x0E,0xFF,0x15,0x0F,0xD3,0xAA,0xF2,0x9A,0x22,0xE8,0xE1,0xAC,0x9B,
    0xFD,0xEF,0xFF,0x43,0xD6,0xEE,0xFE,0xDA,0xF0,0xBB,0xE0,0x78,0x1F,0xF2,0x47,0x83,
    0xCD,0x11,0xB4,0x18,0x03,0x07,0xCA,0xD2,0xB0,0x0C,0x55,0xE1,0x0F,0x41,0x9A,0x04,
    0x56,0xF9,0x82,0x0F,0xB7,0x6F,0xFC,0xAB,0xE5,0xC3,0xD6,0x65,0x10,0x03,0xE2,0xF2,
    0xB6,0xBF,0x1A,0xBA,0xAF,0x07,0xB5,0x58,0xE5,0xC2,0xC0,0x0E,0x4D,0xA5,0xC1,0x00,
    0x48,0x54,0xDA,0xA6,0x13,0x2B,0xF0,0xF9,0x50,0x22,0xB0,0xA9,0xA5,0x4C,0x35,0x85,
    0xFB,0xE9,0xA5,0xEA,0x3C,0x5D,0x22,0x69,0xD4,0xF5,0xBD,0xA2,0x04,0x2C,0xB6,0xDB,
    0x84,0x7E,0x00,0x00,0xAA,0x8C,0xA0,0x15,0xBF,0xF7,0x99,0xF7,0xDA,0x6F,0xD8,0xDB,
    0x4D,0xE6,0xFB,0xFE,0xFC,0x9B,0xEF,0xFB,0x67,0x37,0x3F,0x95,0x6D,0xCD,0x8B,0x6E,
    0x55,0xAC,0x23,0x03,0x02,0x0D,0xDA,0x07,0x00,0xF0,0x32,0x70,0x6F,0x27,0xF8,0xE5,
    0x5B,0x22,0x38,0xE9,0x36,0x7B,0x3E,0xD8,0x7D,0xED,0x12,0x92,0xA7,0xD1,0xD8,0xFD,
    0x8E,0xB4,0xA2,0xA9,0xD2,0xE1,0xF2,0xA2,0xB0,0xF9,0xB6,0xF3,0xED,0x7D,0x78,0x9A,
    0x98,0x80,0xBA,0x0C,0xAC,0x19,0x20,0xFD,0x28,0x30,0x87,0x85,0x83,0xA4,0xF4,0x21,
    0x04,0x34,0xE2,0x47,0xD9,0x4E,0x25,0x24,0x6E,0xF9,0x37,0x99,0xDF,0x26,0x1D,0xFD,
    0x96,0xE2,0x6A,0x99,0x84,0xE5,0xBE,0x56,0x5E,0xDE,0xE9,0x6C,0xE3,0x78,0xAD,0xBE,
    0xDF,0xEB,0xBE,0xD2,0x54,0xCA,0xA0,0x66,0x07,0xE0,0x1E,0x5C,0x9D,0xA1,0xFA,0x91,
    0xD8,0x31,0x74,0x1D,0x16,0x5C,0xC1,0xCA,0xA1,0x2C,0x0F,0x88,0xC2,0x41,0x7F,0xE2,
    0xBC,0xFD,0x55,0x5A,0x61,0x85,0x7A,0xCF,0xA9,0x56,0xB3,0xE9,0x32,0x5C,0xFE,0xA9,
    0x78,0x48,0x06,0x1F,0x24,0x48,0x98,0x1E,0x02,0x06,0xF1,0x2F,0xE3,0xF1,0xDE,0x24,
    0x48,0x10,0xF0,0x20,0xFD,0xB4,0xFB,0xEE,0xC1,0xF4,0x6F,0x01,0x81,0x10,0x6D,0x3F,
    0xD4,0xBB,0xD4,0xD3,0xFE,0xF6,0x28,0xFB,0x3F,0x6E,0x26,0xF4,0xBB,0xCA,0x64,0x90,
    0x3C,0x07,0xF0,0x20,0x84,0x25,0x8F,0xC4,0xB1,0x18,0x76,0x3A,0x2E,0x1F,0x8E,0xD4,
    0x8F,0xBE,0x5C,0xDB,0x45,0xC3,0xE6,0x55,0x87,0xC0,0x88,0xCD,0x67,0x3F,0xFD,0x60,
    0xB4,0x18,0x6E,0x0A,0xBD,0x99,0x97,0x30,0x18,0x6D,0x6F,0x77,0xB4,0x2C,0x11,0x01,
    0xF0,0x42,0x1E,0xA7,0x06,0x08,0x40,0xE0,0x50,0x30,0x20,0x7C,0x76,0xD0,0x8C,0x21,
    0x2A,0x0E,0xF8,0xD3,0x6D,0x89,0x54,0xBB,0x7F,0x9E,0xFE,0xE6,0x01,0x70,0x35,0xB8,
    0xC5,0x6E,0x7A,0x76,0xE0,0xE6,0xB5,0x14,0xEB,0xBE,0xC3,0xE2,0x7C,0x06,0x03,0xDE,
    0x54,0xAF,0xCA,0x99,0x06,0x6D,0x28,0xF7,0xCC,0x37,0x8C,0x27,0x2C,0x11,0x98,0x12,
    0x95,0xA5,0xCC,0xB3,0xCC,0x88,0x1A,0x0C,0x06,0x5A,0x1F,0x36,0xDF,0x3E,0x59,0xA0,
    0xC5,0x78,0xC5,0x51,0x40,0xCB,0x82,0x58,0x30,0xF9,0x5B,0x6C,0x83,0xC0,0x40,0xE6,
    0x0A,0x5F,0x7F,0x7B,0x85,0xCC,0x02,0x1A,0xA5,0x53,0x99,0x0B,0x1A,0xA2,0x34,0x4B,
    0x71,0x69,0xDD,0x06,0x5D,0x3B,0x3B,0xDD,0xEE,0x95,0xF3,0xAA,0x26,0x47,0x0B,0x52,
    0x2B,0x06,0x4A,0x3C,0x04,0x26,0x41,0x00,0x7C,0x0C,0x91,0x3A,0xA0,0x53,0xE2,0xB6,
    0x07,0xA2,0x4C,0x00,0xC1,0xF8,0x37,0x4B,0xD2,0x37,0x6D,0xC6,0xBF,0xA2,0x07,0x2E,
    0xFA,0x32,0x5E,0xA8,0x73,0xF1,0xCF,0x13,0x33,0x98,0xAA,0x2A,0x6D,0xA1,0x04,0x2F,
    0x44,0x19,0x20,0x90,0x25,0xA6,0x06,0x00,0xE0,0x6F,0x97,0x2B,0x1D,0x0F,0xD5,0x25,
    0x56,0x0C,0x0A,0xB1,0x01,0x23,0x29,0x19,0x69,0x5B,0x23,0x90,0x3C,0xAB,0xDE,0x1C,
    0x31,0xB9,0x3F,0xF2,0xDF,0xCB,0xEC,0x51,0x95,0x4E,0xC5,0x10,0xEF,0xBF,0x00,0x00,
    0xAB,0x4C,0xB4,0x41,0x81,0x00,0x21,0x2A,0x00,0xD0,0x61,0x18,0x21,0x88,0x49,0x75,
    0x9F,0x2A,0x4E,0x01,0xFA,0x5B,0xAA,0xAE,0x63,0x70,0x40,0x60,0x21,0x2B,0xC5,0x17,
    0xFE,0x6F,0x06,0xED,0x4E,0xF7,0xD5,0x6E,0xA1,0x3A,0x19,0x41,0x80,0xE0,0x32,0x41,
    0x28,0x19,0x90,0x60,0xFC,0x19,0x4B,0x23,0xF6,0x81,0xB8,0x0D,0xC1,0xC0,0x29,0xBE,
    0xC6,0x74,0x0D,0x82,0x9D,0x49,0x68,0x82,0xA9,0x5F,0x78,0x1F,0x62,0x8E,0x71,0x0F,
    0x7A,0x40,0x28,0x07,0x80,0x81,0xEC,0x7C,0x3F,0x1D,0x02,0x11,0x7B,0x43,0xD2,0xE4,
    0xE3,0xE6,0xE8,0x41,0x57,0xF9,0xE4,0xAA,0x9B,0x55,0xFB,0xEA,0x5C,0x3A,0xC9,0xF9,
    0x8D,0xCC,0xB7,0x2D,0xCD,0x8A,0x51,0x76,0x52,0x62,0xE1,0x03,0x01,0x84,0x70,0x61,
    0x19,0x28,0x8E,0x90,0x7C,0x08,0x5A,0x3D,0x10,0x75,0x56,0x7D,0x58,0x31,0x60,0x96,
    0x3D,0x49,0xF8,0x98,0x41,0xAD,0x7D,0x23,0x25,0xDA,0xC4,0xB9,0xF8,0x9E,0xDA,0xA4,
    0x3D,0x81,0xD7,0xF1,0xA6,0xF3,0xE6,0x3E,0x90,0x45,0xB0,0xD6,0x07,0x40,0xE8,0x29,
    0x47,0xC0,0xA5,0x08,0x42,0x50,0x94,0x10,0x81,0x14,0x21,0x25,0x06,0xE0,0x37,0x47,
    0xA0,0xDC,0x1E,0xB2,0x06,0x84,0x11,0xEB,0x6C,0x27,0x06,0x2B,0x61,0xB8,0x99,0xA1,
    0xC2,0x69,0x8D,0x81,0x9C,0xA5,0x9D,0x2D,0xFF,0x71,0xEC,0x18,0x7A,0x07,0x41,0x4A,
    0x10,0x01,0x8B,0x01,0xC0,0x84,0x10,0x81,0x84,0x10,0xFC,0x14,0xE0,0x8A,0x0F,0x05,
    0x00,0xB8,0xF4,0x7E,0x20,0x0E,0x00,0xD0,0x80,0x0E,0x05,0x53,0x7E,0x2C,0x2D,0x2D,
    0x64,0x3B,0xEA,0x92,0xC2,0xA1,0xB3,0xFE,0x23,0x6C,0x18,0x7A,0x07,0x41,0x4A,0x10,
    0x01,0x8B,0x01,0xC0,0x84,0x10,0x81,0x84,0x10,0xFC,0x14,0xE0,0x8A,0x0F,0x05,0x00,
    0xB8,0xF4,0x7E,0x20,0x0E,0x00,0xD0,0x80,0x0E,0x05,0x53,0x7E,0x2C,0x2D,0x2D,0x64,
    0x3B,0xEA,0x92,0xC2,0xA1,0xB3,0xC2,0xA7,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,
    0xF1,0xB6,0xDF,0xC6,0x0A,0xA6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,
    0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,
    0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,
    0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,
    0x7F,0x1B,0x6D,0xFC,0x6D,0xB7,0xF1,0xB6,0xDF,0xC6,0xDB,0x7F,0x1B,0x6D,0xFB,0x00,
    0x00,0xB3,0xCC,0x8C,0x15,0x4D,0xBF,0x8D,0xB6,0xFE,0x36,0xDB,0xF8,0xDB,0x6F,0xE3,
    0x6D,0xBF,0x8D,0xB6,0xFE,0x36,0xDB,0xF8,0xDB,0x6F,0xE3,0x6D,0xBF,0x8D,0xB6,0xFE,
    0x36,0xDB,0xF8,0xDB,0x6F,0xE3,0x6D,0xBF,0x8C,0x15,0x4D,0xBF,0x8D,0xB6,0xFE,0x36,
    0xDB,0xF8,0xDB,0x6F,0xE3,0x6D,0xBF,0x8D,0xB6,0xFE,0x36,0xDB,0xF8,0xDB,0x6F,0xE3,
    0x6D,0xBF,0x8D,0xB6,0xFE,0x36,0xDB,0xF8,0xDB,0x6F,0xE3,0x6D,0xBF,0x8D,0xB6,0xFE,
    0x36,0xDB,0xF8,0xDB,0x6F,0xE3,0x6D,0xBF,0x8D,0xB6,0xFE,0x36,0xDB,0xF8,0xDB,0x6F,
    0xE3,0x6D,0xBF,0x8D,0xB6,0xFE,0x36,0xDB,0xF8,0xDB,0x6F,0xE3,0x6D,0xBF,0x8D,0xB6,
    0xFE,0x36,0xDB,0xF8,0xDB,0x6F,0xE3,0x6D,0xBF,0x8D,0xB6,0xFE,0x36,0xDB,0xF8,0xDB,
    0x6F,0xE3,0x6D,0xBF,0x8D,0xB6,0xFE,0x36,0xDB,0xF8,0xDB,0x6F,0xE3,0x6D,0xBF,0x8D,
    0xB6,0xFE,0x36,0xDB,0xF8,0xDB,0x6F,0xE3,0x6D,0xBF,0x8D,0xB6,0xFE,0x36,0xDB,0xF8,
    0xDB,0x6F,0xE3,0x6D,0xBF,0x8D,0xB6,0xFE,0x36,0xDB,0xF8,0xDB,0x6F,0xE3,0x6D,0xBF,
    0x8D,0xB6,0xFE,0x36,0xDB,0xF8,0xDB,0x6F,0xE3,0x6D,0xBF,0x8D,0xB6,0xFE,0x36,0xDB,
    0xF8,0xDB,0x6F,0xE3,0x6D,0xBF,0x8D,0xB6,0xFE,0x36,0xDB,0xF8,0xDB,0x6F,0xE3,0x6D,
    0xBF,0x8D,0xB6,0xFE,0x36,0xDB,0xF8,0xDB,0x6F,0xE3,0x6D,0xBF,0x8D,0xB6,0xFE,0x36,
    0xDB,0xF8,0xDB,0x6F,0xE3,0x6D,0xBF,0x8D,0xB6,0xFE,0x36,0xDB,0xF8,0xDB,0x6F,0xE3,
    0x6D,0xBF,0x8D,0xB6,0xFE,0x36,0xDB,0xF8,0xDB,0x6F,0xE3,0x6D,0xBF,0x8D,0xB6,0xFE,
    0x36,0xDB,0xF8,0xDB,0x6F,0xDF,0x00,0x00,
};
/*
 *********************************************************************************************************
 * Variable
 *********************************************************************************************************
 */
OS_STK usbVcTaskStack[USB_VC_TASK_STACK_SIZE]; /* Stack of task usbVcTask() */
OS_EVENT* usbVcSem; /*  Interrupt/API events signal usbVcTask() via this semaphore */
OS_EVENT* USBAudioCmpSemEvt[MAX_AV_CH];
OS_EVENT* USBVideoCmpSemEvt[MAX_AV_CH];
OS_FLAG_GRP *OSUSB_task_flag;

//Multi-CH related
s8  USBEnableStreaming[MAX_AV_CH];
u8  Session_Ready[MAX_AV_CH]={0,0,0,0};
u32 USBVideoBufReadIdx[MAX_AV_CH];
u32 USBVideoPresentTime[MAX_AV_CH];
u32 USBAudioBufReadIdx[MAX_AV_CH];
u32 USBAudioPresentTime[MAX_AV_CH];
s32 T1 = 0,T_prev = 0;
VIDEO_BUF_MNG *USBVideoBuf[MAX_AV_CH];
IIS_BUF_MNG   *USBAudioBuf[MAX_AV_CH];
s32 P2PQuailty = 0, WifiPower = 0, WifiCHNum = 0,WifiPingtime = 0;
u8  PcamCmd[5];
u8  UsbImageMode,PcamPreviewStart,f_com = 0;
u16 UsbAltSetting,UsbTest_mode,UsbOutM,PcamCurRegPos;
u16 IosPktSizeTbl[9] = {0, 128, 256, 384, 512, 680, 800, 900, 1007 };
unsigned int reboot_cnt = 0;
int USB_timeout = 0,USB_COM_DATA=0,gUSB_UPGRADE = 0;
unsigned long USB_total_size=0;
u8  USB_AV_header[header_size] = { 0x00,         // [0] video = 1, audio = 2
                                  0x00,                   // [1] CH : 1, 2, 3, 4;
                                  0x00, 0x00, 0x00,       // [2:4] PresentTime
                                  0x00, 0x00, 0x00,       // [5:7] Size
                                  0x00, 0x00, 0x00,       // [8:10] offset
                                  0x00,                   // [11] FrameType
                                  0x00, 0x00,             // [12:13]Time
                                  /***big video***/   
                                  0x00, 0x00,             // [14:15] Width
                                  0x00, 0x00,             // [16:17] Height
                                  /***small video***/   
                                  0x00, 0x00,             // [18:19] Width
                                  0x00, 0x00,             // [20:21] Height                                 
                                  0x00,                   // [22] FrameRate
                                  /***audio***/
                                  0x00, 0x00,             // [23:24]
                                  0x00,                   // [25] motion
                                  //0x00                    // [25] frame num 
                                  };
unsigned char MP4_config[0x1d] =    
{
    0x00, 0x00, 0x01, 0xB0,
    0x03, 0x00, 0x00, 0x01,
    0xB5, 0x09, 
    0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x01, 0x20,
    0x00, 0xc4, 0x88, 0xba,
    0x98, 0x50, 0x00, 0x40,
    0x01, 0x44, 0x3f
};

u32  MP4_HeaderSize = 0x1d;
u8  Change_RSE =0;
u8  Reset_RES = 0;

/*
 *********************************************************************************************************
 * Extern Variables
 *********************************************************************************************************
 */
extern u8 uiP2PID[P2PID_LENGTH];
extern u8 Snapshot_Error; 
extern u8 P2P_Snapshot;
extern u8 P2P_Snapshot_cnt; 
extern u8 usb_str_desc0[];
extern u8 usb_str_desc1[];
extern u8 usb_str_desc2[];
extern u8 usb_str_desc3[];
//extern VIDEO_BUF_MNG rfiuRxVideoBufMng[MAX_RFIU_UNIT][VIDEO_BUF_NUM]; 
//extern u32 rfiuRxVideoBufMngWriteIdx[MAX_RFIU_UNIT];
//extern IIS_BUF_MNG rfiuRxIIsSounBufMng[MAX_RFIU_UNIT][IIS_BUF_NUM]; 
//extern u32 rfiuRxIIsSounBufMngWriteIdx[MAX_RFIU_UNIT];
extern u8 *rfiuAudioRetDMANextBuf[RFI_AUDIO_RET_BUF_NUM];
extern u8  uiVersionTime[9]; /*Firmware version for MARS internal using.*/
extern u8  GMotionTrigger[MULTI_CHANNEL_MAX];

/*
 *********************************************************************************************************
 * Function body
 *********************************************************************************************************
 */

void Init_USB_Session(void)
{
    int i;
    
    for(i=0; i<MAX_AV_CH; i++)
    {
        USBVideoCmpSemEvt[i]   = OSSemCreate(0);    
        USBAudioCmpSemEvt[i]   = OSSemCreate(0);            
    }
}
/*

Routine Description:

	Initialize USB Video Class.

Arguments:

	None.

Return Value:

	0 - Failure.
	1 - Success.

*/

s32 usbVcInit(void)
{
    u8 Result;
    /* Create the semaphore */
    usbVcSem = OSSemCreate(0);
	Init_USB_Session();
    /* Create the task */
    DEBUG_USB("Trace: USB Vendor Class task creating.\n");
    Result = OSTaskCreate(USB_VC_TASK, USB_VC_TASK_PARAMETER, USB_VC_TASK_STACK, USB_VC_TASK_PRIORITY);
    DEBUG_UART("USB_VC_TASK_PRIORITY = %d !!!\n", USB_VC_TASK_PRIORITY);
    
    if(Result != OS_NO_ERR)
    {
        DEBUG_UART("usbVcInit %d error!!!\n", Result);
    }
    return 1;
}
void usbVC_init()
{
	u32 i, val;
    u8* pos;
    //init clock
    DEBUG_USB("\n usbVC_init \n");
	SYS_CTL0        |=(1<<16)|(1<<19);
	SYS_RSTCTL      |=(1<<16);
	for (i=0; i<10; i++);
	SYS_RSTCTL      &=(~(1<<16));
    SYS_ANA_TEST1   |= 1 | (1<<7);
    
//  SYS_ANA_TEST1|= 1 | (1<<7) | (1<<9);
//  TM5_CTLREG=((239ul<<3)&0xff00)|(239ul&0x3f)|0xC0;//10us
//  TM5_PAUSE_INTEN=0;
    
    PcamPreviewStart= 0;
    UsbAltSetting   = 0;
    PcamCmd[0]      = 0;
    PcamCmd[1]      = 0;
    PcamCmd[2]      = 0;
    PcamCmd[3]      = 0;
    PcamCmd[4]      = 0;
    
    UsbImageMode    = 0;
    //usb_device_buf;
    //DEBUG_USB("\n**** usb_device_buf=>%x \n",usb_device_buf);
  #if 1
    pos = usb_device_buf;
    val = 0;
    for(i=0; i<1024*50; i++)
    {
        *pos = val;
        pos++;
        val++;
    }           
  #endif
    OSUSB_task_flag = OSFlagCreate(0,0);
  #if 1
	//reset
	DevicePHYTestMode       = 1;
	DeviceMaskInterrupt     = 0x0;
	DeviceMaskInterruptG0   = ~(USBD_MCX_SETUP_INT);
	DeviceMaskInterruptG1   = ~(USBD_MF0_OUT_INT | USBD_MF0_SPK_INT);
    DeviceMaskInterruptG2   = ~(USBD_MUSBRST_INT | USBD_MDMA_CMPLT);
	//set pipe FIFO 0:control,1:Bulk out(cmd), 2:Bulk In(resp) 3.Bulk out DMA 4.Bulk in DMA
	DeviceInEP1MaxPktSize   = 0;     // iso  out
    DeviceOutEP1MaxPktSize  = 0;    // iso  IN
	DeviceInEP2MaxPktSize   = 16;       // x
	DeviceOutEP2MaxPktSize  = 16; 
	DeviceOutEP3MaxPktSize  = 16;       // bulk out reg
	DeviceInEP3MaxPktSize   = 512;       // bulk IN  reg
	DeviceOutEP4MaxPktSize  = 512;      // bulk OUT reg 
    DeviceInEP5MaxPktSize   = 32;        // x
    DeviceInEP6MaxPktSize   = 0;        // x
    DeviceOutEP7MaxPktSize  = 64;      // bulk OUT
//  DeviceEP1to4Map = 0x00112233;
	DeviceEP1to4Map = 0x00113333;
    DeviceEP5to8Map = 0x33333322;
    DeviceFIFOMap   = 0xF7151304;
    DeviceFIFOConfig    = ((USBD_PIPE_TYP_BULK<<0)|(0<<2)|(0<<4)|(1<<5))|
    					  ((USBD_PIPE_TYP_BULK<<8)|(0<<10)|(0<<12)|(1<<13))|
    					  ((USBD_PIPE_TYP_BULK<<16)|(0<<18)|(0<<20)|(1<<21))|
    					  ((USBD_PIPE_TYP_ISO<<24)|(1<<26)|(1<<28)|(0<<29));
	DeviceFIFO0ByteCnt  = (1<<12);     // reset fifo
	DeviceFIFO1ByteCnt  = (1<<12);     // reset fifo
	DeviceFIFO2ByteCnt  = (1<<12);     // reset fifo
	DeviceFIFO3ByteCnt  = (1<<12);     // reset fifo
   #if 0	/*1:Force USB1.1 , 0:USB 2.0*/
	DeviceMainCtl       = (1<<5)|(1<<9)|0x2|(1<<2);     // bit9: force full speed1.1
   #else
	DeviceMainCtl       = (1<<5)|(1<<2);     // usb High speed
   #endif
	DeviceAddress       = 0;
	//soft plug
	DevicePHYTestMode   = 0;
  #endif
    IntIrqMask          &=  (~INT_IRQ_MASK_USB);       // enable USB interrupt
    GLOBALInterruptMask = 0x6;              // disable OTG, Host control interrupt
}
void USB_EPO_output_data(BYTE* data,u16 len)//note len must<=64 BYTES
{
    OS_FLAGS flag;
    u16 rem, xlen, pos;
//    DEBUG_USB("\ndata=0x%08x,len=0x%08x",(u32)data,len);
//    DEBUG_USB("\nzaaa=%x",DeviceCXConfigFIFOEmpS);
    #if (OS_CRITICAL_METHOD == 3)                      /* Allocate storage for CPU status register           */
    unsigned int  cpu_sr = 0;                    /* Prevent compiler warning                           */
    #endif
    rem = len;
    pos=0;
    
    while(rem)
    {
        if(rem >= 64)
            xlen = 64;
        else
            xlen = rem;
        
        DeviceDMATargetFIFONum  =(1<<4);	//control bus
        DeviceDMACtlParam1      =((u32)xlen<<8)|(1<<1);
        DeviceDMACtlParam2      =(u32)data+pos;
        DeviceInterruptSourceG2 |=(USBD_MDMA_CMPLT);
        mENABLE_USB_IRQ;
        DeviceDMACtlParam1      =((u32)xlen<<8)|(1<<1)|(1<<0);
        
        while(1)
        {
            mENABLE_USB_IRQ;
            flag = OSFlagPend(OSUSB_task_flag, 0xff, OS_FLAG_WAIT_SET_ANY|OS_FLAG_CONSUME, OS_TICKS_PER_SEC*50, 0 );

            if(flag==0)
            {
                DEBUG_USB("timeout EP0!");
                break;
            }
            if(flag&0x02)
            {
                //DEBUG_USB("%01x", dbg++);
                OSTimeDly(4*1);
                break;
            }
        }
        DeviceInterruptSourceG2 |= (USBD_MDMA_CMPLT);
        pos +=xlen;
        rem -= xlen;
    }
    DeviceDMATargetFIFONum = 0;
//	DEBUG_USB("\n%x,%x,%x,%x",DeviceInterruptSourceG0,DeviceInterruptSourceG1,DeviceInterruptSourceG2,DeviceCXConfigFIFOEmpS);
//	while (!(DeviceCXConfigFIFOEmpS&0x20))
//		DEBUG_USB("\n%x",DeviceCXConfigFIFOEmpS);
//	DeviceCXConfigFIFOEmpS|=1;
}
void Usb_Ctrl_pipe_Handle()
{

	USB_DEV_REQ USB_Setup_req;
	u16 u16tmp;
    //DEBUG_USB("\nS");
    DeviceDMATargetFIFONum      = (1<<4);
    ((u32*)&USB_Setup_req)[0]   = DeviceDMACtlParam3;
    ((u32*)&USB_Setup_req)[1]   = DeviceDMACtlParam3;
    // DEBUG_USB("\n%x,%x",((u32*)&USB_Setup_req)[0],((u32*)&USB_Setup_req)[1]);
    DeviceDMATargetFIFONum      = 0;

    switch (USB_Setup_req.bRequest)
    {
        case USB_RC_SET_ADDRESS:
            DEBUG_USB("\nSet address to %d",USB_Setup_req.wValue);
			if(reboot_cnt>30)
			{
				DEBUG_USB("USB dongle initial fail, Rebooting...");
				sysForceWDTtoReboot();
			}
			else
				reboot_cnt++;
            DeviceAddress   = (DeviceAddress&0x80)|(USB_Setup_req.wValue&0x7f);
            //USB_CONTROL_PIPE_SET_COMMAND_DONE;
            break;
        case USB_RC_GET_DESCRIPTOR:
            //DEBUG_USB("\nD");
            switch ((USB_Setup_req.wValue>>8)&USB_DEV_REQ_REC_MASK)
            {
                case USB_DESC_TYPE_DEVICE:

                    /* get device descriptor */
                    u16tmp = sizeof(USB_DEV_DESC)>USB_Setup_req.wLength?USB_Setup_req.wLength:sizeof(USB_DEV_DESC);
                    //DEBUG_USB("\n%x",u16tmp);
                    USB_EPO_output_data((BYTE*)&usb_isp_dev_desc,u16tmp);
                    break;

                case USB_DESC_TYPE_CONFIGURATION:
                    DEBUG_USB("\nGet Config");
                    //u16tmp=sizeof(USB_CFG_DESC)>USB_Setup_req.wLength?USB_Setup_req.wLength:sizeof(USB_CFG_DESC);
                    //USB_EPO_output_data((BYTE*)&usb_msc_configuration_desc.cfg,u16tmp);
                    //DEBUG_USB("\n USB_Setup_req.wLength: 0x%08x", USB_Setup_req.wLength);
                    u16tmp=sizeof(USB_ISP_CONFIGURATION_DESC)>USB_Setup_req.wLength?USB_Setup_req.wLength:sizeof(USB_ISP_CONFIGURATION_DESC);
                    USB_EPO_output_data((BYTE*)&usb_isp_configuration_desc,u16tmp);
                    break;

                case USB_DESC_TYPE_STRING:
                    DEBUG_USB("\nGet string");
                    reboot_cnt = 0;
                    switch ((USB_Setup_req.wValue)&0xff)
                    {
                        case 0:
                            u16tmp=USB_STR0_bLength>USB_Setup_req.wLength?USB_Setup_req.wLength:USB_STR0_bLength;
                            USB_EPO_output_data((BYTE*)&usb_str_desc0,u16tmp);
                            //USB_CONTROL_PIPE_SET_COMMAND_DONE;		
                            break;
                        case 1:
                            u16tmp=USB_STR1_bLength>USB_Setup_req.wLength?USB_Setup_req.wLength:USB_STR1_bLength;
                            USB_EPO_output_data((BYTE*)&usb_str_desc1,u16tmp);		
                            //USB_CONTROL_PIPE_SET_COMMAND_DONE;
                            break;
                        case 2:
                            u16tmp=USB_STR2_bLength>USB_Setup_req.wLength?USB_Setup_req.wLength:USB_STR2_bLength;
                            USB_EPO_output_data((BYTE*)&usb_str_desc2,u16tmp);		
                            //USB_CONTROL_PIPE_SET_COMMAND_DONE;
                            break;
                        case 3:
                            u16tmp=USB_STR3_bLength>USB_Setup_req.wLength?USB_Setup_req.wLength:USB_STR3_bLength;
                            USB_EPO_output_data((BYTE*)&usb_str_desc3,u16tmp);
                            //USB_CONTROL_PIPE_SET_COMMAND_DONE;
                            break;
                        default:
                            break;
                    }		
                    break;
                default:
                    break;
            }
            break;
            
        case USB_RC_SET_CONFIGURATION:
            DeviceAddress|=(1<<7);
		//Initial buffer for RF video streaming. aher
            break;
        
        case USB_RC_SET_INTERFACE:
            UsbAltSetting = USB_Setup_req.wValue;
        
            if(UsbAltSetting > 8)
                UsbAltSetting = 0;
            DeviceOutEP1MaxPktSize  = IosPktSizeTbl[UsbAltSetting];
            DeviceInEP1MaxPktSize   = IosPktSizeTbl[UsbAltSetting];
            DeviceFIFO0ByteCnt      = (1<<12);     // reset fifo
            DeviceFIFO1ByteCnt      = (1<<12);     // reset fifo
            DeviceFIFO2ByteCnt      = (1<<12);     // reset fifo
            DeviceFIFO3ByteCnt      = (1<<12);     // reset fifo
                      
            DEBUG_USB("\n SET_INTERFACE %02x  Size: %i", UsbAltSetting, IosPktSizeTbl[UsbAltSetting]);
			if(reboot_cnt > 30)
			{
				DEBUG_USB("USB dongle initial fail2, Rebooting...");
				sysForceWDTtoReboot();
			}
			else
				reboot_cnt++;
            break;
            
         case USB_RC_SET_FEATURE:
          //   UsbTest_mode = USB_Setup_req.wValue.
            switch (USB_Setup_req.wValue) 
            {
	            case TEST_SE0_NAK:
	                DevicePHYTestMode = 0x00000008;
	                break;
	            case TEST_J:
	                DevicePHYTestMode = 0x00000002;
                    break;
	            case TEST_K:
	                DevicePHYTestMode = 0x00000004;
	                break;
	            case TEST_PACKET:
//                    USB_test_packet();
	                break;
	            default:
                    break;
            }
            DEBUG_USB("\n SET_FEATURE %x ", USB_Setup_req.wValue);
            break;
            
        case USB_RC_GET_INTERFACE:
            DEBUG_USB("\n USB_RC_GET_INTERFACE");
            USB_EPO_output_data((BYTE*)&UsbAltSetting, 1);
            break;
            
        default:							
            break;
    }
    USB_CONTROL_PIPE_SET_COMMAND_DONE;
}
void Usb_Host_Reset_Cmd()
{
    DeviceFIFO0ByteCnt      = (1<<12);     // reset fifo
    DeviceFIFO1ByteCnt      = (1<<12);     // reset fifo
    DeviceFIFO2ByteCnt      = (1<<12);     // reset fifo
    DeviceFIFO3ByteCnt      = (1<<12);     // reset fifo
    DeviceAddress           = 0;
    DeviceInterruptSourceG2 = 1;
    
    DEBUG_USB( "\n H2D reset." );
}
void FIFO2_Bulk_In_Transfer(u32 len)
{

    u32 flag;
    u32 cnt;
 
    #if (OS_CRITICAL_METHOD == 3)                      /* Allocate storage for CPU status register           */
    unsigned int  cpu_sr = 0;                    /* Prevent compiler warning                           */
    #endif

    DeviceDMATargetFIFONum = 0x00000004; //fifo2
    DeviceDMACtlParam1=(len<<8)|(1<<1);
    DeviceDMACtlParam2=(u32)usb_device_buf;
    DeviceInterruptSourceG2|=(USBD_MDMA_CMPLT);

    mENABLE_USB_IRQ;
    DeviceDMACtlParam1 |=1;
   // DEBUG_USB("\n#D2H 16 Bulk S\n");
#if 1
  //  DEBUG_USB("\n#D2H 16 Bulk S\n");
    while((DeviceInterruptSourceG2 & USBD_MDMA_CMPLT) == 0x00000000);
    DEBUG_USB("# f2 Bulk in \n");
#if  1
    cnt=0;
    while((DeviceInterruptSourceG1 & USBD_MF2_IN_INT) == 0x00000000)
    {                                           
        cnt++;
        if(cnt>8000)	
    	{
    		DEBUG_USB("USBD_MF2_IN timeout\n");
    		break;
    	}
    };
#endif 
  //  DeviceInterruptSourceG2 &= ~USBD_MDMA_CMPLT ;
    DeviceInterruptSourceG2|=(USBD_MDMA_CMPLT);
  //  DeviceDMATargetFIFONum = 0x00000000 ;
#endif  
}
void FIFO0_H2D_4Byte()
{
    u32 len,cnt;
    #if (OS_CRITICAL_METHOD == 3)                      /* Allocate storage for CPU status register           */
    unsigned int  cpu_sr = 0;                    /* Prevent compiler warning                           */
    #endif

    len=DeviceFIFO0ByteCnt;
    DeviceDMATargetFIFONum  = (1<<0);	
    DeviceDMACtlParam1      = ((u32)len<<8)|(0<<1);
    DeviceDMACtlParam2      = (u32)usb_device_buf;
    DeviceInterruptSourceG2 |=(USBD_MDMA_CMPLT);

    DEBUG_USB( "\nH2D len: 0x%08X\n", len);
    if(len > 5)	
		USB_COM_DATA=1;
    else
		USB_COM_DATA=0;
    mENABLE_USB_IRQ;
    DeviceDMACtlParam1      |= 1;    //Start     // start dma
//  DEBUG_USB("# Bulk S\n");
//    while((DeviceInterruptSourceG2 & USBD_MDMA_CMPLT) == 0x00000000);
 	cnt=0;
	while((DeviceInterruptSourceG2 & USBD_MDMA_CMPLT) == 0x00000000)
	{
		cnt++;
	    if(cnt>2000000)	
		{
			DEBUG_USB("USB: recv timeout\n");
            break;
		}
	}
//  DEBUG_USB("# Bulk F\n");
//  pos = usb_device_buf;
//  DeviceInterruptSourceG2 &= ~USBD_MDMA_CMPLT ;
    DeviceInterruptSourceG2 |=(USBD_MDMA_CMPLT);
//  DeviceDMATargetFIFONum  = 0x00000000 ;
   OSTimeDly(1);
}
void FIFO1_D2H_16Byte()
{
    u32 len;
    #if (OS_CRITICAL_METHOD == 3)                      /* Allocate storage for CPU status register           */
    unsigned int  cpu_sr = 0;                    /* Prevent compiler warning                           */
    #endif
    
    len=16;
//  DeviceFIFO3ByteCnt=(1<<12);
    DeviceDMATargetFIFONum  = (1<<1); //fifo1
    DeviceDMACtlParam1      = (len<<8)|(1<<1);
    DeviceDMACtlParam2      = (u32)usb_device_buf;
    DeviceInterruptSourceG2 |= (USBD_MDMA_CMPLT);

    mENABLE_USB_IRQ;
    DeviceDMACtlParam1      |=1;
//  DEBUG_USB("\n#D2H 16 Bulk S\n");
  #if 1
//  DEBUG_USB("\n#D2H 16 Bulk S\n");
    while((DeviceInterruptSourceG2 & USBD_MDMA_CMPLT) == 0x00000000);
    DEBUG_USB("# 16 Bulk F\n");

//  DeviceInterruptSourceG2 &= ~USBD_MDMA_CMPLT ;
    DeviceInterruptSourceG2 |= (USBD_MDMA_CMPLT);
//  DeviceDMATargetFIFONum  =  0x00000000 ;
  #endif
}
void FIFO0_H2D_512Byte()
{
    u32 len,cnt;
    u8 *pos;
    #if (OS_CRITICAL_METHOD == 3)                      /* Allocate storage for CPU status register           */
    unsigned int  cpu_sr = 0;                    /* Prevent compiler warning                           */
    #endif
    
//  DEBUG_USB("DeviceFIFO0ByteCnt=%d\n",DeviceFIFO0ByteCnt);
    len=32;
//    len=DeviceFIFO0ByteCnt;
    DeviceDMATargetFIFONum=(1<<0);	
    DeviceDMACtlParam1=((u32)len<<8);
    DeviceDMACtlParam2=(u32)usb_device_buf;
    DeviceInterruptSourceG2|=(USBD_MDMA_CMPLT);
//  DEBUG_USB( "\nH2D len: 0x%08X\n", len);
//  mENABLE_USB_IRQ;
//  DEBUG_USB("#Out\n");
    DeviceDMACtlParam1 |= 1;    //Start     // start dma

    cnt=0;
    while((DeviceInterruptSourceG2 & USBD_MDMA_CMPLT) == 0x00000000)
    {                                           
        cnt++;
        if(cnt>2000000)	
    	{
    		DEBUG_USB("USBD_MDMA_ timeout\n");
    		gUSB_UPGRADE=1;
    		break;
    	}
    };
#if  1
    cnt=0;
    while((DeviceInterruptSourceG1 & USBD_MF0_OUT_INT) == 0x00000000)
    {                                           
        cnt++;
        if(cnt>2000000)	
    	{
    		DEBUG_USB("USBD_MF0_ timeout\n");
    		gUSB_UPGRADE=1;
    		break;
    	}
    };
#else    
    while((DeviceInterruptSourceG2 & USBD_MDMA_CMPLT) == 0x00000000)
        {                                           
       // DEBUG_USB("# dly");
        };
#endif    
//  DEBUG_USB("#Bulk F\n");
//  pos = usb_device_buf;
//  DeviceInterruptSourceG2 &= ~USBD_MDMA_CMPLT ;
    DeviceInterruptSourceG2|=(USBD_MDMA_CMPLT);
    DeviceDMATargetFIFONum = 0x00000000 ;
//  OSTimeDly(1);
}

/*Initial buffer for RF video streaming.*/
void Start_USB_Session(int ch)
{
      
	/**************************************
    **** Streaming Audio/Video Payload ****
    **************************************/
    unsigned int    cpu_sr = 0;  

    ch = ch % MAX_AV_CH; 

    OS_ENTER_CRITICAL();		
    USBVideoBufReadIdx[ch] = (VideoBufMngWriteIdx) % VIDEO_BUF_NUM;
    USBAudioBufReadIdx[ch] = (iisSounBufMngWriteIdx) % IIS_BUF_NUM;
    USBVideoBuf[ch]         = VideoBufMng;
    USBAudioBuf[ch]         = iisSounBufMng; 
    USBEnableStreaming[ch]  = 1; 
    Session_Ready[ch]       = 1;
    OS_EXIT_CRITICAL();
    
}
void Stop_USB_Session(int ch)
{
    u8 err;
    ch = ch % MAX_AV_CH; 
    USBEnableStreaming[ch]  = 0; 
    if(USBEnableStreaming[ch] <= 0)
    {
        DEBUG_USB("CH %d, stop streaming Audio/Video Payload\n",ch);
        OSSemSet(USBVideoCmpSemEvt[ch], 0, &err);
        OSSemSet(USBAudioCmpSemEvt[ch], 0, &err);                
		USBEnableStreaming[ch]=0;
        Session_Ready[ch] = 0;
    }
}
void Mars_Pcam_Cmd()
{
    int i=0,ch,bytesRecv;
 	RTC_DATE_TIME set_time;
	char command_data[100],buf2[50],buf3[2];
	unsigned char digest[16];
	MD5_CTX ctx;
 	u8* codeAddr = usbfwupgrade_buf;
 	char MD5_buf[33];   
    #if (OS_CRITICAL_METHOD == 3)                      /* Allocate storage for CPU status register           */
    unsigned int  cpu_sr = 0;                    /* Prevent compiler warning                           */
    #endif
    
    DEBUG_USB( "\n Cmd: 0x%02X  0x%02X  0x%02X  0x%02X  0x%02X", PcamCmd[0], PcamCmd[1], PcamCmd[2],PcamCmd[3],PcamCmd[4]);
    switch(PcamCmd[0])
    {
    	case PCAM_CMD_START_PREVIEW:
            DEBUG_USB("\nPCAM_CMD_START_PREVIEW\n");
            PcamPreviewStart=1;
            USB_total_size = 0;
            Start_USB_Session(0);					/*CH number			*/
//            Start_USB_Session(1);
//            Start_USB_Session(2);					/*CH number			*/
//            Start_USB_Session(3);         
            DEBUG_USB( "\nPreviewStart\n");
            break;
        case PCAM_CMD_STOP_PREVIEW:
            PcamPreviewStart=0;
            Stop_USB_Session(0);					/*CH number.		*/
//            Stop_USB_Session(1);
//            Stop_USB_Session(2);					/*CH number.		*/
//            Stop_USB_Session(3);
            //sysTX8211_LeaveWifi(1);
            //sysbackSetEvt(SYS_BACK_RFI_TX_LEV_WIFI,P2PQuailty);            
            sysback_RF_SetEvt(SYS_BACKRF_RFI_TX_LEV_WIFI,P2PQuailty);            
            DEBUG_USB( "\nPreview Stop\n");
            break;
        case PCAM_CMD_SET_RESOLUTION:
            switch(PcamCmd[1])
            {
                case 0x12:  // QVGA
                    UsbImageMode = 0x02;
                    break;

                default:
                case 0x10:  // VGA
                    UsbImageMode = 0x00;
                    break;
            }
	        break;
	    case PCAM_CMD_SET_BRIGHTNESS:
    		/*Recv setting data from host.*/
    		DEBUG_USB("RECV Camera config para\n");
    		FIFO0_H2D_4Byte();
    		ch=*usb_device_buf;
    		DEBUG_USB("\nCH=%d, bright=%d\n",ch,*(usb_device_buf+1));
    		switch(ch)
    		{
    			case 1:
    			DEBUG_USB("Set brightness for CH1...\n");	
//    			iconflag[UI_MENU_SETIDX_CH1_BRIGHT] = *(usb_device_buf+1);
//    			uiSentKeyToUi(UI_KEY_RF_BRIGHTNESS_1);
    			break;
    			case 2:
    			DEBUG_USB("Set brightness for CH2...\n");	
//    			iconflag[UI_MENU_SETIDX_CH2_BRIGHT] = *(usb_device_buf+1);
//    			uiSentKeyToUi(UI_KEY_RF_BRIGHTNESS_2);
    			break;
    			case 3:
    			DEBUG_USB("Set brightness for CH3...\n");	
//    			iconflag[UI_MENU_SETIDX_CH3_BRIGHT] = *(usb_device_buf+1);
//    			uiSentKeyToUi(UI_KEY_RF_BRIGHTNESS_3);
    			break;
    			case 4:
    			DEBUG_USB("Set brightness for CH4...\n");	
//    			iconflag[UI_MENU_SETIDX_CH4_BRIGHT] = *(usb_device_buf+1);
//    			uiSentKeyToUi(UI_KEY_RF_BRIGHTNESS_4);
    			break;
    		}	
	        break;	
    	case PCAM_CMD_GET_BRIGHTNESS:
    		DEBUG_USB("\nSend camera configuration\n");
//    		*(usb_device_buf+0)=1;
//    		*(usb_device_buf+1)=iconflag[UI_MENU_SETIDX_CH1_BRIGHT];
//    		*(usb_device_buf+8)=2;
//    		*(usb_device_buf+9)=iconflag[UI_MENU_SETIDX_CH2_BRIGHT];
//    		*(usb_device_buf+16)=3;
//    		*(usb_device_buf+17)=iconflag[UI_MENU_SETIDX_CH3_BRIGHT];
//    		*(usb_device_buf+24)=4;
//    		*(usb_device_buf+25)=iconflag[UI_MENU_SETIDX_CH4_BRIGHT];	
    		FIFO2_Bulk_In_Transfer(32);
    	    break;	
        case PCAM_CMD_CAMERA_SEL:
            DEBUG_USB("\nPCAM_CMD_CAMERA_SEL\n");
            USB_timeout=0;
    	    break;	
        case PCAM_CMD_GET_STATUS:
            break;
        case PCAM_CMD_PAIR:
            /*Recv setting data from host.*/
            DEBUG_USB("RECV PAIR para\n");
            FIFO0_H2D_4Byte();
            ch=*usb_device_buf;
            DEBUG_USB("\nPAIR CH=%d\n",ch);
            switch(ch)
            {
            	case 1:
                	DEBUG_USB("Pairing CH1...\n");	
//                	uiSentKeyToUi(UI_KEY_RF_PAIR_1);
                	break;
            	case 2:
                	DEBUG_USB("Pairing CH2...\n");	
//                	uiSentKeyToUi(UI_KEY_RF_PAIR_2);
                	break;
            	case 3:
                	DEBUG_USB("Pairing CH3...\n");	
//                	uiSentKeyToUi(UI_KEY_RF_PAIR_3);
                	break;
            	case 4:
                	DEBUG_USB("Pairing CH4...\n");	
//                	uiSentKeyToUi(UI_KEY_RF_PAIR_4);
                	break;
            }	
	        break;
        case PCAM_CMD_GET_PAIR_STATUS:
            break;
        case PCAM_CMD_SIGNAL_MODE:
            break;
        case PCAM_CMD_QUAD_MODE:
            break;
        case PCAM_CMD_CLR_TX_PIR:
    	    break;	
        case PCAM_CMD_GET_TX_PIR:    
            break;		
        case PCAM_CMD_SET_TIME:
        	DEBUG_USB("\nPCAM_CMD_SET_TIME\n");
        	/*Recv setting data from host.*/
        	FIFO0_H2D_4Byte();
        	DEBUG_USB("\nRECV time para\n");
        	set_time.year   =*(usb_device_buf);
        	set_time.month  =*(usb_device_buf+1);
        	set_time.day    =*(usb_device_buf+2);
        	set_time.hour   =*(usb_device_buf+3);
        	set_time.min    =*(usb_device_buf+4);
        	set_time.sec    =*(usb_device_buf+5);
        	DEBUG_USB("y=%d m=%d d=%d, h=%d m=%d s=%d\n",set_time.year,set_time.month,set_time.day,set_time.hour,set_time.min,set_time.sec);		
        	RTC_Set_GMT_Time(&set_time);
        	for(ch=0; ch<4; ch++)
        		uiSetRfTimeRxToTx(ch);
        	break;	
    	case PCAM_CMD_SET_CAMSWITCH:
    		/*Recv setting data from host.*/
    		DEBUG_USB("RECV Camera switch para\n");
    		FIFO0_H2D_4Byte();
    		ch=*usb_device_buf;
    		DEBUG_USB("\nCH=%d, switch=%d\n",ch,*(usb_device_buf+1));
    		switch(ch)
    		{
    			case 1:
    			DEBUG_USB("Set switch for CH1...\n");	
//    			if(*(usb_device_buf+1)==0)	
//					iconflag[UI_MENU_SETIDX_CH1_ON ] = UI_MENU_SETTING_CAMERA_OFF;
//				else
//					iconflag[ UI_MENU_SETIDX_CH1_ON] = UI_MENU_SETTING_CAMERA_ON;
//    			uiSentKeyToUi (UI_KEY_RF_CAM_ON_1);
    			break;
    			case 2:
    			DEBUG_USB("Set switch for CH2...\n");	
//    			if(*(usb_device_buf+1)==0)	
//					iconflag[UI_MENU_SETIDX_CH2_ON ] = UI_MENU_SETTING_CAMERA_OFF;
//				else
//					iconflag[ UI_MENU_SETIDX_CH2_ON] = UI_MENU_SETTING_CAMERA_ON;
//    			uiSentKeyToUi (UI_KEY_RF_CAM_ON_2);
    			break;
    			case 3:
    			DEBUG_USB("Set switch for CH3...\n");	
//    			if(*(usb_device_buf+1)==0)	
//					iconflag[UI_MENU_SETIDX_CH3_ON ] = UI_MENU_SETTING_CAMERA_OFF;
//				else
//					iconflag[ UI_MENU_SETIDX_CH3_ON] = UI_MENU_SETTING_CAMERA_ON;
//    			uiSentKeyToUi (UI_KEY_RF_CAM_ON_3);
    			break;
    			case 4:
    			DEBUG_USB("Set switch for CH4...\n");	
//    			if(*(usb_device_buf+1)==0)	
//					iconflag[UI_MENU_SETIDX_CH4_ON ] = UI_MENU_SETTING_CAMERA_OFF;
//				else
//					iconflag[ UI_MENU_SETIDX_CH4_ON] = UI_MENU_SETTING_CAMERA_ON;
//    			uiSentKeyToUi (UI_KEY_RF_CAM_ON_4);
    			break;
    		}	
    	    break;	
    	case PCAM_CMD_SET_MOTION:
    		/*Recv setting data from host.*/
    		DEBUG_USB("RECV motion config para\n");
    		FIFO0_H2D_4Byte();
    		ch=*usb_device_buf;
    		DEBUG_USB("\nCH=%d, Sensitivity=%d\n",ch,*(usb_device_buf+1));
    		
    		switch(ch)
    		{
    			case 1:
        			DEBUG_USB("Set motion detect for CH1...\n");	
//        			iconflag[UI_MENU_SETIDX_CH1_MOTION_SENSITIVITY] = *(usb_device_buf+1);
//        			uiSentKeyToUi(UI_KEY_RF_MOTION_1);
        			break;
    			case 2:
        			DEBUG_USB("Set motion detect for CH2...\n");	
//        			iconflag[UI_MENU_SETIDX_CH2_MOTION_SENSITIVITY] = *(usb_device_buf+1);
//        			uiSentKeyToUi(UI_KEY_RF_MOTION_2);
    			    break;
    			case 3:
        			DEBUG_USB("Set motion detect for CH3...\n");	
//        			iconflag[UI_MENU_SETIDX_CH3_MOTION_SENSITIVITY] = *(usb_device_buf+1);
//        			uiSentKeyToUi(UI_KEY_RF_MOTION_3);
        			break;
    			case 4:
        			DEBUG_USB("Set motion detect for CH4...\n");	
//        			iconflag[UI_MENU_SETIDX_CH4_MOTION_SENSITIVITY] = *(usb_device_buf+1);
//        			uiSentKeyToUi(UI_KEY_RF_MOTION_4);
        			break;
    		}	
    	    break;			
    	case PCAM_CMD_SET_TVSYSTEM:
            /*Recv setting data from host.*/
            DEBUG_USB("\nRECV TVSYSTEM para\n");
            FIFO0_H2D_4Byte();
            ch=*usb_device_buf;
            DEBUG_USB("\nCH=%d, TV system=%d\n",ch,*(usb_device_buf+1));
//            if (*(usb_device_buf+1)==1)
//            	iconflag[UI_MENU_SETIDX_FLICKER] = UI_MENU_SENSOR_FLICKER_60HZ;
//            else
//            	iconflag[UI_MENU_SETIDX_FLICKER] = UI_MENU_SENSOR_FLICKER_50HZ;
//            uiSentKeyToUi( UI_KEY_RF_FLICKER);	
            break;		
    	case PCAM_CMD_SET_OSDMODE:
    		/*Recv setting data from host.*/
    		DEBUG_USB("RECV OSD mode para\n");
    		FIFO0_H2D_4Byte();
    		ch=*usb_device_buf;
    		DEBUG_USB("\nCH=%d, Switch=%d, Type=%d\n",*usb_device_buf,*(usb_device_buf+1),*(usb_device_buf+2));
    		switch(ch)
    		{
    			case 1:
    				DEBUG_USB(" Set CH1 OSD mode...\n");
    				/*Enable or disable OSD*/
//    				if(*(usb_device_buf+1)==0)	
//    					iconflag[ UI_MENU_SETIDX_CH1_TSP_ON] = UI_MENU_TIME_STAMP_OFF;
//    				else
//    					iconflag[ UI_MENU_SETIDX_CH1_TSP_ON] = UI_MENU_TIME_STAMP_ON;
//        				uiSentKeyToUi (UI_KEY_RF_STAMP_ON_1);
    				/*Select the OSD display mode.*/
//    				iconflag [ UI_MENU_SETIDX_CH1_TSP_TYPE] = *(usb_device_buf+2);
//        			uiSentKeyToUi (UI_KEY_RF_STAMP_TYPE_1);
    			    break;
    			case 2:
    				DEBUG_USB(" Set CH2 OSD mode...\n");
    				/*Enable or disable OSD*/
//    				if(*(usb_device_buf+1)==0)	
//    					iconflag[ UI_MENU_SETIDX_CH2_TSP_ON] = UI_MENU_TIME_STAMP_OFF;
//    				else
//    					iconflag[ UI_MENU_SETIDX_CH2_TSP_ON] = UI_MENU_TIME_STAMP_ON;
//        				uiSentKeyToUi (UI_KEY_RF_STAMP_ON_2);
    				/*Select the OSD display mode.*/
//    				iconflag [ UI_MENU_SETIDX_CH2_TSP_TYPE] = *(usb_device_buf+2);
//        			uiSentKeyToUi (UI_KEY_RF_STAMP_TYPE_2);
    			    break;
    			case 3:
    				DEBUG_USB(" Set CH3 OSD mode...\n");
    				/*Enable or disable OSD*/
//    				if(*(usb_device_buf+1)==0)	
//    					iconflag[ UI_MENU_SETIDX_CH3_TSP_ON] = UI_MENU_TIME_STAMP_OFF;
//    				else
//    					iconflag[ UI_MENU_SETIDX_CH3_TSP_ON] = UI_MENU_TIME_STAMP_ON;
//        				uiSentKeyToUi (UI_KEY_RF_STAMP_ON_3);
    				/*Select the OSD display mode.*/
//    				iconflag [ UI_MENU_SETIDX_CH3_TSP_TYPE] = *(usb_device_buf+2);
//        			uiSentKeyToUi (UI_KEY_RF_STAMP_TYPE_3);
    			    break;
    			case 4:
    				DEBUG_USB(" Set CH4 OSD mode...\n");
    				/*Enable or disable OSD*/
//    				if(*(usb_device_buf+1)==0)	
//    					iconflag[ UI_MENU_SETIDX_CH4_TSP_ON] = UI_MENU_TIME_STAMP_OFF;
//    				else
//    					iconflag[ UI_MENU_SETIDX_CH4_TSP_ON] = UI_MENU_TIME_STAMP_ON;
//        				uiSentKeyToUi (UI_KEY_RF_STAMP_ON_4);
    				/*Select the OSD display mode.*/
//    				iconflag [ UI_MENU_SETIDX_CH4_TSP_TYPE] = *(usb_device_buf+2);
//        			uiSentKeyToUi (UI_KEY_RF_STAMP_TYPE_4);
    			    break;
    		}	
    		break;
    	case PCAM_CMD_SET_SMALLSTREAM_Q:
    		/*Recv setting data from host.*/
    		DEBUG_USB("RECV set small stream quality para\n");
    		FIFO0_H2D_4Byte();
    		ch=*usb_device_buf;
    		DEBUG_USB("\nCH=%d, Level=%d\n",*usb_device_buf,*(usb_device_buf+1));
    		switch(ch)
    		{
    			case 1:
    				DEBUG_USB(" Set CH1 quality...\n");
    				/*Set the video quality for small stream.*/
//    				iconflag [ UI_MENU_SETIDX_CH1_STREAM_QUALITY] =*(usb_device_buf+1);
//        			uiSentKeyToUi (UI_KEY_RF_STREAM_Q_1);
    			    break;
    			case 2:
    				DEBUG_USB(" Set CH2 quality...\n");
    				/*Set the video quality for small stream.*/
//    				iconflag [ UI_MENU_SETIDX_CH2_STREAM_QUALITY] =*(usb_device_buf+1);
//        			uiSentKeyToUi (UI_KEY_RF_STREAM_Q_2);
    			    break;
    			case 3:
    				DEBUG_USB(" Set CH3 quality...\n");
    				/*Set the video quality for small stream.*/
//    				iconflag [ UI_MENU_SETIDX_CH3_STREAM_QUALITY] =*(usb_device_buf+1);
//        			uiSentKeyToUi (UI_KEY_RF_STREAM_Q_3);
    			    break;
    			case 4:
    				DEBUG_USB(" Set CH4 quality...\n");
    				/*Set the video quality for small stream.*/
//    				iconflag [ UI_MENU_SETIDX_CH4_STREAM_QUALITY] =*(usb_device_buf+1);
//        			uiSentKeyToUi (UI_KEY_RF_STREAM_Q_4);
    			    break;
    		}	
		    break;		
        case PCAM_CMD_STOP_PAIR:
        	/*Recv setting data from host.*/
        	DEBUG_USB("RECV STOP PAIR para\n");
        	FIFO0_H2D_4Byte();
        	DEBUG_USB("\nStop pairing CH=%d...\n",*(usb_device_buf));	
        	rfiu_PAIR_Stop(*(usb_device_buf)-1);
            break;
    	case PCAM_CMD_SET_TXFLIPMIRROR:
    		/*Recv setting data from host.*/
            FIFO0_H2D_4Byte();
    		DEBUG_USB("PCAM_CMD_SET_TXFLIPMIRROR %d\n",*usb_device_buf);
            ch = *usb_device_buf;
//            switch(ch)
//            {
//                case 1:
//    				printf(" Set CH1 MIRROR %d...\n",*(usb_device_buf+1));
//                    if(*(usb_device_buf+1) == 0)
//                    {
//                        iconflag[UI_MENU_SETIDX_CH1_MIRROR] = UI_MENU_SETTING_VIDEO_MIRROR_OFF; 
//                    }
//                    else if(*(usb_device_buf+1) == 1)
//                    {
//                        iconflag[UI_MENU_SETIDX_CH1_MIRROR] = UI_MENU_SETTING_VIDEO_MIRROR_RIGHT; 
//                    }
//                    else if(*(usb_device_buf+1) == 2)
//                    {
//                        iconflag[UI_MENU_SETIDX_CH1_MIRROR] = UI_MENU_SETTING_VIDEO_MIRROR_DOWN; 
//                    }
//                    else if(*(usb_device_buf+1) == 3)
//                    {
//                        iconflag[UI_MENU_SETIDX_CH1_MIRROR] = UI_MENU_SETTING_VIDEO_MIRROR_ALL; 
//                    }
//                break;
//                case 2:
//    				printf(" Set CH2 MIRROR %d...\n",*(usb_device_buf+1));
//                    if(*(usb_device_buf+1) == 0)
//                    {
//                        iconflag[UI_MENU_SETIDX_CH2_MIRROR] = UI_MENU_SETTING_VIDEO_MIRROR_OFF; 
//                    } 
//                    else if(*(usb_device_buf+1) == 1)
//                    {
//                        iconflag[UI_MENU_SETIDX_CH2_MIRROR] = UI_MENU_SETTING_VIDEO_MIRROR_RIGHT; 
//                    }
//                    else if(*(usb_device_buf+1) == 2)
//                    {
//                        iconflag[UI_MENU_SETIDX_CH2_MIRROR] = UI_MENU_SETTING_VIDEO_MIRROR_DOWN; 
//                    }
//                    else if(*(usb_device_buf+1) == 3)
//                    {
//                        iconflag[UI_MENU_SETIDX_CH2_MIRROR] = UI_MENU_SETTING_VIDEO_MIRROR_ALL; 
//                    }
//                break;
//                case 3:
//    				printf(" Set CH3 MIRROR %d...\n",*(usb_device_buf+1));
//                    if(*(usb_device_buf+1) == 0)
//                    {
//                        iconflag[UI_MENU_SETIDX_CH3_MIRROR] = UI_MENU_SETTING_VIDEO_MIRROR_OFF; 
//                    }
//                    else if(*(usb_device_buf+1) == 1)
//                    {
//                        iconflag[UI_MENU_SETIDX_CH3_MIRROR] = UI_MENU_SETTING_VIDEO_MIRROR_RIGHT; 
//                    }
//                    else if(*(usb_device_buf+1) == 2)
//                    {
//                        iconflag[UI_MENU_SETIDX_CH3_MIRROR] = UI_MENU_SETTING_VIDEO_MIRROR_DOWN; 
//                    }
//                    else if(*(usb_device_buf+1) == 3)
//                    {
//                        iconflag[UI_MENU_SETIDX_CH3_MIRROR] = UI_MENU_SETTING_VIDEO_MIRROR_ALL; 
//                    }
//                break;
//                case 4:
//    				printf(" Set CH4 MIRROR %d...\n",*(usb_device_buf+1));                    
//                    if(*(usb_device_buf+1) == 0)
//                    {
//                        iconflag[UI_MENU_SETIDX_CH4_MIRROR] = UI_MENU_SETTING_VIDEO_MIRROR_OFF; 
//                    }
//                    else if(*(usb_device_buf+1) == 1)
//                    {
//                        iconflag[UI_MENU_SETIDX_CH4_MIRROR] = UI_MENU_SETTING_VIDEO_MIRROR_RIGHT; 
//                    }
//                    else if(*(usb_device_buf+1) == 2)
//                    {
//                        iconflag[UI_MENU_SETIDX_CH4_MIRROR] = UI_MENU_SETTING_VIDEO_MIRROR_DOWN; 
//                    }
//                    else if(*(usb_device_buf+1) == 3)
//                    {
//                        iconflag[UI_MENU_SETIDX_CH4_MIRROR] = UI_MENU_SETTING_VIDEO_MIRROR_ALL; 
//                    }
//                break;
//                    
//            }
//            uiSentKeyToUi(UI_KEY_RF_FLICKER);
    	    break;	
    	case PCAM_CMD_SET_WIFI_INFO:
    		/*Recv setting data from host.*/
        	DEBUG_USB("PCAM_CMD_SET_WIFI_INFO\n");
            FIFO0_H2D_4Byte();
            WifiCHNum   = *usb_device_buf;
            WifiPower   = *(usb_device_buf+1);
            WifiPingtime= *(usb_device_buf+2);
            M7688_WifiCHNum=WifiCHNum;
            M7688_WifiPower=WifiPower;
            
            //sysTX8211_EnterWifi(P2PQuailty);
            //sysbackSetEvt(SYS_BACK_RFI_TX_ENT_WIFI,P2PQuailty);
            sysback_RF_SetEvt(SYS_BACKRF_RFI_TX_ENT_WIFI,P2PQuailty);
    		DEBUG_USB("\nWIFI INFO %d %d %d\n",WifiCHNum,WifiPower,WifiPingtime);
            break;
    	case PCAM_CMD_SET_P2P_QUALITY:
    		/*Recv setting data from host.*/
            FIFO0_H2D_4Byte();
    		DEBUG_USB("\nPCAM_CMD_SET_P2P_QUALITY %d\n",*usb_device_buf);
            P2PQuailty= *usb_device_buf;
            break;
    	case PCAM_CMD_SET_WIFI_STATUS:
    		/*Recv setting data from host.*/
            FIFO0_H2D_4Byte();
    		DEBUG_USB("\nPCAM_CMD_SET_WIFI_STATUS %d\n",*usb_device_buf);
            //P2PQuailty= *usb_device_buf;
            break;
    	case PCAM_CMD_SET_PTZ:  
    		/*Recv setting data from host.*/
            FIFO0_H2D_4Byte(); //1:up,2:down,3:left,4:right
    		DEBUG_USB("\nPCAM_CMD_SET_PTZ %d\n",*usb_device_buf);
            if(*(usb_device_buf) == 1)
                rfiuSetMotorCtrl_TX(UI_SET_MOTOR_ARROW_UP);
            else if(*(usb_device_buf) == 2)
                rfiuSetMotorCtrl_TX(UI_SET_MOTOR_ARROW_DOWN);
            else if(*(usb_device_buf) == 3)
                rfiuSetMotorCtrl_TX(UI_SET_MOTOR_ARROW_RIGHT);
            else if(*(usb_device_buf) == 4)
                rfiuSetMotorCtrl_TX(UI_SET_MOTOR_ARROW_LEFT);
            break;
    	case PCAM_CMD_GET_TIME:
    		DEBUG_USB("\nSend SYSTEM TIME para\n");
    		RTC_Get_Time(&set_time);
    		*(usb_device_buf+0)=set_time.year;
    		*(usb_device_buf+1)=set_time.month;
    		*(usb_device_buf+2)=set_time.day;
    		*(usb_device_buf+3)=set_time.hour;
    		*(usb_device_buf+4)=set_time.min;
    		*(usb_device_buf+5)=set_time.sec;
    		FIFO2_Bulk_In_Transfer(32);
    	    break;	
    	case PCAM_CMD_GET_CAMSWITCH:
    		DEBUG_USB("\nSend camera switch para\n");
//    		*(usb_device_buf+0)=1;
//    		*(usb_device_buf+1)=iconflag[ UI_MENU_SETIDX_CH1_ON];
//    		*(usb_device_buf+2)=0;
//    		*(usb_device_buf+3)=0;
//    		*(usb_device_buf+4)=2;
//    		*(usb_device_buf+5)=iconflag[ UI_MENU_SETIDX_CH2_ON];
//    		*(usb_device_buf+6)=0;
//    		*(usb_device_buf+7)=0;
//    		*(usb_device_buf+8)=3;
//    		*(usb_device_buf+9)=iconflag[ UI_MENU_SETIDX_CH3_ON];
//    		*(usb_device_buf+10)=0;
//    		*(usb_device_buf+11)=0;
//    		*(usb_device_buf+12)=4;
//    		*(usb_device_buf+13)=iconflag[ UI_MENU_SETIDX_CH4_ON];
//    		*(usb_device_buf+14)=0;
//    		*(usb_device_buf+15)=0;
    		FIFO2_Bulk_In_Transfer(32);
    	    break;	
    	case PCAM_CMD_GET_MOTION:
    		DEBUG_USB("\nSend motion detect para\n");
//    		*(usb_device_buf+0)=1;
//    		*(usb_device_buf+1)=iconflag[ UI_MENU_SETIDX_CH1_MOTION_SENSITIVITY];
//    		*(usb_device_buf+2)=0;
//    		*(usb_device_buf+3)=0;
//    		*(usb_device_buf+4)=2;
//    		*(usb_device_buf+5)=iconflag[ UI_MENU_SETIDX_CH2_MOTION_SENSITIVITY];
//    		*(usb_device_buf+6)=0;
//    		*(usb_device_buf+7)=0;
//    		*(usb_device_buf+8)=3;
//    		*(usb_device_buf+9)=iconflag[ UI_MENU_SETIDX_CH3_MOTION_SENSITIVITY];
//    		*(usb_device_buf+10)=0;
//    		*(usb_device_buf+11)=0;
//    		*(usb_device_buf+12)=4;
//    		*(usb_device_buf+13)=iconflag[ UI_MENU_SETIDX_CH4_MOTION_SENSITIVITY];
//    		*(usb_device_buf+14)=0;
//    		*(usb_device_buf+15)=0;
    		FIFO2_Bulk_In_Transfer(32);
    	    break;	
    	case PCAM_CMD_GET_TVSYSTEM: //8211_RDI_SEP : push msg
    		DEBUG_USB("\nSend Push Msg %d \n",Snapshot_Error);
            if(Snapshot_Error == 1)
            {
        		*(usb_device_buf+0) = 1;
                //DEBUG_USB("\nSend Push Msg %d\n",Snapshot_Error);
                Snapshot_Error = 0;
            }
            else
            {
                *(usb_device_buf+0)=0;
                //DEBUG_USB("\nSend Push Msg %d \n",Snapshot_Error);
            }
    		//*(usb_device_buf+1)=iconflag[ UI_MENU_SETIDX_FLICKER];
    		FIFO2_Bulk_In_Transfer(32);
    	    break;	
    	case PCAM_CMD_GET_OSDMODE:
    		DEBUG_USB("\nSend OSD para\n");
//    		*(usb_device_buf+0)=1;
//    		*(usb_device_buf+1)=iconflag[ UI_MENU_SETIDX_CH1_TSP_ON];
//    		*(usb_device_buf+2)=iconflag[ UI_MENU_SETIDX_CH1_TSP_TYPE];
//    		*(usb_device_buf+3)=0;
//    		*(usb_device_buf+4)=2;
//    		*(usb_device_buf+5)=iconflag[ UI_MENU_SETIDX_CH2_TSP_ON];
//    		*(usb_device_buf+6)=iconflag[ UI_MENU_SETIDX_CH2_TSP_TYPE];
//    		*(usb_device_buf+7)=0;
//    		*(usb_device_buf+8)=3;
//    		*(usb_device_buf+9)=iconflag[ UI_MENU_SETIDX_CH3_TSP_ON];
//    		*(usb_device_buf+10)=iconflag[ UI_MENU_SETIDX_CH3_TSP_TYPE];
//    		*(usb_device_buf+11)=0;
//    		*(usb_device_buf+12)=4;
//    		*(usb_device_buf+13)=iconflag[ UI_MENU_SETIDX_CH4_TSP_ON];
//    		*(usb_device_buf+14)=iconflag[ UI_MENU_SETIDX_CH4_TSP_TYPE];
//    		*(usb_device_buf+15)=0;
    		FIFO2_Bulk_In_Transfer(32);
    	    break;		
    	case PCAM_CMD_GET_SMALLSTREAM_Q:
    		DEBUG_USB("\nSend SMALLSTREAM_Q para\n");
//    		*(usb_device_buf+0)=1;
//    		*(usb_device_buf+1)=iconflag[ UI_MENU_SETIDX_CH1_STREAM_QUALITY];
//    		*(usb_device_buf+2)=0;
//    		*(usb_device_buf+3)=0;
//    		*(usb_device_buf+4)=2;
//    		*(usb_device_buf+5)=iconflag[ UI_MENU_SETIDX_CH2_STREAM_QUALITY];
//    		*(usb_device_buf+6)=0;
//    		*(usb_device_buf+7)=0;
//    		*(usb_device_buf+8)=3;
//    		*(usb_device_buf+9)=iconflag[ UI_MENU_SETIDX_CH3_STREAM_QUALITY];
//    		*(usb_device_buf+10)=0;
//    		*(usb_device_buf+11)=0;
//    		*(usb_device_buf+12)=4;
//    		*(usb_device_buf+13)=iconflag[ UI_MENU_SETIDX_CH4_STREAM_QUALITY];
//    		*(usb_device_buf+14)=0;
//    		*(usb_device_buf+15)=0;
    		FIFO2_Bulk_In_Transfer(32);
    	    break;		
    	case PCAM_CMD_GET_VERSION:
    		DEBUG_USB("\nSend USB FW VERSION.\n");
    		memcpy(usb_device_buf,uiVersion,32);
    		FIFO2_Bulk_In_Transfer(32);
    	    break;	
    	case PCAM_CMD_GET_VERSION_TIME:
    		DEBUG_USB("\nSend USB FW VERSION TIME.\n");
    		memcpy(usb_device_buf,uiVersionTime,9);
    		FIFO2_Bulk_In_Transfer(32);
    	    break;	
    	case PCAM_CMD_GET_VIDEO_READY:
    		DEBUG_USB("\nCheck Video status...........%d\n",USB_total_size);
    		if(USB_total_size>200)
    			*(usb_device_buf+0)=1; // video is ready.	
    		else
    			*(usb_device_buf+0)=0;//video not ready.
    		FIFO2_Bulk_In_Transfer(32);
    	    break;	
    	case PCAM_CMD_GET_P2PUID:
    		DEBUG_USB("\nSend USB P2P UID\n");
    		memcpy(usb_device_buf,uiP2PID,21);
            if((usb_device_buf[0] == ']') ||(usb_device_buf[0] == ' '))
            {
    		    memcpy(usb_device_buf,"12345678901234567890",20);
                DEBUG_USB("uiP2PID %s\n",usb_device_buf);
            }
            DEBUG_USB("UID %s\n",usb_device_buf);
    		FIFO2_Bulk_In_Transfer(32);
    	    break;	
        case PCAM_CMD_GET_RESOLUTION:
            break;		
    	case PCAM_CMD_FW_UPGRADE:
    		/*Recv setting data from host.*/
    		DEBUG_USB("\nFW upgrading.\n");
    		sysDeadLockMonitor_OFF(); /*Turn off watch dog.*/
    		memset(codeAddr, 0, 1024*1024);	
            uiMenuSet_UpgradeServer();
          #if RFIU_SUPPORT
        	uiSetRfDisplayMode(4);// 4="UI_MENU_RF_ENTER_SETUP" Enter Menu mode to alloc 8MB memory for f/w upgrade.
          #endif
            DEBUG_USB("\nFW start.\n");
           // OS_ENTER_CRITICAL();
        	for(i=0;i<1024*1024;)
    		{
    			FIFO0_H2D_512Byte();
    			memcpy(codeAddr+i,usb_device_buf,32);
    			i+=32;
    			if(gUSB_UPGRADE==1)
    			{
    				DEBUG_USB("Download firmware  fail.\n");
					sysForceWDTtoReboot();
    				OSTimeDly(100);
    			}
    		}	
    		DEBUG_USB("Recv file complete.\n");
    		if (i!=(1024*1024))
    		{
    			DEBUG_USB("Firmware length error = %d.\n",i);
				sysForceWDTtoReboot();
                OSTimeDly(100);
    		}
    	  #if 1
    		MD5Init(&ctx);
    		MD5Update(&ctx, (unsigned char*)codeAddr+0x100,1024*1024-0x100);
    		MD5Final(digest,&ctx);
    		for (i = 0; i < 16; i++)
    		{
    			sprintf(buf3,"%02x",digest[i]);
    			buf2[2*i]=buf3[0];
    			buf2[2*i+1]=buf3[1];
    		}
    		buf2[32]='\0';
    		DEBUG_USB("FW MD5_1:%s\n",buf2);	
    		
    		for(i = 0; i < 32; i++)
            {
                MD5_buf[i]=(codeAddr+0xa0)[i];
            }
    		DEBUG_USB("FW MD5_2:%s\n",MD5_buf);
    	  #endif
    	  #if 1
    		if(!strncmp(MD5_buf,buf2,32))
    		{
        		if(ispUpdateAllload_Net(1024*1024)==0)
        			DEBUG_USB("Firmware upgrade fail.\n");	
        		else
        			DEBUG_USB("Firmware upgrade success.\n");
    		}	
    		else
    			DEBUG_USB("MD5SUM check error!\n");
			sysForceWDTtoReboot();
    		OSTimeDly(100);
    	  #endif
    	    break;	
    	case PCAM_CMD_USB_RESET:
    		DEBUG_USB("USB dongle reboot...\n");
			sysForceWDTtoReboot();
    		OSTimeDly(100);
    	    break;	
        default:
            break;
    }
    PcamCmd[0] = PCAM_CMD_NONE;
}
void Pcam_Reg_Cmd_Handle()
{
    u32 reg;
    u8 *pos,ucom[4];
//    DEBUG_USB("B");
    
    FIFO0_H2D_4Byte();
    reg = *(u32*)(usb_device_buf);
    pos = usb_device_buf;
   
    //DEBUG_USB(" %x",*pos);
    ucom[0]=*pos;
    pos++;
    //DEBUG_USB(" %x",*pos);
    ucom[1]=*pos;;
    pos++;
    //DEBUG_USB(" %x",*pos);
    ucom[2]=*pos;
    pos++;
    //DEBUG_USB(" %x",*pos);
    ucom[3]=*pos;
            
//    reg=reg+((u32)(*pos << 24));
//    DEBUG_USB( "\n CMD reg: 0x%08X", reg);   
    if( ((u8)reg == 0x25) && ( (u8)(reg>>8) == 0x6f ) ) // Reg read
    {
        DEBUG_USB("\n read");
        if( ((u8)(reg>>16) == 0x1f) && ( ucom[3] == 0xf8 ) )
        {
            *((volatile unsigned *)(usb_device_buf)) = PcamCmd[0];
             DEBUG_USB("\n 3");
        }
        else if( ((u8)(reg>>16) == 0x1f) && ( ucom[3] == 0xf9 ) )
        {
            *((volatile unsigned *)(usb_device_buf)) = PcamCmd[1];
            
        }
        else if( ((u8)(reg>>16) == 0x1f) && ( ucom[3] == 0xfa ) )
        {
            *((volatile unsigned *)(usb_device_buf)) = PcamCmd[2];
             DEBUG_USB("\n 4");
        }
        else if( ((u8)(reg>>16) == 0x1f) && ( ucom[3] == 0xfb ) )
        {
            *((volatile unsigned *)(usb_device_buf)) = PcamCmd[3];
            f_com = 1; 
            DEBUG_USB("\n 5 f_end");
        }
        else if( ((u8)(reg>>16) == 0x1f) && ( ucom[3] == 0xfc ) )
        {
            *((volatile unsigned *)(usb_device_buf)) = PcamCmd[4];
        }
        else
            *((volatile unsigned *)(usb_device_buf)) = PcamCmd[3];

        FIFO1_D2H_16Byte();
        DEBUG_USB("u");
    }
    else    // Reg write
    {
        DEBUG_USB("\n write");
        if( ((u8)(reg>>0) == 0x1f) && ( (u8)(reg>>8) == 0xf8 ) )
        {
            PcamCmd[0] = (u8)(reg>>16);
            PcamCmd[1] = ucom[3];
            DEBUG_USB("\n 2");
            if((PcamCmd[0]!=PCAM_CMD_START_PREVIEW)&& (PcamCmd[0]!=PCAM_CMD_CAMERA_SEL))
            {
                DEBUG_USB("\n ***** 2");
                f_com = 1; 			
            }
        }
        if( ((u8)(reg>>0) == 0x1f) && ( (u8)(reg>>8) == 0xf9 ) )
        {
            PcamCmd[1] = (u8)(reg>>16);
            f_com = 0;
            DEBUG_USB("\n f_strat 1");
        }
        if( ((u8)(reg>>0) == 0x1f) && ( (u8)(reg>>8) == 0xfa ) )
        {
            PcamCmd[2] = (u8)(reg>>16);
        }
        if( ((u8)(reg>>0) == 0x1f) && ( (u8)(reg>>8) == 0xfb ) )
        {
            PcamCmd[3] = (u8)(reg>>16);

        }
        if( ((u8)(reg>>0) == 0x1f) && ( (u8)(reg>>8) == 0xfc ) )
        {
            PcamCmd[4] = (u8)(reg>>16);
        }
    }

    //DeviceFIFO0ByteCnt=(1<<12);
    if(PcamCmd[0] != PCAM_CMD_NONE)
    {
        Mars_Pcam_Cmd();
    }
//    DEBUG_USB( "\n Pcam_Reg_Cmd: 0x%08X", *((volatile unsigned *)(usb_device_buf)));
}
void D2H_XFER(u32 len ,u32 addr)
{
    u32 flag,cnt,tmp;
    s32 retry;
    #if (OS_CRITICAL_METHOD == 3)                      /* Allocate storage for CPU status register           */
    unsigned int  cpu_sr = 0;                    /* Prevent compiler warning                           */
    #endif
    
   // len=16;
    DeviceFIFO1ByteCnt=(1<<12);
    DeviceDMATargetFIFONum=(1<<1); //fifo1
    DeviceDMACtlParam1=(len<<8)|(1<<1);
    DeviceDMACtlParam2=(u32)addr;
    DeviceInterruptSourceG2|=(USBD_MDMA_CMPLT);
    mENABLE_USB_IRQ;
    DeviceDMACtlParam1 |=1;
   // DEBUG_USB("\n#D2H 16 Bulk S\n");
  #if 1
 	cnt=0;
    retry=3;	/*Usb dongle retry number when occurs timeout or other errors.*/
	USB_timeout=0;
    while((DeviceInterruptSourceG2 & USBD_MDMA_CMPLT) == 0x00000000)
    {
		cnt++;  
		if(retry <=0)
		{
      		DEBUG_USB("USB:Transfer Timeout:%d.\n",retry);
			DeviceDMACtlParam1 = (1<<3);    // dma abort
    	    DeviceFIFO1ByteCnt = (1<<12);
            tmp=DeviceInterruptSourceG1&(USBD_MF0_SPK_INT|USBD_MF0_OUT_INT);
            if (tmp)
            {
                Pcam_Reg_Cmd_Handle();
            }
            else
            {
    			USB_timeout=1;
    			DEBUG_USB("USB dongle rebooting...");
    			sysForceWDTtoReboot();
            }
    	    break;
		}  
		if(DeviceInterruptSourceG2 & USBD_MDMA_ERROR)
        {
          	DeviceInterruptSourceG2|=(USBD_MDMA_CMPLT);
            DeviceDMACtlParam1 = (1<<3);    // dma abort
            while(DeviceDMACtlParam1 & 0X00000008);
            DeviceInterruptSourceG2|=(USBD_MDMA_CMPLT);
        	DEBUG_USB("USB:DMA fail.\n");
            DeviceFIFO1ByteCnt=(1<<12);
            DeviceDMATargetFIFONum=(1<<1); //fifo1
            DeviceDMACtlParam1=(len<<8)|(1<<1);
            DeviceDMACtlParam2=(u32)addr;
            DeviceInterruptSourceG2|=(USBD_MDMA_CMPLT);

            DeviceDMACtlParam1 |=1;
            cnt=0;
            retry--;
        }
        if(cnt > 800000 )   /*If counter decrease to 0, means usb transfer timeout.*/
        {
            DeviceDMACtlParam1 = (1<<3);    // dma abort
            while(DeviceDMACtlParam1 & 0X00000008);
            DeviceInterruptSourceG2|=(USBD_MDMA_CMPLT);
        	DEBUG_USB("USB:Retry start.\n");
            DeviceFIFO1ByteCnt=(1<<12);
            DeviceDMATargetFIFONum=(1<<1); //fifo1
            DeviceDMACtlParam1=(len<<8)|(1<<1);
            DeviceDMACtlParam2=(u32)addr;
            DeviceInterruptSourceG2|=(USBD_MDMA_CMPLT);
            DeviceDMACtlParam1 |=1;
            cnt=0;
            retry--;        	
        }
    }
    cnt=0;
    while((DeviceInterruptSourceG1 & USBD_MF1_IN_INT) == 0x00000000)
    {                                           
        cnt++;
        if(cnt>8000000)	
    	{
    		DEBUG_USB("USBX_MF1_IN timeout\n");
    		break;
    	}
    };
//  DEBUG_USB("# xfer Bulk F\n");
//  DeviceInterruptSourceG2 &= ~USBD_MDMA_CMPLT ;
    DeviceInterruptSourceG2|=(USBD_MDMA_CMPLT);
//  DeviceDMATargetFIFONum = 0x00000000 ;
//  OSTimeDly(4>>2);
  #endif 
}
void D2H_Audio( u32 audAddr, u32 audLen)
{
    u32 flag,rem, pos,len,cnt;
    u32 *header;
  #if (OS_CRITICAL_METHOD == 3)                      /* Allocate storage for CPU status register           */
    unsigned int  cpu_sr = 0;                    /* Prevent compiler warning                           */
  #endif

    if(UsbAltSetting == 0)
        return;

    DeviceFIFO2ByteCnt=(1<<12);
    DeviceFIFO3ByteCnt=(1<<12);
    
    rem = audLen;
    pos = audAddr;
    
    header = (u32*)audAddr;
    *header = 0xff00ffff;       // signature 1
    header++;
    *header = 0x00048096;       // signature 2
    
    header++;
    len = *header;
    *header = 4;    // time stamp 4 byte
//    DEBUG_USB( "\n audLen=0x%05x", audLen );
    
    DEBUG_USB("a");
    while(rem)
    {
        if ( rem >= IosPktSizeTbl[UsbAltSetting] )
            len = IosPktSizeTbl[UsbAltSetting];
        else
            len = rem;
    
        DeviceDMATargetFIFONum=(1<<1);//fifo1
        DeviceDMACtlParam1=(len<<8)|(1<<1);
        DeviceDMACtlParam2=pos;
        DeviceInterruptSourceG2|=(USBD_MDMA_CMPLT);
        mENABLE_USB_IRQ;
        DeviceDMACtlParam1=(len<<8)|(1<<1)|(1<<0);
        cnt = 0;
        while(1)
        {
            flag = OSFlagPend(OSUSB_task_flag, 0x02, OS_FLAG_WAIT_SET_ANY|OS_FLAG_CONSUME, OS_TICKS_PER_SEC*200, 0 );
            mENABLE_USB_IRQ;

            if(flag==0)
            {
                DeviceDMACtlParam1 = (1<<3);    // TIMEOUT dma abort
                DeviceFIFO2ByteCnt=(1<<12);
                DeviceFIFO3ByteCnt=(1<<12);
                //DEBUG_USB("timeout Iso!");
                //DEBUG_USB( "c" );
                return;
            }
            if(flag&0x02)
            {
                while( DeviceFIFO2ByteCnt != 0 )
                {
                    //DEBUG_USB( "\n F2Cnt: 0x%08x", DeviceFIFO2ByteCnt );
                    OSTimeDly(1);
                    cnt++;
                    if(cnt > 200*4 )     // wait 200 ms
                    {
                        DeviceDMACtlParam1=(1<<3);    // dma abort
                        DeviceFIFO2ByteCnt=(1<<12);
                        DeviceFIFO3ByteCnt=(1<<12);
                        //PcamPreviewStart=0;
                        //DEBUG_USB( "\n Stop Pcam." );
                        return;
                    }
                }
                //DEBUG_USB( "\n USB IN  Done." );
                break;
            }
        }
        DeviceInterruptSourceG2|=(USBD_MDMA_CMPLT);
        pos += len;
        rem -= len;
    }
}
void D2H_Image( u32 imgAddr, u32 imgLen )
{
    u32 len, pos;
	int packet_len=8192;
    
  #if (OS_CRITICAL_METHOD == 3)                      /* Allocate storage for CPU status register           */
    unsigned int  cpu_sr = 0;                    /* Prevent compiler warning                           */
  #endif

    len = imgLen;
    pos = imgAddr;
	while(len>0)
	{	
/*
        tmp=DeviceInterruptSourceG1&(USBD_MF0_SPK_INT|USBD_MF0_OUT_INT);
        if (tmp)
        {
            Pcam_Reg_Cmd_Handle();
        }	
*/        
		if((PcamPreviewStart)&&(USB_timeout==0))
		{
			if(len > packet_len)
			{
				D2H_XFER(packet_len,imgAddr);				
				imgAddr+=packet_len;
				if(USB_timeout)
					len=0;
				else
					len-=packet_len;
			}
			else
			{
				D2H_XFER(len,imgAddr);
				len=0;
			}	
		}
		else
		{
			len=0;
			DEBUG_USB("STOP transfer to USB\n.");
		}
	//OSTimeDly(1);
	}		    
}
void UpdateMpeg4Header(int Width,int Height, int UseMpeg_Q)
{
    MP4_config[0x17] &= 0xF0; 
    MP4_config[0x18] &= 0x00;
    MP4_config[0x19] &= 0x7F;
    MP4_config[0x19] &= 0xC0;
    MP4_config[0x1A] &= 0x01;   
        
    MP4_config[0x17] |= (unsigned char)(Width >> 9); 
    MP4_config[0x18] |= (unsigned char)(Width >> 1);     
    MP4_config[0x19] |= (unsigned char)(Width << 7);     
    MP4_config[0x19] |= (unsigned char)(Height >> 7);
    MP4_config[0x1A] |= (unsigned char)(Height << 1);
    if(UseMpeg_Q)
    {
        MP4_config[0x1b]=0x49;
        MP4_config[0x1c]=0x0f; 
    }
    else
    {
        MP4_config[0x1b]=0x44;
       MP4_config[0x1c]=0x3f;  
    }
    
}
void UpdateUSBMIXHeader(int ch,u8 format)
{
    u32 size;
    static unsigned int frame_num[MAX_AV_CH] = 0;
    static s32 smallstream_time[MAX_AV_CH] = 0; 
	unsigned int cur_time;
	u32 diff_time;
    
    cur_time=OSTimeGet();
    
    if((format == 3) || (format == 4))
        USB_AV_header[0] = 2; //Photo diary video 
    else
        USB_AV_header[0] = format; 
    
    USB_AV_header[1] = ch;
    if(format == 1) //audio
    {
        USB_AV_header[2] = USBAudioPresentTime[ch];
        USB_AV_header[3] = USBAudioPresentTime[ch] >> 8;
        USB_AV_header[4] = USBAudioPresentTime[ch] >> 16;
        USB_AV_header[5] = USBAudioBuf[ch][USBAudioBufReadIdx[ch]].size;
        USB_AV_header[6] = USBAudioBuf[ch][USBAudioBufReadIdx[ch]].size >> 8;
        USB_AV_header[7] = USBAudioBuf[ch][USBAudioBufReadIdx[ch]].size >> 16;
        USB_AV_header[11] = 'A';
        
        USB_AV_header[12] = 128;
        USB_AV_header[13] = 128 >> 8;
        USB_AV_header[23] = gRfiuUnitCntl[ch].BitRate;
        USB_AV_header[24] = gRfiuUnitCntl[ch].BitRate >> 8;
        
        //DEBUG_USB(" %08d %08d",(u32)USBAudioPresentTime[ch],USBAudioBuf[ch][USBAudioBufReadIdx[ch]].size);    
    }
    else if(format == 2)    //video
    {
        if(USBVideoBuf[ch][USBVideoBufReadIdx[ch]].flag)
            USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size += 0x1d;
        
        USB_AV_header[4] = Snapshot_Error;
//        if(Snapshot_Error == 1)
//        {
//            DEBUG_USB("UpdateUSBMIXHeader Snapshot_Error %d\n\n",Snapshot_Error);
//            Snapshot_Error = 0;
//        }
        USB_AV_header[5] = USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size;
        USB_AV_header[6] = USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size >> 8;
        USB_AV_header[7] = USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size >> 16;
//        DEBUG_USB("size %d\n",USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size);
        USB_AV_header[8] = (USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size);
        USB_AV_header[9] = (USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size) >> 8;
        USB_AV_header[10] = (USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size) >> 16;
        
        if(USBVideoBuf[ch][USBVideoBufReadIdx[ch]].flag)
            USB_AV_header[11] = 'I';
        else
            USB_AV_header[11] = 'P';
        
        USB_AV_header[12] = (u32)USBVideoBuf[ch][USBVideoBufReadIdx[ch]].time;
        USB_AV_header[13] = (u32)USBVideoBuf[ch][USBVideoBufReadIdx[ch]].time >> 8;
        
        USB_AV_header[14] = mpeg4Width;
        USB_AV_header[15] = mpeg4Width >> 8;

        USB_AV_header[16] = mpeg4Height;
        USB_AV_header[17] = mpeg4Height >> 8;

	    USB_AV_header[18] = 640;
        USB_AV_header[19] = 640 >> 8;

        USB_AV_header[20] = 352;
        USB_AV_header[21] = 352 >> 8;
        
        USB_AV_header[22] = gRfiuUnitCntl[ch].FrameRate;

        USB_AV_header[23] = gRfiuUnitCntl[ch].BitRate;
        USB_AV_header[24] = gRfiuUnitCntl[ch].BitRate >> 8;

        if(USBVideoBuf[ch][USBVideoBufReadIdx[ch]].flag)
            USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size -= 0x1d;

        //USB_AV_header[25] = 0;
        if(GMotionTrigger[ch + MULTI_CHANNEL_LOCAL_MAX] == 1)
        {
            USB_AV_header[25] = 1; 
            GMotionTrigger[ch + MULTI_CHANNEL_LOCAL_MAX] = 0;
        }
        else
            USB_AV_header[25] = 0; 
        //if((mpeg4Width != 1280) && (mpeg4Width != 704) && (mpeg4Width != 352))
        //DEBUG_USB("Error %d W %d H %d\n",USBVideoBufReadIdx[ch],mpeg4Width,mpeg4Height);
    }

}
/*

Routine Description:

	The USB Video Class task.

Arguments:

	pData - The task parameter.

Return Value:

	None.

*/
void usbVcTask(void* pData)
{
    u8 delay_flag,i;
    u8  *buf_addr;
	u16 video_value[MAX_AV_CH]={0,0,0,0};
	u16 video_value_max[MAX_AV_CH]={0,0,0,0};
	u16 audio_value[MAX_AV_CH]={0,0,0,0};
	u16 audio_value_max[MAX_AV_CH]={0,0,0,0};
    u16 ch,err;
	u32 video_buf_offset=0,Size,tmp,len,cnt1=0,sub_stream_size,buf_size;
	int video_frame_cnt,Audio_cnt; 
    int count=0;
    static u8 frame_num[MAX_AV_CH] = {0x0,0x0,0x0,0x0};
    char raytest[]="raymond test file use usb write 123456789";

	u32	psize;
	u8* pbuffer;	
    //FS_FILE* pFile;
    //FS_FILE* p1File;
	
    #if (OS_CRITICAL_METHOD == 3)                      /* Allocate storage for CPU status register           */
    unsigned int  cpu_sr = 0;                    /* Prevent compiler warning                           */
    #endif

    OS_FLAGS USB_event;
    
    //GRTCTime=OSTimeGet();
    //DEBUG_USB( "\n sizeof(USB_ISP_CONFIGURATION_DESC): 0x%08x", sizeof(USB_ISP_CONFIGURATION_DESC) );
    usbVC_init();
#if 0
    if ((pFile = dcfOpen("AV.txt", "w")) == NULL)
    {	
    	DEBUG_USB("open file error!\n");
    }
//#else
    if ((p1File = dcfOpen("RF.txt", "w")) == NULL)
    {	
    	DEBUG_USB("open file error!\n");
    }
#endif

    while (1)
    {
        mENABLE_USB_IRQ;        
        USB_event=OSFlagPend (OSUSB_task_flag, 0xffffffff, OS_FLAG_WAIT_SET_ANY|OS_FLAG_CONSUME, OS_TICKS_PER_SEC*200, 0);
        //mENABLE_USB_IRQ;
        DEBUG_USB("\n.");
        //if( USB_event == 0x00 )
        //    continue;
		
        if (DeviceInterruptSourceG2&1)
        {
            Usb_Host_Reset_Cmd();
        }
        tmp = DeviceInterruptSourceG0&(USBD_MCX_SETUP_INT);
        if (tmp)
        {
            if (tmp&USBD_MCX_SETUP_INT)
            {
                Usb_Ctrl_pipe_Handle();
            }
        }
        tmp = DeviceInterruptSourceG1&(USBD_MF0_SPK_INT|USBD_MF0_OUT_INT);
        if (tmp)
        {
            Pcam_Reg_Cmd_Handle();
        }

      /*if(USB_event & 0x10)
        {
            DEBUG_USB("Img");
        }*/

	  	if(PcamPreviewStart==0)
	  	{
	  		for(i=0; i<MAX_AV_CH;i++)
	  		{
				video_value[i]      = 0;
				video_value_max[i]  = 0;
				audio_value[i]      = 0;
				audio_value_max[i]  = 0;
	  		}	
			video_buf_offset=0;
			cnt1=0;
	  	}
      	if(PcamPreviewStart && f_com)
	    {
            //time1 = OSTimeGet();    // t
            T1 = OSTimeGet();            
            if((T_prev - T1) > 20)
            {
                USB_total_size = 0;
                video_buf_offset = 0;
                T_prev = OSTimeGet();
            }
        	while((PcamPreviewStart == 1)&&(USB_timeout == 0))
        	{
        		tmp=DeviceInterruptSourceG1&(USBD_MF0_SPK_INT|USBD_MF0_OUT_INT);
                if (tmp)
                {
                    Pcam_Reg_Cmd_Handle();
                }
                if((Reset_RES == 1) && (VideoBufMngWriteIdx >= 1) && (MPEG4_Task_Go == 1))
                {
                    video_frame_cnt = 0;
                    Audio_cnt = 0;
                    DEBUG_USB("Reset_RES %d %d\n",USBVideoBufReadIdx[0],USBAudioBufReadIdx[0]);
                }
        		for(ch=0; ch<1; ch++)
        		{                   		
            	    // ------Streaming audio payload------//
            	    if(Reset_RES == 0)
            	    {
                        if(Session_Ready[ch] == 1)
                        {
                        	if(VideoBufMngWriteIdx < USBVideoBufReadIdx[ch])
                        		video_frame_cnt = ((VideoBufMngWriteIdx + VIDEO_BUF_NUM) - USBVideoBufReadIdx[ch]);
                        	else
                                video_frame_cnt = VideoBufMngWriteIdx - USBVideoBufReadIdx[ch];
                        }
                        else
                            video_frame_cnt = 0;

                        if(Session_Ready[ch] == 1)
                        {
                            if(iisSounBufMngWriteIdx >= USBAudioBufReadIdx[ch])
                                Audio_cnt = iisSounBufMngWriteIdx - USBAudioBufReadIdx[ch];
                            else
                                Audio_cnt = (iisSounBufMngWriteIdx + IIS_BUF_NUM) - USBAudioBufReadIdx[ch];
                        }
                        else
                            Audio_cnt=0;
            	    }
                    else
                    {
                        video_frame_cnt = 0;
                        Audio_cnt=0;
                        cnt1=0;
                        DEBUG_USB("video not ready\n");
                    }

                    //if((video_value[ch] == 0) || (USBAudioPresentTime[ch] <= USBVideoPresentTime[ch]))
                    if(1)//(((video_value[ch] == 0)) && (P2P_Snapshot == 0))
                    { 
                        audio_value[ch] = Audio_cnt;
//                        if(audio_value[ch]>4)
//                            DEBUG_USB("A %d %d %d %d\n",audio_value[ch],iisSounBufMngWriteIdx,USBAudioBufReadIdx[ch],USBAudioPresentTime[ch]);
                        if((Audio_cnt > 4)&&(USB_timeout == 0))
                        { 
                            //printf("#%d,%d  ",USBAudioBufReadIdx[ch],iisSounBufMngWriteIdx);
                            /* Add mix header ()*/
                            if(1)//(updateNALheader[ch] == 1)
                            {
        					    UpdateUSBMIXHeader(ch,1);
                                buf_addr = usb_AV_buf + video_buf_offset;
                                USB_total_size += header_size;
                                
                                memcpy_hw(buf_addr ,USB_AV_header,header_size);
                                video_buf_offset += header_size;

                                buf_addr = usb_AV_buf + video_buf_offset;
                                USB_total_size += USBAudioBuf[ch][USBAudioBufReadIdx[ch]].size;
                                #if 0
                                if (dcfWrite(p1File,USBVideoBuf[0][USBVideoBufReadIdx[0]].buffer, USBVideoBuf[0][USBVideoBufReadIdx[0]].size, &Size) == 0)
                                {
                                        DEBUG_USB(" Write test error!!!\n");
                                        dcfClose(p1File);
                                } 
                                #endif
                                if((buf_addr + USBAudioBuf[ch][USBAudioBufReadIdx[ch]].size) > usb_AV_buf_end)
                                {
                                    memcpy_hw(buf_addr ,USBAudioBuf[ch][USBAudioBufReadIdx[ch]].buffer,(usb_AV_buf_end - buf_addr));
        				
                                    buf_size = USBAudioBuf[ch][USBAudioBufReadIdx[ch]].size - (usb_AV_buf_end - buf_addr);
                                    memcpy_hw(usb_AV_buf ,USBAudioBuf[ch][USBAudioBufReadIdx[ch]].buffer + (usb_AV_buf_end - buf_addr) ,buf_size);
                                    video_buf_offset = buf_size;
                                }
                                else
                                {
                                    memcpy_hw(buf_addr ,USBAudioBuf[ch][USBAudioBufReadIdx[ch]].buffer,USBAudioBuf[ch][USBAudioBufReadIdx[ch]].size);
                                    video_buf_offset += USBAudioBuf[ch][USBAudioBufReadIdx[ch]].size;
                                }
                            }
                            if(Audio_cnt > 0)
                            {
                            	Audio_cnt--;		
                                audio_value[ch] = Audio_cnt;
                            	OSSemAccept(USBAudioCmpSemEvt[ch]);
                            	//USBAudioPresentTime[ch] += (USBAudioBuf[ch][USBAudioBufReadIdx[ch]].time);    //if use chunk time 
                            	USBAudioBufReadIdx[ch] = (USBAudioBufReadIdx[ch] + 1) % IIS_BUF_NUM; 
                            }
        	            }
        	        }
                //------ Streaming video payload------//  
                    //if(((audio_value[ch] == 0) || (USBAudioPresentTime[ch] >= USBVideoPresentTime[ch])) && (P2P_Snapshot == 0))
                    if(1)//(((audio_value[ch] == 0)) && (P2P_Snapshot == 0))
        			{   
                        video_value[ch] = video_frame_cnt;
//                        if(video_value[ch]>0)
//                            DEBUG_USB("V %d %d %d %d\n",video_value[ch],VideoBufMngWriteIdx,USBVideoBufReadIdx[ch],USBVideoPresentTime[ch]);
                        #if 1
                        if (video_frame_cnt >= 30)
                        {                            
                            DEBUG_USB("v %d %d %d %d\n",ch,video_frame_cnt,VideoBufMngWriteIdx,USBVideoBufReadIdx[ch]);
                            USBVideoBufReadIdx[ch] = VideoBufMngWriteIdx ;
                            video_frame_cnt = 0;

                        }
                            //DEBUG_USB("v %d %d %d %d\n",ch,video_frame_cnt,USBVideoBufReadIdx[ch],rfiuRxVideoBufMngWriteIdx[ch]);
                        #endif
        			    /* Rf write index move to usb read index End  */
                        if((video_frame_cnt>2) && (USB_timeout==0))
                        {
                            T_prev = OSTimeGet();
                            delay_flag = 0;
                            if(USBVideoBuf[ch][USBVideoBufReadIdx[ch]].flag)
                            {
                                /* Add mix header ()*/
                                //updateNALheader[ch] = 0;
//                                frame_num[ch] = 0;
//                                *(USBVideoBuf[ch][USBVideoBufReadIdx[ch]].buffer+6) = 0x84;
                                UpdateUSBMIXHeader(ch,2);
                                buf_addr = usb_AV_buf + video_buf_offset;
                                USB_total_size += header_size;
                                if((buf_addr + header_size) > usb_AV_buf_end)
                                {
                                    if(((usb_AV_buf_end - buf_addr) < 0) || ((usb_AV_buf_end - buf_addr) > 614400)) //300k
                                    {
                                        USBVideoBufReadIdx[ch] = VideoBufMngWriteIdx ;
                                        video_frame_cnt = 0; 
                                        DEBUG_USB("warnning size %d\n",(usb_AV_buf_end - buf_addr));
                                        break;
                                    }
                                    memcpy_hw(buf_addr ,USB_AV_header,(usb_AV_buf_end - buf_addr));

                                    buf_size = header_size - (usb_AV_buf_end - buf_addr);
                                    if((buf_size < 0) || (buf_size > 614400)) //300k
                                    {
                                        USBVideoBufReadIdx[ch] = VideoBufMngWriteIdx ;
                                        video_frame_cnt = 0;
                                        DEBUG_USB("warnning size %d\n",buf_size);
                                        break;
                                    }
                                    memcpy_hw(usb_AV_buf ,USB_AV_header + (usb_AV_buf_end - buf_addr) ,buf_size);
                                    video_buf_offset = buf_size;
                                }
                                else
                                {
                                    memcpy_hw(buf_addr ,USB_AV_header,header_size);
                                    video_buf_offset += header_size;                                
                                }
                                UpdateMpeg4Header(mpeg4Width,mpeg4Height,USE_MPEG_QUANTIZATION);
                                buf_addr = usb_AV_buf + video_buf_offset;
                                USB_total_size += MP4_HeaderSize;
                                if((buf_addr + MP4_HeaderSize) > usb_AV_buf_end)
                                {
                                    if(((usb_AV_buf_end - buf_addr) < 0) || ((usb_AV_buf_end - buf_addr) > 614400)) //300k
                                    {
                                        USBVideoBufReadIdx[ch] = VideoBufMngWriteIdx ;
                                        video_frame_cnt = 0; 
                                        DEBUG_USB("warnning size %d\n",(usb_AV_buf_end - buf_addr));
                                        break;
                                    }
                                    memcpy_hw(buf_addr ,MP4_config,(usb_AV_buf_end - buf_addr));

                                    buf_size = MP4_HeaderSize - (usb_AV_buf_end - buf_addr);
                                    if((buf_size < 0) || (buf_size > 614400)) //300k
                                    {
                                        USBVideoBufReadIdx[ch] = VideoBufMngWriteIdx ;
                                        video_frame_cnt = 0;
                                        DEBUG_USB("warnning size %d\n",buf_size);
                                        break;
                                    }
                                    memcpy_hw(usb_AV_buf ,MP4_config + (usb_AV_buf_end - buf_addr) ,buf_size);
                                    video_buf_offset = buf_size;
                                }
                                else
                                {
                                    /* Add H264 header ()*/
                                    memcpy_hw(buf_addr,MP4_config,MP4_HeaderSize);
        							//updateNALheader[ch] = 2;
                                    video_buf_offset += MP4_HeaderSize;
                                }

                                buf_addr = usb_AV_buf + video_buf_offset;
                                USB_total_size += USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size;
                                if((buf_addr + USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size) > usb_AV_buf_end)
                                {
                                    if(((usb_AV_buf_end - buf_addr) < 0) || ((usb_AV_buf_end - buf_addr) > 614400)) //300k
                                    {
                                        USBVideoBufReadIdx[ch] = VideoBufMngWriteIdx ;
                                        video_frame_cnt = 0;
                                        DEBUG_USB("warnning size %d\n",(usb_AV_buf_end - buf_addr));
                                        break;
                                    }
                                    memcpy_hw(buf_addr ,USBVideoBuf[ch][USBVideoBufReadIdx[ch]].buffer,(usb_AV_buf_end - buf_addr));

                                    buf_size = USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size - (usb_AV_buf_end - buf_addr);
                                    if((buf_size < 0) || (buf_size > 614400)) //300k
                                    {
                                        USBVideoBufReadIdx[ch] = VideoBufMngWriteIdx ;
                                        video_frame_cnt = 0;
                                        DEBUG_USB("warnning size %d\n",buf_size);
                                        break;
                                    }
                                    memcpy_hw(usb_AV_buf ,USBVideoBuf[ch][USBVideoBufReadIdx[ch]].buffer + (usb_AV_buf_end - buf_addr) ,buf_size);
                                    video_buf_offset = buf_size;
                                }
                                else
                                {
                                    if((USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size < 0) || (USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size > 614400)) //300k
                                    {
                                        USBVideoBufReadIdx[ch] = VideoBufMngWriteIdx ;
                                        video_frame_cnt = 0;
                                        DEBUG_USB("warnning size %d\n",USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size);
                                        break;
                                    }
                                    memcpy_hw(buf_addr ,USBVideoBuf[ch][USBVideoBufReadIdx[ch]].buffer,USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size);
                                    video_buf_offset += USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size;
                                }
    					    }
                            else
                            {
                                /* Add mix header ()*/
                                UpdateUSBMIXHeader(ch,2);
                                buf_addr = usb_AV_buf + video_buf_offset;
                                USB_total_size += header_size;

                                if((buf_addr + header_size) > usb_AV_buf_end)
                                {
                                    if(((usb_AV_buf_end - buf_addr) < 0) || ((usb_AV_buf_end - buf_addr) > 614400)) //300k
                                    {
                                        USBVideoBufReadIdx[ch] = VideoBufMngWriteIdx ;
                                        video_frame_cnt = 0;
                                        DEBUG_USB("warnning size %d\n",(usb_AV_buf_end - buf_addr));
                                        break;
                                    }
                                    memcpy_hw(buf_addr ,USB_AV_header,(usb_AV_buf_end - buf_addr));

                                    buf_size = header_size - (usb_AV_buf_end - buf_addr);
                                    if((buf_size < 0) || (buf_size > 614400)) //300k
                                    {
                                        USBVideoBufReadIdx[ch] = VideoBufMngWriteIdx;
                                        video_frame_cnt = 0;
                                        DEBUG_USB("warnning size %d\n",buf_size);
                                        break;
                                    }
                                    memcpy_hw(usb_AV_buf ,USB_AV_header + (usb_AV_buf_end - buf_addr) ,buf_size);
                                    video_buf_offset = buf_size;
                                }
                                else
                                {
                                    memcpy_hw(buf_addr ,USB_AV_header,header_size);
                                    video_buf_offset += header_size;                                
                                }

                                buf_addr = usb_AV_buf + video_buf_offset;
                                USB_total_size += USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size;
                                #if 0
                                    if (dcfWrite(p1File,USBVideoBuf[0][USBVideoBufReadIdx[0]].buffer, USBVideoBuf[0][USBVideoBufReadIdx[0]].size, &Size) == 0)
                                    {
                                        DEBUG_USB(" Write test error!!!\n");
                                        dcfClose(p1File);
                                    }
                                #endif
                                if((buf_addr + USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size) > usb_AV_buf_end)
                                {
                                    if(((usb_AV_buf_end - buf_addr) < 0) || ((usb_AV_buf_end - buf_addr) > 614400)) //300k
                                    {
                                        USBVideoBufReadIdx[ch] = VideoBufMngWriteIdx ;
                                        video_frame_cnt = 0;
                                        DEBUG_USB("warnning size %d\n",(usb_AV_buf_end - buf_addr));
                                        break;
                                    }
                                    memcpy_hw(buf_addr ,USBVideoBuf[ch][USBVideoBufReadIdx[ch]].buffer,(usb_AV_buf_end - buf_addr));

                                    buf_size = USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size - (usb_AV_buf_end - buf_addr);
                                    if((buf_size < 0) || (buf_size > 614400)) //300k
                                    {
                                        USBVideoBufReadIdx[ch] = VideoBufMngWriteIdx ;
                                        video_frame_cnt = 0;
                                        DEBUG_USB("warnning size %d\n",buf_size);
                                        break;
                                    }
                                    memcpy_hw(usb_AV_buf ,USBVideoBuf[ch][USBVideoBufReadIdx[ch]].buffer + (usb_AV_buf_end - buf_addr) ,buf_size);
                                    video_buf_offset = buf_size;
                                }
                                else
                                {
                                    if((USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size < 0) || (USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size > 614400)) //300k
                                    {
                                        USBVideoBufReadIdx[ch] = VideoBufMngWriteIdx ;
                                        video_frame_cnt = 0;
                                        DEBUG_USB("warnning size %d\n",USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size);
                                        break;
                                    }
                                    memcpy_hw(buf_addr ,USBVideoBuf[ch][USBVideoBufReadIdx[ch]].buffer,USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size);
                                    video_buf_offset += USBVideoBuf[ch][USBVideoBufReadIdx[ch]].size;
                                }
    							//updateNALheader[ch] = 0;
                            }
        					if(video_frame_cnt > 0)
        					{
        						video_frame_cnt--;	
                                video_value[ch] = video_frame_cnt;
        						OSSemAccept(USBVideoCmpSemEvt[ch]);
            		    	    //USBVideoPresentTime[ch] += (USBVideoBuf[ch][USBVideoBufReadIdx[ch]].time); //if use chunk time   
        						USBVideoBufReadIdx[ch] = (USBVideoBufReadIdx[ch] + 1) % VIDEO_BUF_NUM; 
    	    
        					}
                        }
                    }
                    if(0)//((P2P_Snapshot == 1) && (P2P_Snapshot_cnt <= 10) && (P2P_Snapshot_cnt != 0))
                    {
                        DEBUG_USB("Add Picture in photo Diary mode %d \n\n",P2P_Snapshot_cnt); 
                        /* Add mix header ()*/
                        psize = sizeof(MPEG4_NoCam_QVGA);
                        pbuffer = MPEG4_NoCam_QVGA;
                        
					    UpdateUSBMIXHeader(ch,3);
                        buf_addr = usb_AV_buf + video_buf_offset;
                        USB_total_size += header_size;

                        if((buf_addr + header_size) > usb_AV_buf_end)
                        {
                            if(((usb_AV_buf_end - buf_addr) < 0) || ((usb_AV_buf_end - buf_addr) > 614400)) //300k
                            {
                                USBVideoBufReadIdx[ch] = VideoBufMngWriteIdx ;
                                video_frame_cnt = 0;
                                DEBUG_USB("warnning size %d\n",(usb_AV_buf_end - buf_addr));
                                break;
                            }
                            memcpy_hw(buf_addr ,USB_AV_header,(usb_AV_buf_end - buf_addr));

                            buf_size = header_size - (usb_AV_buf_end - buf_addr);
                            if((buf_size < 0) || (buf_size > 614400)) //300k
                            {
                                USBVideoBufReadIdx[ch] = VideoBufMngWriteIdx;
                                video_frame_cnt = 0;
                                DEBUG_USB("warnning size %d\n",buf_size);
                                break;
                            }
                            memcpy_hw(usb_AV_buf ,USB_AV_header + (usb_AV_buf_end - buf_addr) ,buf_size);
                            video_buf_offset = buf_size;
                        }
                        else
                        {
                            memcpy_hw(buf_addr ,USB_AV_header,header_size);
                            video_buf_offset += header_size;                                
                        }

                        buf_addr = usb_AV_buf + video_buf_offset;
                        USB_total_size += psize;
                        #if 0
                            if (dcfWrite(p1File,USBVideoBuf[0][USBVideoBufReadIdx[0]].buffer, USBVideoBuf[0][USBVideoBufReadIdx[0]].size, &Size) == 0)
                            {
                                DEBUG_USB(" Write test error!!!\n");
                                dcfClose(p1File);
                            }
                        #endif
                        if((buf_addr + psize) > usb_AV_buf_end)
                        {
                            if(((usb_AV_buf_end - buf_addr) < 0) || ((usb_AV_buf_end - buf_addr) > 614400)) //300k
                            {
                                USBVideoBufReadIdx[ch] = VideoBufMngWriteIdx ;
                                video_frame_cnt = 0;
                                DEBUG_USB("warnning size %d\n",(usb_AV_buf_end - buf_addr));
                                break;
                            }
                            memcpy_hw(buf_addr ,pbuffer,(usb_AV_buf_end - buf_addr));

                            buf_size = psize - (usb_AV_buf_end - buf_addr);
                            if((buf_size < 0) || (buf_size > 614400)) //300k
                            {
                                USBVideoBufReadIdx[ch] = VideoBufMngWriteIdx ;
                                video_frame_cnt = 0;
                                DEBUG_USB("warnning size %d\n",buf_size);
                                break;
                            }
                            memcpy_hw(usb_AV_buf ,pbuffer + (usb_AV_buf_end - buf_addr) ,buf_size);
                            video_buf_offset = buf_size;
                        }
                        else
                        {
                            if((psize < 0) || (psize > 614400)) //300k
                            {
                                USBVideoBufReadIdx[ch] = VideoBufMngWriteIdx ;
                                video_frame_cnt = 0;
                                DEBUG_USB("warnning size %d\n",psize);
                                break;
                            }
                            memcpy_hw(buf_addr ,pbuffer,psize);
                            video_buf_offset += psize;
                        }
						//updateNALheader[ch] = 0;
//                        USBVideoBufReadIdx[0]  = 0; 
//                        USBAudioBufReadIdx[0]  = 0;         
//                        USBVideoPresentTime[0] = 0;      
//                        USBAudioPresentTime[0] = 0;	
//                        USBVideoBuf[0]         = VideoBufMng;
//                        USBAudioBuf[0]         = iisSounBufMng;
                        if(P2P_Snapshot_cnt != 0)
                            P2P_Snapshot_cnt--;
                    }

                    /* Sent usb_AV_buf to USB */
	       			if(USB_total_size > 0)
	           	 	{ 
                        T1 = OSTimeGet();
                    	buf_addr = usb_AV_buf + 8192 * cnt1;
                    	while((USB_total_size > 8192) && (USB_timeout == 0))
                        {         	                                 
							if( buf_addr >= usb_AV_buf_end )
                       		{
	                       		cnt1 = 0;
    	                    	buf_addr = usb_AV_buf + 8192 * cnt1;
                	        }
							D2H_Image((u32)buf_addr ,8192);
//                            DEBUG_USB("D2H %d %d %d %d \n",*buf_addr,*(buf_addr+1),*(buf_addr+2),*(buf_addr+3));
                        #if 0
                            if (1)//( cnt1 % 2 == 0)
                            {
                             	if (dcfWrite(pFile,buf_addr, 2048, &Size) == 0)
                                {
                                    DEBUG_USB(" Write test error!!!\n");
                                    dcfClose(pFile);
                                }
                            }
                        #endif
    	                    buf_addr += 8192;
        	                USB_total_size -= 8192;
            	            cnt1 ++;
                            T_prev = OSTimeGet();
                    	}
            	    }	
        	    }
                OSTimeDly(1); 	           
            }
            //dcfClose(pFile);  
            //dcfClose(p1File);  	
	    }
	    OSTimeDly(1);	
	}
}   

//void usbVcTask(void* pData)
//{
//    //usbVcDevInit();

//    while (1)
//    {}
//}
void usbVCntHandler(void)
{
    u8 err;
    OS_FLAGS flag;

    IntIrqMask  |= INT_IRQ_MASK_USB;
    flag=0x01;
    if(DeviceInterruptSourceG2&USBD_MDMA_CMPLT)
    {
        flag |= 0x02;           // USB DMA complete
    }
  if(DeviceInterruptSourceG1& (USBD_MF0_OUT_INT | USBD_MF0_SPK_INT) )
    flag |= 0x04;
  if(DeviceInterruptSourceG1& (USBD_MF1_IN_INT | USBD_MF1_SPK_INT) )
    flag |= 0x08;
  if(DeviceInterruptSourceG1& (USBD_MF2_IN_INT | USBD_MF2_SPK_INT) )
    flag |= 0x10;
    OSFlagPost(OSUSB_task_flag, flag , OS_FLAG_SET, &err);
}
#endif

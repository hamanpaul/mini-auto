
//*-------------------------------------??????--------------------------------------------------------------------
#include "general.h"
//#include "lwip/lwipsys.h"
#include "lwip/mem.h"
#include "lwip/memp.h"
#include "lwip/pbuf.h"
#include "lwip/tcpip.h"
#include "lwip/opt.h"
#include "lwip/ip_addr.h"
#include "gpiapi.h"
#include "sysopt.h"
//#include "spiapi.h"
#include "uiapi.h"
#include <lwip/sockets.h>
#include "rtcapi.h"
#include "p2pserver_api.h"
#include "sysapi.h" //Sean
#include "lwip/Netifapi.h"
#include "netif/Ethernet.h"
#include "FTMAC110.h"
#include "lwipapi.h"


#if(NIC_SUPPORT == 1)
//*------------------------------------?????-------------------------------------------------------------------------
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen);
extern u8 SetLwIP(u8 mode);
extern struct hostent* lwip_gethostbyname(const char *name);

//*------------------------------------ ?????????? --------------------------------------
//* IP??
#define 	IP_ADDR0			0
#define 	IP_ADDR1			0
#define 	IP_ADDR2			0
#define 	IP_ADDR3			0

//* ????
#define		GATEWAY_ADDR0 		0
#define		GATEWAY_ADDR1 		0
#define		GATEWAY_ADDR2 		0
#define		GATEWAY_ADDR3 		0

//* ????
#define		NET_MASK0			0
#define		NET_MASK1			0
#define		NET_MASK2			0
#define		NET_MASK3			0

#define HTTP_PORT  					80
#define RTSP_PORT  					554

OS_FLAG_GRP  *gpiNetStatusFlagGrp;    /* Flag for network Status. */

/*Ethernet interface*/
struct netif  FTMAC110_netif;

//UI Setting
u8 LwipIPAddr[4]        = {192,168,1,118};
u8 LwipSubnetMask[4]    = {255,255,255,0};
u8 LwipDefaultGateway[4]= {192,168,1,1};
u8 LwipISStatic=0;     /* 0: Dynamic IP, 1: Static IP */
u8 LwipIpAddrInfo[4]= {0};
u8 LwipSubMaskInfo[4]= {0};
u8 LwipDefaultGatewayInfo[4]= {0};
u8 Lwipredhcp=0;     /* 0:  IP, 1:  IP */
__align(4)  u8_t  __RxBufs[1024] ;			// ?????
__align(4)  u8_t  __TxBufs[1024] ;			// ?????static volatile
const char ssst[]="welcome to ucos world!\n";
u8_t my_ipaddr[5]= {IP_ADDR0,IP_ADDR1,IP_ADDR2,IP_ADDR3};
u8 qetIP=0;
int NTP_ON;
RTC_DATE_TIME gDHCPTime;
u32 DHCP_leasetime=0xFFFFFFFF;//Infinity
static volatile bool tcpip_init_done_sem = false;
//========================================

extern err_t ethernetif_init(struct netif * netif);




#if(HW_BOARD_OPTION == MR9200_RX_TRANWO_D8796P) //20171208 add.
extern u8	Reset_P2P_Connection_flag;
extern u8	Reset_P2P_Connection_Stop_flag;
extern void Reset_P2P_Connection(void);
extern u8 FW_UPGRAD_flag;
#endif

extern u8_t uiMACAddr[6];
extern int net_link_status;
extern u8 renewIP;
extern u8  uiSetTxTime[MULTI_CHANNEL_MAX];
extern RTC_TIME_ZONE ntpTimeZone;
#if APP_KEEP_ALIVE
#define KEEP_ALIVE_TIMEOUT	60
#define MAX_CLIENT			4

extern u8 APPConnectIcon;
extern int gOnlineNum;
extern int gFlagKeepAlive[];
extern RTC_DATE_TIME gKeepAliveTime0;
extern RTC_DATE_TIME gKeepAliveTime1;
extern RTC_DATE_TIME gKeepAliveTime2;
extern RTC_DATE_TIME gKeepAliveTime3;
extern RTC_DATE_TIME gKeepAliveTime4;

#endif

struct hostent
{
    char  *h_name;      /* Official name of the host. */
    char **h_aliases;   /* A pointer to an array of pointers to alternative host names,
                           terminated by a null pointer. */
    int    h_addrtype;  /* Address type. */
    int    h_length;    /* The length, in bytes, of the address. */
    char **h_addr_list; /* A pointer to an array of pointers to network addresses (in
                           network byte order) for the host, terminated by a null pointer. */
#define h_addr h_addr_list[0] /* for backward compatibility */
};
//========================================
void NTP_Switch(int OnOff)
{
    NTP_ON=OnOff;
}

/*Get time from NTP server */
void ntpdate()
{
    char    hostname_IP[50]="";
    int     err;
    int	portno=123;		//NTP is port 123
    int	i;			// misc var i
    unsigned char msg[48]= {010,0,0,0,0,0,0,0,0};	// the packet we send
    unsigned long  buf[1024];	// the buffer we get back

    struct sockaddr_in server_addr;
    int	s;	// socket
    u8	noblock;
    int	tmit;	// the time -- This is a time_t sort of
    RTC_DATE_TIME NTP_time;
    RTC_DATE_TIME Local_time;
    //RTC_TIME_ZONE zone;
    s8 TimeZone;
    u8	retry_cnt=0;
    //u8 DNS_buf[8192];
    struct hostent *addr;

Retry:
    printf("Enter NTP\n");
    s=socket(PF_INET, SOCK_DGRAM, 0);
    if(s<0)
    {
        printf("Create socket fail : %d\n",s);
        return;
    }

    for(i = 0; i < MAX_NTP_NUM; i++)
    {
        err = DN2IP(NTP_SERV[i], hostname_IP);
		if(err <0)
        {
            DEBUG_P2P("\x1B[96mParse NTP_SERVER[%d] fail...Retry Backup Server.\x1B[0m\n", i);
            OSTimeDly(1);
            continue;
        }
        DEBUG_P2P("Get NTP_SERVER[%d],IP = %s\n", i,hostname_IP);
        noblock=1;
        ioctlsocket(s,FIONBIO,&noblock);

        //#convert hostname to ipaddress if needed
        //$ipaddr   = inet_aton($HOSTNAME);
        memset( &server_addr, 0, sizeof( server_addr ));
        server_addr.sin_family=AF_INET;

        server_addr.sin_addr.s_addr = inet_addr(hostname_IP);
        server_addr.sin_port=htons(portno);

        err=sendto(s,msg,sizeof(msg),0,(struct sockaddr *)&server_addr,sizeof(server_addr));
        // get the data back
        OSTimeDly(200);
        err=recv(s,buf,sizeof(buf),0);
        DEBUG_LIGHTCYAN("Retrieve NTP[%d] time: %d\n",i,  err);
        if(err > 0)
            break;
    }

#if((HW_BOARD_OPTION == MR8200_RX_RDI_M721)&&(PROJ_OPT == 5))
    if((retry_cnt == 0) && (i != 48))
    {
        printf("Retrieve NTP time Wrong, retry...\n");
        retry_cnt++;
        close(s);
        goto Retry;
    }
#endif

    tmit=ntohl(buf[10]);	//# get transmit time
    //printf("tmit=%d\n",tmit);

    tmit-= 2208988800U;
    tmit-=946684800;

    if(err>0)
    {
#if AutoNTPupdate
        TimeZone = SendGetTimeZoneMessage();
        if(TimeZone == 100)
            printf("\nNTP Time Get Fail.\n");
        else
        {
            tmit = tmit + TimeZone*3600;
            RTC_Second_To_Time(tmit,&NTP_time);
            printf("\nNTP Time: %s\n",ctime(&tmit));
            RTCTime_Gmt_To_Local(&NTP_time,&Local_time);
            //RTC_Set_Time(&Local_time);
            RTC_Set_GMT_Time(&Local_time);
        }

#else
        RTC_Second_To_Time(tmit,&Local_time);
        printf("\nNTP Time: %s\n",ctime(&tmit));
        //RTCTime_Gmt_To_Local(&NTP_time,&Local_time);
        //RTC_Set_Time(&Local_time);
        RTC_Set_GMT_Time(&Local_time);
#endif
                /*Sync with TX 20140731*/
#if RFIU_SUPPORT
        for(i=0; i<MAX_RFIU_UNIT; i++)
            uiSetRfTimeRxToTx(i);
#endif
#if ((UI_VERSION == UI_VERSION_RDI) ||(UI_VERSION == UI_VERSION_RDI_2) ||(UI_VERSION == UI_VERSION_RDI_3))
        uiFlowCheckDST(&Local_time, 2);
#endif
    }
    else
    {
        printf("Could'n get the NTP Time.\n");
        //sysForceWDTtoReboot(); //20150402_Sean,      NTP issue was fixed by aher 20160322.
    }
    close(s);
}

//*---------------------------------------------------------------------------------------------------------------------
//*????:InitLwIP
//*????:??lwip????????
//*          ???LwIP???????PBUF?PCB??OS????????
//*????:none
//*????:none
//*----------------------------------------------------------------------------------------------------------------------
void tcpip_init_done(void *arg)
{
    tcpip_init_done_sem = true;
}


void WaitlwIPInitDone(void)
{
    void EthernetDropRxFrame(int);
    INT8U err;
    
    while(1)
    {
        EthernetDropRxFrame(1);
        if(tcpip_init_done_sem)
            break;
    }
}


static void InitLwIP(void)
{
    lwipBufInit();
    tcpip_init(tcpip_init_done, 0);
}

//*-----------------------------------------------------------------------------------------------------------------------
//*????:SetLwIP
//*????:??LWIP,?????????????
//*????:none
//*????:none
//*------------------------------------------------------------------------------------------------------------------------

u8 SetLwIP(u8 mode)
{
    struct netif *pwlan = NULL;
    ip4_addr_t IpAddr, NetMask, GateWay, ipaddr;
#if LWIP_DHCP
    INT32U j;
    INT16U i;
    INT8S result;
    INT16U cnt;
    int mscnt =0;
    INT8U err;
    u8_t *p;
    u8 count=0;
    u8 ret;
#endif

    
    if(!qetIP)
    {
        memset(&FTMAC110_netif, 0, sizeof(FTMAC110_netif));
        LWIP_PLATFORM_DIAG(("SetLwIP!!\r\n"));
        printf("SetLwIP_my_hwaddr: %2x:%2x:%2x:%2x:%2x:%2x\n",uiMACAddr[0],uiMACAddr[1],uiMACAddr[2],uiMACAddr[3],uiMACAddr[4],uiMACAddr[5]);
        //netif_init();

        FTMAC110_netif.hwaddr[0]=uiMACAddr[0];
        FTMAC110_netif.hwaddr[1]=uiMACAddr[1];
        FTMAC110_netif.hwaddr[2]=uiMACAddr[2];
        FTMAC110_netif.hwaddr[3]=uiMACAddr[3];
        FTMAC110_netif.hwaddr[4]=uiMACAddr[4];
        FTMAC110_netif.hwaddr[5]=uiMACAddr[5];

        LWIP_PLATFORM_DIAG(("S0!!\r\n"));
        change_duplex_speed(FULL, _100);
        LWIP_PLATFORM_DIAG(("S1!!\r\n"));

        IP4_ADDR(&IpAddr, IP_ADDR0,IP_ADDR1,IP_ADDR2,IP_ADDR3);
        IP4_ADDR(&NetMask, NET_MASK0,NET_MASK1,NET_MASK2,NET_MASK3);
        IP4_ADDR(&GateWay,  GATEWAY_ADDR0, GATEWAY_ADDR1,GATEWAY_ADDR2,GATEWAY_ADDR3);
#if 0
        IP4_ADDR(&IpAddr, 192,168,3,102);
        IP4_ADDR(&NetMask, 255,255,255,0);
        IP4_ADDR(&GateWay,  192, 168,3,1);
#endif
        netif_add(&FTMAC110_netif,&IpAddr, &NetMask,&GateWay, NULL, ethernetif_init, tcpip_input);
        netif_set_default(&FTMAC110_netif);
        netif_set_up(&FTMAC110_netif);
        qetIP=1;
    }
    if(!LwipISStatic)
    {
        printf("DYNAMIC IP\n");
        //OSSemPend(Wait_Link_Status_Evt,OS_IPC_WAIT_FOREVER, &err);  //20160201 Sean Wait Untill Network Link Status

        //dhcp_start(&FTMAC110_netif);
        //OSFlagPost(gpiNetStatusFlagGrp, FLAGGPI_LWIP_IP_READY, OS_FLAG_SET, &err);

#if 1//LWIP_DHCP
        //LWIP_PLATFORM_DIAG(("Start DHCP Request!\r\n"));
        dhcp_start(&FTMAC110_netif);

        do
        {
            LWIP_PLATFORM_DIAG(("Start DHCP Request!!\r\n"));
            count++;

            //result = dhcp_start(&FTMAC110_netif);
            IP4_ADDR(&IpAddr,0,0,0,0);
            for(cnt=0; (cnt<100) && (IpAddr.addr == 0); cnt++)
            {
                IpAddr.addr = FTMAC110_netif.ip_addr.addr;
                OSTimeDlyHMSM(0,0,1,0);
            }
            //dhcp_stop(&FTMAC110_netif);
            if(IpAddr.addr != 0)
            {
                struct dhcp *dhcp;
                dhcp = netif_dhcp_data(&FTMAC110_netif);
                DEBUG_P2P("DHCP:t0=%lu,t1=%lu,t2=%lu\n",
                            dhcp->offered_t0_lease,dhcp->offered_t1_renew,dhcp->offered_t2_rebind);
                DHCP_leasetime=dhcp->offered_t1_renew;
                LWIP_PLATFORM_DIAG(("Start DHCP Request *** OK *** \r\n"));
                ret=0;
                break;
            }
            OSTimeDly(1);
        }
        while (IpAddr.addr == 0);
        LWIP_PLATFORM_DIAG(("\n=== DHCP====\r\n"));
        IpAddr.addr = FTMAC110_netif.ip_addr.addr;
        GateWay.addr = FTMAC110_netif.gw.addr;
        NetMask.addr = FTMAC110_netif.netmask.addr;

        if(1)
        {
            p =(u8_t *) &IpAddr.addr;
            my_ipaddr[0]=p[0];
            my_ipaddr[1]=p[1];
            my_ipaddr[2]=p[2];
            my_ipaddr[3]=p[3];
            LwipIPAddr[0]=p[0];
            LwipIPAddr[1]=p[1];
            LwipIPAddr[2]=p[2];
            LwipIPAddr[3]=p[3];
            OSFlagPost(gpiNetStatusFlagGrp, FLAGGPI_LWIP_IP_READY, OS_FLAG_SET, &err);
            printf("\nMY IP %u.%u.%u.%u \n",p[0],p[1],p[2],p[3]);
            p =(u8_t *) &IpAddr.addr;
            LwipIpAddrInfo[0]=p[0];
            LwipIpAddrInfo[1]=p[1];
            LwipIpAddrInfo[2]=p[2];
            LwipIpAddrInfo[3]=p[3];
            p =(u8_t *) &GateWay.addr;
            LwipDefaultGatewayInfo[0]=p[0];
            LwipDefaultGatewayInfo[1]=p[1];
            LwipDefaultGatewayInfo[2]=p[2];
            LwipDefaultGatewayInfo[3]=p[3];
            p =(u8_t *) &NetMask.addr;
            LwipSubMaskInfo[0]=p[0];
            LwipSubMaskInfo[1]=p[1];
            LwipSubMaskInfo[2]=p[2];
            LwipSubMaskInfo[3]=p[3];
        }
        IP4_ADDR(&ipaddr, 8, 8, 8, 8);
        dns_setserver(0, &ipaddr);
        IP4_ADDR(&ipaddr, 168, 95, 1, 1);
        dns_setserver(1, &ipaddr);

#endif
    }
    return 0;
}

/*
Get Network information. by aher 2013/03/22
*/
void GetNetworkInfo(struct NetworkInfo *info)
{
    int i;

    if(LwipISStatic)
    {
        for(i=0; i<4; i++)
        {
            info->IPaddr[i]=LwipIPAddr[i];
            info->Netmask[i]=LwipSubnetMask[i];
            info->Gateway[i]=LwipDefaultGateway[i];
            info->IsStaticIP = LwipISStatic;
        }
    }
    else
    {
        for(i=0; i<4; i++)
        {
            info->IPaddr[i]=LwipIpAddrInfo[i];
            info->Netmask[i]=LwipSubMaskInfo[i];
            info->Gateway[i]=LwipDefaultGatewayInfo[i];
            info->IsStaticIP = LwipISStatic;
        }
    }
}
void SetNetworkInfo(struct NetworkInfo *info)
{
    int i;
    for(i=0; i<4; i++)
    {
        LwipIPAddr[i]=info->IPaddr[i];
        LwipSubnetMask[i]=info->Netmask[i];
        LwipDefaultGateway[i]=info->Gateway[i];
    }
    LwipISStatic=info->IsStaticIP;
}

/*Clear Ip address.*/
void ClearNetworkInfo(void )
{
    if(LwipIpAddrInfo[0]!=0)
    {
        /*Clear IP information.*/
        FTMAC110_netif.ip_addr.addr=0;
        FTMAC110_netif.gw.addr=0;
        FTMAC110_netif.netmask.addr=0;
        LwipIpAddrInfo[0]=0;
        LwipIpAddrInfo[1]=0;
        LwipIpAddrInfo[2]=0;
        LwipIpAddrInfo[3]=0;
        LwipDefaultGatewayInfo[0]=0;
        LwipDefaultGatewayInfo[1]=0;
        LwipDefaultGatewayInfo[2]=0;
        LwipDefaultGatewayInfo[3]=0;
        LwipSubMaskInfo[0]=0;
        LwipSubMaskInfo[1]=0;
        LwipSubMaskInfo[2]=0;
        LwipSubMaskInfo[3]=0;
    }
}

//*-----------------------------------------------------------------------------------------------------------------------
//*????:LwIPEntry
//*????:LwIP????
//*????:none
//*????:none
//*-----------------------------------------------------------------------------------------------------------------------
// extern void vHandler_RTSP(ST_NETCONN);

void T_LwIPEntry(void *pevent)
{
    RTC_DATE_TIME current_time;
    INT8U   err;
    u8	p2p_fail_cnt=0, x;


    printf("T_LwIPEntry\n");
    OS_Init();
    InitLwIP();

    /*ENABLE_FTMAC110_INT_PHYSTS_CHG*/
    phywrite16(0x8000,FTPHY_REG_CONTROL_TEST2);

    for(x=0; x<50; x++)
    {
        if ((phyread16(FTPHY_REG_STATUS)&FTPHY_REG_STATUS_LINK)==1)
            break;
        OSTimeDly(1);
    }
    OSTimeDly(4); // Add for phy init to get correct status, Paul add, 180529
    if ((phyread16(FTPHY_REG_STATUS)&FTPHY_REG_STATUS_LINK)==0)
    {
        DEBUG_P2P(" Link => FAIL\n");
    }
    else
    {
        DEBUG_P2P(" Link status => Ok\n");
        DEBUG_P2P("Get IP address...\n");
        SetLwIP(0);
        renewIP=0;
    }

    //SetLwIP(0);
    //lwip_app_init();
#if 1
#if CLOUD_SUPPORT		
		gFlagCloudLoginOK = 1;
		RTC_Get_Time(&gCloud_Token_Time);
#endif

    while(!tcpip_init_done_sem)
        OSTimeDly(1);

#if SET_NTPTIME_TO_RTC

    NTP_Switch(NTP_SWITCH_ON);
    ntpdate();
#endif

#if (CHECK_FW_VER_BOOTING && NIC_SUPPORT)
    DEBUG_P2P("Checking the latest firmware version.\n");
    Check_fw_ver_net(Check_by_net);
#endif

    RTC_Get_Time(&gDHCPTime);
#endif
    printf("T_LwIPEntry\n");

    while(1)
    {
        RTC_Get_Time(&current_time);		
#if 1
        if(((net_link_status==NET_LINK_ON)&&(renewIP==1))||((FTMAC110_netif.ip_addr.addr==0)&&(net_link_status==NET_LINK_ON)
		&&(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gDHCPTime)))>DHCP_leasetime)))
        {
            DEBUG_P2P("Renew IP address...\n");
            SetLwIP(0);
            renewIP=0;
            RTC_Get_Time(&gDHCPTime);

#if (CHECK_FW_VER_BOOTING && NIC_SUPPORT)
            DEBUG_P2P("Checking the latest firmware version.\n");
            Check_fw_ver_net(Check_by_net);
			ntpdate();
#endif            
        }


        if(current_time.day!=gDHCPTime.day)
        {
#if (CHECK_FW_VER_BOOTING && NIC_SUPPORT)
            DEBUG_P2P("Checking the latest firmware version.\n");
            Check_fw_ver_net(Check_by_net);
#endif
            RTC_Get_Time(&gDHCPTime);
        }
        
#if CLOUD_SUPPORT   //Token存活一天
        if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gCloud_Token_Time)))>86400)
        {
            gFlagCloudLoginOK = 1;
            RTC_Get_Time(&gCloud_Token_Time);
        }
#endif
#endif // endif 0
        OSTimeDly(20);
    }
}

#else
u8_t my_ipaddr[5]= {0};

#endif

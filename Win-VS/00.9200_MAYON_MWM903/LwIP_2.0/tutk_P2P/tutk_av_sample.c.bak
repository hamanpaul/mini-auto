/*
Copyright (c) 2018 Mars Semiconductor Corp.

Module Name:

    Tutk_av_sample.c

Abstract:

    The routines of P2P Service Interface .
    
    
Environment:

        ARM RealView Developer Suite

Revision History:
    
    2018/12/12    Sean Create  
*/

#include <stdio.h>
#include <math.h>
#include <rt_fp.h>
#include <fenv.h>
#include "general.h"
#include "ucos_ii.h"
#include "lwip/sockets.h"
#include "IOTCAPIs.h"
#include "AVAPIs.h"
#include "AVFRAMEINFO.h"
#include "AVIOCTRLDEFs.h"
#include "task.h"
#include "gpiapi.h"
#include "lwipapi.h"
#include "lwip/ip_addr.h"
#include "lwip/netif.h"
#include "lwip/def.h"
#include "lwip/netdb.h"
#include "lwip/inet.h"
#include "ui.h"
#include "p2p_picture.h"
#include "p2pserver_api.h"
#include "MPEG4api.h"
#include "IISapi.h"
#include "UIapi.h"
#include "uiKey.h"
#include "sysapi.h"
#include "fsapi.h"
#include "GlobalVariable.h"
#include <../rfiu/inc/rfiu.h>
#include "Dcfapi.h"
#include "timerapi.h"
#include "rtcapi.h"
#include "ispapi.h"
#include "../../ui/inc/ui_project.h"
#include "encrptyapi.h"
#include "iduapi.h"
#include "tcp_client_api.h"
#if (P2P_IOCMD_TIMEOUT_HANDLE == 1)
#include "TMR.H"
#endif

//#define HANGON_DEBUG 1

//#include "rfiuapi.h"
/*
 *********************************************************************************************************
 *  Constant
 *********************************************************************************************************
 */
 #ifndef ElemsOfArray
#define ElemsOfArray(x) (sizeof(x) / sizeof(x[0])) 
#endif
static u32 SERVTYPE_STREAM_SERVER = 0;
#define P2P_LIVEVIEW_FIND_PRE_I_FRAME   1
#define MAX_SIZE_IOCTRL_BUF             1024
#define MAX_AV_CHANNEL_NUMBER           16
#define HOSTNAME_IP_BUF_SIZE            20
#define MAX_PUSH_MSG_SVR                2
#define PUSH_MSG_SVR_CONNECT_TIMEOUT    2000
#define PUSH_MSG_SVR_SEND_TIMEOUT       2000
#define SEND_REG_TIMEOUT                2000
#define AV_SENDIOCTRL_TIMEOUT           10     //1sec
#define TUTK_SESSION_ALIVE_TIMEOUT      20
#define AV_SENDIOCTRL_TIMEOUT2          ((TUTK_SESSION_ALIVE_TIMEOUT/2)*10)    //10sec
#define AV_SENDIOCTRL_TIMEOUT_TMR_ID    0
#define SAFE_DEL_P2P_PLAYFILE_TASK
#define P2P_LOCAL_BUF_SIZE (1920*1080*2)

//#define FPS 30 // Video FPS
//For DASA -- start
#undef DASA_ENABLED
#define DASA_HIGH_FPS 30
#define DASA_BTWHIGHNORMAL_FPS 20
#define DASA_NORMAL_FPS 15
#define DASA_BTWNORMALLOW_FPS 10
#define DASA_LOW_FPS 5
#define TEST_RECV_AUDIO_DELAY 1
//#define ENABLE_EMULATER         1
//For DASA -- end

#define RESET_RESEND_BUF_TIMEOUT        1000
//#define RESEND_BUF_MAX_USAGE_RATE       (0.60f)
#define RESEND_BUF_MAX_USAGE_RATE       60
#define RESEND_BUF_MAX_USAGE_RATE_INT   (60)


#if TEST_RECV_AUDIO_DELAY
#define NTP_TIMESTAMP_DELTA 2208988800ull
int ntp_client(char *host_name, struct tm *timeinfo);
#endif

#define AUDIO_FORMAT_PCM // modify this define for test which audio format

#ifdef AUDIO_FORMAT_PCM
#define AUDIO_FRAME_SIZE 640
#define AUDIO_FPS 25
//#define AUDIO_CODEC 0x8C

#elif defined(AUDIO_FORMAT_ADPCM)
#define AUDIO_FRAME_SIZE 160
#define AUDIO_FPS 25
#define AUDIO_CODEC 0x8B

#elif defined(AUDIO_FORMAT_SPEEX)
#define AUDIO_FRAME_SIZE 38
#define AUDIO_FPS 56
#define AUDIO_CODEC 0x8D

#elif defined(AUDIO_FORMAT_MP3)
#define AUDIO_FRAME_SIZE 380
#define AUDIO_FPS 32
#define AUDIO_CODEC 0x8E

#elif defined(AUDIO_FORMAT_SPEEX_ENC)
#define AUDIO_FRAME_SIZE 160
#define AUDIO_ENCODED_SIZE 160
#define AUDIO_FPS 56
#define AUDIO_CODEC 0x8D

#elif defined(AUDIO_FORMAT_G726_ENC)
#define AUDIO_FRAME_SIZE 320
#define AUDIO_ENCODED_SIZE 40
#define AUDIO_FPS 50
#define AUDIO_CODEC 0x8F

#elif defined(AUDIO_FORMAT_G726)
#define AUDIO_FRAME_SIZE 40
#define AUDIO_FPS 50
#define AUDIO_CODEC 0x8F
#endif

#define VIDEO_BUF_SIZE (1024*16)
#define AUDIO_BUF_SIZE (1024*16)

#if TEST_RECV_AUDIO_DELAY
#define TEST_CLIENT_IP "192.168.50.99"
#define TEST_CLIENT_PORT 5544
#define TEST_KIBANA_SERVER_PORT 9200
#endif
#define NTP_SERVER_IP "192.168.50.99"

#define Local_record   0
#define Local_playback 1
#define RX_receive     2
#define RX_transcoder  3
#define MAX_SIZE_IOCTRL_BUF		1024
#define MAX_BUF_SIZE 5120
#define BUFF_FOR_AUDIO  1024
#define P2PTX_AUDIO_TIMESHFT   4

#if (P2P_LV_RATECTL_SUPPORT == 1)
#define LOW_BIT_RATE_LIMIT      6  //Count of enter LOW_SPEED_RATE
#define LOW_BIT_RATE_LEAVE      20 //Percentage of resend buffer usage
#define LOW_BIT_RATE_ENTER      40 //Percentage of resend buffer usage
#define LOW_BIT_RATE_MODE(i) (gClientInfo[i].localSendCount >= LOW_BIT_RATE_LIMIT)
//#define LOW_BIT_RATE_MODE(i) (FALSE)
#define LOW_SPEED_RATE 200
#define MED_SPEED_RATE 500
#define HIGH_SPEED_RATE 1000
#endif
/*
 *********************************************************************************************************
 * Structures
 *********************************************************************************************************
 */
typedef struct _AV_Client
{
    int avIndex[MAX_AV_CH];
    int avChannel;
    int speakerAvIndex;
    int firstIframeSize;
#if ENABLE_TUTK_RESEND
    int resend_buf_usage_rate;
    unsigned int localMaxRate;
    unsigned int localAvgRate;
#endif
#if P2P_LV_RATECTL_SUPPORT
    unsigned char localSendCount;
    unsigned int firstIframeTick;
    unsigned int sndBps;
#endif
    unsigned char bEnableVideo;
    unsigned char bEnableAudio;
    unsigned char bShowInfo;
    unsigned char bP2PConnected;
    unsigned char VOLSend;
    unsigned char bEnableSpeaker;
    unsigned char speakerCh;
    unsigned char bPausePlayBack;
    unsigned char bStopPlayBack;
    unsigned char bSendCache;
    unsigned char playBackCh;
    unsigned char getsupportstream;
    //For DASA -- start
    int doCleanBuffer;
    int doCleanBufferDone;
    int waitKeyFrame;
    //For DASA -- end
    SMsgAVIoctrlPlayRecord playRecord;
    OS_EVENT *sLock;
} AV_Client;

struct netdev
{
    char name[26];
    u16 mtu;
    u32 ipaddr;
    u32 netmask;
    u32 gw;
    u32 flags;
    unsigned char hwmac[6];
};
enum
{
    I_FRAME_NOT_SEND_YET =   0,
    PRE_I_FRAME_SENT         =   1,
    LIVE_I_FRAME_SENT        =    2
};
typedef struct _RATE_CONTRL{
	int prevData;
	int p,q,r,kGain;
}RATE_CONTROL;
RATE_CONTROL rateCtl;

static u32 my_ui2f_cnt = 0;
static u32 resend_buffering_data_size = 0;

/*
 *********************************************************************************************************
 * Variables
 *********************************************************************************************************
 */
// *** AV server ID and password, set here ***
char avID[] = "admin";
long timebase_sec = 0;
long timebase_msec = 0;
static OS_STK 	 gLoginTaskStack[TASK_LOGIN_STACK_SIZE];
#if(DEVSTATUS_ACTIVE_UPDATE)
OS_FLAG_GRP  *gP2pDevStatusFlagGrp = 0;
#endif

int avChannel;
int  bEnableVideo;
int  VOLSend;
AV_Client gClientInfo[MAX_CLIENT];
//static int gProcessRun = 1;
int gOnlineNum = 0;
//For DASA -- start
#ifdef DASA_ENABLED
static int gDASALevel = AV_DASA_LEVEL_QUALITY_HIGH;
#endif
//For DASA -- end
SMsgAVIoctrlListEventResp *gEventList;

#if TEST_RECV_AUDIO_DELAY
unsigned int gAudioTimeStamp = 0;
OS_EVENT *countTimeStampLock;
#endif
uint32_t gStartTick;

struct tm gStartTimeInfo;


int CurrentCH;
int	SpeakerAvIndex;
int fileplayback=0;
int gbSearchEvent=0;
SMsgAVIoctrlPlayRecord gRemote_playfile;
struct search_time search_dir_start,search_dir_end;
s8 P2PEnableplaybackStreaming;
u8 Fileplaying=0;   /*for RDI 2: local playback*/
u8 Remote_play=0;
//Multi-CH related
s8  P2PEnableStreaming[MAX_AV_CH];
u32 P2PVideoBufReadIdx[MAX_AV_CH];
u32 P2PVideoPresentTime[MAX_AV_CH];
u32 P2PAudioBufReadIdx[MAX_AV_CH];
u32 P2PAudioPresentTime[MAX_AV_CH];
u32 P2PChannelStart[MAX_AV_CH];
VIDEO_BUF_MNG *P2PVideoBuf[MAX_AV_CH];
IIS_BUF_MNG   *P2PAudioBuf[MAX_AV_CH];

OS_EVENT* P2PAudioCmpSemEvt[MAX_AV_CH];
OS_EVENT* P2PVideoCmpSemEvt[MAX_AV_CH];
OS_EVENT* P2PAudioPlaybackCmpSemEvt;
OS_EVENT* P2PVideoPlaybackCmpSemEvt;
OS_EVENT* P2PVideoPlaybackStopSemEvt;

static OS_EVENT *ResendBufUsageSem = 0;

static u8    IFrameSentStatus[MAX_CLIENT];
static u32  preIframeIndex[MAX_AV_CH];

#if (MAX_CLIENT == 4)
u8 h264header_updata[MAX_CLIENT]= {0,0,0,0};
#elif (MAX_CLIENT == 3)
u8 h264header_updata[MAX_CLIENT]= {0,0,0};
#else
u8 h264header_updata[MAX_CLIENT]= {0,0,0,0};
#endif

extern  AV_Client gClientInfo[MAX_CLIENT];
int P2PAVsource[MAX_CLIENT];
int P2PAV_CH[MAX_CLIENT];

int gFirstConnect=0;
int videoquality=2;
u8 * gUID = 0;
int gFlagLoginOK = 0;
int gLoginFaileCnt = 0;
int gFlagSpeakerOK = 0;
int gSpeakerFailedCnt = 0;
int gSpeakerSID = -1;
int gPlaybackSID= 0;
char gP2PPassword[UI_P2P_PSW_MAX_LEN]="000000";
#if UI_LIGHT_SUPPORT
u8 AppLightStatus=0;
#endif

#if(UI_VERSION == UI_VERSION_MAYON)
u8 MAYONLightStatus=0;
u8 MAYONAlarmStatus=0;
int gCurPlaybackSID= -1;
#endif

INT32U 	 gSessionTaskStack[TASK_SESSION_STACK_SIZE];
INT32U 	 gListenTaskStack[TASK_LISTEN_STACK_SIZE];
INT32U 	 gSpeakerTaskStack[TASK_SPEAKER_STACK_SIZE];
INT32U   gP2PPlayfileTaskStack[TASK_P2P_PLAYFILE_STACK_SIZE-1];
char 	 timezone_des[256]="Taiwan";
u8* codeAddr = (u8*)((DRAM_MEMORY_END + 4) - 0x800000);
char fw_version[30]= {0};
char FWMD5[32];
extern u8  uiVersion[32];
u8 Reminder_FW_Upgrade=0;
int P2P_AV_Source[MAX_AV_CH];
u8  LocalChannelSource; // ch0 source
u8 Remoteplayback_CH;
s32 idx; //Progress of the f/w dowoloading
u8 OnlineUpdateStatus;
unsigned int gP2PStatus;
int CurrPlaybackSID;
u32 P2PPauseTime,P2PStartPauseTime,P2PStopPauseTime;
#if(HOME_RF_SUPPORT)
u8 gAppPairFlag=0;  /* 0: None, 1: Pair Success, 2: Pair Fail */
u8 gAppTXPairFlag=0;  	/* 0: None, 1: Pair Success, 2: Pair Fail */
u32 gPairAvIndex;
u8 APPversion_IOS[16]  = "IOS_1.0.0.18";
u8 APPversion_AND[16] = "AND_1.0.0.32";
u8 APPSensorListStatus=0;
u8 APPSensorStatus=0;
u8 APPRoomListStatus=0;
u8 APPSceneListStatus=0;
#endif
u8  Reset_P2P_Connection_flag = 0;
u8	Reset_P2P_Connection_Stop_flag = 0;
u8	gSearchFileListFlag = 0;	//0:None; 1:APP use; 2:RX use.
u8 renewIP;

struct sockaddr_in gPushMsgSrvAddr[MAX_PUSH_MSG_SVR];
int gPushDuration=1;
struct sockaddr_in gFWSrvAddr;
unsigned int gPushMsgTime = 0;

static u8    IFrameSentStatus[MAX_CLIENT];
static u32  preIframeIndex[MAX_AV_CH];
#if RFIU_RX_WAKEUP_TX_SCHEME
u8 MAYONTXTypeStatus=0;
u8 gAppWakeCamflag=0;
#endif
char SID_IP_table[5][47];

static int ipcamstart = 0;
static volatile bool gPlaybackTaskRunning = false;
static int chk_session_cnt[MAX_CLIENT];

#if HANGON_DEBUG
u16 gDbgLine = 0;
#endif
/*
 *********************************************************************************************************
 * Extern Variables
 *********************************************************************************************************
 */

extern u32 gPlaybackWidth;
extern u32 gPlaybackHeight;

extern INT8U TutkTransmissionTaskPri;
extern u8 uiP2PID[21];
extern u8 rfiuAudioZeroBuf[RFI_AUIDIO_SILENCE_SIZE];

extern u8 uiP2PID[];
extern VIDEO_BUF_MNG rfiuRxVideoBufMng[MAX_RFIU_UNIT][VIDEO_BUF_NUM];
extern u32 rfiuRxVideoBufMngWriteIdx[MAX_RFIU_UNIT];

extern IIS_BUF_MNG rfiuRxIIsSounBufMng[MAX_RFIU_UNIT][IIS_BUF_NUM];
extern u32 rfiuRxIIsSounBufMngWriteIdx[MAX_RFIU_UNIT];

extern u8 *rfiuAudioRetDMANextBuf[RFI_AUDIO_RET_BUF_NUM];
extern u32 rfiuAudioRetRec_idx;
extern DEF_RFIU_UNIT_CNTL gRfiuUnitCntl[MAX_RFIU_UNIT];

extern u32 guiRFTimerID;

extern u8 P2P_playback_go;
extern u8 P2P_check;

extern unsigned int P2PPlaybackVideoStop;
extern int net_link_status;

extern u8  uiVersionTime[9]; /*Firmware version for MARS internal using.*/
extern u8  uiLightTimer[MULTI_CHANNEL_MAX][4];
extern u8  uiLightInterval[MULTI_CHANNEL_MAX][7][6];
extern int avChannel;
extern int  bEnableVideo;
extern int  VOLSend;

#if APP_KEEP_ALIVE

#define KEEP_ALIVE_TIMEOUT	60

extern int gFlagKeepAlive[];
extern RTC_DATE_TIME gKeepAliveTime0;
extern RTC_DATE_TIME gKeepAliveTime1;
extern RTC_DATE_TIME gKeepAliveTime2;
extern RTC_DATE_TIME gKeepAliveTime3;
extern RTC_DATE_TIME gKeepAliveTime4;

extern u8 APPConnectIcon;
#endif


/*
 **********************************************************************************************************
 * External Functions
 **********************************************************************************************************
 */
extern int atoi(const char *);
extern u16_t lwip_htons(u16_t n);
extern char* ip4addr_ntoa(const ip4_addr_t *addr);
extern void thread_Login(void *arg);
extern void  uiSetP2PImageLevel(u8  CamId, u8 level);
extern u8 uiSetP2PPassword(u8 *password);
extern void ClearNetworkInfo(void);
extern u8 SetLwIP(u8 mode);

extern void P2PCmd_SetCamPair(int avIndex, char *buf);
extern void P2PCmd_GetCamLinkStatus(int avIndex, char *buf);
extern void P2PCmd_SetCamOnOff(int avIndex, char *buf);
extern void P2PCmd_GetCamBrightness(int avIndex, char *buf);
extern void P2PCmd_SetCamBrightness(int avIndex, char *buf);
extern void P2PCmd_GetCamFrequence(int avIndex, char *buf);
extern void P2PCmd_SetCamFrequence(int avIndex, char *buf);
extern void P2PCmd_GetCamRecStatus(int avIndex, char *buf);
extern void P2PCmd_GetLiveDataRate(char *buf); /*Func undefine*/
extern void P2PCmd_SetCamManualRec(int avIndex, char *buf);
extern void P2PCmd_GetCamMotionSensitivity(int avIndex, char *buf);
extern void P2PCmd_SetCamMotionSensitivity(int avIndex, char *buf);
extern void P2PCmd_GetCamRecScheduleTable(int avIndex, char *buf); /*Func Need to Chk*/
extern void P2PCmd_SetCamRecScheduleTable(int avIndex, char *buf); /*Func Need to Chk*/
extern void P2PCmd_GetRecSection(int avIndex, char *buf);
extern void P2PCmd_SetRecSection(int avIndex, char *buf);
extern void P2PCmd_SetFormat(int avIndex, char *buf); /*iconflag remove Chk*/
extern void P2PCmd_GetOverwiteStatus(int avIndex, char *buf);
extern void P2PCmd_SetOverwite(int avIndex, char *buf);
extern void P2PCmd_GetDateTime(int avIndex, char *buf); /*Func Need to Chk*/
extern void P2PCmd_SetDateTime(int avIndex, char *buf); /*Func Need to Chk*/
extern void P2PCmd_SetDefault(int avIndex, char *buf); /*Func Need to Chk, iconflag remove Chk*/
extern void P2PCmd_GetLanguage(int avIndex, char *buf);
extern void P2PCmd_SetLanguage(int avIndex, char *buf);
extern void P2PCmd_GetNetworkInfo(int avIndex, char *buf);
extern void P2PCmd_SetNetworkInfo(int avIndex, char *buf); /*Func undefine*/
extern void P2PCmd_GetLEDStatus(int avIndex, char *buf); /*Func Need to Chk*/
extern void P2PCmd_SetLEDStatus(int avIndex, char *buf); /*Func Need to Chk*/
extern void P2PCmd_GetPlaybackFPS(int avIndex, char *buf); /*Func undefine*/
extern void *memset_hw(void *, unsigned char , unsigned int);
extern void *memcpy_hw(void *dest, const void *src, unsigned int count);

/*
 *********************************************************************************************************
 * Function prototype
 *********************************************************************************************************
 */
void tutk_task_init(void);
void tutk_task_deinit(void );
time_t time_to_epoch(const struct tm *ltm, int utcdiff);
void client_p2pdisconnected(int SID);
void SendVideoFrameData(int SID, u32 time, u32 flag, int size, char *buf);
static void UCT_to_Local_convert_playfile(SMsgAVIoctrlPlayRecord *p);
static void Local_to_UCT_convert(STimeDay *q);
static void UCT_to_Local_convert(SMsgAVIoctrlListEventReq *p);
static char *GetRegMessageString(char *UID, int *pMsgLen, int pushMsgSvrIdx);
static char *GetPushMessageString(char *UID, u32 camidx, int eventType, int *pMsgLen, int pushMsgSvrIdx);
static void SendPushMessage(u32 camidx, int eventType, int pushMsgSvrIdx);
static int GetFile(char *downfile);
void renew_iotclModule(unsigned short port);
static void UpdateAPPLightStatus(u8 Camid);
static void Task_SessionHandler(void* pData);
static void SendRegister(void);
#if UI_LIGHT_SUPPORT
static void UpdateAPPLightStatus(u8 Camid);
#endif
static void tutk_lib_init(void);
//static int avSendIOCtrl2(int nAVChannelID, unsigned int nIOCtrlType, const char *cabIOCtrlData, int nIOCtrlDataSize);
static int avSendIOCtrlWithTimeout(int nAVChannelID, unsigned int nIOCtrlType, const char *cabIOCtrlData, int nIOCtrlDataSize, u16 timeout);
static void StopSendIOCtrl(void *arg);
static void StopAndClearSession(int SID, int reason);
static void SendRegisterInternal(const char *hostname_IP, int pushMsgSvrIdx);
#ifdef SAFE_DEL_P2P_PLAYFILE_TASK
static void SafeDelP2pPlayFileTask(void);
static bool SafeDelSem(OS_EVENT **sem);
#endif
static u32 GetResendBufUsage(int avCh, int *buffering);
static void ShowOnlineUserNum(void *arg);
static INT8U Stop_Task_by_Prio(INT8U prio, INT8U* u8TskStopFlag, OS_EVENT *pevent, OS_FLAG_GRP *pgrp, OS_FLAGS flags);
static void Force_Stop_Playback(int SID);
#ifdef LWIP_BUF_STAT
static void ShowLwipBufUsage(void *arg);
#endif
static void reset_my_ui2f_cnt(void);
static u32 getResendBufferingDataSize(void);
static u32 getResendBufUsage(int, int*);

#define avSendIOCtrl2(a,b,c,d) avSendIOCtrlWithTimeout(a,b,c,d, AV_SENDIOCTRL_TIMEOUT)
#define avSendIOCtrl3(a,b,c,d) avSendIOCtrlWithTimeout(a,b,c,d, AV_SENDIOCTRL_TIMEOUT2)

/*
 *********************************************************************************************************
 * Function
 *********************************************************************************************************
 */
#if(UI_VERSION == UI_VERSION_MAYON)

void UpdateMAYONLightStatus(u8 Camid)
{
    MAYONLightStatus = Camid+1;
}

void UpdateMAYONAlarmStatus(u8 Camid)
{
    MAYONAlarmStatus = Camid+1;
}
#endif

#if RFIU_RX_WAKEUP_TX_SCHEME
void UpdateMAYONTXStatus(u8 Camid)
{
	MAYONTXTypeStatus = Camid+1;
}


#endif
/*Checking P2P information*/
void Check_P2P_info(unsigned int *p2p_info)
{
    //int p2p_info;
    IOTC_Get_Login_Info(p2p_info);
    *p2p_info=*p2p_info&0x07;
	if(renewIP == 1) //Sean: 20170915 add
	   *p2p_info=*p2p_info&0x01;
    DEBUG_P2P("P2P INFO: %x.\n",*p2p_info);
}

/*Load time zone description*/
void Load_timezone_des(char *des)
{
    strcpy(timezone_des,des);
}

/*Return net link status*/
int Get_network_status()
{
    return net_link_status;
}

/*Register APN Server*/
static char *GetRegMessageString(char *UID, int *pMsgLen, int pushMsgSvrIdx)
{
    static char msgBuf[2048];
    char host[32];

    inet_ntoa_r(gPushMsgSrvAddr[pushMsgSvrIdx].sin_addr, host, sizeof(host));
    *pMsgLen =
#if(HW_BOARD_OPTION == MR8211_ZINWELL)
    snprintf(msgBuf, sizeof(msgBuf), 
            "GET /apns/apns.php?cmd=reg_server&uid=%s HTTP/1.1\r\n"
            "Host: %s\r\n"
            "Connection: keep-alive\r\n"
            "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML,like Gecko) Chrome/19.0.1084.52 Safari/536.5\r\n"
            "Accept: */*\r\n""Accept-Encoding: gzip,deflate,sdch\r\n"
            "Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\r\n"
            "Accept-Charset: Big5,utf-8;q=0.7,*;q=0.3\r\n""Pragma: no-cache\r\n"
            "Cache-Control: no-cache\r\n"
            "\r\n", UID, host);
#else
    snprintf(msgBuf, sizeof(msgBuf),
            "GET /tpns/apns.php?cmd=reg_server&uid=%s HTTP/1.1\r\n"
            "Host: %s\r\n"
            "Connection: keep-alive\r\n"
            "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML,like Gecko) Chrome/19.0.1084.52 Safari/536.5\r\n"
            "Accept: */*\r\n""Accept-Encoding: gzip,deflate,sdch\r\n"
            "Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\r\n"
            "Accept-Charset: Big5,utf-8;q=0.7,*;q=0.3\r\n""Pragma: no-cache\r\n"
            "Cache-Control: no-cache\r\n"
            "\r\n", UID, host);
#endif
    return msgBuf;
}

void SetPushMsgDelay(int delay)
{
    gPushDuration=delay;
}


/*****************************************
Input : Packet Data
Return: 0	ERROR
		2	Status: 200 OK
		3	Status: Object Moved
		4	Status: Access Denied
		5	Status: Internal Server Error
*****************************************/
u8 ParsingHTTPHeader(u8* packet, u16 packet_len)
{
	char* body;

	//printf("\x1B[96m packet_len:%d, %s \x1B[0m\n",packet_len,packet);
	if(packet_len == 0)		//Null Data
		return 0;

	body=strstr((char *)packet,"HTTP");

	if(body[9] == 	   '2') 		// 2xx OK
		return 2;
	else if(body[9] == '3')	// 3xx redirect
		return 3;
	else if(body[9] == '4')	// 4xx Error
		return 4;
	else if(body[9] == '5')	// 5xx Server Error
		return 5;
	else
		return 0;
}

#if AutoNTPupdate
s8 SendGetTimeZoneMessage(void)
{
	int skt = -1,err,on=1;
	char *msg;
	u8	timezoneMsg[512];
	u8	TimeZone_ACK[256];
	u8* body;
	u8 	ack_ret,i,retry=0;
	RTC_TIME_ZONE TimeZone;
    char hex_num[3],temp_char[2];
    char hostname_IP[HOSTNAME_IP_BUF_SIZE]="";
    char hostname[50];
	struct sockaddr_in TimeZoneSrvAddr;
	
	#define TimeZonePort	80
	#define TimeZoneServer	"timezone.mars-cloud.com"
	#define TimeZoneServer2	"timezone2.mars-cloud.com"

Retry:
	if(!retry)
    	strcpy(hostname,TimeZoneServer);
    else
    	strcpy(hostname,TimeZoneServer2);    
//    err=DN2IP(hostname,hostname_IP);
    
	TimeZoneSrvAddr.sin_addr.s_addr=inet_addr(hostname_IP);
	TimeZoneSrvAddr.sin_port = htons(TimeZonePort);
	TimeZoneSrvAddr.sin_family = AF_INET;

    if ((skt = (int)socket(AF_INET, SOCK_STREAM, 0)) >= 0)
    {
        setsockopt(skt,SOL_SOCKET,SO_KEEPALIVE,&on,sizeof(on));/*Check the TCP connection whether alive.*/ 
        if (connect(skt, (struct sockaddr *)&TimeZoneSrvAddr, sizeof(struct sockaddr_in)) == 0)
        {
            DEBUG_P2P("Sending TimeZone MSG\n");

			sprintf(timezoneMsg,"GET /api/getGeoInfo HTTP/1.1\r\n"
								"Host: timezone.mars-cloud.com\r\n"
								"Connection: keep-alive\r\n"
								"Cache-Control: max-age=0\r\n"
								"Upgrade-Insecure-Requests: 1\r\n"
								"User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36\r\n"
								"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\r\n"
								"Accept-Encoding: gzip, deflate\r\n"
								"Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\r\n\r\n");

			

			//printf("\x1B[96m%s\x1B[0m\n",timezoneMsg);
			
            if(send(skt, timezoneMsg, strlen(timezoneMsg), 0)<0)
            {
                DEBUG_P2P("Send TimeZone MSG Fail.\n");
                if(!retry)
	            {
	            	DEBUG_P2P("Retry TimeZone MSG\n");
	            	retry = 1;
	            	close(skt);
	            	goto Retry;
	            }
                close(skt);
                return 100;
            }    
            else
            {
                DEBUG_P2P("Send TimeZone MSG Event Success.\n");
				memset(TimeZone_ACK, 0, sizeof(TimeZone_ACK));
	            recv(skt, TimeZone_ACK, sizeof(TimeZone_ACK), 0);  //200 OK	

				ack_ret = ParsingHTTPHeader(TimeZone_ACK, strlen(TimeZone_ACK));
				if(ack_ret != 2)
				{
					DEBUG_P2P("%s\n",TimeZone_ACK);
				}
				else
				{
					memset(TimeZone_ACK, 0, sizeof(TimeZone_ACK));
					recv(skt, TimeZone_ACK, sizeof(TimeZone_ACK), 0);  //DATA
					
					//printf("\x1B[96m%s\x1B[0m\n",TimeZone_ACK);
					body=strstr(TimeZone_ACK,"time_offset");

					if(body[13] == '-')
					{
						TimeZone.operator= 1;
						if(body[14] == '1')
						{
							memset(hex_num,0,sizeof(hex_num)); /*Convert Second*/
							for(i=0;i<2;i++)
							{
								sprintf(temp_char,"%c",body[14+i]);
								strcat(hex_num,temp_char);
							}
							hex_num[2]='\0';

							//TimeZone = 0-strtoul(hex_num,NULL,10); 
							TimeZone.hour = strtoul(hex_num,NULL,10);
						}
						else
						{
							sprintf(hex_num,"%c",body[14]);
							//TimeZone = 0-strtoul(hex_num,NULL,10); 
							TimeZone.hour = strtoul(hex_num,NULL,10);
						}
					}
					else
					{
						if(body[13] == '1')
						{
							memset(hex_num,0,sizeof(hex_num)); /*Convert Second*/
							for(i=0;i<2;i++)
							{
								sprintf(temp_char,"%c",body[13+i]);
								strcat(hex_num,temp_char);
							}
							hex_num[2]='\0';

							//TimeZone = strtoul(hex_num,NULL,10); 
							TimeZone.hour = strtoul(hex_num,NULL,10);
						}
						else
						{
							sprintf(hex_num,"%c",body[13]);
							//TimeZone = strtoul(hex_num,NULL,10); 
							TimeZone.hour = strtoul(hex_num,NULL,10);
						}

					}
					TimeZone.min = 0;
					printf("\x1B[96mTimeZone = %d %d:%d\x1B[0m\n",TimeZone.operator,TimeZone.hour,TimeZone.min);
					//RTC_Set_TimeZone(&TimeZone);

					
				}
            }		
        }
        else
        {		
            DEBUG_P2P("Couldn't send TimeZone MSG\n");
            
            if(!retry)
            {
            	DEBUG_P2P("Retry TimeZone MSG\n");
            	retry = 1;
            	goto Retry;
            }
            close(skt);
            return 100;
        }    
        close(skt);
		if(TimeZone.operator)
			return (0-TimeZone.hour);
		else
			return TimeZone.hour;
        
    }
    else
    {
        DEBUG_P2P("Create socket fail.\n");  
        if(!retry)
        {
			DEBUG_P2P("Retry TimeZone MSG\n");        
        	retry = 1;
        	goto Retry;
        }
        
        if(skt >= 0)
            close(skt);
        
        return 100;
    }
}
#endif


/*Raising event to APN server*/
static char *GetPushMessageString(char *UID, u32 camidx, int eventType, int *pMsgLen, int pushMsgSvrIdx)
{

    /*Content of event*/
    char EventString[10][50]={"%20[Motion]",
    						 "%20[Low_Battery]",
    						 "%20[PIR_Trigger]",
    						 "%20[DOOR_OPEN]",
    						 "%20[Siren_Switch_ON]",
    						 "%20[SOS]",		//Door bell sos
    						 "%20[Hello]",		//Door bell
    						 "%20[LOST_LINK]",	//LOST LINK
    						 "%20[MAT]",		//Bed Blanket 
    						 "%20[MAT2]",		//Bathroom Blanket
    						};
    char EventTime[50];
    char str[50];
#if (UI_VERSION == UI_VERSION_MAYON)
    char channel[100];
#else
    char channel[100];
#endif
#if DOOR_BELL_SUPPORT
    char rdiDoor[20];
#endif
    char sensor_id[20];
    char sensor_name[20];
    static char msgBuf[2048];
    RTC_DATE_TIME   localTime;
    u32 LocalTimeInSec;
    char deviceUID[21];
    char host[32];
    int i;
    //DEBUG_P2P("%s: camidx-0x%X, eventType-0x%X\n",__func__, camidx, eventType);
    RTC_Get_Time(&localTime);
    LocalTimeInSec=RTC_Time_To_Second(&localTime)+946684800;
    //DEBUG_P2P("UNIX=%d\n",LocalTimeInSec);

    *pMsgLen = 0;
    memset_hw(deviceUID,0,21);
    strncpy(deviceUID,UID,20);


#if HOME_RF_SUPPORT
    /*Send HA Sensor to APP directly.*/
    if (camidx > 4)
    {

        sprintf(EventTime,"%d/%02d/%02d-%02d:%02d",localTime.year+2000,localTime.month,localTime.day,localTime.hour,localTime.min);
        strcat(EventTime, "%20[");
        sysAppGetSensorName(camidx);
        memset(sensor_name, 0, sizeof(sensor_name));
        strncpy(sensor_name,homeRFSensorName,16);
        for(i=0; i<16; i++)
            if(sensor_name[i] == ' ')
                sensor_name[i] = '_';
        strcat(sensor_name, "]%20");
        memset(msgBuf, 0, sizeof(msgBuf));
        inet_ntoa_r(gPushMsgSrvAddr[pushMsgSvrIdx].sin_addr, host, sizeof(host));
        *pMsgLen = snprintf(msgBuf, sizeof(msgBuf),
                            "GET /tpns/apns.php?cmd=raise_event&uid=%s&event_type=100&event_time=%lu&msg=%s%s%s HTTP/1.1\r\n"
                            "Host: %s\r\n"
                            "Connection: keep-alive\r\n"
                            "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML,like Gecko) Chrome/19.0.1084.52 Safari/536.5\r\n"
                            "Accept: */*\r\n"
                            "Accept-Encoding: gzip,deflate,sdch\r\n"
                            "Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\r\n"
                            "Accept-Charset: Big5,utf-8;q=0.7,*;q=0.3\r\n"
                            "Pragma: no-cache\r\n"
                            "Cache-Control: no-cache\r\n"
                            "\r\n", deviceUID,LocalTimeInSec,EventTime,sensor_name,deviceUID, host);
    }
    else
#endif
    {
#if DOOR_BELL_SUPPORT
    if ((eventType  & RDI_PUSHMSG_PREFIX) != 0) //RDI door bell
    {
        /*Send string to APP directly.*/
        strcpy(str,EventString[eventType & (~RDI_PUSHMSG_PREFIX)]);
        sprintf(rdiDoor, "%20[%04X]%20", camidx); //Sensor ID
        strcat(str,rdiDoor);
        DEBUG_P2P("%s: rdiDoor-%s\n",__func__, rdiDoor);
        DEBUG_P2P("%s: str-%s\n",__func__, str);
    }
    else /*for Normal event send, don't append sensor ID*/
#endif
        /*Send string to APP directly.*/
        strncpy(str, EventString[eventType], sizeof(str));
        snprintf(EventTime, sizeof(EventTime), "%d/%02d/%02d-%02d:%02d",localTime.year+2000,localTime.month,localTime.day,localTime.hour,localTime.min);
        strcat(EventTime, "%20");
        DEBUG_P2P("%s: EventTime-%s\n",__func__, EventTime);
#if (UI_VERSION == UI_VERSION_MAYON)
		if(EVENT_LOWBATTERY == eventType)
		{
			i=0;
			//sprintf(channel, "CH");
			do
			{
				if(camidx & 0x01)
				{
					snprintf(channel, sizeof(channel), "CH:%d", i+1);
				}
			}while( (camidx = (camidx >> 1)) && (i++ < MAX_RFIU_UNIT));
		}
		else
		{
			snprintf(channel, sizeof(channel), "CH%d", camidx+1);
		}
#else
        snprintf(channel, sizeof(channel), "CH%d", camidx+1);
#endif
        strcat(channel, str);
        //DEBUG_P2P("%s: channel-%s: len-%d\n",__func__, channel, strlen(channel));
        memset(msgBuf, 0, sizeof(msgBuf));
        inet_ntoa_r(gPushMsgSrvAddr[pushMsgSvrIdx].sin_addr, host, sizeof(host));
        *pMsgLen = snprintf(msgBuf, sizeof(msgBuf), 
                            "GET /tpns/apns.php?cmd=raise_event&uid=%s&event_type=100&event_time=%lu&msg=%s%s%s HTTP/1.1\r\n"
                            "Host: %s\r\n"
                            "Connection: keep-alive\r\n"
                            "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML,like Gecko) Chrome/19.0.1084.52 Safari/536.5\r\n"
                            "Accept: */*\r\n"
                            "Accept-Encoding: gzip,deflate,sdch\r\n"
                            "Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\r\n"
                            "Accept-Charset: Big5,utf-8;q=0.7,*;q=0.3\r\n"
                            "Pragma: no-cache\r\n"
                            "Cache-Control: no-cache\r\n"
                            "\r\n", deviceUID, LocalTimeInSec, EventTime, channel, deviceUID, host);
    }
    //DEBUG_P2P("%s: msgBuf done-size %d\n",__func__,strlen(msgBuf));
    return msgBuf;
}


static void SendPushMessage(u32 camidx, int eventType, int pushMsgSvrIdx)
{
    char *msg;
    int skt = -1, ret;
    int len;
    
    if(gUID == 0)
        return;

    if (gPushMsgSrvAddr[pushMsgSvrIdx].sin_addr.s_addr == 0)
    {
        DEBUG_P2P("No push message server\n");
        SendRegister();
        //return;
    }
    
    msg = GetPushMessageString(gUID, camidx, eventType, &len, pushMsgSvrIdx);
    skt = TcpConnect2((struct sockaddr *)&gPushMsgSrvAddr[pushMsgSvrIdx], PUSH_MSG_SVR_CONNECT_TIMEOUT, 1, 0);
    if(skt >= 0)
    {
        TcpSetSendTimeout(skt, PUSH_MSG_SVR_SEND_TIMEOUT);

        DEBUG_P2P("Sending push MSG[%d]\n", pushMsgSvrIdx);
        DEBUG_P2P("%s: msg done-size %d\n",__func__, len);
        if(len > 0 && TcpSendAll(skt, msg, len) != len)
        {
            DEBUG_P2P("Send MSG Fail.\n");
            ret = -1;
        }
        else
        {
            DEBUG_P2P("Send MSG Success.\n");
            ret = 0;
        }
        
        shutdown(skt, SHUT_RDWR);
        closesocket(skt);
        skt = INVALID_SOCKET;
    }
    else
    {
        DEBUG_P2P("Couldn't send MSG\n");
        ret=-1;
    }
    
    if(ret<0)	/*Register TPNS server again, when sending push notification fail.*/
        SendRegister();
}


s32 P2PSendEvent(u32 camidx,u32 eventType)
{
    static bool ready = false;
    char *buf;
    int size;
    SMsgAVIoctrlEvent *q;
    unsigned int current_time;
    u32 difftime;
    
    current_time = OSTimeGet();
#if (UI_VERSION == UI_VERSION_MAYON)
    if(!ready)
    {
        INT8U err;
        
        if(gpiNetStatusFlagGrp == 0)
            return 0;
        
        OSFlagAccept(gpiNetStatusFlagGrp, FLAGGPI_LWIP_IP_READY|FLAGGPI_TUTK_READY, OS_FLAG_WAIT_SET_ALL, &err);
        if(err != OS_NO_ERR)
            return 0;
        
        ready = true;
    }

    //Skip time check on MWM903, Paul add for push msg always on, 2018.08.29
	IOTC_Get_Login_Info(&gP2PStatus);
	if(gP2PStatus==7)
	{
        int i;
        
        DEBUG_P2P("Ready send MSG.\n");
        for(i = 0; i < MAX_PUSH_MSG_SVR; ++i)
            SendPushMessage(camidx, eventType, i);
	}
#else
    if(((current_time-gPushMsgTime)>600)&&(gP2PStatus==7)) //30 sec
    {
        int i;
        
        DEBUG_P2P("Ready send MSG.\n");
        
        for(i = 0; i < MAX_PUSH_MSG_SVR; ++i)
            SendPushMessage(camidx, eventType, i);        

        /*Send message via TUTK ioctl command*/
#if 0
        DEBUG_P2P("send msg for android\n");
        buf=IOCtrlBuf;
        size = sizeof(SMsgAVIoctrlEvent);
        q = (SMsgAVIoctrlEvent*)buf;
        q->time=20131008080405; 		// UTC Time
        q->channel=1; 		// Camera Index
        q->event=AVIOCTRL_EVENT_MOTIONDECT; 		// Event Type

        if(avSendIOCtrl2(0, IOTYPE_USER_IPCAM_EVENT_REPORT, (char *)q, size) == AV_ER_NoERROR)
        {
            DEBUG_P2P("IPCAM_EVENT_REPORT OK \n\n");
        }
        //
#endif
        //RTC_Get_Time(&gPushMsgTime);
        gPushMsgTime=OSTimeGet();
    }
#endif
	return 1;
}


#if ENABLE_TUTK_RESEND
//static int resend_buf_usage_rate[MAX_CLIENT+1];

#if (P2P_LV_RATECTL_SUPPORT == 1)
void RateCtlInit( RATE_CONTROL *k){
	k->kGain=0;
	k->p=1;
	k->q=1;
	k->r=1;
	k->prevData=0;
	return;
}


int RateCtlCalculat( RATE_CONTROL *k, int data){
	k->p=k->p+k->q;
	k->kGain=k->p*10 /(k->p+k->r) ;
	data=(k->prevData+k->kGain*(data-k->prevData)/10)+100;
	k->p=(1-k->kGain*k->p/10);
	k->prevData=data;
	return data;
}
#endif
void ResendBufUsageMaxRate(void);

void ResendBufUsageRateUpdate(void)
{
    ResendBufUsageMaxRate();
}

int ResendBufUsageRate(void)
{
    return 0;//resend_buf_usage_rate;
}

void ResendBufUsageMaxRate(void)
{
    int i, tmp;
    u32 max_rate = 0;
    
    for(i = 0; i < MAX_CLIENT; ++i)
    {
        u32 tmp2;
        
        if(!gClientInfo[i].bEnableAudio && !gClientInfo[i].bEnableVideo)
            continue;
        
        tmp2 = getResendBufUsage(gClientInfo[i].avChannel, 0);
        if(tmp2 > max_rate)
        {
            max_rate = tmp2;
            tmp = max_rate;
            tmp = (tmp*402+gClientInfo[i].resend_buf_usage_rate*622)>>10;
            gClientInfo[i].resend_buf_usage_rate = tmp;
        }
    }
}

#endif

/*Firmware Upgrade via internet.*/
s32 Upgrade_fw_net(u32 dummy, u32 dummy2)
{
    char fw_name[30];

    if(GetFile("MD5SUM")==0)
    {
        DEBUG_P2P("FWMD5=%s\n",FWMD5);
        strcpy(fw_name,fw_version);
        strcat(fw_name,".bin");
        if(GetFile(fw_name)<0)
            DEBUG_P2P("Get firmware fail!\n");
    }
    else
        DEBUG_P2P("Get MD5SUM fail!\n");
    return 1;
}

#if ISP_NEW_UPGRADE_FLOW_SUPPORT
void netSetFirmwareName(char *Version, u32 Length)
{
	memset(fw_version, 0x0, 30);
	if(Version == NULL)
		return;
	strncpy(fw_version, Version, Length);
}

char *netGetFirmwareName(void)
{
	return fw_version;
}

int netDoDownloadFile(char *pPath, u8 *BufAddr)
{
	char urlfile[100], buf2[50], buf3[4], hostname_IP[HOSTNAME_IP_BUF_SIZE]="", hostname[50];
	u32 Index, FileSizeLimit = (1 << (20 + 3)), TryBackupServer = 0;
	int skt, bytesRecv, i, result, on = 1;
	char *pCh;
	u8 digest[16], err, retry;
	MD5_CTX ctx;

	sysDeadLockMonitor_OFF(); /*Turn off watch dog.*/

Retry:
	if(TryBackupServer == 0)
	{
		strcpy(hostname, FW_SERVER);
		err = DN2IP(hostname,hostname_IP);
		if(err == 0)
			DEBUG_P2P("Get FW_SERVER,IP = %s\n",hostname_IP);
		else
		{
			DEBUG_P2P("Parse FW_SERVER fail...\n");
			if(TryBackupServer == 0)
			{
				DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
				TryBackupServer = 1;
				goto Retry;
			}
		}

		memset(urlfile, 0, 100);
		sprintf(urlfile, "%s%s/%s", FW_PATH, fw_version, pPath);

		DEBUG_P2P("Get %s\n",urlfile);
		OnlineUpdateStatus = FW_DOWNLOADING;
		gFWSrvAddr.sin_addr.s_addr = inet_addr(hostname_IP);
		gFWSrvAddr.sin_port = htons(PORT_FW);
		gFWSrvAddr.sin_family = AF_INET;
	}
	else //China Server
	{
		memset(urlfile, 0, 100);
		sprintf(urlfile, "%s%s/%s", FW_PATH, fw_version, pPath);

		DEBUG_P2P("Get %s\n",urlfile);
		OnlineUpdateStatus = FW_DOWNLOADING;
		gFWSrvAddr.sin_addr.s_addr = inet_addr("119.29.94.156");
		gFWSrvAddr.sin_port = htons(PORT_FW);
		gFWSrvAddr.sin_family = AF_INET;
	}

	if((skt = (int)socket(AF_INET, SOCK_STREAM, 0)) >= 0)
	{
		result = -1;
		retry = 0;
		setsockopt(skt, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on));/*Check the TCP connection whether alive.*/
		while(result < 0)
		{
			result = connect(skt, (struct sockaddr *)&gFWSrvAddr, sizeof(struct sockaddr_in));
			retry++;
			if(result < 0)
			{
				close(skt);
				(skt = (int)socket(AF_INET, SOCK_STREAM, 0));
			}
			if(retry > 10)
			{
				if(TryBackupServer == 0)
				{
					DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
					TryBackupServer = 1;
					close(skt);
					goto Retry;
				}
				OnlineUpdateStatus = FW_DOWNLOAD_FAIL;
				break;
			}
		}
		if(result == 0)
		{
			memset(BufAddr, 0, FileSizeLimit);
			sprintf((char *)BufAddr, "GET %s HTTP/1.1\r\n"
					"Host: %s\r\n"
					"Connection: keep-alive\r\n"
					"User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML,like Gecko) Chrome/19.0.1084.52 Safari/536.5\r\n"
					"Accept: text/html, application/xhtm l+xml,applicatio n/xml;q=0.9,*/*; q=0.8\r\n"
					"Accept-Encoding: gzip,deflate,sdch\r\n"
					"Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\r\n"
					"Accept-Charset: Big5,utf-8;q=0.7,*;q=0.3\r\n"
					"Cache-Control: no-cache\r\n"
					"\r\n", urlfile, inet_ntoa2(gFWSrvAddr.sin_addr));
			send(skt, BufAddr, strlen((char *)BufAddr), 0);
			Index = 0;
			i=0;
			memset(BufAddr, 0, FileSizeLimit);

			while(1)
			{
				bytesRecv = recv(skt, BufAddr + Index, FileSizeLimit, 0);
				DEBUG_P2P("#");
				if(bytesRecv > 0)
				{
					Index += bytesRecv;
				}
				else if(bytesRecv == 0)
				{
					DEBUG_P2P("Receive file finish.\n");
					break;
				}
				else
				{
					DEBUG_P2P("Connection Closed.\n");
					OnlineUpdateStatus = FW_DOWNLOAD_FAIL;
					OSFlagPost(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_UPDATE_SEC, OS_FLAG_SET, &err);
					break;
				}
			}

			// 20160929 Sean Modify Parsing method.
			pCh = strstr((char *)BufAddr,"HTTP");
			if(pCh[9] == '3') // 3xx redirect
			{
				DEBUG_P2P("HTTP 302 found, Search data.\n");
				pCh = strstr((char *)BufAddr,"\r\n\r\n") + 4;
				pCh = strstr(pCh,"\r\n\r\n") + 4;
			}
			else if(pCh[9] == '4') // 4xx Error
			{
				DEBUG_P2P("HTTP 4xx found, Download Error.\n");
				return -1;
			}
			else
			{
				DEBUG_P2P("Normal Download.\n");
				pCh = strstr((char *)BufAddr,"\r\n\r\n") + 4;
			}

			Index = Index - ((u8 *)pCh - BufAddr);
			//DEBUG_P2P("RECV LEN: %d\n",idx);
			if(strcmp(pPath, "MD5SUM"))
			{
				OSTimeDly(1);
				MD5Init(&ctx);
				MD5Update(&ctx, (unsigned char*)pCh, Index);
				MD5Final(digest,&ctx);
				for (i = 0; i < 16; i++)
				{
					sprintf(buf3,"%02x",digest[i]);
					buf2[2*i]=buf3[0];
					buf2[2*i+1]=buf3[1];
				}
				buf2[32]='\0';
				DEBUG_P2P("FW MD5:%s\n",buf2);

				if(!strncmp(FWMD5,buf2,32))
				{
					OnlineUpdateStatus = FW_DOWNLOAD_FINISH;
					memcpy(BufAddr, pCh, Index);
				}
				else
				{
					DEBUG_P2P("MD5 check error!!\n");
					if(TryBackupServer == 0)
					{
						DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
						TryBackupServer = 1;
						close(skt);
						goto Retry;
					}
					OnlineUpdateStatus = FW_DOWNLOAD_FAIL;
					OSFlagPost(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_UPDATE_SEC, OS_FLAG_SET, &err);
				}
			}
			else
			{
				strcpy(FWMD5, pCh);
				DEBUG_P2P("MD5SUM:%s\n",FWMD5);
			}
		}
		else
		{
			DEBUG_P2P("Connect fail!\n");
			if(TryBackupServer == 0)
			{
				DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
				TryBackupServer = 1;
				close(skt);
				goto Retry;
			}
			OnlineUpdateStatus = FW_DOWNLOAD_FAIL;
			OSFlagPost(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_UPDATE_SEC, OS_FLAG_SET, &err);
			close(skt);
			return -1;
		}
		close(skt);
		return 0;
	}
	else
	{
		DEBUG_P2P("Socket create error=%d\n",skt);
		if(TryBackupServer == 0)
		{
			DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
			TryBackupServer = 1;
			goto Retry;
		}
		OnlineUpdateStatus = FW_DOWNLOAD_FAIL;
		OSFlagPost(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_UPDATE_SEC, OS_FLAG_SET, &err);
		return -1;
	}
}

int netGetVersionFileInfo(u8 *pSrcBuf, u32 LenOfBuf, u32 *ReadSize)
{
	char urlfile[100], req_fw_version[1024], hostname_IP[HOSTNAME_IP_BUF_SIZE]="", hostname[50];
    int skt, bytesRecv, result, retry, on=1;
    u32 idx, TryBackupServer = 0;
    char *pCh;

	// Reset target buffer
	memset(pSrcBuf, 0, LenOfBuf);
	*ReadSize = 0;

Retry:
	if(renewIP == 1)
	{
		DEBUG_P2P("Renew IP, leave check_fw.\n");
		goto End;
	}

	if(TryBackupServer == 0)
	{
		strcpy(hostname,FW_SERVER);

	    //if(DN2IP(hostname, hostname_IP) == 0)
	    if (0)//(DN2IP(hostname, hostname_IP) == 0)
	    {
	        DEBUG_P2P("Get FW_SERVER, IP = %s\n", hostname_IP);
	    }
	    else
	    {
	        DEBUG_P2P("Parse FW_SERVER fail...\n");
	        if(TryBackupServer == 0)
			{
				DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
				TryBackupServer = 1;
				goto Retry;
			}
	        goto End;
	    }
	    memset(urlfile, 0, 100);
	    sprintf(urlfile, "%sVersion.ini", "/TMPS/");
	    DEBUG_P2P("Get %s\n", urlfile);
	    gFWSrvAddr.sin_addr.s_addr = inet_addr("192.168.210.64");
	    gFWSrvAddr.sin_port = htons(PORT_FW);
	    gFWSrvAddr.sin_family = AF_INET;
	}
	else
	{
		memset(urlfile, 0, 100);
	    sprintf(urlfile, "%sVersion.ini", "/TMPS/");
	    DEBUG_P2P("Get %s\n", urlfile);
	    gFWSrvAddr.sin_addr.s_addr = inet_addr("192.168.210.64");
	    gFWSrvAddr.sin_port = htons(PORT_FW);
	    gFWSrvAddr.sin_family = AF_INET;
	}

	if((skt = (int)socket(AF_INET, SOCK_STREAM, 0)) >= 0)
    {
        result = -1;
        retry = 0;
        setsockopt(skt, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on));
        while(result < 0)
        {
            result = connect(skt, (struct sockaddr *)&gFWSrvAddr, sizeof(struct sockaddr_in));
            retry++;
            if(result < 0)
            {
                close(skt);
                (skt = (int)socket(AF_INET, SOCK_STREAM, 0));
            }
            if(retry > 10)
                break;
        }
        if(result == 0)
        {
            memset(req_fw_version, 0,1024);
            sprintf(req_fw_version, "GET %s HTTP/1.1\r\n"
                    "Host: %s\r\n"
                    "Connection: keep-alive\r\n"
                    "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML,like Gecko) Chrome/19.0.1084.52 Safari/536.5\r\n"
                    "Accept: text/html, application/xhtm l+xml,applicatio n/xml;q=0.9,*/*; q=0.8\r\n"
                    "Accept-Encoding: gzip,deflate,sdch\r\n"
                    "Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\r\n"
                    "Accept-Charset: Big5,utf-8;q=0.7,*;q=0.3\r\n"
                    "Cache-Control: no-cache\r\n"
                    "\r\n",urlfile,inet_ntoa2(gFWSrvAddr.sin_addr));
            send(skt, req_fw_version, strlen(req_fw_version), 0);
            idx = 0;
            memset(req_fw_version, 0, 1024);
            while(1)
            {
                if(net_link_status == NET_LINK_OFF)
                {
                    DEBUG_P2P("NET_LINK_OFF.\n");
                    break;
                }
                bytesRecv = recv(skt, req_fw_version + idx, 1024, 0 );
                if(bytesRecv < 0)
                {
                    DEBUG_P2P("Connection Closed.\n");
                    break;
                }
                else if(bytesRecv == 0)
                {
                    DEBUG_P2P("Receive file finish.\n");
                    break;
                }
                else
                {
                    idx += bytesRecv;
                }
            }
            close(skt);

            if(idx > LenOfBuf)
            {
            	DEBUG_P2P("Receive buffer overflow.\n");
            	goto End;
            }

            pCh = strstr(req_fw_version, "[");
            if(pCh == NULL)
            	return 0;

            *ReadSize = (pCh - req_fw_version);
            memcpy(pSrcBuf, pCh, idx - *ReadSize);
            return 1;
        }
        else
        {
        	DEBUG_P2P("Connect fail!\n");
        	if(TryBackupServer == 0)
        	{
        		TryBackupServer = 1;
        		close(skt);
        		goto Retry;
        	}
        }
        close(skt);
    }
    else
    {
        DEBUG_P2P("Socket create error=%d\n",skt);
        if(TryBackupServer == 0)
    	{
    		TryBackupServer = 1;
    		goto Retry;
    	}
    }

End:
	return 0;
}
#endif
static void check_fw(char *version)
{
    char urlfile[100], req_fw_version[1024], hostname_IP[HOSTNAME_IP_BUF_SIZE]="", hostname[50];
    int skt, bytesRecv, result, retry, err, on=1, i=0;
    s32 idx;
    char *ver;
    u8 ver_len, fw_fail=0;

Retry:

	if(renewIP == 1)
	{
		DEBUG_P2P("Renew IP, leave check_fw.\n");
		goto End;
	}

	if(!fw_fail)
	{
	    strcpy(hostname,FW_SERVER);
	    err=DN2IP(hostname,hostname_IP);

	    if(err==0)
	        DEBUG_P2P("Get FW_SERVER,IP = %s\n",hostname_IP);
	    else
	    {
	        DEBUG_P2P("Parse FW_SERVER fail...\n");
	        if(!fw_fail)
			{
				DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
				fw_fail = 1;
				goto Retry;
			}
	        ver=0;
	        return;
	    }
	    memset(urlfile, 0, 100);
	    sprintf(urlfile, "%sVersion.ini",FW_PATH);
	    DEBUG_P2P("Get %s\n",urlfile);
	    //uiSetRfDisplayMode(4);// 4="UI_MENU_RF_ENTER_SETUP" Enter Menu mode to alloc 8MB memory for f/w upgrade.
	    //gFWSrvAddr.sin_addr.s_addr=inet_addr("119.81.84.106");
	    gFWSrvAddr.sin_addr.s_addr=inet_addr(hostname_IP);
	    gFWSrvAddr.sin_port = htons(PORT_FW);
	    gFWSrvAddr.sin_family = AF_INET;
	}
	else //China Server
	{
		/*
	    strcpy(hostname,FW_SERVER2);
	    err=DN2IP(hostname,hostname_IP);

	    if(err==0)
	        DEBUG_P2P("Get FW_SERVER,IP = %s\n",hostname_IP);
	    else
	    {
	        DEBUG_P2P("Parse FW_SERVER fail...\n");
	        ver=0;
	        return;
	    }
	    */
	    memset(urlfile, 0, 100);
	    sprintf(urlfile, "%sVersion.ini",FW_PATH);
	    DEBUG_P2P("Get %s\n",urlfile);
	    //gFWSrvAddr.sin_addr.s_addr=inet_addr(hostname_IP);
	    gFWSrvAddr.sin_addr.s_addr=inet_addr("119.29.94.156");
	    gFWSrvAddr.sin_port = htons(PORT_FW);
	    gFWSrvAddr.sin_family = AF_INET;

	}
    if ((skt = (int)socket(AF_INET, SOCK_STREAM, 0)) >=0)
    {
        result=-1;
        retry=0;
        setsockopt(skt,SOL_SOCKET,SO_KEEPALIVE,&on,sizeof(on));
        while(result<0)
        {
            result=connect(skt, (struct sockaddr *)&gFWSrvAddr, sizeof(struct sockaddr_in));
            retry++;
            if(result<0)
            {
                close(skt);
                (skt = (int)socket(AF_INET, SOCK_STREAM, 0));
            }
            if(retry>10)
                break;
        }
        if(result==0)
        {
            memset(req_fw_version, 0,1024);
            sprintf(req_fw_version, "GET %s HTTP/1.1\r\n"
                    "Host: %s\r\n"
                    "Connection: keep-alive\r\n"
                    "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML,like Gecko) Chrome/19.0.1084.52 Safari/536.5\r\n"
                    "Accept: text/html, application/xhtm l+xml,applicatio n/xml;q=0.9,*/*; q=0.8\r\n"
                    "Accept-Encoding: gzip,deflate,sdch\r\n"
                    "Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\r\n"
                    "Accept-Charset: Big5,utf-8;q=0.7,*;q=0.3\r\n"
                    "Cache-Control: no-cache\r\n"
                    "\r\n", urlfile, inet_ntoa2(gFWSrvAddr.sin_addr));
            send(skt, req_fw_version,strlen(req_fw_version), 0);
            idx=0;
            memset(req_fw_version, 0,1024);
            while(1)
            {
                if(net_link_status==NET_LINK_OFF)
                {
                    DEBUG_P2P( "NET_LINK_OFF.\n");
                    ver=0;
                    break;
                }
                bytesRecv = recv(skt, req_fw_version+idx, 1024, 0 );
                if ( bytesRecv  < 0  )
                {
                    DEBUG_P2P( "Connection Closed.\n");
                    ver=0;
                    break;
                }
                else if(bytesRecv==0)
                {
                    DEBUG_P2P( "Receive file finish.\n");
                    break;
                }
                else
                {
                    idx+=bytesRecv;
                }
            }
            ver=strstr(req_fw_version,"\r\n\r\n")+4;
            if(strncmp(ver,"[VERSION=",9))
            {
                *ver=0;
                strcpy(version,ver);
            }
            else
            {
                ver=strchr(ver,'=')+1;
                //aher test 2015/09/04
                //ver_len=strlen(uiVersion);
                for(i=0; i<40; i++)
                {
                    if(ver[i]==']')
                    {
                        break;
                    }
                }
                if(i>=40)
                {
                    ver_len=strlen((char *)uiVersion);
                }
                else
                {
                    if(ver[i-1]==' ')
                    {
                        i--;
                    }
                    ver_len=i;
                }
                ver[ver_len]='\0';
                strcpy(fw_version,ver);
                ver[ver_len]='0';
                ver=strstr(req_fw_version,"\r\n\r\n")+4;
                ver=strstr(ver,"\r\n\r\n")+4;
                if(strncmp(ver,"[DATE=",6))
                {
                    *ver = 0;
                    strcpy(version,ver);
                }
                else
                {
                    ver=strchr(ver,'=')+1;
                    ver_len=strlen((char *)uiVersionTime);
                    ver[ver_len]='\0';
                    strcpy(version,ver);
                }
            }
            //strcpy(version,ver);
        }
        else
        {
            *ver = 0;
            strcpy(version,ver);
            DEBUG_P2P("Connect fail!\n");
			if(!fw_fail)
			{
				fw_fail = 1;
				close(skt);
				goto Retry;
			}
        }
        close(skt);
    }
    else
    {
        *ver=0;
        strcpy(version,ver);
        DEBUG_P2P("Socket create error=%d\n",skt);
        if(!fw_fail)
    	{
    		fw_fail = 1;
    		goto Retry;
    	}
    }
End:
}
/*Check firmware version on the http server.*/
#if 1
u8 Check_fw_ver_net(u8 connected)
{
#if ((SW_APPLICATION_OPTION == MR8202_GATEWAYBOX_RX) || (SW_APPLICATION_OPTION == MR8202_AN_KLF08W))
#if ISP_NEW_UPGRADE_FLOW_SUPPORT
	ispUpdateFirmwareVersion(0x1f);
#endif
    return 1;	// Upgrade by APP cmd, auto detect doesn't any more.
#else
    char ver[1024];
    char ver2[1024];

    if(net_link_status==NET_LINK_OFF)
    {
        //ver=0;
        Reminder_FW_Upgrade=0;
        return Reminder_FW_Upgrade;
    }

#if (NET_FW_TEST == 1)
    strcpy(uiVersionTime, "20180322");
#endif
    if(connected)
    {
        do
        {
			if(renewIP)
				break;
            check_fw(ver);
            check_fw(ver2);
        }
        while((strcmp(ver,ver2))&&(net_link_status==NET_LINK_ON));

        if(ver==0)
        {
            DEBUG_P2P("FW server connection fail!\n");
            Reminder_FW_Upgrade=0;
        }
        //else if((strcmp(uiVersion,ver))&&(strcmp(uiVersion,ver2)))
        else if((atoi((char *)uiVersionTime)<atoi(ver))&&(atoi((char *)uiVersionTime)<atoi(ver2)))
        {
            DEBUG_P2P("New firmware %s has released.\n",fw_version);
            //strcpy(fw_version,fw_ver);
            //DEBUG_P2P("fw_version=%s\n",fw_version);
            /*Show Upgrade f/w tips.*/
#if ((UI_VERSION == UI_VERSION_RDI) ||(UI_VERSION == UI_VERSION_RDI_2) ||\
			(UI_VERSION == UI_VERSION_RDI_3) || (UI_FW_UPGRADE_ICON_ENABLE == 1))
            uiOsdDrawRemindDownload(UI_OSD_DRAW);
#endif
            Reminder_FW_Upgrade=1;

        }
        else
        {
            DEBUG_P2P("Current firmware is latest.\n");
            Reminder_FW_Upgrade=0;
        }
        return Reminder_FW_Upgrade;
    }
    else
    {
        return Reminder_FW_Upgrade;
    }
#endif//End of SW_APPLICATION_OPTION
}
#endif

/*Fetch file from HTTP server*/
static int GetFile(char *downfile)
{
    char urlfile[100], buf2[50], buf3[4], hostname_IP[HOSTNAME_IP_BUF_SIZE]="", hostname[50];
    int skt, bytesRecv, i, result, ret, on=1;//,ret,a;
    u8 digest[16], err, retry, fw_fail=0;
    MD5_CTX ctx;
    char* body;

    sysDeadLockMonitor_OFF(); /*Turn off watch dog.*/

Retry:

	if(fw_fail == 0)
	{
	    strcpy(hostname,FW_SERVER);
	    err=DN2IP(hostname,hostname_IP);//Paul
	    if(err==0)
	        DEBUG_P2P("Get FW_SERVER,IP = %s\n",hostname_IP);
	    else
	    {
	        DEBUG_P2P("Parse FW_SERVER fail...\n");
	        if(fw_fail == 0)
			{
				DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
				fw_fail = 1;
				goto Retry;
			}
	    }

	//u8* codeAddr2 = (u8*)((DRAM_MEMORY_END + 4) - 0x800000+4*1024*1024);
	    memset(urlfile, 0, 100);
	    sprintf(urlfile, "%s%s/%s",FW_PATH,fw_version,downfile);

	    DEBUG_P2P("Get %s\n",urlfile);
	    OnlineUpdateStatus=FW_DOWNLOADING;
#if 0 /*Enter Menu screen.*/
#if (RFIU_SUPPORT)
	    uiSetRfDisplayMode(4);// 4="UI_MENU_RF_ENTER_SETUP" Enter Menu mode to alloc 8MB memory for f/w upgrade.
#endif
#endif
	    gFWSrvAddr.sin_addr.s_addr=inet_addr(hostname_IP);
	    gFWSrvAddr.sin_port = htons(PORT_FW);
	    gFWSrvAddr.sin_family = AF_INET;
	}
	else //China Server
	{
		/*
		strcpy(hostname,FW_SERVER2);
		err=DN2IP(hostname,hostname_IP);
		if(err==0)
			DEBUG_P2P("Get FW_SERVER,IP = %s\n",hostname_IP);
		else
			DEBUG_P2P("Parse FW_SERVER fail...\n");
		*/
		memset(urlfile, 0, 100);
		sprintf(urlfile, "%s%s/%s",FW_PATH,fw_version,downfile);

		DEBUG_P2P("Get %s\n",urlfile);
		OnlineUpdateStatus=FW_DOWNLOADING;
#if 0 /*Enter Menu screen.*/
#if (RFIU_SUPPORT)
		uiSetRfDisplayMode(4);// 4="UI_MENU_RF_ENTER_SETUP" Enter Menu mode to alloc 8MB memory for f/w upgrade.
#endif
#endif
		//gFWSrvAddr.sin_addr.s_addr=inet_addr(hostname_IP);
		gFWSrvAddr.sin_addr.s_addr=inet_addr("119.29.94.156");
		gFWSrvAddr.sin_port = htons(PORT_FW);
		gFWSrvAddr.sin_family = AF_INET;
	}
    if ((skt = (int)socket(AF_INET, SOCK_STREAM, 0)) >=0)
    {
        result=-1;
        retry=0;
        ret=setsockopt(skt,SOL_SOCKET,SO_KEEPALIVE,&on,sizeof(on));/*Check the TCP connection whether alive.*/

        while(result<0)
        {
            result=connect(skt, (struct sockaddr *)&gFWSrvAddr, sizeof(struct sockaddr_in));
            retry++;
            if(result<0)
            {

                close(skt);
                (skt = (int)socket(AF_INET, SOCK_STREAM, 0));
            }
            if(retry>10)
            {
            	if(!fw_fail)
            	{
					DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
            		fw_fail = 1;
            		close(skt);
            		goto Retry;
            	}
                OnlineUpdateStatus=FW_DOWNLOAD_FAIL;
                break;
            }
        }
        //if (connect(skt, (struct sockaddr *)&gFWSrvAddr, sizeof(struct sockaddr_in)) == 0)
        if(result==0)
        {

            memset(codeAddr, 0, 1024*1024*8);
            sprintf((char *)codeAddr, "GET %s HTTP/1.1\r\n"
                    "Host: %s\r\n"
                    "Connection: keep-alive\r\n"
                    "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML,like Gecko) Chrome/19.0.1084.52 Safari/536.5\r\n"
                    "Accept: text/html, application/xhtm l+xml,applicatio n/xml;q=0.9,*/*; q=0.8\r\n"
                    "Accept-Encoding: gzip,deflate,sdch\r\n"
                    "Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\r\n"
                    "Accept-Charset: Big5,utf-8;q=0.7,*;q=0.3\r\n"
                    "Cache-Control: no-cache\r\n"
                    "\r\n",urlfile,inet_ntoa2(gFWSrvAddr.sin_addr));
            send(skt, codeAddr,strlen((char *)codeAddr), 0);
            idx=0;
            i=0;
            memset(codeAddr, 0, 1024*1024*8);

            while(1)
            {
                bytesRecv = recv(skt, codeAddr+idx, 1024*1024*8, 0 );
                DEBUG_P2P("#");
                if ( bytesRecv < 0 )
                {
                    DEBUG_P2P( "Connection Closed.\n");
                    OnlineUpdateStatus=FW_DOWNLOAD_FAIL;
                    OSFlagPost(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_UPDATE_SEC, OS_FLAG_SET, &err);

                    break;
                }
                else if(bytesRecv==0)
                {
                    DEBUG_P2P( "Receive file finish.\n");
                    break;
                }
                else
                {
                    idx+=bytesRecv;
                }
                /*Avoid dead lock.*/
#if 0
                if(i==1000)
                {
                    OSTimeDly(1);
                    i=0;
                }
                i++;
#endif
            }
			   //printf("req_fw_version_RESP=%s\n",req_fw_version);
			   
			   /*Test Downlad.bin File
							if ((pFile = dcfOpen("\\Download.bin", "w")) == NULL)
							{
							  DEBUG_DCF("!!!Error: create Download error!!!\n");
							
							}
							printf(">\"<\n");
							dcfWrite(pFile, codeAddr, idx, &writesize);
							
							dcfClose(pFile, &tmp);
			   */
			   
			// 20160929 Sean Modify Parsing method.
			   body=strstr((char *)codeAddr,"HTTP");
			   if(body[9] == '3') // 3xx redirect
			   {
				   DEBUG_P2P("HTTP 302 found, Search data.\n");
				   body=strstr((char *)codeAddr,"\r\n\r\n")+4;
				   body=strstr(body,"\r\n\r\n")+4;
			   }
			   else if(body[9] == '4') // 4xx Error
			   {
				   DEBUG_P2P("HTTP 4xx found, Download Error.\n");
				   return -1;
			   }
			   else
			   {
				   DEBUG_P2P("Normal Download.\n");
				   body=strstr((char *)codeAddr,"\r\n\r\n")+4;
			   }
			
			   
			   //if(idx > 1024) // Sean 20160725: Use for URL redirect solution.
			   //{
			   //  for(a=0;a<16;a++)
			   //  {
			   //	   if(body[a] != 0)
			   //	   {
			   //		   DEBUG_P2P("NEXT SEARCH!!\n");
			   //		   body=strstr(body,"\r\n\r\n")+4;
			   //		   break;
			   //	   }
			   //  }
			   //}				   
            //DEBUG_P2P("addr1=%d,addr2=%d,diff=%d\n",codeAddr,body,body-codeAddr);
            //DEBUG_P2P("idx=%d,body=%ld,codeAddr=%ld,diff=%d\n",idx,body,codeAddr,body-codeAddr);
            idx=idx-(body-(char *)codeAddr);
            //DEBUG_P2P("RECV LEN: %d\n",idx);
            if(strcmp(downfile,"MD5SUM"))
            {
                //sysDeadLockMonitor_OFF(); /*Turn off watch dog.*/
                OSTimeDly(1);
                MD5Init(&ctx);
                MD5Update(&ctx, (unsigned char*)body,idx);
                MD5Final(digest,&ctx);
                for (i = 0; i < 16; i++)
                {
                    sprintf(buf3,"%02x",digest[i]);
                    buf2[2*i]=buf3[0];
                    buf2[2*i+1]=buf3[1];
                }
                buf2[32]='\0';
                DEBUG_P2P("FW MD5:%s\n",buf2);

                if(!strncmp(FWMD5,buf2,32))
                {
                    OnlineUpdateStatus=FW_DOWNLOAD_FINISH;
                    memcpy(codeAddr,body,idx);
#if ISP_NEW_UPGRADE_FLOW_SUPPORT
                    sysSetEvt(SYS_EVT_UPGRADE_BY_NET, idx);
#else
                    ispUpdateAllload_Net(idx);
#endif
                }
                else
                {
                    DEBUG_P2P("MD5 check error!!\n");
                    if(!fw_fail)
	            	{
						DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
	            		fw_fail = 1;
	            		close(skt);
	            		goto Retry;
	            	}
                    OnlineUpdateStatus=FW_DOWNLOAD_FAIL;
                    OSFlagPost(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_UPDATE_SEC, OS_FLAG_SET, &err);
                }
                //sysForceWDTtoReboot();
            }
            else
            {
                strcpy(FWMD5,body);
            }
        }
        else
        {
            DEBUG_P2P("Connect fail!\n");
            if(!fw_fail)
        	{
				DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
        		fw_fail = 1;
        		close(skt);
        		goto Retry;
        	}
            OnlineUpdateStatus=FW_DOWNLOAD_FAIL;
            OSFlagPost(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_UPDATE_SEC, OS_FLAG_SET, &err);
            close(skt);
            return -1;
        }
        close(skt);
        return 0;
    }
    else
    {
        DEBUG_P2P("Socket create error=%d\n",skt);
        if(!fw_fail)
    	{
			DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
    		fw_fail = 1;
    		goto Retry;
    	}
        OnlineUpdateStatus=FW_DOWNLOAD_FAIL;
        OSFlagPost(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_UPDATE_SEC, OS_FLAG_SET, &err);
        return -1;
    }
}

/*Return the progress of f/w downloading*/
u8 GetFWDownProgress(s32* fw_length)
{
    *fw_length=idx;
    return OnlineUpdateStatus;
}

int AuthCallBackFn(char *viewAcc,char *viewPwd)

{
    char PW[32];
    strcpy(PW,viewPwd);
    //DEBUG_P2P("APP_PW[%s]\n",PW);

    if(strcmp(viewAcc, "admin") == 0 && strcmp(viewPwd,gP2PPassword) == 0)
        return 1;
    return 0;
}


void UpdateHeader(int ch,int UseMpeg_Q)
{
    int Width,Height;
    if(ch < 4)
    {
        if(P2P_AV_Source[ch] == Local_record)
        {
            if(ch == 0)
            {
                Width  = VideoClipOption[LocalChannelSource].asfVopWidth;
                Height = VideoClipOption[LocalChannelSource].asfVopHeight;
            }
            else
            {
                Width  = VideoClipOption[ch + 1].asfVopWidth;
                Height = VideoClipOption[ch + 1].asfVopHeight;
            }
        }
        else
        {
            Width  = gRfiuUnitCntl[ch].TX_PicWidth;
            Height = gRfiuUnitCntl[ch].TX_PicHeight;
        }
    }
    else//Local playck
    {
        Width = gPlaybackWidth;
        Height= gPlaybackHeight;
        //DEBUG_P2P("Play File RES= %d x %d\n",Width,Height);
    }
    MPEG4_config[0x17] &= 0xF0;
    MPEG4_config[0x18] &= 0x00;
    MPEG4_config[0x19] &= 0x7F;
    MPEG4_config[0x19] &= 0xC0;
    MPEG4_config[0x1A] &= 0x01;

    MPEG4_config[0x17] |= (unsigned char)(Width >> 9);
    MPEG4_config[0x18] |= (unsigned char)(Width >> 1);
    MPEG4_config[0x19] |= (unsigned char)(Width << 7);
    MPEG4_config[0x19] |= (unsigned char)(Height >> 7);
    MPEG4_config[0x1A] |= (unsigned char)(Height << 1);

    if(UseMpeg_Q)
    {
        MPEG4_config[0x1b]=0x49;
        MPEG4_config[0x1c]=0x0f;
    }
    else
    {
        MPEG4_config[0x1b]=0x44;
        MPEG4_config[0x1c]=0x3f;
    }


}
void UpdateH264Header(int ch)
{
//    DEBUG_P2P("# %d %d\n",gRfiuUnitCntl[ch].TX_PicWidth,gRfiuUnitCntl[ch].TX_PicHeight);
    int Width,Height,quality;
    if(ch > 4)// Playback.
    {
        Width = gPlaybackWidth;
        Height = gPlaybackHeight;
        quality = 1;
    }
    else
    {
        Width = gRfiuUnitCntl[ch].TX_PicWidth;
        Height = gRfiuUnitCntl[ch].TX_PicHeight;
        quality = videoquality;
    }
#if( (SW_APPLICATION_OPTION == MR9300_RFDVR_RX1RX2) || (SW_APPLICATION_OPTION == MR9300_NETBOX_RX1RX2) )

    if((quality == 1))
    {
        if((Width == 640)&&(Height == 352))
        {
            H264_config[0x07] = 0x1E;
            H264_config[0x08] = 0xDA;
            H264_config[0x09] = 0x02;
            H264_config[0x0A] = 0x80;
            H264_config[0x0B] = 0xB6;
            H264_config[0x0C] = 0x40;
        }
        else if((Width == 1280)&&(Height == 720))
        {
            H264_config[0x07] = 0x1E;
            H264_config[0x08] = 0xDA;
            H264_config[0x09] = 0x01;
            H264_config[0x0A] = 0x40;
            H264_config[0x0B] = 0x16;
            H264_config[0x0C] = 0xE4;
        }
        else if((Width == 1920)&&(Height == 1072))
        {
            H264_config[0x07] = 0x28;
            H264_config[0x08] = 0xDA;
            H264_config[0x09] = 0x01;
            H264_config[0x0A] = 0xE0;
            H264_config[0x0B] = 0x08;
            H264_config[0x0C] = 0x79;
        }
        else if((Width == 1920)&&((Height == 1080)|| (Height == 1088)))
        {
            H264_config[0x07] = 0x28;
            H264_config[0x08] = 0xDA;
            H264_config[0x09] = 0x01;
            H264_config[0x0A] = 0xE0;
            H264_config[0x0B] = 0x08;
            H264_config[0x0C] = 0x9F;
            H264_config[0x0D] = 0x95;
        }
    }
    else
    {
        H264_config[0x07] = 0x1E;
        H264_config[0x08] = 0xDA;
        H264_config[0x09] = 0x02;
        H264_config[0x0A] = 0x80;
        H264_config[0x0B] = 0xB6;
        H264_config[0x0C] = 0x40;
    }
#else
    if((quality == 1) ||(quality == 2))
    {
        if((Width == 640)&&(Height == 352))
        {
            H264_config[0x07] = 0x1E;
            H264_config[0x08] = 0xDA;
            H264_config[0x09] = 0x02;
            H264_config[0x0A] = 0x80;
            H264_config[0x0B] = 0xB6;
            H264_config[0x0C] = 0x40;
        }
        else if((Width == 1280)&&(Height == 720))
        {
            H264_config[0x07] = 0x1E;
            H264_config[0x08] = 0xDA;
            H264_config[0x09] = 0x01;
            H264_config[0x0A] = 0x40;
            H264_config[0x0B] = 0x16;
            H264_config[0x0C] = 0xE4;
        }
        else if((Width == 1920)&&(Height == 1072))
        {
            H264_config[0x07] = 0x28;
            H264_config[0x08] = 0xDA;
            H264_config[0x09] = 0x01;
            H264_config[0x0A] = 0xE0;
            H264_config[0x0B] = 0x08;
            H264_config[0x0C] = 0x79;
        }
        else if((Width == 1920)&&((Height == 1080)|| (Height == 1088)))
        {
            H264_config[0x07] = 0x28;
            H264_config[0x08] = 0xDA;
            H264_config[0x09] = 0x01;
            H264_config[0x0A] = 0xE0;
            H264_config[0x0B] = 0x08;
            H264_config[0x0C] = 0x9F;
            H264_config[0x0D] = 0x95;
        }
    }
    else
    {
        H264_config[0x07] = 0x1E;
        H264_config[0x08] = 0xDA;
        H264_config[0x09] = 0x02;
        H264_config[0x0A] = 0x80;
        H264_config[0x0B] = 0xB6;
        H264_config[0x0C] = 0x40;
    }
#endif
}

void unregedit_client_from_video(int SID)
{
    gClientInfo[SID].bEnableVideo = 0;
}

void regedit_client_to_video(int SID)
{
    gClientInfo[SID].bEnableVideo = 1;
}

void regedit_client_to_audio(int SID)
{
    gClientInfo[SID].bEnableAudio = 1;
}

void unregedit_client_from_audio(int SID)
{
    gClientInfo[SID].bEnableAudio = 0;
}

void regedit_client_to_avsession(int SID, int avIndex)
{
    gClientInfo[SID].avChannel = avIndex;
}

void regedit_client_to_speaker(int SID, int avIndex)
{
    gClientInfo[SID].bEnableSpeaker = 1;
    gClientInfo[SID].speakerAvIndex = avIndex;
}

void unregedit_client_from_speaker(int SID)
{
    gClientInfo[SID].bEnableSpeaker = 0;
}

void unregedit_client_from_avsession(int SID)
{
    int i;

    for(i=0; i<MAX_AV_CH; i++)
    {
        DEBUG_P2P("avServStop called SID[%d] avIndex[%d]\n", SID, gClientInfo[SID].avIndex[i]);
        avServStop(gClientInfo[SID].avIndex[i]);
        gClientInfo[SID].avIndex[i] = -1;
    }
    if((gClientInfo[SID].playBackCh!=0)&&((search_dir_start.YMD>0)||(search_dir_start.HMS>0)))
    {
        DEBUG_P2P("avServStop called SID[%d] avChannel[%d]\n",SID,gClientInfo[SID].avChannel);
        avServStop(gClientInfo[SID].avChannel);
        search_dir_start.YMD=0;
        search_dir_start.HMS=0;
        search_dir_end.YMD=0;
        search_dir_end.HMS=0;
    }
    gClientInfo[SID].avChannel= -1;
    unregedit_client_from_video(SID);
    unregedit_client_from_audio(SID);
    //aher
    unregedit_client_from_speaker(SID);
}

void LoadP2PPassword(char *password)
{
    strcpy(gP2PPassword,password);
}



/*yAPP to 8200 by aher*/
void Kill_Task_Speaker(int SID)
{
    if(gClientInfo[SID].bEnableSpeaker)
    {
        unregedit_client_from_speaker(SID);
#if (REMOTE_TALK_BACK == 0)
        rfiu_AudioRetONOFF_APP(0,CurrentCH);
#endif
        gSpeakerSID=-1;
        OSTimeDly(4);
        avClientStop(SpeakerAvIndex);
        DEBUG_P2P("====Kill_Task_Speaker:%d====\n",CurrentCH);
        //OSTaskSuspend(SPEAKER_TASK_PRIORITY);
#if REMOTE_TALK_BACK
        iisPreviewI2OEnd();
#endif
        //OSTimeDly(3);
        OSTaskDel(SPEAKER_TASK_PRIORITY);
    }
}

#if REMOTE_TALK_BACK

/*
}yAPP to 8211 by Peter.
*/

u8  TalkBackBuffer[IIS_CHUNK_SIZE * 2];

void Task_Speaker(void *pdata)
{
    int             SID         = gSpeakerSID;
    int             ret         = 0;
    FRAMEINFO_t     frameInfo;
    unsigned int    pnFrameIdx;
    unsigned long   servType;
    AV_Client       *p          = &gClientInfo[SID];
    int             TotalSize   = 0;
    int             i           = 0;
    int             offset      = 0;

    pnFrameIdx      = 0;

    SpeakerAvIndex  = avClientStart(SID, NULL, NULL, 20, &servType, p->speakerCh); // password no need
    if(SpeakerAvIndex >= 0)
    {
        iisPreviewI2OBegin();
        while(1)
        {
            if (gClientInfo[SID].bEnableSpeaker < 1)
            {
                OSTimeDly(3);
                DEBUG_P2P("Closing Task.\n");
                continue;
            }
            gFlagSpeakerOK  = 1;

            if (avCheckAudioBuf(SpeakerAvIndex))
            {
                if(iisSounBufMngWriteIdx == (IIS_BUF_NUM - 1))
                    ret = avRecvAudioData(SpeakerAvIndex , TalkBackBuffer + TotalSize, IIS_CHUNK_SIZE, (char*)&frameInfo, 16, &pnFrameIdx);
                else
                    ret = avRecvAudioData(SpeakerAvIndex , iisSounBufMng[iisSounBufMngWriteIdx].buffer + TotalSize, IIS_CHUNK_SIZE, (char*)&frameInfo, 16, &pnFrameIdx);

                if (ret < 0)
                    DEBUG_P2P("Receiving audio fail. Ret=%d\n", ret);
                else
                {
                    TotalSize  += ret;
                    if(TotalSize >= IIS_CHUNK_SIZE)
                    {
                        TotalSize              -= IIS_CHUNK_SIZE;
                        if(iisSounBufMngWriteIdx == (IIS_BUF_NUM - 1))
                        {
                            memcpy(iisSounBufMng[iisSounBufMngWriteIdx].buffer + offset, TalkBackBuffer + offset, IIS_CHUNK_SIZE - offset);
                            memcpy(iisSounBufMng[0].buffer, TalkBackBuffer + IIS_CHUNK_SIZE, ret);
                        }
                        iisSounBufMngWriteIdx   = (iisSounBufMngWriteIdx + 1) % IIS_BUF_NUM;
                        //OSSemAccept(iisTrgSemEvt);
                        //OSSemPost(iisCmpSemEvt);
                        OSSemPost(iisPlaybackSemEvt);
                        OSSemPost(iisPlaybackSemEvt);
                        OSSemPost(iisPlaybackSemEvt);
                        OSSemPost(iisPlaybackSemEvt);
                        if(iisSounBufMngWriteIdx == (IIS_BUF_NUM - 1))
                            offset  = ret;
                    }
                }
            }
            else
            {
                OSTimeDly(1);
            }

        }
    }
}

#else

/*
}yAPP to 8200 by aher.
*/

void Task_Speaker(void *pdata)
{
    int SID = gSpeakerSID;
    int ret =0;
    FRAMEINFO_t frameInfo;
    unsigned int pnFrameIdx;
    unsigned int servType;
    AV_Client *p = &gClientInfo[SID];
    int TotalSize=0;
    int i=0;
    int CH;
    //==============================//
    pnFrameIdx=0;
    CH=(int)pdata;
    DEBUG_P2P("===Task_Speaker Create:%d,SID:%d===\n",CH, SID);
    SpeakerAvIndex = avClientStart(SID, NULL, NULL, 20, &servType, p->speakerCh); // password no need
    DEBUG_P2P("SpeakerAvIndex=%d\n",SpeakerAvIndex);
    if(SpeakerAvIndex >= 0)
    {
        while(1)
        {
            if (gClientInfo[SID].bEnableSpeaker<1)
            {
                OSTimeDly(3);
                DEBUG_P2P("Closing Speaker Task.\n");
                continue;
            }
            gFlagSpeakerOK = 1;
            if (avCheckAudioBuf(SpeakerAvIndex)>10)
            {
                for(i=0; i<5; i++)
                {
                    ret = avRecvAudioData(SpeakerAvIndex ,(char *)(rfiuAudioRetDMANextBuf[0]+TotalSize), BUFF_FOR_AUDIO, (char*)&frameInfo, 16,&pnFrameIdx);
                    //memcpy(rfiuAudioRetDMANextBuf[0]+TotalSize,rfiuAudioZeroBuf,1024);
                    if (ret<0)
                        DEBUG_P2P("Receiving audio fail. Ret=%d\n",ret);
                    else
                    {
                        TotalSize+=ret;
                        if(TotalSize>=(1024*(rfiuAudioRetRec_idx+1)))
                        {
                            rfiuAudioRetRec_idx=(rfiuAudioRetRec_idx+1)%RFI_AUDIO_RET_BUF_NUM;
                            if(rfiuAudioRetRec_idx == 0)
                            {
                                TotalSize=0;
                            }
                        }
                        if((rfiuAudioRetRec_idx & 0x07)==0)
                        {
                            gRfiuUnitCntl[CH].TxPktMap[RFI_AUDIORETURN1_ADDR_OFFSET/RFI_GRP_INPKTUNIT + (rfiuAudioRetRec_idx>>3)].PktCount=64;
                            gRfiuUnitCntl[CH].TxPktMap[RFI_AUDIORETURN1_ADDR_OFFSET/RFI_GRP_INPKTUNIT + (rfiuAudioRetRec_idx>>3)].RetryCount=0;
                            gRfiuUnitCntl[CH].TxPktMap[RFI_AUDIORETURN1_ADDR_OFFSET/RFI_GRP_INPKTUNIT + (rfiuAudioRetRec_idx>>3)].WriteDiv=8;
                            gRfiuUnitCntl[CH].TxPktMap[RFI_AUDIORETURN1_ADDR_OFFSET/RFI_GRP_INPKTUNIT + (rfiuAudioRetRec_idx>>3)].ReadDiv =0;
                            gRfiuUnitCntl[CH].TxPktMap[RFI_AUDIORETURN1_ADDR_OFFSET/RFI_GRP_INPKTUNIT + (rfiuAudioRetRec_idx>>3)].PktMap0 =0xffffffff;
                            gRfiuUnitCntl[CH].TxPktMap[RFI_AUDIORETURN1_ADDR_OFFSET/RFI_GRP_INPKTUNIT + (rfiuAudioRetRec_idx>>3)].PktMap1 =0xffffffff;
                        }
                    }
                }
            }
            OSTimeDly(2);
        }
    }
    else
    {
        DEBUG_P2P("Task_Speaker avClientStart fail :%d\n ",SpeakerAvIndex);
        while(1)
        {
            OSTimeDly(3);
        }
    }

}

#endif


void Remoteplayback_busy(void)
{
    int SID,i;
    int ret;
#if ENABLE_TUTK_RESEND
    int nResend = 0;
#endif
#if (UI_VERSION == UI_VERSION_MAYON)
    INT8U err;
#endif
    VIDEO_BUF_MNG *P2PVideoPlaybackBuf_busy;
    u32 P2PVideoPlaybackBufReadIdx_busy;
    u32 P2PVideoPlaybackPresentTime_busy;
    u32 P2PChannelPlaybackStart;
    SMsgAVIoctrlPlayRecordResp buf;
    SMsgAVIoctrlPlayRecordResp *q;

    SID=gPlaybackSID;
#if ENABLE_TUTK_RESEND
    gClientInfo[gPlaybackSID].avChannel =avServStart3(SID, AuthCallBackFn, 20, SERVTYPE_STREAM_SERVER, gClientInfo[SID].playBackCh, &nResend);
#else
    gClientInfo[gPlaybackSID].avChannel=avServStart(SID, "admin", gP2PPassword, 10, SERVTYPE_STREAM_SERVER,gClientInfo[SID].playBackCh);
#endif
    if(gClientInfo[gPlaybackSID].avChannel < 0)
    {
        DEBUG_P2P("avindex-avServStart failed SID[%d] code[%d]!!!\n", SID,gClientInfo[gPlaybackSID].avChannel);
        //IOTC_Session_Close(SID);
    }
    DEBUG_P2P("gClientInfo[gPlaybackSID].avChannel=%d\n",gClientInfo[gPlaybackSID].avChannel);
    DEBUG_P2P("---> Remoteplayback_busy\n");

#if((UI_VERSION == UI_VERSION_RDI) || (UI_VERSION == UI_VERSION_RDI_2) || (UI_VERSION == UI_VERSION_RDI_3))
#if (((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 3))||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 5)) ||\
    (HW_BOARD_OPTION == MR9200_RX_RDI_M906) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 9))||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 12)))
    if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPEN)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_Japan_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_Japan_QVGA;
        }
    }
#elif(((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 6)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 8)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 10))||\
      ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 11)))
    if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_GERMAN)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_German_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_German_QVGA;
        }
    }
    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_SPANISH)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_Spanish_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_Spanish_QVGA;
        }
    }
#else
    if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_SPANISH)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_Spanish_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_Spanish_QVGA;
        }
    }
#endif
#if(((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 8)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 10)) ||\
    ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 11)))
    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_Italy)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_Italy_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_Italy_QVGA;
        }
    }
    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_DUTCH)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_Netherland_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_Netherland_QVGA;
        }
    }
#endif
    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_FRENCH)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_French_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_French_QVGA;
        }
    }
    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_ENGLISH)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;

        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_QVGA;
        }
    }

#elif(UI_VERSION == UI_VERSION_TRANWO)
    if (CurrLanguage == 1)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_Spanish_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_Spanish_QVGA;
        }
    }
#if(UI_OTHER_LANGUAGE ==1)
    else if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPANSE)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_Japan_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_Japan_QVGA;
        }
    }
#endif
    else
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_QVGA;
        }
    }

#else
    P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
    P2PVideoPlaybackBufReadIdx_busy=0;
    for(i=0; i<1; i++)
    {
        P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
        P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
        P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_QVGA);
        P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
        P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_QVGA;
    }
#endif

    gPlaybackWidth=320;
    gPlaybackHeight=240;
    for(i=0; i<20; i++)
    {
        //------ Streaming video payload------//
        if(gClientInfo[SID].bStopPlayBack == 1)
        {
            DEBUG_P2P("bStopPlayBack\n");
#if (UI_VERSION == UI_VERSION_MAYON) //Fixed task delete fail issue, Paul, 2019/04/10
            err = Stop_Task_by_Prio(P2P_PLAYFILE_TASK_PRIORITY, &(gClientInfo[SID].bStopPlayBack),
                  P2PVideoPlaybackStopSemEvt, NULL, FLAGSYS_RDYSTAT_PLAY_FINISH );
            gClientInfo[SID].bStopPlayBack = 0;
#endif
            break;
        }
        //DEBUG_P2P("video_value=%d\n",video_value);

        P2PVideoPlaybackPresentTime_busy = (P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy].time); //if use chunk time
        #if(VIDEO_CODEC_OPTION == H264_CODEC)
        UpdateH264Header(6); // n ch1~4.
        memcpy(p2pbusylocal_buffer, H264_config, 0x18);
        memcpy_hw(p2pbusylocal_buffer+0x18, P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy].buffer, P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy].size);
        SendVideoFrameData(SID, P2PVideoPlaybackPresentTime_busy, P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy].flag, 0x18+P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy].size, (char *)p2pbusylocal_buffer);
        #else
        UpdateHeader(6,USE_MPEG_QUANTIZATION);
        memcpy(exifPrimaryBitstream, MPEG4_config, 0x1d);
        memcpy_hw(exifPrimaryBitstream+0x1d, P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy].buffer, P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy].size);
        SendVideoFrameData(SID, P2PVideoPlaybackPresentTime_busy, P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy].flag, 0x1d+P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy].size, (char *)exifPrimaryBitstream);
        #endif
        //P2PVideoPlaybackBufReadIdx_busy++;
        OSTimeDly(1);
    }
    DEBUG_P2P("End of playback busy.\n");
#if (UI_VERSION == UI_VERSION_MAYON) //Fixed task delete fail issue, Paul, 2019/04/10
    err = Stop_Task_by_Prio(P2P_PLAYFILE_TASK_PRIORITY, &(gClientInfo[SID].bStopPlayBack),
          P2PVideoPlaybackStopSemEvt, NULL, FLAGSYS_RDYSTAT_PLAY_FINISH );
#else
    gClientInfo[SID].bStopPlayBack =1;
    OSTimeDly(1);
#endif
    avServStop(gClientInfo[SID].avChannel);
    OSTimeDly(1);

    gClientInfo[SID].playBackCh=0;
}
/*
Play file task.
*/
extern u8 p2p_30PS;
extern u8 Get_p2p_playback;
#if(VIDEO_CODEC_OPTION == H264_CODEC)
void Task_remote_file_playback(void *pdata)
{

    //int rec_avindex;
    int ret;
    int SID;
    u16 video_value =0;
//    u16 video_value_max =0;
    u16 audio_value = 0;
//    u16 audio_value_max = 0;

    u32 P2PVideoPlaybackBufReadIdx;
    u32 P2PVideoPlaybackPresentTime;
    u32 P2PAudioPlaybackBufReadIdx;
    u32 P2PAudioPlaybackPresentTime;
//    u32 P2PChannelPlaybackStart;

    VIDEO_BUF_MNG *P2PVideoPlaybackBuf;
    IIS_BUF_MNG   *P2PAudioPlaybackBuf;
    u8 *playback_buf = p2plocal_buffer+P2P_LOCAL_BUF_SIZE/2;
#if ENABLE_TUTK_RESEND
    int nResend;
#endif
    u32 tmp;
    SMsgAVIoctrlPlayRecordResp buf;
    SMsgAVIoctrlPlayRecordResp *q;
    INT8U os_err;
    bool drop_gop = false;

    memset(&buf, 0, sizeof(buf));
    q = &buf;
    SID = gPlaybackSID;
    CurrPlaybackSID = SID;
//DEBUG_P2P("gPlaybackSID=%d, gClientInfo[SID].playBackCh)=%d\n",SID,gClientInfo[SID].playBackCh);
#if ENABLE_TUTK_RESEND
    nResend = 0;
    gClientInfo[CurrPlaybackSID].avChannel = avServStart3(CurrPlaybackSID, AuthCallBackFn, (TUTK_SESSION_ALIVE_TIMEOUT/2), SERVTYPE_STREAM_SERVER, gClientInfo[SID].playBackCh, &nResend);
    //gClientInfo[CurrPlaybackSID].avChannel = avServStart(CurrPlaybackSID, "admin", gP2PPassword, 40, SERVTYPE_STREAM_SERVER,gClientInfo[CurrPlaybackSID].playBackCh);
#else
    gClientInfo[CurrPlaybackSID].avChannel = avServStart(CurrPlaybackSID, "admin", gP2PPassword, 40, SERVTYPE_STREAM_SERVER,gClientInfo[CurrPlaybackSID].playBackCh);
#endif

    if(gClientInfo[CurrPlaybackSID].avChannel < 0)
    {
        DEBUG_RED("avindex-avServStart failed SID[%d] code[%d]!!!\n", SID,gClientInfo[CurrPlaybackSID].avChannel);
        //IOTC_Session_Close(SID);

		Fileplaying = 0;
        Remote_play = 0;
#if(UI_VERSION == UI_VERSION_MAYON)
		gCurPlaybackSID = -1;
#endif
		OSTaskDel(OS_PRIO_SELF);
		return;
    }
    
#if ENABLE_TUTK_RESEND
    avServSetResendSize(gClientInfo[CurrPlaybackSID].avChannel, TUTK_RESEND_BUF_SIZE);
#endif    
    
    DEBUG_P2P("gClientInfo[CurrPlaybackSID:%d].avChannel=%d\n",CurrPlaybackSID, gClientInfo[CurrPlaybackSID].avChannel);
    Get_p2p_playback = 1;
    tmp = GetVideoDuration((s8 *)dcfPlaybackCurFile->pDirEnt->d_name)/10;
    //InitsysbackLowEvt();
    Get_p2p_playback = 0;
    sysSetEvt(SYS_EVT_SET_P2P_PLAYBACK,0);
    P2P_playback_go = 0;
    P2PVideoPlaybackBufReadIdx = 0;
    P2PVideoPlaybackPresentTime = 0;
    P2PAudioPlaybackBufReadIdx = 0;
    P2PAudioPlaybackPresentTime = 0;

    P2PVideoPlaybackBuf = P2PVideoBufMng;
    P2PAudioPlaybackBuf = P2PiisSounBufMng;

    if(!P2PVideoPlaybackCmpSemEvt)
        P2PVideoPlaybackCmpSemEvt = OSSemCreate(0);
    else
        OSSemSet(P2PVideoPlaybackCmpSemEvt, 0, &os_err);
    
    if(!P2PAudioPlaybackCmpSemEvt)
        P2PAudioPlaybackCmpSemEvt = OSSemCreate(0);
    else
        OSSemSet(P2PAudioPlaybackCmpSemEvt, 0, &os_err);

    gClientInfo[CurrPlaybackSID].VOLSend=0;

    while(P2P_playback_go != 1)
        OSTimeDly(1);
    
    ret = avServResetBuffer(gClientInfo[CurrPlaybackSID].avChannel, RESET_ALL, RESET_RESEND_BUF_TIMEOUT);
    DEBUG_YELLOW("\navServResetBuffer1 video sid[%d] err[%d] avIndex[%d]\n", CurrPlaybackSID, ret, gClientInfo[SID].avChannel);    
#ifdef SAFE_DEL_P2P_PLAYFILE_TASK    
    while(gPlaybackTaskRunning)
#else
    while(1)
#endif    
    {
        if(gClientInfo[CurrPlaybackSID].bStopPlayBack == 1)
        {
            DEBUG_RED("bStopPlayBack\n");
            break;
        }

        if(gClientInfo[CurrPlaybackSID].bPausePlayBack)
        {
            OSTimeDly(1);
            continue;
        }
        
        //------ Streaming video payload------//
        if((audio_value == 0) || (P2PAudioPlaybackPresentTime >= P2PVideoPlaybackPresentTime))
        {
            video_value = OSSemAccept(P2PVideoPlaybackCmpSemEvt);

        //DEBUG_P2P("P2PVideoBufMngWriteIdx = %d,P2PVideoPlaybackBufReadIdx = %d \n",P2PVideoBufMngWriteIdx,P2PVideoPlaybackBufReadIdx);
        if (video_value > 0)
        {
            OSSemAccept(P2PVideoPlaybackCmpSemEvt);
            P2PVideoPlaybackPresentTime = (P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].time); //if use chunk time
        }
        else
            OSTimeDly(2);
        
        if(video_value > 0)
        {
            u32 frame_size = 0;
            
            if(!drop_gop)
            {
                if(GetResendBufUsage(gClientInfo[SID].avChannel, 0) >= RESEND_BUF_MAX_USAGE_RATE)
                {
                    DEBUG_RED("\nresend buffering >= %d%%, drop gop!\n", RESEND_BUF_MAX_USAGE_RATE);
                    drop_gop = true;
                    goto playback_drop_gop;
                }
            
                if(P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag)
                {
                    //step1 : upgrade H264 header
                    UpdateH264Header(6); // n ch1~4.
                    
                    //step2 : add audio stream 
                    if(audio_value > 0)
                    {
                        frame_size = 0x06+0x18+P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size+P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].size*(audio_value);
                        if(frame_size >= 131072)
                            DEBUG_RED("invalid frame size=%d\n", frame_size);                                                                   
                        
                        PlaybackLinkAV_config[0x04]=0x08*(audio_value); 
                        memcpy_hw(playback_buf, PlaybackLinkAV_config, 0x06);
                        memcpy_hw(playback_buf+0x06, P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].buffer, P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].size*(audio_value));
                        //DEBUG_YELLOW("== 111 %d %x %x==\n",audio_value,PlaybackLinkAV_config[0x03],PlaybackLinkAV_config[0x04]); 
                        //step3 : add H264 header
                        memcpy(playback_buf+0x06+P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].size*(audio_value), H264_config, 0x18);
                        
                        
                        //step4 : add video stream
                        memcpy_hw(playback_buf+0x06+P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].size*(audio_value)+0x18, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].buffer, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size);
                        SendVideoFrameData(SID, 
                                           P2PVideoPlaybackPresentTime/1000, 
                                           P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag,
                                           0x06+0x18+P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size+P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].size*(audio_value), 
                                           (char *)playback_buf);
                        
                        

                        //step5 : delete audio evtcnt
                        while(audio_value > 0)
                        {
                            OSSemAccept(P2PAudioPlaybackCmpSemEvt);
                            P2PAudioPlaybackPresentTime += (P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].time);
                            P2PAudioPlaybackBufReadIdx = (P2PAudioPlaybackBufReadIdx + 1) % IIS_BUF_NUM;
                            audio_value = audio_value-1;
                        }
                    }
                    else
                    {
                        //DEBUG_YELLOW("== 333 ==\n");
                        frame_size = 0x18+P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size;
                        if(frame_size >= 131072)
                            DEBUG_RED("invalid frame size=%d\n", frame_size);                        
                        
                        memcpy(playback_buf, H264_config, 0x18);
                        memcpy_hw(playback_buf+0x18, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].buffer, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size);
                        
                        SendVideoFrameData(SID, 
                                           P2PVideoPlaybackPresentTime/1000,
                                           P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag,
                                           0x18+P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size,
                                           (char *)playback_buf);
                    }

                    //Always send the i-frame with VOL header.
                    gClientInfo[SID].VOLSend = 0;
                }
                else
                {
                    if(audio_value > 0)
                    {
                        frame_size = 0x06+P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size+P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].size*(audio_value);
                        if(frame_size >= 131072)
                            DEBUG_RED("invalid frame size=%d\n", frame_size);                        
                        
                        PlaybackLinkAV_config[0x04]=0x08*(audio_value); 
                        memcpy_hw(playback_buf, PlaybackLinkAV_config, 0x06);
                        memcpy_hw(playback_buf+0x06, P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].buffer, P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].size*(audio_value));
                        memcpy_hw(playback_buf+0x06+P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].size*(audio_value), P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].buffer, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size);                        
                        
                        SendVideoFrameData(SID,
                                           P2PVideoPlaybackPresentTime/1000,
                                           P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag, 
                                           0x06+P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size+P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].size*(audio_value), 
                                           (char*)playback_buf);
                        while(audio_value > 0)
                        {
                            OSSemAccept(P2PAudioPlaybackCmpSemEvt);
                            P2PAudioPlaybackPresentTime += (P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].time);
                            P2PAudioPlaybackBufReadIdx = (P2PAudioPlaybackBufReadIdx + 1) % IIS_BUF_NUM;
                            audio_value = audio_value-1;
                            //DEBUG_YELLOW("loss %d, P2P %d\n",audio_value[ch],P2PAudioBufReadIdx[ch]);
                        }
                    }
                    else
                    {
                        frame_size = P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size;
                        SendVideoFrameData(SID, P2PVideoPlaybackPresentTime/1000, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size, (char *)P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].buffer);
                        if(frame_size >= 131072)
                            DEBUG_RED("invalid frame size=%d\n", frame_size);                        
                    }
                }
                
                P2P_check=0;
                //aher test 20140316
                //DEBUG_P2P("TO=%lu,N=%lu\n",tmp,P2PVideoPlaybackPresentTime/1000);
                if(P2PVideoPlaybackPresentTime/1000>=tmp-200)
                {
                    //DEBUG_P2P("Send AVIOCTRL_RECORD_PLAY_END\n");
                    OSTimeDly(40);
                    q->command = AVIOCTRL_RECORD_PLAY_END;
                    ret = avSendIOCtrl2(gClientInfo[SID].avChannel, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp));

                    if(ret== AV_ER_NoERROR)
                    {
                        DEBUG_P2P("AVIOCTRL_RECORD_PLAY_END OK\n");
                    }
                    else
                        DEBUG_P2P("AVIOCTRL_RECORD_PLAY_END FAIL[%d]\n", ret);
                    
#ifdef SAFE_DEL_P2P_PLAYFILE_TASK
                    break;
#else      
                    if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
                        DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
#endif                
                }
            }
            else
            {
                int resend_buf_usage;
playback_drop_gop:                
                //drop gop
                
                resend_buf_usage = GetResendBufUsage(gClientInfo[SID].avChannel, 0);
                if(P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag)
                {
                    
                    frame_size = 0x06+0x18+P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size+P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].size*(audio_value);
                    if(frame_size >= 131072)
                        DEBUG_RED("invalid frame size=%d\n", frame_size);                    
                    
                    //step1 : upgrade H264 header
                    UpdateH264Header(6); // n ch1~4.
                    
                    //step2 : add audio stream 
                    if(audio_value > 0)
                    {
                        PlaybackLinkAV_config[0x04]=0x08*(audio_value); 
                        if(resend_buf_usage < RESEND_BUF_MAX_USAGE_RATE_INT && P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag)
                        {
                            memcpy_hw(playback_buf, PlaybackLinkAV_config, 0x06);
                            memcpy_hw(playback_buf+0x06, P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].buffer, P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].size*(audio_value));
                            //step3 : add H264 header
                            memcpy(playback_buf+0x06+P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].size*(audio_value), H264_config, 0x18);
                            
                            //step4 : add video stream
                            memcpy_hw(playback_buf+0x06+P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].size*(audio_value)+0x18, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].buffer, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size);                            
                            SendVideoFrameData(SID, 
                                               P2PVideoPlaybackPresentTime/1000, 
                                               P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag,
                                               0x06+0x18+P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size+P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].size*(audio_value), 
                                               (char *)playback_buf);
                            drop_gop = false;
                        }

                        //step5 : delete audio evtcnt
                        while(audio_value > 0)
                        {
                            OSSemAccept(P2PAudioPlaybackCmpSemEvt);
                            P2PAudioPlaybackPresentTime += (P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].time);
                            P2PAudioPlaybackBufReadIdx = (P2PAudioPlaybackBufReadIdx + 1) % IIS_BUF_NUM;
                            audio_value = audio_value-1;
                        }
                    }
                    else
                    {
                        frame_size = 0x18+P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size;
                        if(frame_size >= 131072)
                            DEBUG_RED("invalid frame size=%d\n", frame_size);                        
                        
                        if(resend_buf_usage < RESEND_BUF_MAX_USAGE_RATE_INT && P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag)
                        {
                            memcpy(playback_buf, H264_config, 0x18);
                            memcpy_hw(playback_buf+0x18, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].buffer, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size);                            
                            SendVideoFrameData(SID, 
                                               P2PVideoPlaybackPresentTime/1000,
                                               P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag,
                                               0x18+P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size,
                                               (char *)playback_buf);                        
                            drop_gop = false;
                            
                        }
                    }

                    //Always send the i-frame with VOL header.
                    gClientInfo[SID].VOLSend = 0;
                }
                else
                {
                    if(audio_value > 0)
                    {
                        frame_size = 0x06+P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size+P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].size*(audio_value);
                        if(frame_size >= 131072)
                            DEBUG_RED("invalid frame size=%d\n", frame_size);
                        
                        PlaybackLinkAV_config[0x04]=0x08*(audio_value);                         
                        if(resend_buf_usage < RESEND_BUF_MAX_USAGE_RATE_INT && P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag)
                        {
                            memcpy_hw(playback_buf, PlaybackLinkAV_config, 0x06);
                            memcpy_hw(playback_buf+0x06, P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].buffer, P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].size*(audio_value));
                            memcpy_hw(playback_buf+0x06+P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].size*(audio_value), P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].buffer, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size);                                                    
                            SendVideoFrameData(SID,
                                               P2PVideoPlaybackPresentTime/1000,
                                               P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag, 
                                               0x06+P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size+P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].size*(audio_value), 
                                               (char*)playback_buf);
                            drop_gop = false;

                        }
                        
                        while(audio_value > 0)
                        {
                            OSSemAccept(P2PAudioPlaybackCmpSemEvt);
                            P2PAudioPlaybackPresentTime += (P2PAudioPlaybackBuf[P2PAudioPlaybackBufReadIdx].time);
                            P2PAudioPlaybackBufReadIdx = (P2PAudioPlaybackBufReadIdx + 1) % IIS_BUF_NUM;
                            audio_value = audio_value-1;
                            //DEBUG_YELLOW("loss %d, P2P %d\n",audio_value[ch],P2PAudioBufReadIdx[ch]);
                        }
                    }
                    else
                    {
                        frame_size = P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size;
                        if(frame_size >= 131072)
                            DEBUG_RED("invalid frame size=%d\n", frame_size);                        
                        if(resend_buf_usage < RESEND_BUF_MAX_USAGE_RATE_INT && P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag)
                        {
                            SendVideoFrameData(SID, P2PVideoPlaybackPresentTime/1000, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size, (char *)P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].buffer);
                            drop_gop = false;
                            
                        }
                    }
                }
                
                P2P_check=0;
                //aher test 20140316
                //DEBUG_P2P("TO=%lu,N=%lu\n",tmp,P2PVideoPlaybackPresentTime/1000);
                if(P2PVideoPlaybackPresentTime/1000>=tmp-200)
                {
                    //DEBUG_P2P("Send AVIOCTRL_RECORD_PLAY_END\n");
                    OSTimeDly(40);
                    q->command = AVIOCTRL_RECORD_PLAY_END;
                    ret = avSendIOCtrl4(gClientInfo[SID].avChannel, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp));

                    if(ret== AV_ER_NoERROR)
                    {
                        DEBUG_P2P("AVIOCTRL_RECORD_PLAY_END OK\n");
                    }
                    else
                        DEBUG_P2P("AVIOCTRL_RECORD_PLAY_END FAIL[%d]\n", ret);
                    
#ifdef SAFE_DEL_P2P_PLAYFILE_TASK
                    break;
#else      
                    if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
                        DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
#endif                
                }
            }
        }

        if (video_value > 0)
        {
            P2PVideoPlaybackBufReadIdx = (P2PVideoPlaybackBufReadIdx + 1) % (VIDEO_BUF_NUM-10);
        }
        	}
    }
#ifdef SAFE_DEL_P2P_PLAYFILE_TASK    
playback_task_end:
    ret = avServResetBuffer(gClientInfo[CurrPlaybackSID].avChannel, RESET_ALL, RESET_RESEND_BUF_TIMEOUT);
    DEBUG_GREEN("graceful exit playback task\n");
    OSTaskDel(OS_PRIO_SELF);
#endif    
}
#else
void Task_remote_file_playback(void *pdata)
{

	//int rec_avindex;
	int ret;
	int SID;
	u16 video_value =0;
	u16 video_value_max =0;
	u16 audio_value = 0;
	//u16 audio_value_max = 0;
	u8  err;
	u32 P2PVideoPlaybackBufReadIdx;
    u32 P2PVideoPlaybackPresentTime;
	//u32 P2PAudioPlaybackBufReadIdx;
	u32 P2PAudioPlaybackPresentTime;
	//u32 P2PChannelPlaybackStart;

	VIDEO_BUF_MNG *P2PVideoPlaybackBuf;
	//IIS_BUF_MNG   *P2PAudioPlaybackBuf;
	//int nResend;
    u32 tmp;
    u8 p2p_totaltime = 0;

    SMsgAVIoctrlPlayRecordResp buf;
    SMsgAVIoctrlPlayRecordResp *q;

	DEBUG_P2P("Create Task_remote_file_playback.\n");
    q=&buf;
	SID=gPlaybackSID;
    CurrPlaybackSID=SID;
//printf("gPlaybackSID=%d, gClientInfo[SID].playBackCh)=%d\n",SID,gClientInfo[SID].playBackCh);
	gClientInfo[CurrPlaybackSID].avChannel=avServStart(CurrPlaybackSID, "admin", gP2PPassword, 1, SERVTYPE_STREAM_SERVER,gClientInfo[CurrPlaybackSID].playBackCh);

	//gClientInfo[gPlaybackSID].avChannel = avServStart3(SID, AuthCallBackFn,10, SERVTYPE_STREAM_SERVER, gClientInfo[SID].playBackCh, &nResend);
	//avServSetResendSize(gClientInfo[gPlaybackSID].avChannel,64);
	if(gClientInfo[CurrPlaybackSID].avChannel < 0)
	{
		DEBUG_P2P("avindex-avServStart failed SID[%d] code[%d]!!!\n", SID,gClientInfo[CurrPlaybackSID].avChannel);
		//IOTC_Session_Close(SID);
		Fileplaying=0;
        Remote_play=0;
		OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY);
		#if(HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) //Sean: 20170608 add.
		goto end;
		#endif
	}
	DEBUG_P2P("gClientInfo[CurrPlaybackSID:%d].avChannel=%d\n",CurrPlaybackSID,gClientInfo[CurrPlaybackSID].avChannel);
    Get_p2p_playback = 1;
	tmp=GetVideoDuration(dcfPlaybackCurFile->pDirEnt->d_name)/10;
    //InitsysbackLowEvt();
    Get_p2p_playback = 0;
	sysSetEvt(SYS_EVT_SET_P2P_PLAYBACK,0);
	P2PVideoPlaybackBufReadIdx = 0;
    P2PVideoPlaybackPresentTime = 0;
	//P2PAudioPlaybackBufReadIdx = 0;
	P2PAudioPlaybackPresentTime = 0;
	//P2PChannelPlaybackStart = 1;

	P2PVideoPlaybackBuf = P2PVideoBufMng;
	//P2PAudioPlaybackBuf= P2PiisSounBufMng;

	P2PVideoPlaybackCmpSemEvt   = OSSemCreate(0);
	if(P2PVideoPlaybackCmpSemEvt == 0)
		printf("Create P2PVideoPlaybackCmpSemEvt fail.\n");
	else
	{
		printf("Create P2PVideoPlaybackCmpSemEvt ok.\n");
		OSSemSet(P2PVideoPlaybackCmpSemEvt, 0, &err);
		if(err!= OS_NO_ERR)
			printf("Set P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
	}
    P2PAudioPlaybackCmpSemEvt   = OSSemCreate(0);
	if(P2PAudioPlaybackCmpSemEvt == 0)
		printf("Create P2PAudioPlaybackCmpSemEvt fail.\n");
	else
	{
		printf("Create P2PAudioPlaybackCmpSemEvt ok.\n");
		OSSemSet(P2PAudioPlaybackCmpSemEvt, 0, &err);
		if(err!= OS_NO_ERR)
			printf("Set P2PAudioPlaybackCmpSemEvt fail = %d\n",err);

	}

	gClientInfo[CurrPlaybackSID].VOLSend=0;
	//P2PEnableplaybackStreaming  += 1;
	#if(HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) //Sean: 20170608 add.
    play_back_start = 1;
    #endif

	while(P2P_playback_go != 1)
		OSTimeDly(1);
	while(1)
	{
#if (UI_VERSION == UI_VERSION_MAYON) //Fixed task delete fail issue, Paul, 2019/04/10
        if(gClientInfo[CurrPlaybackSID].bStopPlayBack)
        {
            DEBUG_P2P("bStopPlayBack\n");
            if(gClientInfo[CurrPlaybackSID].bStopPlayBack == 1)
            {
                gClientInfo[CurrPlaybackSID].bStopPlayBack=2;
                avServExit(CurrPlaybackSID, gClientInfo[CurrPlaybackSID].avChannel);
                OSSemPost(P2PVideoPlaybackStopSemEvt);
            }

            OSTimeDly(1);
            continue;
#else
		if(gClientInfo[CurrPlaybackSID].bStopPlayBack == 1)
		{
			DEBUG_P2P("bStopPlayBack\n");
			break;
		}
#endif
        }
		if(gClientInfo[CurrPlaybackSID].bPausePlayBack)
		{
			OSTimeDly(1);
			continue;
		}
        
		//------ Streaming video payload------//
            if((audio_value == 0) || (P2PAudioPlaybackPresentTime >= P2PVideoPlaybackPresentTime))
    		{
    		    video_value = OSSemAccept(P2PVideoPlaybackCmpSemEvt);

				//printf("video_value=%d\n",video_value);
                if (video_value > 0)
                {
        		    if(video_value_max < video_value)
                        video_value_max = video_value;
                    if(( p2p_30PS == 1) &&( p2p_totaltime == 0))
                    {
                        p2p_totaltime = 1;
                        tmp=tmp*2;
                    }
                    P2PVideoPlaybackPresentTime = (P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].time); //if use chunk time
                }
				else
					OSTimeDly(2);

                if(video_value> 0)
                {
                   if(gClientInfo[SID].VOLSend==0 && P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag)
                   {
                    //UpdateHeader(ch,gRfiuUnitCntl[ch].TX_Status & RFIU_TX_STA_MPEG_Q);
					   UpdateHeader(6,USE_MPEG_QUANTIZATION);
                       memcpy(p2plocal_buffer, MPEG4_config, 0x1d);
                       memcpy_hw(p2plocal_buffer+0x1d, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].buffer, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size);
                       SendVideoFrameData(SID, P2PVideoPlaybackPresentTime/1000, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag, 0x1d+P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size, p2plocal_buffer);
						//SendVideoFrameData(SID, P2PVideoPresentTime[0], P2PVideoBuf[0][P2PVideoBufReadIdx[0]].flag, 0x1d+P2PVideoBuf[0][P2PVideoBufReadIdx[0]].size, p2plocal_buffer);

						//Always send the i-frame with VOL header.
                        gClientInfo[SID].VOLSend = 0;
                    }
                    else if(gClientInfo[SID].VOLSend==1)
                    {
                        SendVideoFrameData(SID, P2PVideoPlaybackPresentTime/1000, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].buffer);
                    }
                    P2P_check=0;
                    //aher test 20140316
//printf("TO=%lu,N=%lu\n",tmp,P2PVideoPlaybackPresentTime/1000);
                    if(P2PVideoPlaybackPresentTime/1000>=tmp-200)
                    {
//printf("Send AVIOCTRL_RECORD_PLAY_END\n");
                        OSTimeDly(40);
                        q->command=AVIOCTRL_RECORD_PLAY_END;
                        ret=avSendIOCtrl2(gClientInfo[SID].avChannel, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp));

                        //if(avSendIOCtrl2(gClientInfo[gPlaybackSID].avChannel, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp)) == AV_ER_NoERROR)
                        if(ret== AV_ER_NoERROR)
					    {
						    DEBUG_P2P("AVIOCTRL_RECORD_PLAY_END OK\n");
					    }
                        else
                            DEBUG_P2P("AVIOCTRL_RECORD_PLAY_END FAIL\n");
                        //if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
                        //        DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
                        OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY);
                    }
                }

                if (video_value > 0)
                {
                    P2PVideoPlaybackBufReadIdx = (P2PVideoPlaybackBufReadIdx + 1) % (VIDEO_BUF_NUM-10);
                }
            }

	}
	OSTimeDly(2);
	#if(HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) //Sean: 20170608 add.
    end:
    #endif
}
#endif
/*
Return the recorded file list to APP or Search the matched file to play.
*/
int get_recorded_filelist(SMsgAVIoctrlListEventReq *p,int SID,int avIndex)
{
    unsigned int ioType;
    char IOCtrlBuf[MAX_BUF_SIZE];
    char *buf;
    int ret;

    int i=0;
    int get_play_file=0;

    SMsgAVIoctrlListEventResp*q=(SMsgAVIoctrlListEventResp*)p2pEventList;
#if (HW_BOARD_OPTION != A1018_FPGA_BOARD)
    /*Initalize SMsgAVIoctrlListEventResp*/

    u32	waitFlag;
    u8	err;

//Paul: 20180821 add func define for RDI use.
    #if((UI_VERSION == UI_VERSION_TRANWO) || (UNIC_PLAYBACK_LIST_SUPPORT == 1))
    if(gSearchFileListFlag != 0)
	{
		DEBUG_P2P("File List is Using... return.\n");
		return 0;
	}
	else
		gSearchFileListFlag = 1; // APP use.
	#endif

    q->total=0;
    q->index=0;
    q->endflag=0;
    q->count=0;
    if(sysGetStorageStatus(SYS_I_STORAGE_MAIN) == SYS_V_STORAGE_READY)
    {
        if(gbSearchEvent == 0)
        {
            UCT_to_Local_convert(p);

            search_dir_start.YMD=(((p->stStartTime.year-1980)& 0x7F) <<9) |((p->stStartTime.month & 0xF)<< 5) |((p->stStartTime.day) & 0x1F);
            search_dir_start.HMS=((p->stStartTime.hour& 0x1F )<<11) |((p->stStartTime.minute& 0x3F)<< 5) |((p->stStartTime.second/2) & 0x1F);
            search_dir_end.YMD=(((p->stEndTime.year-1980)& 0x7F) <<9) |((p->stEndTime.month & 0xF)<< 5) |((p->stEndTime.day) & 0x1F);
            search_dir_end.HMS=((p->stEndTime.hour& 0x1F )<<11) |((p->stEndTime.minute& 0x3F)<< 5) |((p->stEndTime.second/2) & 0x1F);
            DEBUG_P2P("Search recording file for camera:%d\n",p->channel);
            DEBUG_P2P("START DIR = %02d/%02d/%02d %02d:%02d:%02d\n",(search_dir_start.YMD >> 9)+1980,
                      (search_dir_start.YMD & 0x01E0)>>5,
                      (search_dir_start.YMD & 0x001F),
                      (search_dir_start.HMS>>11),
                      (search_dir_start.HMS & 0x07E0)>>5,
                      (search_dir_start.HMS& 0x001F)<<1);
            DEBUG_P2P("END DIR = %02d/%02d/%02d %02d:%02d:%02d\n",(search_dir_end.YMD >> 9)+1980,
                      (search_dir_end.YMD & 0x01E0)>>5,
                      (search_dir_end.YMD & 0x001F),
                      (search_dir_end.HMS>>11),
                      (search_dir_end.HMS & 0x07E0)>>5,
                      (search_dir_end.HMS& 0x001F)<<1);
        }
        else
        {
            UCT_to_Local_convert_playfile(&gRemote_playfile);
            search_dir_start.YMD=(((gRemote_playfile.stTimeDay.year-1980)& 0x7F) <<9) |((gRemote_playfile.stTimeDay.month & 0xF)<< 5) |((gRemote_playfile.stTimeDay.day) & 0x1F);
            search_dir_start.HMS=((gRemote_playfile.stTimeDay.hour& 0x1F )<<11) |((gRemote_playfile.stTimeDay.minute& 0x3F)<< 5) |((gRemote_playfile.stTimeDay.second/2) & 0x1F);
            search_dir_end.YMD=(((gRemote_playfile.stTimeDay.year-1980)& 0x7F) <<9) |((gRemote_playfile.stTimeDay.month & 0xF)<< 5) |((gRemote_playfile.stTimeDay.day) & 0x1F);
            search_dir_end.HMS=((gRemote_playfile.stTimeDay.hour& 0x1F )<<11) |((gRemote_playfile.stTimeDay.minute& 0x3F)<< 5) |((gRemote_playfile.stTimeDay.second/2) & 0x1F);
            DEBUG_P2P("Search FILE=%02d/%02d/%02d %02d:%02d:%02d,CH=%d\n\n",(search_dir_start.YMD >> 9)+1980,
                      (search_dir_start.YMD & 0x01E0)>>5,
                      (search_dir_start.YMD & 0x001F),
                      (search_dir_start.HMS>>11),
                      (search_dir_start.HMS & 0x07E0)>>5,
                      (search_dir_start.HMS & 0x001F)<<1,
                      Remoteplayback_CH);
        }
        dcfPlaybackCurDir = dcfGetVideoDirListHead();
        do//Folder search
        {
            if(((dcfPlaybackCurDir->pDirEnt->fsFileCreateDate_YMD>=search_dir_start.YMD)&&(dcfPlaybackCurDir->pDirEnt->fsFileCreateDate_YMD<=search_dir_end.YMD))
                    &&(get_play_file==0))
            {
                if(dcfScanFileOnPlaybackDir()==0)
                {
                    DEBUG_P2P("Enter folder fail!\n");
                    dcfPlaybackCurDir=dcfPlaybackCurDir->next;
                }
                else
                {
                    dcfPlaybackCurFile=dcfGetPlaybackFileListHead();
                    do //Check the file time.
                    {
                        if(((((search_dir_start.YMD==search_dir_end.YMD)&&(search_dir_start.YMD==dcfPlaybackCurDir->pDirEnt->fsFileCreateDate_YMD))&&((search_dir_start.HMS<=dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS)&&(search_dir_end.HMS>=dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS)))
                                ||(((dcfPlaybackCurDir->pDirEnt->fsFileCreateDate_YMD==search_dir_start.YMD)&&(dcfPlaybackCurDir->pDirEnt->fsFileCreateDate_YMD<search_dir_end.YMD))&&(search_dir_start.HMS<=dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS))
                                ||(((dcfPlaybackCurDir->pDirEnt->fsFileCreateDate_YMD>search_dir_start.YMD)&&(dcfPlaybackCurDir->pDirEnt->fsFileCreateDate_YMD==search_dir_end.YMD))&&(search_dir_end.HMS>=dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS))
                                ||((dcfPlaybackCurDir->pDirEnt->fsFileCreateDate_YMD>search_dir_start.YMD)&&(dcfPlaybackCurDir->pDirEnt->fsFileCreateDate_YMD<search_dir_end.YMD))))
                        {

                            //DEBUG_P2P("current FILE : %s\n,IDX= %d,p->channel=%d\n",dcfPlaybackCurFile->pDirEnt->d_name,atoi(&(dcfPlaybackCurFile->pDirEnt->d_name[7])),p->channel);
                            //if((gbSearchEvent == 0)&&)
                            if((gbSearchEvent == 0))
                            {
                                if(((p->channel==(atoi(&(dcfPlaybackCurFile->pDirEnt->d_name[7]))-1))||(p->channel==255))&&(q->total<160))/*Only send 160 event once.*/
                                {
                                    //DEBUG_P2P("Match FILE : %s,Total=%d\n",dcfPlaybackCurFile->pDirEnt->d_name,q->total);
                                    q->channel=atoi(&(dcfPlaybackCurFile->pDirEnt->d_name[7]));
                                    //DEBUG_P2P("CH IDX=%d\n",q->channel);
                                    q->stEvent[q->count].CameraCH=q->channel;
                                    q->stEvent[q->count].stTime.year = (dcfPlaybackCurFile->pDirEnt->fsFileCreateDate_YMD >> 9)+1980;
                                    q->stEvent[q->count].stTime.month =(dcfPlaybackCurFile->pDirEnt->fsFileCreateDate_YMD & 0x01E0)>>5;
                                    q->stEvent[q->count].stTime.day = (dcfPlaybackCurFile->pDirEnt->fsFileCreateDate_YMD & 0x001F);
                                    //q->stEvent[nCnt].stTime.wday = 5;
                                    q->stEvent[q->count].stTime.hour = (dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS>>11);
                                    q->stEvent[q->count].stTime.minute =(dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS & 0x07E0)>>5;
                                    q->stEvent[q->count].stTime.second = (dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS & 0x001F)<<1;
                                    q->stEvent[q->count].event = AVIOCTRL_EVENT_ALL;
                                    //q->stEvent[nCnt].status = 0;

                                    Local_to_UCT_convert(&(q->stEvent[q->count].stTime));
                                    q->total++;
                                    q->count++;
                                }
                                if(q->count>=80)
                                {
                                    /*
                                    buf=IOCtrlBuf;
                                    ret = avRecvIOCtrl(avIndex, &ioType, (char *)buf, MAX_BUF_SIZE, 0);
                                    if(ioType==IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL)
                                    {
                                    	SMsgAVIoctrlPlayRecord *pp = (SMsgAVIoctrlPlayRecord *)buf;
                                    	SMsgAVIoctrlPlayRecordResp *qq=(SMsgAVIoctrlPlayRecordResp *)buf;
                                    if(pp->command==AVIOCTRL_RECORD_PLAY_START)
                                    {
                                    	DEBUG_P2P("IPCAM_RECORD_PLAYCONTROL-%d\n",pp->command);
                                    	//switch (pp->command)
                                    	//{
                                    		//case AVIOCTRL_RECORD_PLAY_START :
                                    		//{
                                    			DEBUG_P2P("AVIOCTRL_RECORD_PLAY_START\n");
                                    			gbSearchEvent=1;
                                    			regedit_client_to_video(SID);
                                    			gClientInfo[SID].bPausePlayBack = 0;
                                    			gClientInfo[SID].bStopPlayBack = 0;
                                    			gClientInfo[SID].playBackCh = IOTC_Session_Get_Free_Channel(SID);
                                    			qq->command=pp->command;
                                    			qq->result=gClientInfo[SID].playBackCh;
                                    			gPlaybackSID=SID;
                                    			gRemote_playfile=*pp;
                                    			get_recorded_filelist((SMsgAVIoctrlListEventReq *)pp,SID,avIndex);
                                    			DEBUG_P2P("PLAY FILE: %d/%d/%d %d:%d:%d\n",gRemote_playfile.stTimeDay.year,gRemote_playfile.stTimeDay.month,gRemote_playfile.stTimeDay.day,gRemote_playfile.stTimeDay.hour,gRemote_playfile.stTimeDay.minute,gRemote_playfile.stTimeDay.second);
                                    	Remoteplayback_CH=pp->channel;
                                    			if(avSendIOCtrl2(avIndex, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)qq, sizeof(SMsgAVIoctrlPlayRecordResp)) == AV_ER_NoERROR)
                                    			{
                                    				DEBUG_P2P("IPCAM_RECORD_PLAYCONTROL_RESP OK \n\n");
                                    			}
                                    			P2PEnableplaybackStreaming++;
                                    DEBUG_P2P("P2PEnableplaybackStreaming222=%d\n",P2PEnableplaybackStreaming);

                                    			P2PPlaybackVideoStop=0;
                                                #if 1
                                                    DEBUG_P2P("Fileplaying= %d,Remote_play= %d  \n",Fileplaying,Remote_play);
                                                if(Fileplaying)
                                                    Remoteplayback_busy();
                                                else
                                                {
                                                    Fileplaying=1;
                                                    Remote_play=1;
#if(UI_VERSION == UI_VERSION_MAYON)
                                                    gCurPlaybackSID = -1;
#endif
                                                    OSTaskCreate(Task_remote_file_playback, (void *)0,P2P_PLAYFILE_TASK_STACK, P2P_PLAYFILE_TASK_PRIORITY);
                                                }
                                                #else
                                                    OSTaskCreate(Task_remote_file_playback, (void *)0,P2P_PLAYFILE_TASK_STACK, P2P_PLAYFILE_TASK_PRIORITY);
                                                #endif
                                    		//}
                                    		//break;
                                    	//}
                                    	q->endflag=1;
                                    	if(avSendIOCtrl2(avIndex, IOTYPE_USER_IPCAM_LISTEVENT_RESP, (char *)q, sizeof(SMsgAVIoctrlListEventResp)+(sizeof(SAvEvent)*q->count)) == AV_ER_NoERROR)
                                    	{
                                    		DEBUG_P2P("Stop sending the file list.\n");
                                    			return 0;
                                    	}
                                    }
                                    }
                                    */
                                    if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_LISTEVENT_RESP, (char *)q, sizeof(SMsgAVIoctrlListEventResp)+(sizeof(SAvEvent)*q->count)) == AV_ER_NoERROR)
                                    {
                                        /*
                                        if(q->endflag)
                                        {
                                        	DEBUG_P2P("Stop sending the file list.\n");
                                        	return 0;
                                        }
                                        else
                                        */
                                        DEBUG_P2P("Send file list-%d\n",q->index);
                                    }
                                    q->index++;
                                    q->count=0;
                                }
                            }
                            else
                            {
                                //DEBUG_P2P("Checking FILE: %s\n",dcfPlaybackCurFile->pDirEnt->d_name);
                                if(Remoteplayback_CH==atoi(&(dcfPlaybackCurFile->pDirEnt->d_name[7])))
                                    if(((dcfPlaybackCurFile->pDirEnt->fsFileCreateDate_YMD >> 9)+1980)==gRemote_playfile.stTimeDay.year)
                                        if(((dcfPlaybackCurFile->pDirEnt->fsFileCreateDate_YMD & 0x01E0)>>5)==gRemote_playfile.stTimeDay.month)
                                            if(((dcfPlaybackCurFile->pDirEnt->fsFileCreateDate_YMD & 0x001F))==gRemote_playfile.stTimeDay.day)
                                                if(((dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS>>11))==gRemote_playfile.stTimeDay.hour)
                                                    if(((dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS & 0x07E0)>>5)==gRemote_playfile.stTimeDay.minute)
                                                        if(((dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS & 0x001F)<<1)==gRemote_playfile.stTimeDay.second)
                                                        {
                                                            DEBUG_P2P("CURRENT FILE: %s\n",dcfPlaybackCurFile->pDirEnt->d_name);
                                                            get_play_file=1;

															if(gSearchFileListFlag != 2)
                                                            	gSearchFileListFlag = 0;
                                                            return 0;
                                                        }
                            }
                        }

                        if(get_play_file==0)
                        {
                            dcfPlaybackCurFile=dcfPlaybackCurFile->next;
                        }
                    }
                    while((dcfPlaybackCurFile!=dcfGetPlaybackFileListHead())&&(get_play_file==0));
                    dcfPlaybackCurDir=dcfPlaybackCurDir->next;
                }
            }
            else
            {
                dcfPlaybackCurDir=dcfPlaybackCurDir->next;
            }
        }
        while((dcfPlaybackCurDir!=dcfGetVideoDirListHead())&&(get_play_file==0));
        q->endflag=1;
        if(gbSearchEvent==0)
        {
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_LISTEVENT_RESP, (char *)q, sizeof(SMsgAVIoctrlListEventResp)+(sizeof(SAvEvent)*q->count)) == AV_ER_NoERROR)
            {
                DEBUG_P2P("Match Event Numer : %d\n",q->total);
                DEBUG_P2P("Send file list-END\n");
                gbSearchEvent=1;
            }
            q->total=0;
            q->index=0;
            q->endflag=0;
            q->count=0;
            //
            //^Event listAPP,SMsgAVIoctrlListEventRespP^Eventsmemory address.
            //HbMemoryPoolip2pEventList,size1024 byteSMsgAVIoctrlListEventResp+80SAvEvent.
            gbSearchEvent=1;
        }
    }
    else
    {
        DEBUG_P2P("No SD Card.\n");
        q->endflag=1;
        if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_LISTEVENT_RESP, (char *)q, sizeof(SMsgAVIoctrlListEventResp)+(sizeof(SAvEvent)*q->count)) == AV_ER_NoERROR)
        {
            DEBUG_P2P("Match Event Numer : %d\n",q->total);
            DEBUG_P2P("Send file list-END\n");
            gbSearchEvent=1;
        }
    }
    if(gSearchFileListFlag != 2)
		gSearchFileListFlag = 0;
#endif
}


/*Convert UCT time to local time. When receive a ioctl command : IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL.*/
static void UCT_to_Local_convert_playfile(SMsgAVIoctrlPlayRecord *p)
{
    RTC_DATE_TIME convert_time;
    u32	convert_second;
    RTC_TIME_ZONE zone;

    convert_time.year=p->stTimeDay.year-2000;
    convert_time.month=p->stTimeDay.month;
    convert_time.day=p->stTimeDay.day;
    convert_time.hour=p->stTimeDay.hour;
    convert_time.min=p->stTimeDay.minute;
    convert_time.sec=p->stTimeDay.second;
    convert_second=RTC_Time_To_Second(&convert_time);

    if(RTC_Get_DST()==1)	//Is DST duration?	 return 1 means 1hour, 2 means 2hours.
    {
        convert_second=convert_second+3600;
    }
    else if(RTC_Get_DST()==2)
    {
        convert_second=convert_second+7200;
    }

    RTC_Get_TimeZone(&zone);
    if(!zone.operator)
        convert_second=convert_second+zone.hour*60*60+zone.min*60;
    else
        convert_second=convert_second-zone.hour*60*60-zone.min*60;
    RTC_Second_To_Time(convert_second, &convert_time);
    //DEBUG_P2P("CONVERT-2 %d-%d-%d  %d:%d:%d\n",convert_time.year,convert_time.month,convert_time.day,convert_time.hour,convert_time.min,convert_time.sec);
    p->stTimeDay.year=convert_time.year+2000;
    p->stTimeDay.month=convert_time.month;
    p->stTimeDay.day=convert_time.day;
    p->stTimeDay.hour=convert_time.hour;
    p->stTimeDay.minute=convert_time.min;
    p->stTimeDay.second=convert_time.sec;

}


/*Convert UCT time to local time. When receive a ioctl command : IOTYPE_USER_IPCAM_LISTEVENT_REQ.*/
static void UCT_to_Local_convert(SMsgAVIoctrlListEventReq *p)
{
    RTC_DATE_TIME convert_time;
    u32	convert_second;
    RTC_TIME_ZONE zone;

    /*search start time */
    convert_time.year=p->stStartTime.year-2000;
    convert_time.month=p->stStartTime.month;
    convert_time.day=p->stStartTime.day;
    convert_time.hour=p->stStartTime.hour;
    convert_time.min=p->stStartTime.minute;
    convert_time.sec=p->stStartTime.second;
    convert_second=RTC_Time_To_Second(&convert_time);

    if(RTC_Get_DST()==1)	//Is DST duration?	 return 1 means 1hour, 2 means 2hours.
    {
        convert_second=convert_second+3600;
    }
    else if(RTC_Get_DST()==2)
    {
        convert_second=convert_second+7200;
    }

    RTC_Get_TimeZone(&zone);
    if(!zone.operator)
        convert_second=convert_second+zone.hour*60*60+zone.min*60;
    else
        convert_second=convert_second-zone.hour*60*60-zone.min*60;
    RTC_Second_To_Time(convert_second, &convert_time);
    //DEBUG_P2P("CONVERT-2 %d-%d-%d  %d:%d:%d\n",convert_time.year,convert_time.month,convert_time.day,convert_time.hour,convert_time.min,convert_time.sec);
    p->stStartTime.year=convert_time.year+2000;
    p->stStartTime.month=convert_time.month;
    p->stStartTime.day=convert_time.day;
    p->stStartTime.hour=convert_time.hour;
    p->stStartTime.minute=convert_time.min;
    p->stStartTime.second=convert_time.sec;

    /*search end time */
    convert_time.year=p->stEndTime.year-2000;
    convert_time.month=p->stEndTime.month;
    convert_time.day=p->stEndTime.day;
    convert_time.hour=p->stEndTime.hour;
    convert_time.min=p->stEndTime.minute;
    convert_time.sec=p->stEndTime.second;
    convert_second=RTC_Time_To_Second(&convert_time);

    if(RTC_Get_DST()==1)	//Is DST duration?	 return 1 means 1hour, 2 means 2hours.
    {
        convert_second=convert_second+3600;
    }
    else if(RTC_Get_DST()==2)
    {
        convert_second=convert_second+7200;
    }

    RTC_Get_TimeZone(&zone);
    if(!zone.operator)
        convert_second=convert_second+zone.hour*60*60+zone.min*60;
    else
        convert_second=convert_second-zone.hour*60*60-zone.min*60;
    RTC_Second_To_Time(convert_second, &convert_time);
    p->stEndTime.year=convert_time.year+2000;
    p->stEndTime.month=convert_time.month;
    p->stEndTime.day=convert_time.day;
    p->stEndTime.hour=convert_time.hour;
    p->stEndTime.minute=convert_time.min;
    p->stEndTime.second=convert_time.sec;

}

/*Convert UCT time to local time. For response : IOTYPE_USER_IPCAM_LISTEVENT_RESP.*/
static void Local_to_UCT_convert(STimeDay *q)
{
    RTC_DATE_TIME convert_time;
    u32	convert_second;
    RTC_TIME_ZONE zone;

    convert_time.year=q->year-2000;
    convert_time.month=q->month;
    convert_time.day=q->day;
    convert_time.hour=q->hour;
    convert_time.min=q->minute;
    convert_time.sec=q->second;
    convert_second=RTC_Time_To_Second(&convert_time);

    if(RTC_Get_DST()==1)	//Is DST duration?	 return 1 means 1hour, 2 means 2hours.
    {
        convert_second=convert_second-3600;
    }
    else if(RTC_Get_DST()==2)
    {
        convert_second=convert_second-7200;
    }

    RTC_Get_TimeZone(&zone);
    if(!zone.operator)
        convert_second=convert_second-zone.hour*60*60+zone.min*60;
    else
        convert_second=convert_second+zone.hour*60*60-zone.min*60;
    RTC_Second_To_Time(convert_second, &convert_time);
    //DEBUG_P2P("CONVERT-2 %d-%d-%d  %d:%d:%d\n",convert_time.year,convert_time.month,convert_time.day,convert_time.hour,convert_time.min,convert_time.sec);
    q->year=convert_time.year+2000;
    q->month=convert_time.month;
    q->day=convert_time.day;
    q->hour=convert_time.hour;
    q->minute=convert_time.min;
    q->second=convert_time.sec;

}
void client_p2pconnected(int SID)
{
    int i;
    gClientInfo[SID].bP2PConnected = 1;
    gClientInfo[SID].bShowInfo = 1;
    gClientInfo[SID].VOLSend= 0;
    for(i=0; i<MAX_AV_CH; i++)
        gClientInfo[SID].avIndex[i]=-1;
    gOnlineNum++;
}

void client_p2pdisconnected(int SID)
{
    DEBUG_P2P("P2P Client was disconnected[%d].\n", SID);
    gClientInfo[SID].bP2PConnected = 0;
    //aher 20130801
    gClientInfo[SID].getsupportstream=0;
#if(UI_VERSION == UI_VERSION_MAYON)
	if(CurrPlaybackSID == SID)
	{
		CurrPlaybackSID = -1;
		Remote_play = 0;
		Fileplaying = 0;
	}
#endif
    --gOnlineNum;
    DEBUG_P2P("unregedit_client_from_avsession(%d)\n",SID);
    unregedit_client_from_avsession(SID);
    unregedit_client_from_speaker(SID);
    DEBUG_P2P("IOTC_Session_Close(%d)\n",SID);
    IOTC_Session_Close(SID);
}

extern u8 uiCaptureVideo(void);

void Init_P2P_Session(void)
{
    int i;

    for(i=0; i<MAX_AV_CH; i++)
    {
        P2PVideoCmpSemEvt[i]   = OSSemCreate(0);
        P2PAudioCmpSemEvt[i]   = OSSemCreate(0);
    }
}


void Start_P2P_Session(int ch, int source)
{

    /**************************************
    **** Streaming Audio/Video Payload ****
    **************************************/
    unsigned int    cpu_sr = 0;
    INT8U           err;
    u8              level;
    u8              LocalChannel;
    int             i;
    u8              isBatteryCam = 0;

    ch = ch % MAX_AV_CH;

    DEBUG_P2P("P2PEnableStreaming[%d]: %d\n",ch,(P2PEnableStreaming[ch]));

    P2P_AV_Source[ch]   = source;
    #if  RFIU_RX_WAKEUP_TX_SCHEME
    isBatteryCam = (gRfiuUnitCntl[ch].RFpara.BateryCam_support);
    #endif
    if(P2PEnableStreaming[ch] == 0)
    {
        DEBUG_P2P("CH %d, start streaming Audio/Video Payload\n",ch);
        if(source == Local_record)
        {
#if 0
            //uiCaptureVideo();
            uiKeyVideoCapture();
#else
            DEBUG_P2P("Set 720P frame rate 5 fps\n");
            MultiChannelMpeg4SetVideoFrameRate(MPEG4_VIDEO_FRAMERATE_10, &VideoClipOption[2]);
            if(ch == 0)
            {
                switch(videoquality)
                {
                    case 1: // HD
                        LocalChannelSource                  = 2;
                        VideoClipParameter[2].asfVopWidth   = 1280;
                        VideoClipParameter[2].asfVopHeight  = 720;
                        break;
                    case 2: // VGA
                        LocalChannelSource                  = 1;
                        VideoClipParameter[1].asfVopWidth   = 640;
                        VideoClipParameter[1].asfVopHeight  = 480;
                        break;
                    case 3: // QVGA
                    case 4:
                    case 5:
                        LocalChannelSource                  = 1;
                        VideoClipParameter[1].asfVopWidth   = 320;
                        VideoClipParameter[1].asfVopHeight  = 240;
                        break;
                }
                LocalChannel    = LocalChannelSource;
            }
            else
            {
                LocalChannel                                    = ch + 1;
                VideoClipParameter[LocalChannel].asfVopWidth    = 1280;
                VideoClipParameter[LocalChannel].asfVopHeight   = 720;
            }
#if 0
            if(OSFlagAccept(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_CARD1_RDY, OS_FLAG_WAIT_SET_ALL, &err))   // SD card ready
            {
                DEBUG_P2P("SD card ready\n");
                VideoClipParameter[ch + 1].sysCaptureVideoMode  = sysCaptureVideoMode;
            }
            else    // SD card not ready
            {
                DEBUG_P2P("SD card not ready\n");
                VideoClipParameter[ch + 1].sysCaptureVideoMode  = sysCaptureVideoMode | ASF_CAPTURE_EVENT_DUMMY_ENA;
            }
#else
            if (sysGetStorageStatus(SYS_I_STORAGE_MAIN) == SYS_V_STORAGE_NREADY)
            {
                DEBUG_P2P("Main storage not ready\n");
                VideoClipParameter[LocalChannel].sysCaptureVideoMode  = sysCaptureVideoMode | ASF_CAPTURE_EVENT_DUMMY_ENA;
            }
            else
            {
                DEBUG_P2P("Main storage ready\n");
                VideoClipParameter[LocalChannel].sysCaptureVideoMode  = sysCaptureVideoMode;
            }
#endif
            if(MultiChannelGetCaptureVideoStatus(LocalChannel) && ((VideoClipOption[LocalChannel].asfVopWidth != VideoClipParameter[LocalChannel].asfVopWidth) || (VideoClipOption[LocalChannel].asfVopHeight != VideoClipParameter[LocalChannel].asfVopHeight)))
                MultiChannelSysCaptureVideoStopOneCh(LocalChannel);
            MultiChannelSysCaptureVideoOneCh(LocalChannel);
#endif

#if (MULTI_CHANNEL_VIDEO_REC)
            OSFlagPend(gSysSubReadyFlagGrp, FLAGSYS_SUB_RDYSTAT_REC_CH0 << (LocalChannel), OS_FLAG_WAIT_CLR_ALL, OS_IPC_WAIT_FOREVER, &err);
            while((VideoClipOption[LocalChannel].MPEG4_Task_Go == 0) || (VideoClipOption[LocalChannel].IIS_Task_Go == 0))
                OSTimeDly(1);

            OS_ENTER_CRITICAL();
            P2PVideoBufReadIdx[ch]                  = VideoClipOption[LocalChannel].VideoBufMngReadIdx;
            P2PVideoPresentTime[ch]                 = 0;

            P2PAudioBufReadIdx[ch]                  = VideoClipOption[LocalChannel].iisSounBufMngReadIdx;
            P2PAudioPresentTime[ch]                 = 0;
            P2PChannelStart[ch]                     = 1;

            P2PVideoBuf[ch]                         = VideoClipOption[LocalChannel].VideoBufMng;
            P2PAudioBuf[ch]                         = VideoClipOption[LocalChannel].iisSounBufMng;
            VideoClipOption[LocalChannel].SetIVOP   = 1;
            OS_EXIT_CRITICAL();

            /*
            DEBUG_P2P("P2PVideoBufReadIdx[%d]  = %d\n",     ch, P2PVideoBufReadIdx[ch]);
            DEBUG_P2P("P2PVideoPresentTime[%d] = %d\n",     ch, P2PVideoPresentTime[ch]);
            DEBUG_P2P("P2PVideoCmpSemEvt[%d]   = %d\n",     ch, P2PVideoCmpSemEvt[ch]->OSEventCnt);
            DEBUG_P2P("P2PVideoBuf[%d]         = 0x%08x\n", ch, P2PVideoBuf[ch]);
            DEBUG_P2P("P2PAudioBufReadIdx[%d]  = %d\n",     ch, P2PAudioBufReadIdx[ch]);
            DEBUG_P2P("P2PAudioPresentTime[%d] = %d\n",     ch, P2PAudioPresentTime[ch]);
            DEBUG_P2P("P2PAudioCmpSemEvt[%d]   = %d\n",     ch, P2PAudioCmpSemEvt[ch]->OSEventCnt);
            DEBUG_P2P("P2PAudioBuf[%d]         = 0x%08x\n", ch, P2PAudioBuf[ch]);
            */
#else
            OS_ENTER_CRITICAL();
            P2PVideoBufReadIdx[ch]  = 0;
            P2PVideoPresentTime[ch] = 0;

            P2PAudioBufReadIdx[ch]  = 0;
            P2PAudioPresentTime[ch] = 0;
            P2PChannelStart[ch]     = 1;

            P2PVideoBuf[ch]         = VideoBufMng;
            P2PAudioBuf[ch]         = iisSounBufMng;
            OS_EXIT_CRITICAL();
#endif
        }
        else if(source == Local_playback)
        {

          //  uiFlowPlaybackMode(UI_KEY_PLAY);//In playback thumbnail, send KE to playfile
            OS_ENTER_CRITICAL();
            P2PVideoBufReadIdx[ch]  = 0;
            P2PVideoPresentTime[ch] = 0;

            P2PAudioBufReadIdx[ch]  = 0;
            P2PAudioPresentTime[ch] = 0;
            P2PChannelStart[ch]=1;

            P2PVideoBuf[ch] = VideoBufMng;
            P2PAudioBuf[ch] = iisSounBufMng;
            OS_EXIT_CRITICAL();
        }
        else if(source == RX_receive)
        {
            DEBUG_P2P("RX_receive\n");

            if( gFirstConnect == 0) //APPi, L]wresolutionHD, 
            {
                rfiuRX_P2pVideoQuality = 2;
            }

            if( (rfiuRX_CamOnOff_Sta >> ch) & 0x01)
            {
                OS_ENTER_CRITICAL();
                P2PVideoBufReadIdx[ch]  = rfiuRxVideoBufMngWriteIdx[ch];
                P2PAudioBufReadIdx[ch]  = rfiuRxIIsSounBufMngWriteIdx[ch];

                P2PVideoPresentTime[ch] = 100; //Lsk TODO: msut add av time difference
                P2PAudioPresentTime[ch] = 100;
                P2PChannelStart[ch]=1;

                P2PVideoBuf[ch] = rfiuRxVideoBufMng[ch];
                P2PAudioBuf[ch] = rfiuRxIIsSounBufMng[ch];
                OS_EXIT_CRITICAL();
#if(UI_VERSION == UI_VERSION_MAYON)
//Add by Paul for liveview speed up, ask TX generate iFrame. 2018/08/29
				rfiuRX_OpMode = rfiuRX_OpMode | RfIU_RX_OPMODE_FORCE_I;
	            rfiu_SetRXOpMode_1(ch);
    	        rfiuRX_OpMode = rfiuRX_OpMode & (~RfIU_RX_OPMODE_FORCE_I);
//				DEBUG_P2P("CH:%d,Pt=%lu,%d\n", ch,P2PVideoBufReadIdx[ch], rfiuRxVideoBufMngWriteIdx[ch]);
#endif
#if 1
                if((isBatteryCam == 0) && (gRfiu_Op_Sta[ch]==RFIU_RX_STA_LINK_BROKEN))
                {
                    DEBUG_P2P("===== %d-CH is Out of Range =====\n",ch);
                    DEBUG_P2P("Out of Range\n");
                    P2PVideoBufReadIdx[ch]  = (0-60) % VIDEO_BUF_NUM;
                  #if (((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 3))||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 5))||\
                       ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 9)) || (HW_BOARD_OPTION == MR9200_RX_RDI_M906)||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 12)))
                    if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPEN)
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Japan_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Japan_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                    else
                    {
                        for(i=0; i<60; i++)
                        {
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_QVGA);
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_QVGA;
                            OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                  #elif (((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 6))|| ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 8)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 10))||\
                         ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 11)))
                    if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_GERMAN)
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_German_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_German_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                        }
                    }
                    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_FRENCH)
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_French_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_French_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                        }
                    }
                    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_Italy)//MPEG4_OutOfRange_Italy_QVGA
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Italy_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Italy_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                        }
                    }
                    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_DUTCH)//MPEG4_OutOfRange_Netherland_QVGA
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Netherland_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Netherland_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                        }
                    }
                    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_SPANISH)//MPEG4_OutOfRange_Spanish_QVGA
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Spanish_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Spanish_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                        }
                    }
                    else
                    {
                        for(i=0; i<60; i++)
                        {
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_QVGA);
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_QVGA;
                            OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                  #else
                   #if (UI_VERSION == UI_VERSION_TRANWO)
                   #if (UI_OTHER_LANGUAGE == 1)
                    if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPANSE)
                    {
                        for(i=0; i<60; i++)
                        {
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Japan_QVGA);
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Japan_QVGA;
                            OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                    else
                   #endif
                    {
                        for(i=0; i<60; i++)
                        {
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_QVGA);
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_QVGA;
                            OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                   #else
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                  #endif
                  #endif
                    gRfiuUnitCntl[ch].TX_PicWidth=320;
                    gRfiuUnitCntl[ch].TX_PicHeight=240;
                    //OSSemSet(P2PVideoCmpSemEvt[ch], 3, &err);

                }
#endif
            }
            else
            {
                DEBUG_P2P("-->RF CH-%d is OFF, Client-%d\n",ch,P2PEnableStreaming[ch]);
                OS_ENTER_CRITICAL();
                P2PVideoBufReadIdx[ch]  = rfiuRxVideoBufMngWriteIdx[ch];
                P2PAudioBufReadIdx[ch]  = rfiuRxIIsSounBufMngWriteIdx[ch];

                P2PVideoPresentTime[ch] = 100; //Lsk TODO: msut add av time difference
                P2PAudioPresentTime[ch] = 100;
                P2PChannelStart[ch]=1;

                P2PVideoBuf[ch] = rfiuRxVideoBufMng[ch];
                P2PAudioBuf[ch] = rfiuRxIIsSounBufMng[ch];
                OS_EXIT_CRITICAL();
                //--Fill black bitstream--//
                /*
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].flag=1;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].time=100;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].size=sizeof(MPEG4_NoCam_QVGA);//451;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].offset=0;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].buffer=MPEG4_NoCam_QVGA;

                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].flag=1;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].time=100;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].size=sizeof(MPEG4_NoCam_QVGA);//451;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].offset=0;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].buffer=MPEG4_NoCam_QVGA;

                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].flag=1;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].time=100;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].size=sizeof(MPEG4_NoCam_QVGA);//451;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].offset=0;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].buffer=MPEG4_NoCam_QVGA;
                */
              #if (((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 3))||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 5))||\
                   ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 9)) || (HW_BOARD_OPTION == MR9200_RX_RDI_M906)||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 12)))
                if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPEN)
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Japan_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Japan_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                    }
                }
                else
                {
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
              #elif (((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 6)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 8)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 10))||\
                     ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 11)))
                if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_GERMAN)
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_German_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_German_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                    }
                }
                else if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_FRENCH)
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_French_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_French_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                    }
                }
                else if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_Italy)//MPEG4_NoCam_Italy_QVGA
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Italy_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Italy_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                    }
                }
                else if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_DUTCH)//MPEG4_NoCam_Netherland_QVGA
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Netherland_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Netherland_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                    }
                }
                else if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_SPANISH)//MPEG4_NoCam_Spanish_QVGA
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Spanish_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Spanish_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                    }
                }
                else
                {
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
              #else
               #if (UI_VERSION == UI_VERSION_TRANWO)
               #if (UI_OTHER_LANGUAGE == 1)
                if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPANSE)
                {
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Japan_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Japan_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
                else
                #endif
                {
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
               #else
                for(i=0; i<60; i++)
                {
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_QVGA);
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_QVGA;
                    OSSemPost(P2PVideoCmpSemEvt[ch]);
                }
              #endif
              #endif
                gRfiuUnitCntl[ch].TX_PicWidth=320;
                gRfiuUnitCntl[ch].TX_PicHeight=240;
            }
        }
        else if(source == RX_transcoder)
        {
        }
    }
    else
    {
        if(source == RX_receive)
        {
            if( (rfiuRX_CamOnOff_Sta >> ch) & 0x01)
            {
                if((isBatteryCam == 0) && (gRfiu_Op_Sta[ch]==RFIU_RX_STA_LINK_BROKEN))
                {
                    DEBUG_P2P("===== %d-CH is Out of Range =====\n",ch);
                    DEBUG_P2P("Out of Range\n");
                    //P2PVideoBufReadIdx[ch]  = (0-60) % VIDEO_BUF_NUM;
                  #if (((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 3))||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 5))||\
                       ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 9)) || (HW_BOARD_OPTION == MR9200_RX_RDI_M906)||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 12)))
                    if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPEN)
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Japan_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Japan_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                        }
                    }
                    else
                    {
                        for(i=0; i<60; i++)
                        {
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_QVGA);
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_QVGA;
                            OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                  #elif (((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 6)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 8)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 10))||\
                         ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 11)))
                    if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_GERMAN)
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_German_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_German_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                        }
                    }
                    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_FRENCH)
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_French_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_French_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                        }
                    }
                    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_Italy)//MPEG4_OutOfRange_Italy_QVGA
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Italy_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Italy_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                        }
                    }
                    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_DUTCH)//MPEG4_OutOfRange_Netherland_QVGA
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Netherland_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Netherland_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                        }
                    }
                    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_SPANISH)//MPEG4_OutOfRange_Spanish_QVGA
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Spanish_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Spanish_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                        }
                    }
                    else
                    {
                        for(i=0; i<60; i++)
                        {
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_QVGA);
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_QVGA;
                            OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                  #else
                   #if (UI_VERSION == UI_VERSION_TRANWO)
                   #if (UI_OTHER_LANGUAGE == 1)
                    if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPANSE)
                    {
                        for(i=0; i<60; i++)
                        {
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Japan_QVGA);
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Japan_QVGA;
                            OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                    else
                    #endif
                    {
                        for(i=0; i<60; i++)
                        {
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_QVGA);
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_QVGA;
                            OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                   #else
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                  #endif
                  #endif
                    gRfiuUnitCntl[ch].TX_PicWidth=320;
                    gRfiuUnitCntl[ch].TX_PicHeight=240;
                    //OSSemSet(P2PVideoCmpSemEvt[ch], 3, &err);

                }            
            }
            else
            {
                DEBUG_P2P("-->RF CH-%d is OFF, Client-%d\n",ch,P2PEnableStreaming[ch]);
                OS_ENTER_CRITICAL();
                P2PVideoBufReadIdx[ch]  = rfiuRxVideoBufMngWriteIdx[ch];
                P2PAudioBufReadIdx[ch]  = rfiuRxIIsSounBufMngWriteIdx[ch];

                P2PVideoPresentTime[ch] = 100; //Lsk TODO: msut add av time difference
                P2PAudioPresentTime[ch] = 100;
                P2PChannelStart[ch]=1;

                P2PVideoBuf[ch] = rfiuRxVideoBufMng[ch];
                P2PAudioBuf[ch] = rfiuRxIIsSounBufMng[ch];
                OS_EXIT_CRITICAL();
                //--Fill black bitstream--//
                /*
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].flag=1;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].time=100;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].size=sizeof(MPEG4_NoCam_QVGA);//451;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].offset=0;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].buffer=MPEG4_NoCam_QVGA;

                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].flag=1;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].time=100;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].size=sizeof(MPEG4_NoCam_QVGA);//451;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].offset=0;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].buffer=MPEG4_NoCam_QVGA;

                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].flag=1;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].time=100;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].size=sizeof(MPEG4_NoCam_QVGA);//451;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].offset=0;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].buffer=MPEG4_NoCam_QVGA;
                */
              #if (((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 3))||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 5))||\
                   ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 9)) || (HW_BOARD_OPTION == MR9200_RX_RDI_M906)||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 12)))
                if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPEN)
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Japan_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Japan_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                    }
                }
                else
                {
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
              #elif (((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 6)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 8)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 10))||\
                     ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 11)))
                if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_GERMAN)
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_German_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_German_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                    }
                }
                else if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_FRENCH)
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_French_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_French_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                    }
                }
                else if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_Italy)//MPEG4_NoCam_Italy_QVGA
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Italy_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Italy_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                    }
                }
                else if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_DUTCH)//MPEG4_NoCam_Netherland_QVGA
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Netherland_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Netherland_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                    }
                }
                else if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_SPANISH)//MPEG4_NoCam_Spanish_QVGA
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Spanish_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Spanish_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]); 
                    }
                }
                else
                {
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
              #else
               #if (UI_VERSION == UI_VERSION_TRANWO)
               #if (UI_OTHER_LANGUAGE == 1)
                if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPANSE)
                {
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Japan_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Japan_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
                else
                #endif
                {
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
               #else
                for(i=0; i<60; i++)
                {
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_QVGA);
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_QVGA;
                    OSSemPost(P2PVideoCmpSemEvt[ch]);
                }
              #endif
              #endif
                gRfiuUnitCntl[ch].TX_PicWidth=320;
                gRfiuUnitCntl[ch].TX_PicHeight=240;
            }
        }
    }

    P2PEnableStreaming[ch]  += 1;

}


void Stop_P2P_Session(int ch)
{//Should be channel number, less then MAX_AV_CH
    u8 err;

    DEBUG_P2P("CH %d, Stop P2P Session \n\n", ch);
//    ch = ch % MAX_AV_CH;

    P2PEnableStreaming[ch]  -= 1;
    if(P2PEnableStreaming[ch] <= 0)
    {
        DEBUG_P2P("CH %d, stop streaming Audio/Video Payload\n",ch);
        OSSemSet(P2PVideoCmpSemEvt[ch], 0, &err);
        OSSemSet(P2PAudioCmpSemEvt[ch], 0, &err);
        P2PEnableStreaming[ch]=0;
    }
#if (P2P_LV_RATECTL_SUPPORT == 1)
    rfiuCamFeedBackAPPStaCmd(ch, 255, 0);
#endif    
    
}


void Reset_P2P_Session(void)
{
    int i;
    u8 err;

    for(i=0; i<MAX_AV_CH; i++)
    {
        OSSemSet(P2PVideoCmpSemEvt[i], 0, &err);
        OSSemSet(P2PAudioCmpSemEvt[i], 0, &err);
    }
}

// ----------------------
// HUD Update APP Sensor ]m 20150929 Sean
// ----------------------
#if HOME_RF_SUPPORT

void UpdateAPPSensorListStatus(void)
{
    APPSensorListStatus = 1;
}

void UpdateAPPSensorStatus(u8 sID)
{
    APPSensorStatus = sID;
}

void UpdateAPPRoomListStatus(void)
{
    APPRoomListStatus = 1;
}

void UpdateAPPSceneListStatus(void)
{
    APPSceneListStatus = 1;
}

#endif
void cmd_s_chk(void )
{
    struct st_SInfo Sinfo;
    int i, ret;

    for(i =0; i < MAX_CLIENT; i++)
    {
        ret = IOTC_Session_Check(i, &Sinfo);
        DEBUG_RED("SID[%d] sesscion chk:%d\n",i, ret);
    }
}

int check_avCh_in_SID(int SID, int avIdx)
{
    int chTmp=0;
    while(chTmp++ < MAX_CLIENT)
        if(gClientInfo[SID].avIndex[chTmp] == avIdx)
            return 1;
    return 0;
}

void adj_conn(char bw, char lanIp, char RR,char Par)
{
    struct st_ConnectOption S_ConnectOption;
    S_ConnectOption.IsLowConnectionBandwidth =bw;
    S_ConnectOption.IsNotToCheckLanIpforP2P =lanIp;
    S_ConnectOption.IsP2PRequestRoundRobin =RR;
    S_ConnectOption.IsParallel =Par;
    IOTC_Set_Connection_Option(&S_ConnectOption);
    DEBUG_P2P("Set IOTC CONN BW-%d CheckLanIP-%d ReqRoundRobin-%d, isParallel-%d\n", bw, lanIp, RR, Par);
}


int Check_Session_Status(int SID)
{
    struct st_SInfo Sinfo;
    int ret;
    int i;
    u8 err;

    ret = IOTC_Session_Check(SID, &Sinfo);
    if(gClientInfo[SID].bP2PConnected == 0)
    {
//        DEBUG_RED("SID[%d] was disconnected(check ret = %d)\n", SID, ret);
        return -1;
    }


    if(ret == IOTC_ER_SESSION_CLOSE_BY_REMOTE)
    {
        DEBUG_P2P("[thread_ForSessionHandler] remote site close this session, SID[%d]\n", SID);
        if(gClientInfo[SID].bEnableSpeaker>0)
        {
            Kill_Task_Speaker(SID);
        }
    }
    else if(ret == IOTC_ER_REMOTE_TIMEOUT_DISCONNECT)
    {
        DEBUG_P2P("[thread_ForSessionHandler] disconnected due to remote site no response for a while SID[%d]\n", SID);
        if(gClientInfo[SID].bEnableSpeaker>0)
        {
            Kill_Task_Speaker(SID);
        }
    }
    else if(ret == IOTC_ER_INVALID_SID)
    {
        DEBUG_P2P("[thread_ForSessionHandler] Session cant be used anymore\n");
        if(gClientInfo[SID].bEnableSpeaker>0)
        {
            Kill_Task_Speaker(SID);
        }
    }
    if(ret < 0)
    {
        memset(SID_IP_table[SID], 0, sizeof(SID_IP_table[SID]));
        if(gClientInfo[SID].bEnableSpeaker>0)
        {
            Kill_Task_Speaker(SID);
        }
        DEBUG_P2P("Check Session : Session close ret[%d] SID[%d]\n", ret, SID);
        client_p2pdisconnected(SID);

        /*Close remote playback task.*/
        if(gClientInfo[SID].playBackCh!=0)
        {
            for(i=0; i<MAX_AV_CH; i++)
            {
                if(gClientInfo[SID].avIndex[i] == gClientInfo[SID].avChannel)
                    Stop_P2P_Session(i);
            }
#if ENABLE_TUTK_RESEND            
            if(GetResendBufUsage(gClientInfo[SID].avChannel, 0) >= RESEND_BUF_MAX_USAGE_RATE)
            {
                err = avServResetBuffer(gClientInfo[SID].avChannel, RESET_ALL, RESET_RESEND_BUF_TIMEOUT);
                DEBUG_YELLOW("[%s] avServResetBuffer2 sid[%d] err[%d] avIndex[%d]\n",__func__, SID, err, gClientInfo[SID].avChannel);
            }
#endif
            avServStop(gClientInfo[SID].avChannel);
            P2PPlaybackVideoStop=1;
            unregedit_client_from_video(SID);
            gClientInfo[SID].bStopPlayBack = 1;
            gClientInfo[SID].bPausePlayBack = 0;
            P2PEnableplaybackStreaming--;
            DEBUG_P2P("P2PEnableplaybackStreaming5555=%d\n",P2PEnableplaybackStreaming);
            P2PEnableplaybackStreaming=0;
			
            if(P2PVideoPlaybackCmpSemEvt)
            {
                OSSemSet(P2PVideoPlaybackCmpSemEvt, 0, &err);
                if(err!= OS_NO_ERR)
                    printf("222Set P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
            }
            
            if(P2PAudioPlaybackCmpSemEvt)
            {
                OSSemSet(P2PAudioPlaybackCmpSemEvt, 0, &err);
                if(err!= OS_NO_ERR)
                    printf("222Set P2PAudioPlaybackCmpSemEvt fail = %d\n", err);
            }
            
#ifndef SAFE_DEL_P2P_PLAYFILE_TASK     
            P2PVideoPlaybackCmpSemEvt = OSSemDel(P2PVideoPlaybackCmpSemEvt, OS_DEL_ALWAYS, &err);
            if(err!= OS_NO_ERR)
                printf("222Del P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
            P2PAudioPlaybackCmpSemEvt = OSSemDel(P2PAudioPlaybackCmpSemEvt, OS_DEL_ALWAYS, &err);
            if(err!= OS_NO_ERR)
                printf("222Del P2PAudioPlaybackCmpSemEvt fail = %d\n", err);
#endif            
            
            gClientInfo[SID].playBackCh=0;
            DEBUG_P2P("Fileplaying= %d ,Remote_play= %d \n",Fileplaying,Remote_play);
            DEBUG_P2P("DELETE P2P PLAYFILE TASK1.\n");
#ifdef SAFE_DEL_P2P_PLAYFILE_TASK
            SafeDelP2pPlayFileTask();
#else            
            if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
                DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");

            if(OS_NO_ERR !=  OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY))
                DEBUG_P2P("OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
#endif            
            
            Fileplaying = 0;
            Remote_play = 0;
#if(UI_VERSION == UI_VERSION_MAYON)
			CurrPlaybackSID = -1;
#endif
        }

        //for check device connect timeout by aher 2012/12/21
        if(gOnlineNum<=0)
        {
            if(gFirstConnect)
            {
                if(gClientInfo[SID].bEnableSpeaker>0)
                {
                    Kill_Task_Speaker(SID);
                }
                /*Close remote playback task.*/
                if((Fileplaying)&&(Remote_play==1))
                {
                    P2PPlaybackVideoStop=1;
                    unregedit_client_from_video(SID);
                    gClientInfo[SID].bStopPlayBack = 1;
                    gClientInfo[SID].bPausePlayBack = 0;
                    P2PEnableplaybackStreaming = 0;
                    if(P2PVideoPlaybackCmpSemEvt)
                    {
                        OSSemSet(P2PVideoPlaybackCmpSemEvt, 0, &err);
                        if(err!= OS_NO_ERR)
                            printf("333Set P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
                    }
                    
                    if(P2PAudioPlaybackCmpSemEvt)
                    {
                        OSSemSet(P2PAudioPlaybackCmpSemEvt, 0, &err);
                        if(err!= OS_NO_ERR)
                            printf("333Set P2PAudioPlaybackCmpSemEvt fail = %d\n", err);
                    }
#ifndef SAFE_DEL_P2P_PLAYFILE_TASK
                    P2PVideoPlaybackCmpSemEvt=OSSemDel(P2PVideoPlaybackCmpSemEvt, OS_DEL_ALWAYS, &err);
                    if(err!= OS_NO_ERR)
                        printf("333Del P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
                    P2PAudioPlaybackCmpSemEvt=OSSemDel(P2PAudioPlaybackCmpSemEvt, OS_DEL_ALWAYS, &err);
                    if(err!= OS_NO_ERR)
                        printf("333Del P2PAudioPlaybackCmpSemEvt fail = %d\n", err);
#endif                    
                    DEBUG_P2P("Fileplaying= %d ,Remote_play= %d \n",Fileplaying,Remote_play);
                    DEBUG_P2P("DELETE P2P PLAYFILE TASK2.\n");
                    
#ifdef SAFE_DEL_P2P_PLAYFILE_TASK
                    SafeDelP2pPlayFileTask();
                    OSFlagPend(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_PLAY_FINISH, OS_FLAG_WAIT_CLR_ALL|OS_FLAG_CONSUME, OS_IPC_WAIT_FOREVER, &err);
                    DEBUG_P2P("pend FLAGSYS_RDYSTAT_PLAY_FINISH.\n");
#else                    
                    if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
                        DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");

                    OSFlagPend(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_PLAY_FINISH, OS_FLAG_WAIT_CLR_ALL|OS_FLAG_CONSUME, OS_IPC_WAIT_FOREVER, &err);
                    DEBUG_P2P("pend FLAGSYS_RDYSTAT_PLAY_FINISH.\n");

                    if(OS_NO_ERR !=  OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY))
                        DEBUG_P2P("OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
#endif                    
                    
                    Fileplaying = 0;
                    Remote_play = 0;
                    search_dir_start.YMD = 0;
                    search_dir_start.HMS = 0;
                    search_dir_end.YMD = 0;
                    search_dir_end.HMS = 0;
                }
                //gFirstConnect=0;
            }
            for (i = 0; i < MAX_AV_CH; i++)
                uiSetP2PImageLevel(i,0);
        }
    }

    return ret;
}


#if APP_KEEP_ALIVE
int Clear_Session_Status(int SID) //20160509 Sean : Check APP is Alive or not.
{
    u8 err;
    int i;
    
    if(SID >= ElemsOfArray(gClientInfo))
        return -1;

    if(gClientInfo[SID].bP2PConnected == 0)
        return -1;
    
    DEBUG_P2P("Check Session Fail[%d], Clear Session Status.\n",SID);
    memset(SID_IP_table[SID], 0, sizeof(SID_IP_table[SID]));

    if(gClientInfo[SID].bEnableSpeaker>0)
    {
        Kill_Task_Speaker(SID);
    }
    client_p2pdisconnected(SID);
    /*Close remote playback task.*/
    if(gClientInfo[SID].playBackCh!=0)
    {
        avServStop(gClientInfo[SID].avChannel);
        P2PPlaybackVideoStop=1;
        unregedit_client_from_video(SID);
        gClientInfo[SID].bStopPlayBack = 1;
        gClientInfo[SID].bPausePlayBack = 0;
        P2PEnableplaybackStreaming--;
        DEBUG_P2P("P2PEnableplaybackStreaming5555=%d\n",P2PEnableplaybackStreaming);
        P2PEnableplaybackStreaming=0;
        if(P2PVideoPlaybackCmpSemEvt)
            OSSemSet(P2PVideoPlaybackCmpSemEvt, 0, &err);
        if(P2PAudioPlaybackCmpSemEvt)
            OSSemSet(P2PAudioPlaybackCmpSemEvt, 0, &err);
        gClientInfo[SID].playBackCh=0;
        DEBUG_P2P("Fileplaying= %d ,Remote_play= %d \n",Fileplaying,Remote_play);
        DEBUG_P2P("DELETE P2P PLAYFILE TASK3.\n");
#ifdef SAFE_DEL_P2P_PLAYFILE_TASK
        SafeDelP2pPlayFileTask();
#else        
        if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
            DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");

        if(OS_NO_ERR !=  OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY))
            DEBUG_P2P("OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
#endif        

        Fileplaying=0;
        Remote_play=0;
#if(UI_VERSION == UI_VERSION_MAYON)
		CurrPlaybackSID = -1;
#endif
    }

    //for check device connect timeout by aher 2012/12/21
    if(gOnlineNum<=0)
    {
        if(gFirstConnect)
        {
            if(gClientInfo[SID].bEnableSpeaker>0)
            {
                Kill_Task_Speaker(SID);
            }
            /*Close remote playback task.*/
            if((Fileplaying)&&(Remote_play==1))
            {
                P2PPlaybackVideoStop=1;
                unregedit_client_from_video(SID);
                gClientInfo[SID].bStopPlayBack = 1;
                gClientInfo[SID].bPausePlayBack = 0;
                P2PEnableplaybackStreaming=0;
                if(P2PVideoPlaybackCmpSemEvt)
                    OSSemSet(P2PVideoPlaybackCmpSemEvt, 0, &err);
                if(P2PAudioPlaybackCmpSemEvt)
                    OSSemSet(P2PAudioPlaybackCmpSemEvt, 0, &err);
                DEBUG_P2P("Fileplaying= %d ,Remote_play= %d \n",Fileplaying,Remote_play);
                DEBUG_P2P("DELETE P2P PLAYFILE TASK4.\n");
#ifdef SAFE_DEL_P2P_PLAYFILE_TASK
                SafeDelP2pPlayFileTask();
                OSFlagPend(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_PLAY_FINISH, OS_FLAG_WAIT_CLR_ALL|OS_FLAG_CONSUME, OS_IPC_WAIT_FOREVER, &err);
                DEBUG_P2P("pend FLAGSYS_RDYSTAT_PLAY_FINISH.\n");
#else                
                if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
                    DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");

                OSFlagPend(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_PLAY_FINISH, OS_FLAG_WAIT_CLR_ALL|OS_FLAG_CONSUME, OS_IPC_WAIT_FOREVER, &err);
                DEBUG_P2P("pend FLAGSYS_RDYSTAT_PLAY_FINISH.\n");

                if(OS_NO_ERR !=  OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY))
                    DEBUG_P2P("OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
#endif                

                Fileplaying=0;
                Remote_play=0;
#if(UI_VERSION == UI_VERSION_MAYON)
				CurrPlaybackSID = -1;
#endif
                search_dir_start.YMD=0;
                search_dir_start.HMS=0;
                search_dir_end.YMD=0;
                search_dir_end.HMS=0;
            }
        }
        for (i = 0; i < MAX_AV_CH; i++)
            uiSetP2PImageLevel(i,0);
    }

    return 0;
}

void SendAudioFrameData(int SID, u32 time, int size, char *buf)
{
    FRAMEINFO_t frameInfo;
    int ret;
    if(size == 0) return; //check with Lucian
    if(gClientInfo[SID].bEnableAudio == 0) return;
    memset(&frameInfo, 0, sizeof(FRAMEINFO_t));
    frameInfo.codec_id = MEDIA_CODEC_AUDIO_PCM;
    frameInfo.flags = (AUDIO_SAMPLE_16K << 2) | (AUDIO_DATABITS_8 << 1) | AUDIO_CHANNEL_MONO;
    frameInfo.timestamp = time;

    ret = avSendAudioData(gClientInfo[SID].avChannel, buf, size, &frameInfo, sizeof(FRAMEINFO_t));

    if(ret < 0)
    {
        DEBUG_P2P("avSendAudioData error [%d] SID[%d] avIndex[%d]\n", ret, SID, gClientInfo[SID].avChannel);
        unregedit_client_from_audio(SID);
    }
}


static u32 beforetime = 0;
static u32 kbpersec = 0;
void SendVideoFrameData(int SID, u32 time, u32 flag, int size, char *buf)
{
    FRAMEINFO_t frameInfo;
    int ret =0;
    u32 buffering = 0;
    INT8U os_err;
#if (ENABLE_TUTK_RESEND == 1)
    unsigned int rndBufUsage;
#endif
    //OSSemPend(SendFrameLock, 0, &os_err);
    if(SID < 0 || size == 0 || buf == 0)
        return; //check with Lucian
    
    if(gClientInfo[SID].bEnableVideo == 0)
        return;

    memset(&frameInfo, 0, sizeof(FRAMEINFO_t));

    #if(VIDEO_CODEC_OPTION == MPEG4_CODEC)
	frameInfo.codec_id = MEDIA_CODEC_VIDEO_MPEG4;
    #elif(VIDEO_CODEC_OPTION == H264_CODEC)
    frameInfo.codec_id = MEDIA_CODEC_VIDEO_H264;
    #endif
    
#if (ENABLE_TUTK_RESEND == 1)
    rndBufUsage = GetResendBufUsage(gClientInfo[SID].avChannel, &buffering);
    if(rndBufUsage >= RESEND_BUF_MAX_USAGE_RATE_HIGH || !CheckFrameSize(size, buffering))
    {        
        ret = avServResetBuffer(gClientInfo[SID].avChannel, RESET_ALL, RESET_RESEND_BUF_TIMEOUT);
        DEBUG_RED("avServResetBuffer3 video sid[%d] err[%d] avIndex[%d] %d,%d,%d\n", SID, ret, gClientInfo[SID].avChannel, rndBufUsage, buffering, size);
    }
#endif     

    if(flag)
    {
        frameInfo.flags = IPC_FRAME_FLAG_IFRAME;
#if (P2P_LV_RATECTL_SUPPORT == 1) && ENABLE_TUTK_RESEND
        if(gClientInfo[SID].connMode != LAN_MODE)
        {
            if(gClientInfo[SID].appReceived1stIFrame && LOW_BIT_RATE_MODE(SID) && (gClientInfo[SID].resend_buf_usage_rate < LOW_BIT_RATE_LEAVE))
            {
                DEBUG_P2P("Rbf[avCh:%d] %d%%, leave LBR mode1: %d times\n", gClientInfo[SID].avChannel, gClientInfo[SID].resend_buf_usage_rate, gClientInfo[SID].localSendCount);
                gClientInfo[SID].localSendCount = 0;
            }            
        }
        else
        {
            if(LOW_BIT_RATE_MODE(SID) && (gClientInfo[SID].resend_buf_usage_rate < LOW_BIT_RATE_LEAVE))
            {
                DEBUG_GREEN("Rbf[avCh:%d] %d%%, leave LBR mode2: %d times\n", gClientInfo[SID].avChannel, gClientInfo[SID].resend_buf_usage_rate, gClientInfo[SID].localSendCount);
                gClientInfo[SID].localSendCount = 0;
            }
        }
#endif
    }
    else
    {
        frameInfo.flags = IPC_FRAME_FLAG_PBFRAME;
    }

    frameInfo.onlineNum = gOnlineNum;
    frameInfo.timestamp = time;
    
#if P2P_DEBUG_ENA
    gpioSetLevel(2,9,1);
#endif


#if (P2P_LV_RATECTL_SUPPORT == 1) && ENABLE_TUTK_RESEND
    if((gClientInfo[SID].playBackCh == 0 ) && LOW_BIT_RATE_MODE(SID))
    {
        // low bit rate mode, send I frame only, drop all P frame
        if(frameInfo.flags == IPC_FRAME_FLAG_IFRAME)
        {
            DEBUG_P2P("[Low Bit Rate] Send I Frame:%d\n", size);
            if(ipcamstart)
            {
                ipcamstart = 0;
                printf("\nsend first I frame!\n");
            }            
            
            ret = avSendFrameData(gClientInfo[SID].avChannel, buf, size, &frameInfo, sizeof(FRAMEINFO_t));
            kbpersec += size;
        }
    }
    else
#endif
    {  //normal speed mode, send all frame
        if(flag && ipcamstart)
        {
            ipcamstart = 0;
            printf("\nsend first I frame!\n");
        }
        ret = avSendFrameData(gClientInfo[SID].avChannel, buf, size, &frameInfo, sizeof(FRAMEINFO_t));
        kbpersec += size;
    }
    
    if((OSTimeGet() - beforetime) >= 60)
    {
        printf("\n\n%u KB/3s\n\n", kbpersec/1024);
        kbpersec = 0;
        beforetime = OSTimeGet();
    }    

#if P2P_DEBUG_ENA
//if(frameInfo.flags == IPC_FRAME_FLAG_IFRAME)
    gpioSetLevel(2,9,0);
#endif
#if (ENABLE_TUTK_RESEND == 1)
    rndBufUsage = GetResendBufUsage(gClientInfo[SID].avChannel, &buffering);
    if((rndBufUsage >= RESEND_BUF_MAX_USAGE_RATE_HIGH) || (ret == AV_ER_EXCEED_MAX_SIZE))
    {
        if(ret == AV_ER_EXCEED_MAX_SIZE)
        {
#if DEBUG_SEND_FRAME
            u32 resend_count = 0;
            int ret;
            ret = avServGetResendFrmCount(gClientInfo[SID].avChannel, &resend_count);
            DEBUG_LIGHTRED("resend frm count[%d][%d]\n", ret, resend_count);
            DEBUG_RED("sid[%d] resend video buf full[%d][%d]!\n", SID, size, line);
#else            
            DEBUG_RED("[sendV] sid[%d] resend video buf full[%d]!\n", SID, size);
#endif        
        }
        else
        {

            DEBUG_YELLOW("[sendV] avServResetBuffer4 video sid[%d]...\n", SID);
        }
        ret = avServResetBuffer(gClientInfo[SID].avChannel, RESET_ALL, RESET_RESEND_BUF_TIMEOUT);
        DEBUG_YELLOW("[sendV] avServResetBuffer5 video sid[%d] err[%d] avIndex[%d]%d,%d\n", SID, ret, gClientInfo[SID].avChannel, rndBufUsage, buffering);
    }
    else
#endif   
    if(ret < 0)
    {
        DEBUG_P2P("avSendFrameData error [%d] SID[%d] avIndex[%d] 0x%p %d\n", ret, SID, gClientInfo[SID].avChannel, buf, size);
        unregedit_client_from_video(SID);
    }
    
#if (P2P_LV_RATECTL_SUPPORT == 1)
    if((gClientInfo[SID].firstIframeTick == 0 ) && (gClientInfo[SID].VOLSend == 0) && (frameInfo.flags == IPC_FRAME_FLAG_IFRAME))
    {
        gClientInfo[SID].firstIframeTick = OS_GetSysTick();
        gClientInfo[SID].firstIframeSize = size;
    }
#endif
}



void Handle_IOCTRL_Cmd(int SID, int avIndex, char *buf)
{
#if (CHIP_OPTION == CHIP_A1025A)
//	u8	j,k, LED_level;
#endif
#if (HOME_RF_SUPPORT)
    static unsigned int room_id_add =0;
    static unsigned int sensor_id_add =0;
    static unsigned int scene_id_add =0;
#endif
    unsigned int i,x;
    unsigned int ioType;
    int ret;
    int Light_CHN;
	u8 result;

#if RFIU_RX_WAKEUP_TX_SCHEME
	if(MAYONTXTypeStatus != 0)
	{
        int size = sizeof(SMsgAVIoctrlGetCameraTypeResp);
        SMsgAVIoctrlGetCameraTypeResp q;

		q.channel 	= MAYONTXTypeStatus - 1;			// Add by Paul for APP check batterycam channel, 180508

		q.CameraType 	= gRfiuUnitCntl[MAYONTXTypeStatus - 1].RFpara.BateryCam_support;
					
		q.BatteryLevel = gRfiuUnitCntl[MAYONTXTypeStatus - 1].RFpara.TxBatteryLev;
		
		if(q.BatteryLevel > 3)
			q.BatteryLevel = 3;

		MAYONTXTypeStatus = 0;

        	//Fixed issue of nly 1 client can get TX_TYPE_RESP when battery cam sleep , Paul add, 180613
        	for(i = 0; i < MAX_CLIENT; ++i)
        	{
        		if((gClientInfo[i].bP2PConnected == 1) ||(gClientInfo[i].bEnableVideo == 1))
        		{
        			if(avSendIOCtrl2(gClientInfo[i].avChannel, IOTYPE_USER_IPCAM_GET_TX_TYPE_RESP, (char*)&q, size)== AV_ER_NoERROR)
        			{
        				DEBUG_P2P("IPCAM_GET_TX_TYPE_RESP[%d:%d] OK\n\n", i, gClientInfo[i].avChannel);
        			}
        		}
        	}
    }
#endif

	if (MAYONLightStatus != 0)
	{
		int size = sizeof(SMsgAVIoctrlGetCameraLightResp);
		SMsgAVIoctrlGetCameraLightResp q;

		q.switch_value = uiGetLightOnOffAPP(MAYONLightStatus - 1);
		q.value = uiGetLightStatusAPP(MAYONLightStatus - 1);

        MAYONLightStatus = 0;

		if(avSendIOCtrl2(avIndex, IOTYPE_USER_IPCAM_GET_TX_LIGHT_RESP, (char*)&q, size)== AV_ER_NoERROR)
		{
			DEBUG_P2P("IPCAM_GET_TX_LIGHT_RESP OK\n\n");
		}

	}

	if (MAYONAlarmStatus != 0)
	{
		int size = sizeof(SMsgAVIoctrlGetCameraAlarmResp);
		SMsgAVIoctrlGetCameraAlarmResp q;

		q.switch_value= uiGetAlarmOnOffAPP(MAYONAlarmStatus - 1);
		q.AlarmStatus = uiGetAlarmStatusAPP(MAYONAlarmStatus - 1);

        MAYONAlarmStatus = 0;

		if(avSendIOCtrl2(avIndex, IOTYPE_USER_IPCAM_GET_TX_ALARM_RESP, (char*)&q, size)== AV_ER_NoERROR)
		{
			DEBUG_P2P("IPCAM_GET_TX_ALARM_RESP OK\n\n");
		}

	}

#endif
#if (UI_LIGHT_SUPPORT)
// ----------------------
// HUD Update APP Light ]m 20151126 Sean
// ----------------------
    if (AppLightStatus != 0)
    {
        int size =  sizeof(SMsgAVIoctrlGetLightStatusResp);

        SMsgAVIoctrlGetLightStatusResp q;

        q.channel = AppLightStatus-1;

        if((iconflag[UI_MENU_SETIDX_CH1_LS_STATUS + AppLightStatus-1])<2)
            q.status = 0;
        else
            q.status = 1;

        AppLightStatus = 0;

        for(i=0; i<MAX_CLIENT; i++)
        {
            if((ret = Check_Session_Status(i)) < 0) //session disconnected
                continue;
            if(avSendIOCtrl2(gClientInfo[i].avIndex[0], IOTYPE_RDI_GETLIGHTSTATUS_RESP, (char *)&q, size)== AV_ER_NoERROR)
                DEBUG_P2P("IOTYPE_RDI_GETLIGHTSTATUS_RESP_2 OK\n\n");
        }
    }
#endif

#if HOME_RF_SUPPORT
//////////////////////////////////////////
// ----------------------
// HUD Update APP Status ]m 20151230 Sean
// ----------------------
    if (APPSensorListStatus != 0)
    {
        int size =  sizeof(SMsgAVIoctrlGetSensorLstResp);
        int i, j, ret;

        SMsgAVIoctrlGetSensorLstResp q;

        sysAppGetSensorList(&q,0);
        APPSensorListStatus = 0;

        for(i=0; i<MAX_CLIENT; i++)
        {
            if((ret = Check_Session_Status(i)) < 0) //session disconnected
                continue;
            if(avSendIOCtrl2(gClientInfo[i].avIndex[0], IOTYPE_USER_GETSENSORLST_RESP, (char*)&q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETSENSORLST_RESP2 OK\n\n");
            }
            if(q.nTotalCount > MAXSENSOR_NUM_ONCE)
                for(j = 0; j < (q.nTotalCount)/(MAXSENSOR_NUM_ONCE+1); i++)
                {
                    sysAppGetSensorList(&q,j+1);
                    if(avSendIOCtrl2(gClientInfo[i].avIndex[0], IOTYPE_USER_GETSENSORLST_RESP, (char*)&q, size)== AV_ER_NoERROR)
                        DEBUG_P2P("GETSENSORLST_RESP2_%d OK\n\n",j+2);
                }
        }
    }

    if (APPSensorStatus != 0)
    {
        int size =  sizeof(SMsgAVIoctrlGetSensorResp);
        int i, ret;

        SMsgAVIoctrlGetSensorResp q;

        sysAppGetSensor(APPSensorStatus,&q);
        APPSensorStatus = 0;

        for(i=0; i<MAX_CLIENT; i++)
        {
            if((ret = Check_Session_Status(i)) < 0) //session disconnected
                continue;
            if(avSendIOCtrl2(gClientInfo[i].avIndex[0], IOTYPE_USER_GETSENSOR_RESP, (char*)&q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETSENSOR_RESP2 OK\n\n");
            }
        }
    }

    if (APPRoomListStatus != 0)
    {
        int size =  sizeof(SMsgAVIoctrlGetRoomLstResp);
        int i, j, ret;

        SMsgAVIoctrlGetRoomLstResp q;

        sysAppGetRoomList(&q,0);
        APPRoomListStatus = 0;

        DEBUG_P2P("\nGET ROOM : %d, %d, %d \n",q.nCount,q.nStartIdx,q.nTotalCount);

        for(i=0; i<MAX_CLIENT; i++)
        {
            if((ret = Check_Session_Status(i)) < 0) //session disconnected
                continue;
            if(avSendIOCtrl2(gClientInfo[i].avIndex[0], IOTYPE_USER_GETROOMLST_RESP, (char*)&q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETROOMLST_RESP2 OK\n\n");
            }
            if(q.nTotalCount > MAXROOM_NUM_ONCE)
                for(j = 0; j < (q.nTotalCount)/(MAXROOM_NUM_ONCE+1); j++)
                {
                    sysAppGetRoomList(&q,j+1);
                    if(avSendIOCtrl2(gClientInfo[i].avIndex[0], IOTYPE_USER_GETROOMLST_RESP, (char*)&q, size)== AV_ER_NoERROR)
                        DEBUG_P2P("GETROOMLST_RESP2_%d OK\n\n",j+2);
                }
        }
    }

    if (APPSceneListStatus != 0)
    {
        int size =  sizeof(SMsgAVIoctrlGetSceneLstResp);
        int i, j, ret;

        SMsgAVIoctrlGetSceneLstResp q;

        sysAppGetSceneList(&q,0);
        APPSceneListStatus = 0;

        for(i=0; i<MAX_CLIENT; i++)
        {
            if((ret = Check_Session_Status(i)) < 0) //session disconnected
                continue;
            if(avSendIOCtrl2(gClientInfo[i].avIndex[0], IOTYPE_USER_GETSCENCELST_RESP, (char*)&q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETSCENCELST_RESP2 OK\n\n");
            }
            if(q.nTotalCount > MAXSCENE_NUM_ONCE)
                for(j = 0; j < (q.nTotalCount)/(MAXSCENE_NUM_ONCE+1); j++)
                {
                    sysAppGetSceneList(&q,j+1);
                    if(avSendIOCtrl2(gClientInfo[i].avIndex[0], IOTYPE_USER_GETSCENCELST_RESP, (char*)&q, size)== AV_ER_NoERROR)
                        DEBUG_P2P("GETSCENCELST_RESP2_%d OK\n\n",j+2);
                }
        }
    }
//////////////////////////////////////////
#endif

    if(avIndex < 0)
        return;

    memset(buf, 0, MAX_BUF_SIZE);
    ret = avRecvIOCtrl(avIndex, &ioType, (char *)buf, MAX_BUF_SIZE, 0);
    if(ret < 0)
    {
        if(ret == AV_ER_INVALID_SID || ret == AV_ER_SESSION_CLOSE_BY_REMOTE || ret == AV_ER_REMOTE_TIMEOUT_DISCONNECT)
        {
            if(gOnlineNum == 1)
            	ClearP2PConnection();
        }
        
        if(ret != AV_ER_DATA_NOREADY)
            DEBUG_P2P("Handle IOCTL CMD fail ret[%d] avIndex[%d]\n", ret, avIndex);
        
        //unregedit_client_from_avsession(SID);
        return;
    }

    //DEBUG_GREEN("Get ioType %x\n", ioType);
    switch(ioType)
    {
#if (HW_BOARD_OPTION  == MR8202A_RX_TARNWO_D8530)
        /* ----------------------
           Creat WalMart 20180305 Sean
           Functional Hard Code 20181718 Hank
		   ---------------------- */
		case IOTYPE_WALMART_SETCAMERAPAIR_REQ:
		    P2PCmd_SetCamPair(avIndex, buf);
		    break;

		case IOTYPE_WALMART_GETCAMERASTASUS_REQ:
		    P2PCmd_GetCamLinkStatus(avIndex, buf);
		    break;

		case IOTYPE_WALMART_SETCAMERASTASUS_REQ:
		    P2PCmd_SetCamOnOff(avIndex, buf);
		    break;

		case IOTYPE_WALMART_GETCAMERABRIT_REQ:
		    P2PCmd_GetCamBrightness(avIndex, buf);
		    break;

		case IOTYPE_WALMART_SETCAMERABRIT_REQ:
		    P2PCmd_SetCamBrightness(avIndex, buf);
    		break;

		case IOTYPE_WALMART_GETCAMERAFREQ_REQ:
		    P2PCmd_GetCamFrequence(avIndex, buf);
		    break;

		case IOTYPE_WALMART_SETCAMERAFREQ_REQ:
		    P2PCmd_SetCamFrequence(avIndex, buf);
		    break;

		case IOTYPE_WALMART_GETRECORDMANUAL_REQ:
		    P2PCmd_GetCamRecStatus(avIndex, buf);
    		break;

		case IOTYPE_WALMART_GETLIVEVIEWDATARATE_REQ:
		    P2PCmd_GetLiveDataRate(buf);
    		break;

		case IOTYPE_WALMART_SETRECORDMANUAL_REQ:
		    P2PCmd_SetCamManualRec(avIndex, buf);
    		break;

		case IOTYPE_WALMART_GETRECORDMOTIONLEV_REQ:
    		P2PCmd_GetCamMotionSensitivity(avIndex, buf);
    		break;

		case IOTYPE_WALMART_SETRECORDMOTIONLEV_REQ:
    		P2PCmd_SetCamMotionSensitivity(avIndex, buf);
    		break;

		case IOTYPE_WALMART_GETRECORDSCHEDULE_REQ:
    		P2PCmd_GetCamRecScheduleTable(avIndex, buf);
    		break;

		case IOTYPE_WALMART_SETRECORDSCHEDULE_REQ:
		    P2PCmd_SetCamRecScheduleTable(avIndex, buf);
		    break;

		case IOTYPE_WALMART_GETRECORDDURATION_REQ:
    		P2PCmd_GetRecSection(avIndex, buf);
    		break;

		case IOTYPE_WALMART_SETRECORDDURATION_REQ:
			P2PCmd_SetRecSection(avIndex, buf);
		    break;

		case IOTYPE_WALMART_SETSDFORMAT_REQ:
    		P2PCmd_SetFormat(avIndex, buf);
    		break;

		case IOTYPE_WALMART_GETSDOVERWRITE_REQ:
    		P2PCmd_GetOverwiteStatus(avIndex, buf);
    		break;

		case IOTYPE_WALMART_SETSDOVERWRITE_REQ:
		    P2PCmd_SetOverwite(avIndex, buf);
    		break;

		case IOTYPE_WALMART_GETSYSTIME_REQ:
			P2PCmd_GetDateTime(avIndex, buf);
    		break;

		case IOTYPE_WALMART_SETSYSTIME_REQ:
			P2PCmd_SetDateTime(avIndex, buf);
	    	break;

		case IOTYPE_WALMART_SETDEFAULT_REQ:
    		P2PCmd_SetDefault(avIndex, buf);
    		break;

		case IOTYPE_WALMART_GETLANG_REQ:
			P2PCmd_GetLanguage(avIndex, buf);
		    break;

		case IOTYPE_WALMART_SETLANG_REQ:
			P2PCmd_SetLanguage(avIndex, buf);
		    break;

		case IOTYPE_WALMART_GETNETSTATUS_REQ:
			P2PCmd_GetNetworkInfo(avIndex, buf);
		    break;

		case IOTYPE_WALMART_SETNETSTATUS_REQ:
		    P2PCmd_SetNetworkInfo(avIndex, buf);
    		break;

		case IOTYPE_WALMART_GETLED_REQ:
			P2PCmd_GetLEDStatus(avIndex, buf);
		    break;

		case IOTYPE_WALMART_SETLED_REQ:
			P2PCmd_SetLEDStatus(avIndex, buf);
		    break;

		case IOTYPE_WALMART_GETPLAYBACKFPS_REQ:
    		P2PCmd_GetPlaybackFPS(avIndex, buf);
    		break;

#elif( (CHIP_OPTION == CHIP_A1025A))
		// ----------------------
		// ???WalMart 20180305 Sean
		// ----------------------

		case IOTYPE_WALMART_SETCAMERAPAIR_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraPairResp);
			SMsgAVIoctrlSetCameraPairReq *p = (SMsgAVIoctrlSetCameraPairReq *)buf;
			SMsgAVIoctrlSetCameraPairResp *q=(SMsgAVIoctrlSetCameraPairResp *)buf;
#if(HOME_RF_SUPPORT)
			gPairAvIndex = avIndex;
#endif
			DEBUG_P2P("IOTYPE_WALMART_SETCAMERAPAIR_REQ OK:%d\n\n",p->channel);

			BoxExtKey = p->channel;

			uiSentKeyToUi(UI_KEY_CAM_PAIR);

			//if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_SETCAMERAPAIR_RESP, (char*)q, size)== AV_ER_NoERROR)
			//{
			//	DEBUG_P2P("IOTYPE_WALMART_SETCAMERAPAIR_RESP OK\n\n");
			//}
		}
		break;

		case IOTYPE_WALMART_GETCAMERASTASUS_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraStatusResp);
			SMsgAVIoctrlGetCameraStatusReq *p = (SMsgAVIoctrlGetCameraStatusReq *)buf;
			SMsgAVIoctrlGetCameraStatusResp *q=(SMsgAVIoctrlGetCameraStatusResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETCAMERASTASUS_REQ %d %d OK\n\n",  p->channel, gRfiu_Op_Sta[p->channel]);


			if (gRfiu_Op_Sta[p->channel] == RFIU_RX_STA_LINK_OK)
				q->status = 1;
			else
				q->status = 0;
			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_GETCAMERASTASUS_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETCAMERASTASUS_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETCAMERASTASUS_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraStatusResp);
			SMsgAVIoctrlSetCameraStatusReq *p = (SMsgAVIoctrlSetCameraStatusReq *)buf;
			SMsgAVIoctrlSetCameraStatusResp *q=(SMsgAVIoctrlSetCameraStatusResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETCAMERASTASUS_REQ OK,%d\n\n",p->channel);

			BoxExtKey = p->channel;
			iconflag[UI_MENU_SETIDX_CH1_ON + p->channel] = p->status;

			uiSentKeyToUi(UI_KEY_CAM_ON);
			q->result = 0;

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_SETCAMERASTASUS_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETCAMERASTASUS_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETCAMERABRIT_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraBrightnessResp);
			SMsgAVIoctrlGetCameraBrightnessReq *p = (SMsgAVIoctrlGetCameraBrightnessReq *)buf;
			SMsgAVIoctrlGetCameraBrightnessResp *q=(SMsgAVIoctrlGetCameraBrightnessResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETCAMERABRIT_REQ OK:%d\n\n",p->channel);

			q->status = iconflag[UI_MENU_SETIDX_BRIGHTNESS_CH1 + p->channel];

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_GETCAMERABRIT_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETCAMERABRIT_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETCAMERABRIT_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraBrightnessResp);
			SMsgAVIoctrlSetCameraBrightnessReq *p = (SMsgAVIoctrlSetCameraBrightnessReq *)buf;
			SMsgAVIoctrlSetCameraBrightnessResp *q=(SMsgAVIoctrlSetCameraBrightnessResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETCAMERABRIT_REQ OK:%d\n\n",p->channel);

			BoxExtKey = p->channel;
			iconflag[UI_MENU_SETIDX_BRIGHTNESS_CH1 + p->channel] = p->status;

			uiSentKeyToUi(UI_KEY_CAM_BRIGHTNESS);
			q->result = 0;

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_SETCAMERABRIT_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETCAMERABRIT_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETCAMERAFREQ_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraFreqResp);
			SMsgAVIoctrlGetCameraFreqReq *p = (SMsgAVIoctrlGetCameraFreqReq *)buf;
			SMsgAVIoctrlGetCameraFreqResp *q=(SMsgAVIoctrlGetCameraFreqResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETCAMERAFREQ_REQ OK\n\n");

			q->status = 1;//iconflag[UI_MENU_SETIDX_50HZ_60HZ];			//Paul modify for debug only

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_GETCAMERAFREQ_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETCAMERAFREQ_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETCAMERAFREQ_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraFreqResp);
			SMsgAVIoctrlSetCameraFreqReq *p = (SMsgAVIoctrlSetCameraFreqReq *)buf;
			SMsgAVIoctrlSetCameraFreqResp *q=(SMsgAVIoctrlSetCameraFreqResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETCAMERAFREQ_REQ OK\n\n");

			BoxExtKey = 0;
			iconflag[UI_MENU_SETIDX_50HZ_60HZ] = p->status;

			uiSentKeyToUi(UI_KEY_CAM_FLICKER);

			q->result = 0;

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_SETCAMERAFREQ_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETCAMERAFREQ_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETRECORDMANUAL_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetManualRecordResp);
			SMsgAVIoctrlGetManualRecordReq *p = (SMsgAVIoctrlGetManualRecordReq *)buf;
			SMsgAVIoctrlGetManualRecordResp *q=(SMsgAVIoctrlGetManualRecordResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETRECORDMANUAL_REQ OK\n\n");

			if(MultiChannelGetCaptureVideoStatus(p->channel) == 1)
				q->status = 1;
			else
				q->status = 0;

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_GETRECORDMANUAL_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETRECORDMANUAL_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETLIVEVIEWDATARATE_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetLiveViewDataRateReq);
			SMsgAVIoctrlGetLiveViewDataRateReq *p = (SMsgAVIoctrlGetLiveViewDataRateReq *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETLIVEVIEWDATARATE_REQ OKl bitRate=%d, index=%d\n\n", p->bitRate, p->lastFrameIndex);

		}
		break;

		case IOTYPE_WALMART_SETRECORDMANUAL_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetManualRecordResp);
			SMsgAVIoctrlSetManualRecordReq *p = (SMsgAVIoctrlSetManualRecordReq *)buf;
			SMsgAVIoctrlSetManualRecordResp *q=(SMsgAVIoctrlSetManualRecordResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETRECORDMANUAL_REQ OK\n\n");

			BoxExtKey = p->channel;
			if(gSystemStorageReady == 1)
			{
				uiSentKeyToUi(UI_KEY_CAM_MANUAL_REC);
				q->result = 0;
			}
			else
				q->result = 1; //SD card Not ready.

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_SETRECORDMANUAL_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETRECORDMANUAL_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETRECORDMOTIONLEV_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraMotionLevelResp);
			SMsgAVIoctrlGetCameraMotionLevelReq *p = (SMsgAVIoctrlGetCameraMotionLevelReq *)buf;
			SMsgAVIoctrlGetCameraMotionLevelResp *q=(SMsgAVIoctrlGetCameraMotionLevelResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETRECORDMOTIONLEV_REQ OK\n\n");

			q->status =	iconflag[UI_MENU_SETIDX_MOTION_SENSITIVITY_CH1 + p->channel];


			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_GETRECORDMOTIONLEV_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETRECORDMOTIONLEV_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETRECORDMOTIONLEV_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraMotionLevelResp);
			SMsgAVIoctrlSetCameraMotionLevelReq *p = (SMsgAVIoctrlSetCameraMotionLevelReq *)buf;
			SMsgAVIoctrlSetCameraMotionLevelResp *q=(SMsgAVIoctrlSetCameraMotionLevelResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETRECORDMOTIONLEV_REQ OK\n\n");


			BoxExtKey = p->channel;

			iconflag[UI_MENU_SETIDX_MOTION_SENSITIVITY_CH1 + p->channel] = p->status;

			uiSentKeyToUi(UI_KEY_CAM_SENSITIVITY);

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_SETRECORDMOTIONLEV_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETRECORDMOTIONLEV_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETRECORDSCHEDULE_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraRecordScheduleResp);
			SMsgAVIoctrlGetCameraRecordScheduleReq *p = (SMsgAVIoctrlGetCameraRecordScheduleReq *)buf;
			SMsgAVIoctrlGetCameraRecordScheduleResp *q=(SMsgAVIoctrlGetCameraRecordScheduleResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETRECORDSCHEDULE_REQ OK,%d\n\n",p->channel);

			for(j=0;j<56;j++)
			{
				q->status[j] = uiScheduleTime[j/8][p->channel][3*(j%8)];
				//if(j%8 == 0)
				//	printf("\n");
				//printf("\x1B[96m%d \x1B[0m",q->status[j]);
			}

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_GETRECORDSCHEDULE_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETRECORDSCHEDULE_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETRECORDSCHEDULE_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraRecordScheduleResp);
			SMsgAVIoctrlSetCameraRecordScheduleReq *p = (SMsgAVIoctrlSetCameraRecordScheduleReq *)buf;
			SMsgAVIoctrlSetCameraRecordScheduleResp *q=(SMsgAVIoctrlSetCameraRecordScheduleResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETRECORDSCHEDULE_REQ OK,%d\n\n",p->channel);

			for(j=0;j<56;j++)
			{
				//if(j%8 == 0)
				//	printf("\n");
				for(k=0;k<3;k++)
				{
					uiScheduleTime[j/8][p->channel][k + 3*(j%8)] = p->status[j];
				}
				//printf("%d ",p->status[j]);
			}

			/*
			for(j=0;j<7;j++)
			{
					printf("\n");
				for(k=0;k<8;k++)
					printf("\x1B[96m%d \x1B[0m",uiScheduleTime[j][p->channel][k*3]);
			}
			*/
			BoxExtKey = p->channel;
			uiSentKeyToUi(UI_KEY_CAM_SCHEDULE);
			q->result = 0;

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_SETRECORDSCHEDULE_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETRECORDSCHEDULE_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETRECORDDURATION_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraRecordDurationResp);
			SMsgAVIoctrlGetCameraRecordDurationResp *q=(SMsgAVIoctrlGetCameraRecordDurationResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETRECORDDURATION_REQ OK\n\n");

			q->status = iconflag[UI_MENU_SETIDX_SECTION];

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_GETRECORDDURATION_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETRECORDDURATION_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETRECORDDURATION_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraRecordDurationResp);

			SMsgAVIoctrlSetCameraRecordDurationReq *p=(SMsgAVIoctrlSetCameraRecordDurationReq *)buf;
			SMsgAVIoctrlSetCameraRecordDurationResp *q=(SMsgAVIoctrlSetCameraRecordDurationResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETRECORDDURATION_REQ OK\n\n");

			BoxExtKey = 0;
			iconflag[UI_MENU_SETIDX_SECTION] = p->status;

			uiSentKeyToUi(UI_KEY_CAM_INTERVAL);

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_SETRECORDDURATION_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETRECORDDURATION_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETSDFORMAT_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraSDFormatResp);
			SMsgAVIoctrlSetCameraSDFormatResp *q=(SMsgAVIoctrlSetCameraSDFormatResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETSDFORMAT_REQ OK\n\n");

			BoxExtKey = 0;
	        iconflag[UI_MENU_SETIDX_FORMAT] = 0;

			uiSentKeyToUi(UI_KEY_SD_FORMAT);
			q->result = 0;

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_SETSDFORMAT_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETSDFORMAT_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETSDOVERWRITE_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraSDOverWriteResp);

			SMsgAVIoctrlGetCameraSDOverWriteResp *q=(SMsgAVIoctrlGetCameraSDOverWriteResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETSDOVERWRITE_REQ OK\n\n");

			q->status = iconflag[UI_MENU_SETIDX_OVERWRITE];



			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_GETSDOVERWRITE_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETSDOVERWRITE_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETSDOVERWRITE_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraSDOverWriteResp);

			SMsgAVIoctrlSetCameraSDOverWriteReq *p=(SMsgAVIoctrlSetCameraSDOverWriteReq *)buf;
			SMsgAVIoctrlSetCameraSDOverWriteResp *q=(SMsgAVIoctrlSetCameraSDOverWriteResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETSDOVERWRITE_REQ OK\n\n");

			BoxExtKey = 0;
			iconflag[UI_MENU_SETIDX_OVERWRITE] = p->status;

			uiSentKeyToUi(UI_KEY_SD_OVERWRITE);

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_SETSDOVERWRITE_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETSDOVERWRITE_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETSYSTIME_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraSystemTimeResp);

			SMsgAVIoctrlGetCameraSystemTimeResp *q=(SMsgAVIoctrlGetCameraSystemTimeResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETSYSTIME_REQ OK\n\n");

			RTC_Get_Time(&SetTime);

			q->time[0] = SetTime.year;
			q->time[1] = SetTime.month;
			q->time[2] = SetTime.day;
			q->time[3] = SetTime.hour;
			q->time[4] = SetTime.min;

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_GETSYSTIME_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETSYSTIME_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETSYSTIME_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraSystemTimeResp);

			SMsgAVIoctrlSetCameraSystemTimeReq *p=(SMsgAVIoctrlSetCameraSystemTimeReq *)buf;
			SMsgAVIoctrlSetCameraSystemTimeResp *q=(SMsgAVIoctrlSetCameraSystemTimeResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETSYSTIME_REQ OK\n\n");

			SetTime.year 	= p->time[0];
			SetTime.month 	= p->time[1];
			SetTime.day		= p->time[2];
			SetTime.hour	= p->time[3];
			SetTime.min		= p->time[4];
			SetTime.sec		= 0;
			BoxExtKey = 0;
			iconflag[UI_MENU_SETIDX_DATE_TIME] = 1;

			uiSentKeyToUi(UI_KEY_SYS_TIME);
			//RTC_Set_Time(&SetTime);
			q->result = 0;

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_SETSYSTIME_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETSYSTIME_RESP OK\n\n");
			}
		}
		break;


		case IOTYPE_WALMART_SETDEFAULT_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraSystemTimeResp);

			SMsgAVIoctrlSetCameraDefaultResp *q=(SMsgAVIoctrlSetCameraDefaultResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETDEFAULT_REQ OK\n\n");

			BoxExtKey = 0;
			iconflag[UI_MENU_SETIDX_DEFAULT] = 0;
			uiSentKeyToUi(UI_KEY_SYS_DEFAULT);
			q->result = 0;


			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_SETDEFAULT_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETDEFAULT_RESP OK\n\n");
			}
		}
		break;


		case IOTYPE_WALMART_GETLANG_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraLanguageResp);

			SMsgAVIoctrlGetCameraLanguageResp *q=(SMsgAVIoctrlGetCameraLanguageResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETLANG_REQ OK\n\n");

			q->status = iconflag[UI_MENU_SETIDX_LANGUAGE];

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_GETLANG_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETLANG_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETLANG_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraLanguageResp);

			SMsgAVIoctrlSetCameraLanguageReq *p=(SMsgAVIoctrlSetCameraLanguageReq *)buf;
			SMsgAVIoctrlSetCameraLanguageResp *q=(SMsgAVIoctrlSetCameraLanguageResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETLANG_REQ OK\n\n");

			BoxExtKey = 0;
			iconflag[UI_MENU_SETIDX_LANGUAGE] = p->status;

			uiSentKeyToUi(UI_KEY_SYS_LANGUAGE);

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_SETLANG_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETLANG_RESP OK\n\n");
			}
		}
		break;


		case IOTYPE_WALMART_GETNETSTATUS_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraNetStatusResp);
			struct NetworkInfo info;
			SMsgAVIoctrlGetCameraNetStatusResp *q=(SMsgAVIoctrlGetCameraNetStatusResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETNETSTATUS_REQ OK\n\n");

			GetNetworkInfo(&info);

			sprintf(q->ipAddress,"%d.%d.%d.%d",info.IPaddr[0],info.IPaddr[1],info.IPaddr[2],info.IPaddr[3]);
			sprintf(q->gateway,"%d.%d.%d.%d",info.Gateway[0],info.Gateway[1],info.Gateway[2],info.Gateway[3]);
			sprintf(q->mask,"%d.%d.%d.%d",info.Netmask[0],info.Netmask[1],info.Netmask[2],info.Netmask[3]);
			sprintf(q->MAC,"%d-%d-%d-%d-%d-%d",uiMACAddr[0],uiMACAddr[1],uiMACAddr[2],uiMACAddr[3],uiMACAddr[4],uiMACAddr[5]);
			sprintf(q->UID,"%s",gUID);

			DEBUG_P2P("IP=%s\n",q->ipAddress);
			DEBUG_P2P("Netmask=%s\n",q->mask);
			DEBUG_P2P("Gateway=%s\n",q->gateway);
			DEBUG_P2P("MAC=%s\n",q->MAC);
			DEBUG_P2P("UID=%s\n",q->UID);

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_GETNETSTATUS_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETNETSTATUS_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETNETSTATUS_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraNetStatusResp);

			SMsgAVIoctrlSetCameraNetStatusReq *p=(SMsgAVIoctrlSetCameraNetStatusReq *)buf;
			SMsgAVIoctrlSetCameraNetStatusResp *q=(SMsgAVIoctrlSetCameraNetStatusResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETNETSTATUS_REQ OK\n\n");





			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_SETNETSTATUS_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETNETSTATUS_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETLED_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetLEDResq);

			SMsgAVIoctrlGetLEDResq *q=(SMsgAVIoctrlGetLEDResq *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETLED_REQ OK\n\n");

			gpioGetLevel(0, 31, &LED_level);

			q->status = LED_level;

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_GETLED_RESQ, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETLED_RESQ OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETLED_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetLEDResq);

			SMsgAVIoctrlSetLEDReq *p=(SMsgAVIoctrlSetLEDReq *)buf;
			SMsgAVIoctrlSetLEDResq *q=(SMsgAVIoctrlSetLEDResq *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETLED_REQ OK\n\n");

			q->result = !(gpioSetLevel(0, 31, p->status));

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_SETLED_RESQ, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETLED_RESQ OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETPLAYBACKFPS_REQ:
		{
			SMsgAVIoctrlGetPlayBackFPSReq *p=(SMsgAVIoctrlGetPlayBackFPSReq *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETPLAYBACKFPS_REQ OK:%d\n\n",p->FPS);

//			app_report_fps = p->FPS;
		}
		break;
#endif
		case IOTYPE_WALMART_GETCAMERASTASUS_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraStatusResp);
			SMsgAVIoctrlGetCameraStatusReq *p = (SMsgAVIoctrlGetCameraStatusReq *)buf;
			SMsgAVIoctrlGetCameraStatusResp *q=(SMsgAVIoctrlGetCameraStatusResp *)buf;

			
    u8 value[4]; 
    u8 i, result;
DEBUG_P2P("IOTYPE_WALMART_GETCAMERASTASUS_REQ %d %d OK\n\n",  p->channel, gRfiu_Op_Sta[p->channel]);
    for (i = 0;i < 4; i++)
    {
			if (gRfiu_Op_Sta[i] == RFIU_RX_STA_LINK_OK)
				value[i] = 1;
			else
				value[i] = 0;

    }

    q->channel1[0] = value[0];
    q->channel2[0] = value[1];
    q->channel3[0] = value[2];
    q->channel4[0] = value[3];
			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_GETCAMERASTASUS_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETCAMERASTASUS_RESP OK\n\n");
			}
		}
		break;
//--------------------Home Automation testing--------------------------------------------------------------
#if (HOME_RF_SUPPORT == 1)
// ??HA cmd???cmd???

        case IOTYPE_HA_JASON_CMD_REQ:
        {
		char msg[1024];
		DEBUG_P2P("IOTYPE_HA_JASON_CMD_REQ OK\n");

		//DEBUG_GREEN("%s\n",buf);
		
            result = JSONCmdHandleEvent(buf, msg);

	     //20181204 PAIR???task??DRESP

		if(result == 0) //PAIR mode
		{
			gPairAvIndex = avIndex;
			break;
		}

		if(result == 1)
		{
			//DEBUG_YELLOW("strlen(buf)2:%d, %s\n",strlen(buf), buf);

	            if(avSendIOCtrl3(avIndex, IOTYPE_HA_JASON_CMD_RESP, (char*)buf, strlen(buf))== AV_ER_NoERROR)
	                        DEBUG_P2P("IOTYPE_HA_JASON_CMD_RESP OK\n\n");
		}
		else
		{
			//DEBUG_BLUE("strlen(buf):%d, %s\n",strlen(msg), msg);

	            if(avSendIOCtrl3(avIndex, IOTYPE_HA_JASON_CMD_RESP, (char*)&msg, strlen(msg))== AV_ER_NoERROR)
	                        DEBUG_P2P("IOTYPE_HA_JASON_CMD_RESP OK\n\n");
		}
		memset(buf, 0, 1024);
        }
        break;
		
#elif 0//(HOME_RF_SUPPORT)

            
        case IOTYPE_USER_GETSENSORLST_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetSensorLstResp);
            SMsgAVIoctrlGetSensorLstReq *p = (SMsgAVIoctrlGetSensorLstReq *)buf;
            SMsgAVIoctrlGetSensorLstResp *q=(SMsgAVIoctrlGetSensorLstResp *)buf;

#if sensor_test
            sysAppGetSensorList(q,0);
#else
            q->nCount=3;
            q->nStartIdx=0;
            q->nTotalCount=3;
            q->sSensors[0].bytePushAlarm=1;
            q->sSensors[0].byteBattery=100;
            q->sSensors[0].byteStatus= mrss_Normal;
            q->sSensors[0].byteType= mrst_Door;
            q->sSensors[0].nSensorID=11;
            q->sSensors[0].byteSirenAlarm=1;
            q->sSensors[0].data.door.nIsOpen=1;
            q->sSensors[0].byteIsHealthType=0;
            strcpy (q->sSensors[0].szName,"test_door");

            q->sSensors[1].bytePushAlarm=1;
            q->sSensors[1].byteBattery=100;
            q->sSensors[1].byteStatus= mrss_Normal;
            q->sSensors[1].byteType= mrst_PIR;
            q->sSensors[1].nSensorID=12;
            q->sSensors[1].byteIsHealthType=0;
            strcpy (q->sSensors[1].szName,"test_pir");

            q->sSensors[2].bytePushAlarm=1;
            q->sSensors[2].byteBattery=100;
            q->sSensors[2].byteStatus= mrss_Normal;
            q->sSensors[2].byteType= mrst_Temperature;
            q->sSensors[2].nSensorID=13;
            q->sSensors[2].byteSirenAlarm=1;
            q->sSensors[2].byteIsHealthType=0;
            q->sSensors[2].data.tp.nTemperature=0x1D05;
            q->sSensors[2].data.tp.nHigh=0x3200;
            q->sSensors[2].data.tp.nLow=0x0500;
            q->sSensors[2].data.tp.nAlarmSwitch = 0x3;
            strcpy (q->sSensors[2].szName,"test_temperature");
#endif
            DEBUG_P2P("GETSENSORLST_REQ OK \n");

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_GETSENSORLST_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETSENSORLST_RESP OK\n\n");
            }
            if(q->nTotalCount > MAXSENSOR_NUM_ONCE)
            {
                for(i = 0; i < (q->nTotalCount)/(MAXSENSOR_NUM_ONCE+1); i++)
                {
                    sysAppGetSensorList(q,i+1);
                    if(avSendIOCtrl3(avIndex, IOTYPE_USER_GETSENSORLST_RESP, (char*)q, size)== AV_ER_NoERROR)
                        DEBUG_P2P("GETSENSORLST_RESP_%d OK\n\n",i+2);
                }
            }
        }
        break;

        case IOTYPE_USER_SETADDSENSOR_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetAddSensorResp);
            SMsgAVIoctrlSetAddSensorReq *p = (SMsgAVIoctrlSetAddSensorReq *)buf;
            SMsgAVIoctrlSetAddSensorResp *q=(SMsgAVIoctrlSetAddSensorResp *)buf;
            gPairAvIndex = avIndex;
            DEBUG_P2P("SETADDSENSOR_REQ OK \n");
#if sensor_test
            sysAppEnterPairMode();
#else
            q->result=0;
            q->sSensor.nSensorID=100+sensor_id_add;
            sensor_id_add++;
            q->sSensor.bytePushAlarm=1;
            q->sSensor.byteBattery=100;
            q->sSensor.byteStatus=1;
            q->sSensor.byteType=0;
            q->sSensor.data.door.nIsOpen=1;
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_SETADDSENSOR_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETADDSENSOR_RESP OK\n\n");
            }
#endif
        }
        break;

        case IOTYPE_USER_SETEDITSENSOR_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetEditSensorResp);
            SMsgAVIoctrlSetEditSensorReq *p = (SMsgAVIoctrlSetEditSensorReq *)buf;
            SMsgAVIoctrlSetEditSensorResp *q=(SMsgAVIoctrlSetEditSensorResp *)buf;

            DEBUG_P2P("SETEDITSENSOR_REQ OK \n");

#if sensor_test
            q->result = sysAppEditSensor(p);
#else
            q->result=0;
#endif

            DEBUG_P2P("\nEdit SENSOR: %d %d,%d,%d,%d,%x,%s\n",p->sSensor.byteSirenAlarm,p->sSensor.bytePushAlarm,p->sSensor.byteBattery,p->sSensor.byteStatus,p->sSensor.byteType,p->sSensor.nSensorID,p->sSensor.szName);
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_SETEDITSENSOR_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETEDITSENSOR_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_SETDELSENSOR_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetDelSensorResp);
            SMsgAVIoctrlSetDelSensorReq *p = (SMsgAVIoctrlSetDelSensorReq *)buf;
            SMsgAVIoctrlSetDelSensorResp *q=(SMsgAVIoctrlSetDelSensorResp *)buf;

            DEBUG_P2P("SETDELSENSOR_REQ OK \n");
#if sensor_test
            q->result = sysAppDeleteSensor(p);
            UpdateAPPSensorListStatus();
#else
            q->result=0;
#endif
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_SETDELSENSOR_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETDELSENSOR_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_GETROOMLST_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetRoomLstResp);
            SMsgAVIoctrlGetRoomLstReq *p = (SMsgAVIoctrlGetRoomLstReq *)buf;
            SMsgAVIoctrlGetRoomLstResp *q=(SMsgAVIoctrlGetRoomLstResp *)buf;

            DEBUG_P2P("GETROOMLST_REQ OK \n");

#if room_test
            sysAppGetRoomList(q,0);
            //if(q->nTotalCount == 0)
#else
            q->nCount=2;
            q->nStartIdx=0;
            q->nTotalCount=2;
            q->sRooms[0].nRoomID=33;
            q->sRooms[0].nSensorCount=3;
            strcpy(q->sRooms[0].szName,"Living room");
            q->sRooms[0].nSensors[0]=11;
            q->sRooms[0].nSensors[1]=12;
            q->sRooms[0].nSensors[2]=13;

            q->sRooms[1].nRoomID=34;
            q->sRooms[1].nSensorCount=2;
            strcpy(q->sRooms[1].szName,"Bed room");
            q->sRooms[1].nSensors[0]=12;
            q->sRooms[1].nSensors[1]=13;
#endif
            DEBUG_P2P("\nGET ROOM : %d, %d, %d \n",q->nCount,q->nStartIdx,q->nTotalCount);

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_GETROOMLST_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETROOMLST_RESP OK\n\n");
            }
            if(q->nTotalCount > MAXROOM_NUM_ONCE)
            {
                for(i = 0; i < (q->nTotalCount)/(MAXROOM_NUM_ONCE+1); i++)
                {
                    sysAppGetRoomList(q,i+1);
                    if(avSendIOCtrl3(avIndex, IOTYPE_USER_GETROOMLST_RESP, (char*)q, size)== AV_ER_NoERROR)
                        DEBUG_P2P("GETROOMLST_RESP_%d OK\n\n",i+2);
                }
            }
        }
        break;

        case IOTYPE_USER_SETADDROOM_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetAddRoomResp);
            SMsgAVIoctrlSetAddRoomReq *p = (SMsgAVIoctrlSetAddRoomReq *)buf;
            SMsgAVIoctrlSetAddRoomResp *q=(SMsgAVIoctrlSetAddRoomResp *)buf;

            DEBUG_P2P("SETADDROOM_REQ OK \n");
            DEBUG_P2P("\nSET ADD ROOM : %d, %d, %d, %s\n",p->sRoom.nRoomID,p->sRoom.nSensorCount,p->sRoom.nSensors[0],p->sRoom.szName);

#if room_test
            q->sRoom.nRoomID = sysAppAddRoom(p);
            UpdateAPPRoomListStatus();
            if(q->sRoom.nRoomID == 0)
                q->sRoom.nRoomID = -1; //?s?W???? ?W?L??jRoom??q
#else
            q->sRoom.nRoomID=100+room_id_add;
            room_id_add++;
#endif
            DEBUG_P2P("q->sRoom.nRoomID = 0x%x\n",q->sRoom.nRoomID);
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_SETADDROOM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETADDROOM_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_SETEDITROOM_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetEditRoomResp);
            SMsgAVIoctrlSetEditRoomReq *p = (SMsgAVIoctrlSetEditRoomReq *)buf;
            SMsgAVIoctrlSetEditRoomResp *q=(SMsgAVIoctrlSetEditRoomResp *)buf;

            DEBUG_P2P("SETEDITROOM_REQ OK \n");

#if room_test
            q->result = sysAppEditRoom(p);
            UpdateAPPRoomListStatus();
#else
            q->result=0;
#endif
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_SETEDITROOM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETEDITROOM_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_SETDELROOM_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetDelRoomResp);
            SMsgAVIoctrlSetDelRoomReq *p = (SMsgAVIoctrlSetDelRoomReq *)buf;
            SMsgAVIoctrlSetDelRoomResp *q=(SMsgAVIoctrlSetDelRoomResp *)buf;

            DEBUG_P2P("SETDELROOM_REQ OK \n");
#if room_test
            q->result = sysAppDeleteRoom(p);
            UpdateAPPRoomListStatus();
#else
            q->result=0;
#endif
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_SETDELROOM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETDELROOM_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_GETIPCAMSUPPORT_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetIPCamSupportResp);
            SMsgAVIoctrlGetIPCamSupportReq *p = (SMsgAVIoctrlGetIPCamSupportReq *)buf;
            SMsgAVIoctrlGetIPCamSupportResp *q=(SMsgAVIoctrlGetIPCamSupportResp *)buf;

            DEBUG_P2P("GETIPCAMSUPPORT_REQ OK \n");
            q->nIsSupport=1;
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_GETIPCAMSUPPORT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETIPCAMSUPPORT_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_GETSENSOR_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetSensorResp);
            SMsgAVIoctrlGetSensorReq *p = (SMsgAVIoctrlGetSensorReq *)buf;
            SMsgAVIoctrlGetSensorResp *q= (SMsgAVIoctrlGetSensorResp *)buf;

            DEBUG_P2P("GETSENSOR_REQ OK \n");
#if sensor_test
            sysAppGetSensor(p->nSensorID,q);
#else
            if(p->nSensorID == 11)
            {
                q->sSensor.nSensorID = p->nSensorID;
                q->sSensor.byteStatus= mrss_Normal;
                q->sSensor.byteType= mrst_Door;
                q->sSensor.data.door.nIsOpen=1;
                strcpy(q->sSensor.szName,"test_door");
                q->result=0;
            }
            else if(p->nSensorID == 12)
            {
                q->sSensor.nSensorID = p->nSensorID;
                q->sSensor.byteStatus= mrss_Normal;
                q->sSensor.byteType= mrst_PIR;
                strcpy(q->sSensor.szName,"test_pir");
                q->result=0;
            }
            else if(p->nSensorID == 13)
            {
                q->sSensor.nSensorID = p->nSensorID;
                q->sSensor.byteStatus= mrss_Normal;
                q->sSensor.byteType= mrst_Temperature;
                q->sSensor.data.tp.nTemperature=0x1D05;
                q->sSensor.data.tp.nHigh=0x3200;
                q->sSensor.data.tp.nLow=0x0500;
                q->sSensor.data.tp.nAlarmSwitch = 0x3;
                strcpy(q->sSensor.szName,"test_temperature");
                q->result=0;
            }
            else
                return;
            q->sSensor.bytePushAlarm=1;
            q->sSensor.byteBattery=100;
#endif
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_GETSENSOR_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETSENSOR_RESP OK\n\n");
            }
        }
        break;



        case IOTYPE_USER_GETSENSORLOG_REQ:
        {
            u8 idx;
            int size =  sizeof(SMsgAVIoctrlGetSensorLogResp);
            SMsgAVIoctrlGetSensorLogReq *p = (SMsgAVIoctrlGetSensorLogReq *)buf;
            SMsgAVIoctrlGetSensorLogResp *q= (SMsgAVIoctrlGetSensorLogResp *)buf;

            DEBUG_P2P("GETSENSORLOG_REQ OK \n");

            idx=sysGetUISensorListIdx(p->nSensorID);

#if CDVR_iHome_LOG_SUPPORT
            sysAppGetSensorLog(p->nSensorID,q,p->nStartIdx);
#endif

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_GETSENSORLOG_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETSENSORLOG_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_GETSCENCELST_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetSceneLstResp);
            SMsgAVIoctrlGetSceneLstReq *p = (SMsgAVIoctrlGetSceneLstReq *)buf;
            SMsgAVIoctrlGetSceneLstResp *q= (SMsgAVIoctrlGetSceneLstResp *)buf;

            sysAppGetSceneList(q,0);

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_GETSCENCELST_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETSCENCELST_RESP OK\n\n");
            }
            if(q->nTotalCount > MAXSCENE_NUM_ONCE)
            {
                for(i = 0; i < (q->nTotalCount)/(MAXSCENE_NUM_ONCE+1); i++)
                {
                    sysAppGetSceneList(q,i+1);
                    if(avSendIOCtrl3(avIndex, IOTYPE_USER_GETSCENCELST_RESP, (char*)q, size)== AV_ER_NoERROR)
                        DEBUG_P2P("GETSCENCELST_RESP_%d OK\n\n",i+2);
                }
            }
        }
        break;

        case IOTYPE_USER_SETADDSCENEHEAD_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetAddSceneHeadResp);
            SMsgAVIoctrlSetAddSceneHeadReq *p = (SMsgAVIoctrlSetAddSceneHeadReq *)buf;
            SMsgAVIoctrlSetAddSceneHeadResp *q= (SMsgAVIoctrlSetAddSceneHeadResp *)buf;

            q->sScene.nSceneID = sysAppAddScene(p);
            UpdateAPPSceneListStatus();
            //if(p->sScene.nSceneID != -1)
            //    break;

            DEBUG_P2P("SETADDSCENEHEAD_REQ OK \n");

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_SETADDSCENEHEAD_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETADDSCENEHEAD_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_GETSCENE_REQ:
        {
            int GetSceneID;
            int size =  sizeof(SMsgAVIoctrlGetSceneResp);
            SMsgAVIoctrlGetSceneReq *p = (SMsgAVIoctrlGetSceneReq *)buf;
            SMsgAVIoctrlGetSceneResp *q= (SMsgAVIoctrlGetSceneResp *)buf;

            DEBUG_P2P("GETSCENE_REQ OK \n");

            GetSceneID = p->nSceneID;
            sysAppGetScene(GetSceneID,q,0);

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_GETSCENE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETSCENE_RESP OK\n\n");
            }
            if(q->nTotalCount > MAXSENSOR_NUM_ONCE)
            {
                for(i = 0; i < (q->nTotalCount)/MAXSENSOR_NUM_ONCE; i++)
                {
                    sysAppGetScene(GetSceneID,q,i+1);
                    if(avSendIOCtrl3(avIndex, IOTYPE_USER_GETSCENE_RESP, (char*)q, size)== AV_ER_NoERROR)
                        DEBUG_P2P("GETSCENE_RESP_%d OK\n\n",i+2);
                }
            }
        }
        break;

        case IOTYPE_USER_SETEDITSCENEHEAD_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetEditSceneHeadResp);
            SMsgAVIoctrlSetEditSceneHeadReq *p = (SMsgAVIoctrlSetEditSceneHeadReq *)buf;
            SMsgAVIoctrlSetEditSceneHeadResp *q= (SMsgAVIoctrlSetEditSceneHeadResp *)buf;

            DEBUG_P2P("SETEDITSCENEHEAD_REQ OK \n");

            q->result = sysAppEditSceneName(p);
            UpdateAPPSceneListStatus();

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_SETEDITSCENEHEAD_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETEDITSCENEHEAD_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_SETEDITSCENE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetEditSceneResp);
            SMsgAVIoctrlSetEditSceneReq *p = (SMsgAVIoctrlSetEditSceneReq *)buf;
            SMsgAVIoctrlSetEditSceneResp *q= (SMsgAVIoctrlSetEditSceneResp *)buf;

            DEBUG_P2P("SETEDITSCENE_REQ OK \n");

            q->result = sysAppEditScene(p,0);
            UpdateAPPSceneListStatus();
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_SETEDITSCENE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETEDITSCENE_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_SETDELSCENE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetDelSceneResp);
            SMsgAVIoctrlSetDelSceneReq *p = (SMsgAVIoctrlSetDelSceneReq *)buf;
            SMsgAVIoctrlSetDelSceneResp *q= (SMsgAVIoctrlSetDelSceneResp *)buf;

            DEBUG_P2P("SETDELSCENE_REQ OK \n");

            q->result = sysAppDeleteScene(p);
            UpdateAPPSceneListStatus();

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_SETDELSCENE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETDELSCENE_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_PLAYSCENE_REQ:
        {
            int size = sizeof(SMsgAVIoctrlPlaySceneResp);
            SMsgAVIoctrlPlaySceneReq *p = (SMsgAVIoctrlPlaySceneReq *)buf;
            SMsgAVIoctrlPlaySceneResp *q= (SMsgAVIoctrlPlaySceneResp *)buf;

            DEBUG_P2P("PLAYSCENE_REQ OK \n");

            q->result = sysAppExecuteScene(p->nSceneID);

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_PLAYSCENE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("PLAYSCENE_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_IPCAM_VERIFYVERSION_REQ:
        {
            int size = sizeof(SMsgAVIoctrlVerifyVersionResp);
            SMsgAVIoctrlVerifyVersionReq *p = (SMsgAVIoctrlVerifyVersionReq *)buf;
            SMsgAVIoctrlVerifyVersionResp *q= (SMsgAVIoctrlVerifyVersionResp *)buf;

            DEBUG_P2P("IPCAM_VERIFYVERSION_REQ OK \n");

            if(p->version[0] == APPversion_IOS[0])
            {
                if(p->version[4] == APPversion_IOS[4])
                {
                    q->result = 0;
                }
                else if(p->version[4] < APPversion_IOS[4])
                {
                    q->result = 1;
                }
                else if(p->version[4] > APPversion_IOS[4])
                {
                    q->result = 2;
                }
            }
            if(p->version[0] == APPversion_AND[0])
            {
                if(p->version[4] == APPversion_AND[4])
                {
                    q->result = 0;
                }
                else if(p->version[4] < APPversion_AND[4])
                {
                    q->result = 1;
                }
                else if(p->version[4] > APPversion_AND[4])
                {
                    q->result = 2;
                }
            }

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_VERIFYVERSION_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_VERIFYVERSION_RESP OK\n\n");
            }
        }
        break;
#endif /*#if (HOME_RF_SUPPORT)*/
//--------------------

#if APP_KEEP_ALIVE
        /*===============================KEEP ALIVE==================================*/
        case IOTYPE_USER_IPCAM_KEEPALIVE_REQ:
        {
            i = 0;
            DEBUG_CYAN("IPCAM_KEEPALIVE_REQ:%d OK \n",SID);
            gFlagKeepAlive[SID] = 1;
            switch(SID)
            {
                case 0:
                    RTC_Get_Time(&gKeepAliveTime0);
                    break;
                case 1:
                    RTC_Get_Time(&gKeepAliveTime1);
                    break;
                case 2:
                    RTC_Get_Time(&gKeepAliveTime2);
                    break;
                case 3:
                    RTC_Get_Time(&gKeepAliveTime3);
                    break;
                case 4:
                	RTC_Get_Time(&gKeepAliveTime4);
                    break;
                default:
                    break;
            }
        }
        break;
            /*===============================KEEP ALIVE==================================*/
#endif
#if(UI_VERSION == UI_VERSION_MAYON)
#if  RFIU_RX_WAKEUP_TX_SCHEME
        case IOTYPE_USER_IPCAM_GET_TX_TYPE_REQ:
        {
            int size = sizeof(SMsgAVIoctrlGetCameraTypeResp);
            SMsgAVIoctrlGetCameraTypeReq *p = (SMsgAVIoctrlGetCameraTypeReq *)buf;
            SMsgAVIoctrlGetCameraTypeResp *q= (SMsgAVIoctrlGetCameraTypeResp *)buf;

            DEBUG_P2P("IPCAM_GET_TX_TYPE_REQ OK \n");

//			q->channel = p->channel;//In the same buf, dont need to set.		// Add by Paul for APP check batterycam channel, 180508

			q->CameraType 	= gRfiuUnitCntl[p->channel].RFpara.BateryCam_support;

			q->BatteryLevel = gRfiuUnitCntl[p->channel].RFpara.TxBatteryLev;

			if(q->BatteryLevel > 3)
				q->BatteryLevel = 3;

			if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_TX_TYPE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_GET_TX_TYPE_RESP OK\n\n");
            }

        }
        break;
#endif


        case IOTYPE_USER_IPCAM_CHECK_TX_ALARM_REQ:
        {
            int size = sizeof(SMsgAVIoctrlGetAlarmSupportResp);
            SMsgAVIoctrlGetAlarmSupportReq *p = (SMsgAVIoctrlGetAlarmSupportReq *)buf;
            SMsgAVIoctrlGetAlarmSupportResp *q= (SMsgAVIoctrlGetAlarmSupportResp *)buf;

            DEBUG_P2P("IPCAM_CHECK_TX_ALARM_REQ OK \n");

//			q->channel = p->channel;//In the same buf, dont need to set.

			q->alarmsupport	= uiGetSuptAlarmAPP(p->channel);

			if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_CHECK_TX_ALARM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_CHECK_TX_ALARM_RESP OK\n\n");
            }

        }
        break;

        case IOTYPE_USER_IPCAM_GET_TX_ALARM_REQ:
        {
            int size = sizeof(SMsgAVIoctrlGetCameraAlarmResp);
            SMsgAVIoctrlGetCameraAlarmReq *p = (SMsgAVIoctrlGetCameraAlarmReq *)buf;
            SMsgAVIoctrlGetCameraAlarmResp *q= (SMsgAVIoctrlGetCameraAlarmResp *)buf;

            DEBUG_P2P("IPCAM_GET_TX_ALARM_REQ OK \n");

            q->switch_value= uiGetAlarmOnOffAPP(p->channel);
			q->AlarmStatus = uiGetAlarmStatusAPP(p->channel);

			if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_TX_ALARM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_GET_TX_ALARM_RESP OK\n\n");
            }

        }
        break;


        case IOTYPE_USER_IPCAM_SET_TX_ALARM_REQ:
        {
            int size = sizeof(SMsgAVIoctrlSetCameraAlarmResp);
            SMsgAVIoctrlSetCameraAlarmReq *p = (SMsgAVIoctrlSetCameraAlarmReq *)buf;
            SMsgAVIoctrlSetCameraAlarmResp *q= (SMsgAVIoctrlSetCameraAlarmResp *)buf;

            DEBUG_P2P("IPCAM_SET_TX_ALARM_REQ OK \n");

			if(p->switch_value)	//ON
			{
				uiSetAlarmOnOffAPP(p->channel, 1);
				uiSetAlarmStatusAPP(p->channel, p->AlarmStatus);
			}
			else	//OFF
			{
				uiSetAlarmOnOffAPP(p->channel, 0);
			}

			q->result = 0;

			if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_SET_TX_ALARM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_SET_TX_ALARM_RESP OK\n\n");
            }

        }
        break;

        case IOTYPE_USER_IPCAM_CHECK_SUPPORT_PIR_REQ:
        {
            int size = sizeof(SMsgAVIoctrlCheckSupportPIRResp);
//			SMsgAVIoctrlCheckSupportPIRReq *p= (SMsgAVIoctrlCheckSupportPIRReq *)buf;
            SMsgAVIoctrlCheckSupportPIRResp *q= (SMsgAVIoctrlCheckSupportPIRResp *)buf;

            DEBUG_P2P("IPCAM_CHECK_SUPPORT_PIR_REQ OK \n");

//			q->channel = p->channel;//In the same buf, dont need to set.

			q->PIRsupport = 1;	//Always ON.

			if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_CHECK_SUPPORT_PIR_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_CHECK_SUPPORT_PIR_RESP OK\n\n");
            }

        }
        break;

        case IOTYPE_USER_IPCAM_GET_PIR_VALUE_REQ:
        {
            int size = sizeof(SMsgAVIoctrlGetCameraPIRResp);
            SMsgAVIoctrlGetCameraPIRReq *p = (SMsgAVIoctrlGetCameraPIRReq *)buf;
            SMsgAVIoctrlGetCameraPIRResp *q= (SMsgAVIoctrlGetCameraPIRResp *)buf;

            DEBUG_P2P("IPCAM_GET_PIR_VALUE_REQ OK \n");

			q->value = uiGetMotionStatusAPP(p->channel);

			if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_PIR_VALUE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_GET_PIR_VALUE_RESP OK\n\n");
            }

        }
        break;


        case IOTYPE_USER_IPCAM_SET_PIR_VALUE_REQ:
        {
            int size = sizeof(SMsgAVIoctrlSetCameraPIRResp);
            SMsgAVIoctrlSetCameraPIRReq *p = (SMsgAVIoctrlSetCameraPIRReq *)buf;
            SMsgAVIoctrlSetCameraPIRResp *q= (SMsgAVIoctrlSetCameraPIRResp *)buf;

            DEBUG_P2P("IPCAM_SET_PIR_VALUE_REQ OK \n");

			uiSetMotionStatusAPP(p->channel, p->value);

			if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_SET_PIR_VALUE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_SET_PIR_VALUE_RESP OK\n\n");
            }

        }
        break;


		case IOTYPE_USER_IPCAM_CHECK_SUPPORT_LIGHT_REQ:
		{
			int size = sizeof(SMsgAVIoctrlCheckSupportLightResp);
			SMsgAVIoctrlCheckSupportLightReq *p = (SMsgAVIoctrlCheckSupportLightReq *)buf;
			SMsgAVIoctrlCheckSupportLightResp *q= (SMsgAVIoctrlCheckSupportLightResp *)buf;

			DEBUG_P2P("IPCAM_CHECK_SUPPORT_LIGHT_REQ OK \n");

//			q->channel = p->channel;//In the same buf, dont need to set.

			q->Lightsupport = uiGetSuptLightAPP(p->channel);

			if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_CHECK_SUPPORT_LIGHT_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IPCAM_CHECK_SUPPORT_LIGHT_RESP OK\n\n");
			}

		}
		break;

		case IOTYPE_USER_IPCAM_GET_TX_LIGHT_REQ:
		{
			int size = sizeof(SMsgAVIoctrlGetCameraLightResp);
			SMsgAVIoctrlGetCameraLightReq *p = (SMsgAVIoctrlGetCameraLightReq *)buf;
			SMsgAVIoctrlGetCameraLightResp *q= (SMsgAVIoctrlGetCameraLightResp *)buf;

			DEBUG_P2P("IPCAM_GET_TX_LIGHT_REQ OK \n");

			q->switch_value = uiGetLightOnOffAPP(p->channel);
			q->value = uiGetLightStatusAPP(p->channel);

			if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_TX_LIGHT_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IPCAM_GET_TX_LIGHT_RESP OK\n\n");
			}

		}
		break;


		case IOTYPE_USER_IPCAM_SET_TX_LIGHT_REQ:
		{
			int size = sizeof(SMsgAVIoctrlSetCameraLightResp);
			SMsgAVIoctrlSetCameraLightReq *p = (SMsgAVIoctrlSetCameraLightReq *)buf;
			SMsgAVIoctrlSetCameraLightResp *q= (SMsgAVIoctrlSetCameraLightResp *)buf;

			DEBUG_P2P("IPCAM_SET_TX_LIGHT_REQ OK \n");

			if(p->switch_value)	//ON
			{
				uiSetLightOnOffAPP(p->channel, 1);
				uiSetLightStatusAPP(p->channel, p->value);
			}
			else	//OFF
			{
				uiSetLightOnOffAPP(p->channel, 0);
			}
			q->result = 0;

			if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_SET_TX_LIGHT_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IPCAM_SET_TX_LIGHT_RESP OK\n\n");
			}

		}
		break;
		case IOTYPE_USER_IPCAM_GET_TX_ALL_INFO_REQ:
		{//This flow move to IOTYPE_USER_IPCAM_START execute, for liveview speed up.
		//Comment add by Paul at 181019
			int size = sizeof(SMsgAVIoctrlTxAllInfoResp);
			SMsgAVIoctrlGetTxAllInfoReq *p = (SMsgAVIoctrlGetTxAllInfoReq *)buf;
			SMsgAVIoctrlTxAllInfoResp *q= (SMsgAVIoctrlTxAllInfoResp *)buf;

			DEBUG_P2P("IOTYPE_USER_IPCAM_GET_TX_ALL_INFO_REQ OK \n");

//			q->channel 	= p->channel;		// Add by Paul for APP check batterycam channel, 180508
			q->CameraType 	= gRfiuUnitCntl[p->channel].RFpara.BateryCam_support;
			q->BatteryLevel = gRfiuUnitCntl[p->channel].RFpara.TxBatteryLev;
			if(q->BatteryLevel > 3)
				q->BatteryLevel = 3;
			q->alarmsupport	= uiGetSuptAlarmAPP(p->channel);
			q->Lightsupport = uiGetSuptLightAPP(p->channel);
			q->PIRsupport = 1;	//Always ON.

			if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_TX_ALL_INFO_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_USER_IPCAM_GET_TX_ALL_INFO_RESP OK\n\n");
			}
		}
		break;
#endif
        case IOTYPE_USER_IPCAM_START:
        {
                    SMsgAVIoctrlAVStream *p = (SMsgAVIoctrlAVStream *)buf;
#if(UI_VERSION == UI_VERSION_MAYON)
                    //Add by Paul at 180829 for liveview speed up, copy from IOTYPE_USER_IPCAM_GET_TX_ALL_INFO_RESP
                    int size = sizeof(SMsgAVIoctrlTxAllInfoResp);
                    SMsgAVIoctrlTxAllInfoResp *q= (SMsgAVIoctrlTxAllInfoResp *)buf;
#endif
            ipcamstart = 1;
            if(gClientInfo[SID].playBackCh==0)
            {
#if ENABLE_TUTK_RESEND
                    int err;
#endif

                    DEBUG_P2P("IPCAM_START[%d:%d]\n", SID, avIndex);

#if (P2P_LV_RATECTL_SUPPORT == 1)
                    gClientInfo[SID].localSendCount = 0;
                    gClientInfo[SID].firstIframeTick = 0;
                    gClientInfo[SID].appReceived1stIFrame = false;
#endif
//STOP Start: to fixed IPCAM_STOP/IPCAM_START CMD lost
                    if(gClientInfo[SID].bEnableVideo != 0)
                    {
                        DEBUG_P2P("[AUTO STOP] IPCAM_STOP[%d:%d]\n", SID, gClientInfo[SID].avChannel);
#if(DEVSTATUS_ACTIVE_UPDATE == 1)
                        sysback_Net_SetEvt(SYS_BACK_DEVSTATUS_UPDATE, SYS_BACK_DEVSTATUS_START, gClientInfo[SID].avChannel);
#endif
                        if(gClientInfo[SID].bEnableSpeaker>0)
                            Kill_Task_Speaker(SID);
                        if(gOnlineNum<=0)
                        {
                            gOnlineNum=0;
                            gFirstConnect=0;
                        }

                        unregedit_client_from_video(SID);
#if (ENABLE_TUTK_RESEND == 1)
                        if(gClientInfo[SID].resend_buf_usage_rate >= 0)
                        {
                            err = avServResetBuffer(gClientInfo[SID].avChannel, RESET_ALL, RESET_RESEND_BUF_TIMEOUT);
                            DEBUG_P2P("[%s] avServResetBuffer6 sid[%d] err[%d] avIndex[%d]\n",__func__, SID, err, gClientInfo[SID].avChannel);
                        }
#endif
                        for(i=0; i<MAX_AV_CH; i++)
                        {
                            if(gClientInfo[SID].avIndex[i] == gClientInfo[SID].avChannel)
                                Stop_P2P_Session(i);
#if RFIU_RX_WAKEUP_TX_SCHEME
                                if(gRfiuUnitCntl[p->channel].RFpara.BatCam_PIRMode == 0)
                                {//dont sleep if PIR triggered, Paul add, fixed PIR rec too short. 181121

                                    sysSetBTCWakeStatus(i,SYS_BTC_WAKEUP_APP,FALSE);
                        			if(gRfiuUnitCntl[i].WakeUpTxEn == 1)
                        			   gRfiuUnitCntl[i].WakeUpTxEn = 0; 
                        			else
                        			{
                        			    if((rfiuRX_CamSleep_Sta & (0x01 << i))  ==0)
                        			    {
                        			        if(gRfiuUnitCntl[i].SleepTxEn == 0)
                        				    rfiuCamSleepCmd(i);
                        			    }
                                    	}
                                }
#endif
                        }
                    }
                }
//End stop
                regedit_client_to_avsession(SID, avIndex);
                regedit_client_to_video(SID);
                gClientInfo[SID].VOLSend=0;
                for(i=0; i<MAX_AV_CH; i++)
                {
                    if(gClientInfo[SID].avIndex[i] == gClientInfo[SID].avChannel)
                    {
                        CurrentCH=i;
#if(UI_VERSION == UI_VERSION_MAYON)
        				//Add by Paul at 180829 for liveview speed up, copy from IOTYPE_USER_IPCAM_GET_TX_ALL_INFO_RESP
                        // Add by Paul at 180828 for liveview speed up
                        q->CameraType 	= gRfiuUnitCntl[CurrentCH].RFpara.BateryCam_support;
                        q->BatteryLevel = gRfiuUnitCntl[CurrentCH].RFpara.TxBatteryLev;
                        if(q->BatteryLevel > 3)
                        	q->BatteryLevel = 3;
                        q->alarmsupport	= uiGetSuptAlarmAPP(CurrentCH);//Modify by Paul for wrong channel, 2018.10.12
                        q->Lightsupport = uiGetSuptLightAPP(CurrentCH);
                        q->PIRsupport = 1;//Always On
                        q->channel 	= CurrentCH;
                        if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_TX_ALL_INFO_RESP, (char*)q, size)== AV_ER_NoERROR)
                        {
                        	DEBUG_P2P("IOTYPE_USER_IPCAM_GET_TX_ALL_INFO_RESP OK\n\n");
                        }

#if BLK_FRAME_SUPPORT
                        //0x18 is H264 header size
                        DEBUG_RED("Send black fram via AvIndex %d\n",gClientInfo[SID].avChannel);
                        SendVideoFrameData(SID, 0, 1, 0x18+sizeof(H264_black_720x480), (char *)H264_black_720x480);
                        SendVideoFrameData(SID, 0, 1, 0x18+sizeof(H264_black_720x480), (char *)H264_black_720x480);
                        SendVideoFrameData(SID, 0, 1, 0x18+sizeof(H264_black_720x480), (char *)H264_black_720x480);
#endif
#endif
#if RFIU_RX_WAKEUP_TX_SCHEME//Wake all BTC hereif(gRfiu_Op_Sta[i] == RFIU_RX_STA_LINK_BROKEN) 

            			if ((gRfiuUnitCntl[i].RFpara.BateryCam_support) // Add by Paul when Battery cam changed to normal cam.
    									&& (SysCamOnOffFlag & (0x01 << i)))  // Add by Paul to filter disabled cam wakeup.
                        {
                            if(gRfiu_Op_Sta[i] == RFIU_RX_STA_LINK_BROKEN) // Add by Paul, wake up TX when link broken in any case.
                            {
                				DEBUG_P2P("Wakeup TX Channel[%d]\n", i);
                                if(gRfiuUnitCntl[i].SleepTxEn == 1)
                                    gRfiuUnitCntl[i].SleepTxEn = 0;
                				gRfiuUnitCntl[i].WakeUpTxEn=1;
        						sysSetBTCTimer(i, sysGetBTCWakeTime());		//Add by Paul for clear state when app triggered, 180508
        						sysSetBTCWakeStatus(i,SYS_BTC_WAKEUP_APP,TRUE); //Paul add for UI, 180507
                            }
                            else
                            {
                                DEBUG_P2P("Extand TX Channel[%d]\n", i);
                                sysSetBTCTimer(i, sysGetBTCWakeTime());
                                sysSetBTCWakeStatus(i,SYS_BTC_WAKEUP_APP,TRUE); //Paul add for UI, 180507
                                rfiuResetBatCamLiveMaxTime(i);
                                rfiu_SetTXsleepTime(i);
                            }
            			}
#endif //end RFIU_RX_WAKEUP_TX_SCHEME


                        h264header_updata[SID]=0;
                        if(gFirstConnect==0)
                        {
                            struct st_SInfo Sinfo;
                            ++chk_session_cnt[SID];
                            ret = IOTC_Session_Check(SID, &Sinfo);
                            //gFirstConnect=1;

                            for(x=0; x<MAX_AV_CH; x++)
                            {
#if LAN_VGA_30FPS
                                if(Sinfo.Mode!=2)	// The connection mode is not LAN.
                                {
                                    DEBUG_P2P("Set VGA to 10 FPS.\n");
                                    uiSetP2PImageLevel(x,2);// Set the video quality to level 2 when P2P client connected.
                                }
                                else
                                {
                                    DEBUG_P2P("Set VGA to 15 FPS.\n");
                                    uiSetP2PImageLevel(x,4);// Set the video quality to level 4 when P2P client connected.
                                }
#else
                                DEBUG_P2P("Set QHD .\n");
                                uiSetP2PImageLevel(x,2);// Set the video quality to level 2 when P2P client connected.
#endif
                            }
                            OSTimeDly(1);
                        }
                        else
                        {
                            uiSetP2PImageLevel(i,6);
                        }
#if ENABLE_TUTK_RESEND
                        gClientInfo[SID].localSendCount = LOW_BIT_RATE_LIMIT;//Force enter LOW BIT RATE MODE
#endif
#if(HW_BOARD_OPTION == MR8211_ZINWELL)
                        Start_P2P_Session(CurrentCH, Local_record);
#else
                        Start_P2P_Session(CurrentCH, RX_receive);
#endif

                        #if P2P_LIVEVIEW_FIND_PRE_I_FRAME
                        if (gRfiuUnitCntl[i].RFpara.BateryCam_support == 0)
                        {
                            if(FindPreIFrameIndex(CurrentCH)>=0) 
                                IFrameSentStatus[SID] = I_FRAME_NOT_SEND_YET; // found pre i frame ok
                            else 
                                IFrameSentStatus[SID] = PRE_I_FRAME_SENT; // found pre i frame fail, don't send pre I Frame
                        }
                        else 
                            IFrameSentStatus[SID] = PRE_I_FRAME_SENT; // Battery cam don't send pre i frame
                        #endif

                        if( sysCameraMode == SYS_CAMERA_MODE_RF_RX_QUADSCR )
                        {
                        #if( (SW_APPLICATION_OPTION  ==  MR9300_RFDVR_RX1RX2) || (SW_APPLICATION_OPTION == MR9300_NETBOX_RX1RX2) )

                        #else
                          #if RFRX_HALF_MODE_SUPPORT
                            if(rfiuRX_CamOnOff_Num <= 2)
                            {
                                if(sysTVOutOnFlag)
                                    iduPlaybackMode(RF_RX_2DISP_WIDTH*2,RF_RX_2DISP_HEIGHT+RFRX_HALF_MODE_SHIFT_TV*2,RF_RX_2DISP_WIDTH*2);
                                else
                                    iduPlaybackMode(RF_RX_2DISP_WIDTH*2,RF_RX_2DISP_HEIGHT+RFRX_HALF_MODE_SHIFT*2,RF_RX_2DISP_WIDTH*2);
                            }
                            else
                          #endif
                                iduPlaybackMode(RF_RX_2DISP_WIDTH*2,RF_RX_2DISP_HEIGHT*2,RF_RX_2DISP_WIDTH*2);
                        #endif
                            if(sysTVOutOnFlag)
                            {
                                tvTVE_INTC = TV_INTC_BOTFDSTART_ENA;
                            }
                            else
                            {
                                IduIntCtrl |= IDU_FTCINT_ENA;
                            }
                            //printf("[PAUL]|\n");
                        }

                    }
                }
            }
 
        break;
        case IOTYPE_USER_IPCAM_STOP:
        {
            if(gClientInfo[SID].playBackCh==0)
            {
//                SMsgAVIoctrlAVStream *p = (SMsgAVIoctrlAVStream *)buf;
#if (ENABLE_TUTK_RESEND==1)
                int err;
#endif
                CurrentCH=-1;
                for(i=0; i<MAX_AV_CH; i++)
                {
                    if(gClientInfo[SID].avIndex[i] == gClientInfo[SID].avChannel)
                    {//Current liveview channel
                        if(gClientInfo[SID].avIndex[i] == avIndex)
                        {//Want to stop channel
                            CurrentCH = i;
                        }
                        break;
                    }
                }

                if(CurrentCH == -1)
                {
                    DEBUG_P2P("Skip IPCAM_STOP[%d:%d-%d]\n", SID, avIndex, gClientInfo[SID].avIndex[i]);
                    break;
                }
                else
                {
                DEBUG_P2P("IPCAM_STOP[%d:%d]\n", SID, avIndex);
                }

#if(DEVSTATUS_ACTIVE_UPDATE)
                sysback_Net_SetEvt(SYS_BACK_DEVSTATUS_UPDATE, SYS_BACK_DEVSTATUS_STOP, avIndex);
#endif

                if(gClientInfo[SID].bEnableSpeaker>0)
                    Kill_Task_Speaker(SID);
                if(gOnlineNum<=0)
                {
                    gOnlineNum=0;
                    gFirstConnect=0;
                }

                unregedit_client_from_video(SID);

                for(i=0; i<MAX_AV_CH; i++)
                {
                    if(gClientInfo[SID].avIndex[i] == gClientInfo[SID].avChannel)
                    {
                        Stop_P2P_Session(i);
#if RFIU_RX_WAKEUP_TX_SCHEME
                        if(gRfiuUnitCntl[i].RFpara.BatCam_PIRMode == 0)
                        {//dont sleep if PIR triggered, Paul add, fixed PIR rec too short. 181121

                            sysSetBTCWakeStatus(i,SYS_BTC_WAKEUP_APP,FALSE);
            				if(gRfiuUnitCntl[i].WakeUpTxEn == 1)
            				   gRfiuUnitCntl[i].WakeUpTxEn = 0; 
            				else
            				{
            				    if((rfiuRX_CamSleep_Sta & (0x01 << i))  ==0)
            				    {
            				        if(gRfiuUnitCntl[i].SleepTxEn == 0)
            				            rfiuCamSleepCmd(i);
            				   }
            				}
                            }
#endif
#if ENABLE_TUTK_RESEND
                        if(gClientInfo[SID].resend_buf_usage_rate >= 0)
                        {
                            err = avServResetBuffer(gClientInfo[SID].avChannel, RESET_ALL, RESET_RESEND_BUF_TIMEOUT);
                            DEBUG_P2P("[%s] avServResetBuffer7 sid[%d] err[%d] avIndex[%d]\n",__func__, SID, err, gClientInfo[SID].avChannel);
                        }
#endif
                    }
                }
        	}
        }
        break;
        case IOTYPE_USER_IPCAM_AUDIOSTART:
        {
            if(gClientInfo[SID].playBackCh==0)
            {
                SMsgAVIoctrlAVStream *p = (SMsgAVIoctrlAVStream *)buf;
                DEBUG_P2P("IPCAM_AUDIOSTART[%d:%d]\n", p->channel, avIndex);
                regedit_client_to_audio(SID);
                if(gClientInfo[SID].bEnableSpeaker>0)
                    Kill_Task_Speaker(SID);
            }
        }
        break;
        case IOTYPE_USER_IPCAM_AUDIOSTOP:
        {
            if(gClientInfo[SID].playBackCh==0)
            {
                SMsgAVIoctrlAVStream *p = (SMsgAVIoctrlAVStream *)buf;
                DEBUG_P2P("IPCAM_AUDIOSTOP[%d:%d]\n", p->channel, avIndex);
                unregedit_client_from_audio(SID);
            }
        }
        break;

        case IOTYPE_USER_IPCAM_GETSUPPORTSTREAM_REQ:
        {
            unsigned short i;
            int index;
            int size = sizeof(int) + (sizeof(SStreamDef)*MAX_AV_CH);
            int ret;
            int nResend;

            SMsgAVIoctrlGetSupportStreamResp *p = (SMsgAVIoctrlGetSupportStreamResp *)buf;
            DEBUG_P2P("IPCAM_GETSUPPORTSTREAM_REQ \n\n");

            //ahre 20130801
            if(gClientInfo[SID].getsupportstream==1)
                return;

            gClientInfo[SID].getsupportstream=1;
            p->number = MAX_AV_CH;

            for(i=0; i<MAX_AV_CH; i++)
            {
                p->streams[i].index = i;
                p->streams[i].channel = i;
            }
            DEBUG_P2P("SID[%d] set support Multi-CH\n\n\n", SID);
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GETSUPPORTSTREAM_RESP, (char *)p, size) == AV_ER_NoERROR)
            {
                for(i = 1; i< MAX_AV_CH; ++i)
                {
                    DEBUG_YELLOW("enable CH%d begin...\n",i);
#if(UI_VERSION == UI_VERSION_MAYON)//Modify for relay mode connection lose issue. Add by Paul 2018.08.28
                    #if ENABLE_TUTK_RESEND
                    ret = avServStart3(SID, AuthCallBackFn, 15, SERVTYPE_STREAM_SERVER, i, &nResend);
                    #else
                    ret = avServStart(SID, "admin", gP2PPassword, 20, SERVTYPE_STREAM_SERVER, i);
                    #endif
#else
                    ret=avServStart(SID, "admin", gP2PPassword, 10, SERVTYPE_STREAM_SERVER, i);
#endif
                    //ret = avServStart3(SID, AuthCallBackFn,10, SERVTYPE_STREAM_SERVER, i, &nResend);
                    DEBUG_YELLOW("enable CH%d end...\n",i);
                    if(ret < 0)
                    {
                        DEBUG_P2P("avServStart failed SID[%d] code[%d]!!!\n", SID, ret);
                        IOTC_Session_Close(SID);
                        return;
                    }
                    gClientInfo[SID].avIndex[i]=ret;
                    avServSetResendSize(gClientInfo[SID].avIndex[i], TUTK_RESEND_BUF_SIZE);
                    DEBUG_P2P("@@ avServStart OK SID[%d] idx[%d]\n", SID, gClientInfo[SID].avIndex[i]);
                }
                if(gRfiuUnitCntl[sysRFRxInMainCHsel].TX_PicWidth > RF_RX_2DISP_WIDTH*2) //eRFresolution
                {
                    rfiuRX_P2pVideoQuality = 1;
                }
                else
                {
                    rfiuRX_P2pVideoQuality = 2;
                }
            }
        }
        break;

        case IOTYPE_USER_IPCAM_GETPASSWORD_REQ:
        {
//            SMsgAVIoctrlGetPasswdReq *p= (SMsgAVIoctrlGetPasswdReq *)buf;
            SMsgAVIoctrlGetPasswdResp *q= (SMsgAVIoctrlGetPasswdResp *)buf;
            int size=sizeof(SMsgAVIoctrlGetPasswdResp);

            DEBUG_P2P("IPCAM_GETPASSWORD_REQ\n");
            memcpy(q->passwd, UI_P2P_PSW, sizeof(q->passwd));
            DEBUG_P2P("Get PW:%s\n",UI_P2P_PSW);
            avSendIOCtrl3(avIndex,IOTYPE_USER_IPCAM_GETPASSWORD_RESP, (char *) q, size);

        }
        break;
        case IOTYPE_USER_IPCAM_SETPASSWORD_REQ:
        {
            SMsgAVIoctrlSetPasswdReq *p= (SMsgAVIoctrlSetPasswdReq *)buf;
            SMsgAVIoctrlSetPasswdResp *q= (SMsgAVIoctrlSetPasswdResp *)buf;
            int size=sizeof(SMsgAVIoctrlSetPasswdResp);
            DEBUG_P2P("IPCAM_SETPASSWORD_REQ\n");
            strcpy(gP2PPassword,p->newpasswd);
            DEBUG_P2P("New password = %s\n",gP2PPassword);
            uiSetP2PPassword((u8 *)gP2PPassword);

            q->result=0;
            avSendIOCtrl3(avIndex,IOTYPE_USER_IPCAM_SETPASSWORD_RESP, (char *) q, size);

        }
        break;
#if 1
        case IOTYPE_USER_IPCAM_GET_VIDEOMODE_REQ: //v
        {
            int size = (sizeof(SStreamDef)*MAX_AV_CH);
            SMsgAVIoctrlGetVideoModeResp *p = (SMsgAVIoctrlGetVideoModeResp *)buf;

            DEBUG_P2P("IPIDEOMODE_REQ\n\n");
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_VIDEOMODE_RESP, (char *)p, size) == AV_ER_NoERROR)
            {
                DEBUG_P2P("orl video mode=%d \n\n",p->mode);
                DEBUG_P2P("IPCAM_GET_VIDEOMODE OK \n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_VIDEOMODE_REQ: //v
        {
            int size = sizeof(SMsgAVIoctrlSetStreamCtrlResp);
            //aher
            SMsgAVIoctrlSetVideoModeReq *p = (SMsgAVIoctrlSetVideoModeReq *)buf;
            SMsgAVIoctrlSetStreamCtrlResp *q = (SMsgAVIoctrlSetStreamCtrlResp *)buf;
            DEBUG_P2P(" video mode=%d \n\n",p->mode);
            DEBUG_P2P("IPCAM_SET_VIDEOMODE_REQ\n\n");
            q->result=0xEA;
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_SET_VIDEOMODE_RESP, (char *)q, size) == AV_ER_NoERROR)
            {
                DEBUG_P2P("video mode result=%d \n\n",q->result);
                DEBUG_P2P("IPCAM_SET_VIDEOMODE_RESP OK \n\n");
            }
        }
        break;
#endif
#if 1
        case IOTYPE_USER_IPCAM_GET_ENVIRONMENT_REQ: //
        {
            int size = sizeof(SMsgAVIoctrlGetEnvironmentResp);
            unsigned char mode;
            SMsgAVIoctrlGetEnvironmentReq *p = (SMsgAVIoctrlGetEnvironmentReq *)buf;
            SMsgAVIoctrlGetEnvironmentResp *q = (SMsgAVIoctrlGetEnvironmentResp*)buf;

            DEBUG_P2P("IPCAM_GET_ENVIRONMENT_REQ\n\n");
            if(sysGetFrequency(p->channel,&mode)<0)
            {
                DEBUG_P2P("GET ENVIRONMENT Fail!! \n");
                q->mode=255;
            }
            else
            {
                DEBUG_P2P("GET ENVIRONMENT OK!! \n");
                q->mode=mode;
            }
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_ENVIRONMENT_RESP, (char *)p, size) == AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_GET_ENVIRONMENT_REQ OK \n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_ENVIRONMENT_REQ: //
        {
            int size = sizeof(SMsgAVIoctrlSetEnvironmentResp);
            SMsgAVIoctrlSetEnvironmentReq *p = (SMsgAVIoctrlSetEnvironmentReq *)buf;
            SMsgAVIoctrlSetEnvironmentResp *q = (SMsgAVIoctrlSetEnvironmentResp*)buf;

            DEBUG_P2P("IPCAM_SET_ENVIRONMENT_REQ OK \n");

            if(sysSetFrequency(p->channel,p->mode)<0)
            {
                DEBUG_P2P("SET ENVIRONMENT Fail!! \n");
//                q->result=-1;
                q->result=1;//result is unsigned char
            }
            else
            {
                DEBUG_P2P("SET ENVIRONMENT OK!! \n");
                q->result=0;
            }
            if(avSendIOCtrl3(avIndex, (unsigned int)IOTYPE_ZW_PLUGCAM_SET_FREQUENCY_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_SET_ENVIRONMENT_RESP OK\n\n");
            }
        }
        break;
#endif
#if 1
        case IOTYPE_USER_IPCAM_GETSTREAMCTRL_REQ: //T~ get
        {
            int size = sizeof(int) + (sizeof(SStreamDef)*MAX_AV_CH);
            SMsgAVIoctrlGetStreamCtrlResq *p = (SMsgAVIoctrlGetStreamCtrlResq *)buf;
            DEBUG_P2P("IPCAM_GETSTREAMCTRL_REQ\n\n");
            p->quality=videoquality;
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GETSTREAMCTRL_RESP, (char *)p, size) == AV_ER_NoERROR)
            {
                DEBUG_P2P("orl STREAMCTRL level =%d \n\n",p->quality);
                DEBUG_P2P("IPCAM_GETSTREAMCTRL_REQ OK \n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SETSTREAMCTRL_REQ: //T~ set. Set the resoultion to 720P/VGA/QVGA
        {
#if ((HW_BOARD_OPTION == MR8202A_RX_TARNWO_D8530)||(HW_BOARD_OPTION == A1025A_EVB_axviwe))

				int size = sizeof(SMsgAVIoctrlSetStreamCtrlResp);
				int i;
				SMsgAVIoctrlSetStreamCtrlReq *p = (SMsgAVIoctrlSetStreamCtrlReq *)buf;
				SMsgAVIoctrlSetStreamCtrlResp *q = (SMsgAVIoctrlSetStreamCtrlResp *)buf;
				DEBUG_P2P("STREAMCTRL level =%d \n\n",p->quality);
				DEBUG_P2P("IOTYPE_IPCAM_SETSTREAMCTRL_REQ\n\n");

				q->result=0;
				for (i = 0; i < MAX_RFIU_UNIT; i++)
					iconflag[UI_MENU_SETIDX_RESOLUTION_CH1+i] = p->quality;
                uiSentKeyToUi(UI_KEY_CAM_RESOLUTION);

#else
            int size = sizeof(SMsgAVIoctrlSetStreamCtrlResp);
            int i;
            SMsgAVIoctrlSetStreamCtrlReq *p = (SMsgAVIoctrlSetStreamCtrlReq *)buf;
            SMsgAVIoctrlSetStreamCtrlResp *q = (SMsgAVIoctrlSetStreamCtrlResp *)buf;
            DEBUG_P2P("STREAMCTRL level =%d \n\n",p->quality);
            DEBUG_P2P("IPCAM_SETSTREAMCTRL_REQ\n\n");

            q->result=0;
            if (p->quality==1)
            {
                videoquality=1;
                gFirstConnect=1;
                DEBUG_P2P("Set TX resoultion to FHD");
                for (i = 0; i < MAX_RFIU_UNIT; i++)
                    uiSetP2PImageLevel(i,1);

            }
            else if (p->quality==2)
            {
                struct st_SInfo Sinfo;
                ++chk_session_cnt[SID];
                ret = IOTC_Session_Check(SID, &Sinfo);
                DEBUG_P2P("Set TX resoultion to VGA ");
                videoquality=2;
                gFirstConnect=1;
                for (i = 0; i < MAX_RFIU_UNIT; i++)
                {
#if LAN_VGA_30FPS
                    if(Sinfo.Mode!=2)
                    {
                        DEBUG_P2P("10 FPS.\n");
                        uiSetP2PImageLevel(i,2);
                    }
                    else
                    {
                        DEBUG_P2P("15 FPS.\n");
                        uiSetP2PImageLevel(i,4);
                    }
#else
                    DEBUG_P2P("10 FPS.\n");
                    uiSetP2PImageLevel(i,2);
#endif
                }
            }
            else if (p->quality==3)
            {
                DEBUG_P2P("Set TX resoultion to QVGA(H).\n");
                videoquality=3;
                gFirstConnect=1;
                for (i = 0; i < MAX_RFIU_UNIT; i++)
                    uiSetP2PImageLevel(i,3);
            }
            else if (p->quality==4)
            {
                DEBUG_P2P("Set TX resoultion to QVGA(M).\n");
                videoquality=4;
                gFirstConnect=1;
                for (i = 0; i < MAX_RFIU_UNIT; i++)
                    uiSetP2PImageLevel(i,4);
            }
            else if (p->quality==5)
            {
                DEBUG_P2P("Set TX resoultion to QVGA(L).\n");
                videoquality=5;
                gFirstConnect=1;
                for (i = 0; i < MAX_RFIU_UNIT; i++)
                    uiSetP2PImageLevel(i,5);

            }
            else
            {
                DEBUG_P2P("Set TX resoultion Fail.\n");
                q->result=0x01;
            }

            if( sysCameraMode == SYS_CAMERA_MODE_RF_RX_QUADSCR )
            {
                if(rfiuRX_OpMode & RFIU_RX_OPMODE_QUAD)
                {
                #if( (SW_APPLICATION_OPTION == MR9300_RFDVR_RX1RX2) || (SW_APPLICATION_OPTION == MR9200_MIXCAM_RX1RX2) || (SW_APPLICATION_OPTION == MR9300_NETBOX_RX1RX2) )
                    //Idu_ClearQuadBuf();
                #else
                    DEBUG_P2P("memset_hw_Word(p2p_1)\n");
                    Idu_ClearBuf(DISPLAY_BUF_NUM);
                #endif
                }

            #if( (SW_APPLICATION_OPTION == MR9300_RFDVR_RX1RX2) || (SW_APPLICATION_OPTION == MR9300_NETBOX_RX1RX2) )

            #else
              #if RFRX_HALF_MODE_SUPPORT
                if(rfiuRX_CamOnOff_Num <= 2)
                {
                    if(sysTVOutOnFlag)
                        iduPlaybackMode(RF_RX_2DISP_WIDTH*2,RF_RX_2DISP_HEIGHT+RFRX_HALF_MODE_SHIFT_TV*2,RF_RX_2DISP_WIDTH*2);
                    else
                        iduPlaybackMode(RF_RX_2DISP_WIDTH*2,RF_RX_2DISP_HEIGHT+RFRX_HALF_MODE_SHIFT*2,RF_RX_2DISP_WIDTH*2);
                }
                else
              #endif
                    iduPlaybackMode(RF_RX_2DISP_WIDTH*2,RF_RX_2DISP_HEIGHT*2,RF_RX_2DISP_WIDTH*2);
            #endif

                if(sysTVOutOnFlag)
                {
                    tvTVE_INTC = TV_INTC_BOTFDSTART_ENA;
                    iduTVOSDEnable(IDU_OSD_L0_WINDOW_0);
                }
                else
                {
                    IduIntCtrl |= IDU_FTCINT_ENA;
                }
            }
#endif
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_SETSTREAMCTRL_RESP, (char *)q, size) == AV_ER_NoERROR)
            {
                DEBUG_P2P("STREAMCTRL level result =%d \n\n",q->result);
                DEBUG_P2P("IPCAM_SETSTREAMCTRL_RESP OK \n\n");
                rfiuRX_P2pVideoQuality = (videoquality == 1) ? 1 : 2; ////1:FHD, 2:HD/QHD
                DEBUG_P2P("update resolution 1:FHD, 2:HD/QHD rfiuRX_P2pVideoQuality %d\n", rfiuRX_P2pVideoQuality);
            }
        }
#endif
        break;


#if 0
        case IOTYPE_USER_IPCAM_LISTWIFIAP_REQ: // WIFI
        {

            int size = sizeof(int) + (sizeof(SStreamDef)*MAX_AV_CH);
            SMsgAVIoctrlListWifiApResp *p = (SMsgAVIoctrlListWifiApResp*)buf;

            DEBUG_P2P("IPCAM_LISTWIFIAP_REQ\n\n");
            DEBUG_P2P("WIFI.ssid=%d\n",p->stWifiAp->ssid);
            DEBUG_P2P("WIFI.mode=%d\n",p->stWifiAp->mode);
            DEBUG_P2P("WIFI.enctype=%d\n",p->stWifiAp->enctype);
            DEBUG_P2P("WIFI.signal=%d\n",p->stWifiAp->signal);
            DEBUG_P2P("WIFI.status=%d\n",p->stWifiAp->status);

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_LISTWIFIAP_RESP, (char *)p, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_LISTWIFIAP_RESP OK \n\n");
            }
        }
        break;
#endif

#if 1
        case IOTYPE_USER_IPCAM_GETMOTIONDETECT_REQ: // get
        {

            int size =sizeof(SMsgAVIoctrlGetMotionDetectResp);
            u8 cam;
            u8 isEnable;
            u8 sensitivity;
            SMsgAVIoctrlGetMotionDetectReq *p = (SMsgAVIoctrlGetMotionDetectReq *)buf;
            SMsgAVIoctrlGetMotionDetectResp *q = (SMsgAVIoctrlGetMotionDetectResp *)buf;


            DEBUG_P2P("IPCAM_GETMOTIONDETECT_REQ\n\n");
            sysGet_MotionEnable(p->channel,&isEnable, &sensitivity,&sensitivity);
            if(!isEnable)
                q->sensitivity=0;
            else
                q->sensitivity=sensitivity;
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GETMOTIONDETECT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETMOTIONDETECT_RESP OK:channel:%d, sensitivity:%d\n\n",q->channel,q->sensitivity);
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SETMOTIONDETECT_REQ: // set
        {

            int size =sizeof(SMsgAVIoctrlSetMotionDetectResp);
            int sensitivity;
            int isEnable;
            SMsgAVIoctrlSetMotionDetectReq *p = (SMsgAVIoctrlSetMotionDetectReq *)buf;
            SMsgAVIoctrlSetMotionDetectResp *q = (SMsgAVIoctrlSetMotionDetectResp *)buf;

            DEBUG_P2P("IPCAM_SETMOTIONDETECT_REQ: channel:%d, sensitivity:%d\n\n",p->channel,p->sensitivity);
            if(p->sensitivity!=0)
                isEnable=1;
            else
                isEnable=0;
            if(!sysSet_MotionEnable(p->channel,isEnable, p->sensitivity,p->sensitivity))
            {
                DEBUG_P2P("USER_IPCAM_SET_SENSITIVITY Fail!! \n");
            }
            else
            {
                DEBUG_P2P("USER_IPCAM_SET_SENSITIVITY OK!! \n");
            }

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_SETMOTIONDETECT_RESP, (char *)q, size) == AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_SETMOTIONDETECT_RESP OK \n\n");
            }
        }
        break;
#endif

        case IOTYPE_USER_IPCAM_PTZ_COMMAND: // PTZ
        {
            int size = sizeof(int) + (sizeof(SStreamDef)*MAX_AV_CH);
            SMsgAVIoctrlPtzCmd *p = (SMsgAVIoctrlPtzCmd *)buf;

            DEBUG_P2P("IPCAM_PTZ_COMMAND\n\n");
            DEBUG_P2P("PTZ=%d\n",p->control);

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_PTZ_COMMAND, (char *)p, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_PTZ_COMMAND OK \n\n");
            }
        }
        break;

        case IOTYPE_USER_IPCAM_GETRECORD_REQ: //v get
        {
            int size =  sizeof(SMsgAVIoctrlGetRecordResq);
            unsigned int mode;
//            SMsgAVIoctrlGetRecordReq *p = (SMsgAVIoctrlGetRecordReq *)buf; //Never use here
            SMsgAVIoctrlGetRecordResq *q = (SMsgAVIoctrlGetRecordResq *)buf;

            DEBUG_P2P("IPCAM_GETRECORD_REQ \n\n");
//            if(sysGetRecordMode(&mode)<0)//Should not be less then 0, return is u8
            if(sysGetRecordMode(&mode)==0)
            {
                DEBUG_P2P("GETRECORD Fail!!\n");
//                q->recordType=-1;//Should not be less then 0, return is u8
                q->recordType=0;
            }
            else
            {
                DEBUG_P2P("GETRECORD OK!!\n");
                q->recordType=mode;
            }
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GETRECORD_RESP, (char *)q, size) == AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_GETRECORD_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_IPCAM_SETRECORD_REQ: //v set
        {
            int size =  sizeof(SMsgAVIoctrlSetRecordResp);

            SMsgAVIoctrlSetRecordReq *p = (SMsgAVIoctrlSetRecordReq *)buf;
            SMsgAVIoctrlSetRecordResp *q = (SMsgAVIoctrlSetRecordResp *)buf;
            DEBUG_P2P("IPCAM_SETRECORD_REQ \n\n");
            DEBUG_P2P(" mode =%d \n\n",p->recordType);
//            if(sysSetRecordMode(p->recordType)<0)//Should not be less then 0, return is u8
            if(sysSetRecordMode(p->recordType)==0)
            {
                DEBUG_P2P("SETRECORD Fail!!\n");
//                q->result=-1;//Should not be less then 0, return is u8
                q->result=0;
            }
            else
            {
                DEBUG_P2P("SETRECORD OK!!\n");
                q->result=1;
            }
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_SETRECORD_RESP, (char *)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_SETRECORD_RESP OK\n\n");
                DEBUG_P2P(" mode result =%d \n\n",p->recordType);
            }
        }
        break;

        case IOTYPE_USER_IPCAM_SPEAKERSTART:
        {
            DEBUG_P2P("IPCAM_SPEAKERSTART:%d\n",CurrentCH);
            if(gSpeakerSID <= 0)
            {
                SMsgAVIoctrlAVStream *p = (SMsgAVIoctrlAVStream *)buf;
                gClientInfo[SID].speakerCh = p->channel;
                gSpeakerSID = SID;
                regedit_client_to_speaker(SID, avIndex);
                rfiu_AudioRetONOFF_APP(1,CurrentCH);
                if(OSTaskCreate(Task_Speaker, (void *)CurrentCH, SPEAKER_TASK_STACK, SPEAKER_TASK_PRIORITY) != OS_NO_ERR)
                {
                    DEBUG_P2P("OSTaskCreate Task_Speaker failed!!!!!!!!!!!!!!!!!!!\n");
                    return;
                }
            }

        }
        break;

        case IOTYPE_USER_IPCAM_SPEAKERSTOP:
        {
            DEBUG_P2P("IPCAM_SPEAKERSTOP\n");
            if(gClientInfo[SID].bEnableSpeaker>0)
            {
                Kill_Task_Speaker(SID);
            }
            /*
            unregedit_client_from_speaker(SID);
            rfiu_AudioRetONOFF_APP(0,CurrentCH);
            avClientStop(SpeakerAvIndex);
            gSpeakerSID=-1;
            OSTaskDel(SPEAKER_TASK_PRIORITY);
            */
        }
        break;

        case IOTYPE_USER_IPCAM_GETAUDIOOUTFORMAT_REQ:
        {
            int size = sizeof(int) + sizeof(SMsgAVIoctrlGetAudioOutFormatResp);

            //SMsgAVIoctrlGetAudioOutFormatReq *p = (SMsgAVIoctrlGetAudioOutFormatReq *)buf;// Never use
            SMsgAVIoctrlGetAudioOutFormatResp *q = (SMsgAVIoctrlGetAudioOutFormatResp *)buf;

            //DEBUG_P2P("aher channel=%d\n",q->channel);
            DEBUG_P2P("IPCAM_GETAUDIOOUTFORMAT_REQ\n");
            q->format=0x8C;
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GETAUDIOOUTFORMAT_RESP, (char *)q, size) == AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_GETAUDIOOUTFORMAT_RESP OK \n\n");
            }
        }
        break;

        case IOTYPE_USER_IPCAM_RECEIVE_FIRST_IFRAME:
        {
            u32 currTick;
            int ch;
            gClientInfo[SID].VOLSend = 1;
            DEBUG_P2P("IPCAM_RECEIVE_FIRST_IFRAME OK \n");
#if (P2P_LV_RATECTL_SUPPORT == 1) && ENABLE_TUTK_RESEND
            currTick = OS_GetSysTick()  - gClientInfo[SID].firstIframeTick;
            if(currTick ==0) currTick++;
            gClientInfo[SID].sndBps =
                (((gClientInfo[SID].firstIframeSize *8 *20) / (currTick)) / 1024);// Translate to per-sec by Kbit
            DEBUG_YELLOW("[P2P] Curr Bitrate = %dKbps, size = %dKB\n", gClientInfo[SID].sndBps,
                                                            gClientInfo[SID].firstIframeSize/ 1024);
            gClientInfo[SID].firstIframeTick = 0;
            gClientInfo[SID].localMaxRate = gClientInfo[SID].sndBps;
            gClientInfo[SID].localAvgRate = gClientInfo[SID].sndBps;
            gClientInfo[SID].localSendCount = 0;
            RateCtlInit(&rateCtl);

            if((gClientInfo[SID].sndBps <= MED_SPEED_RATE) || (LOW_BIT_RATE_MODE(SID)))
            {
                for(ch=0; ch < MAX_AV_CH; ch++)
                {//IOTYPE_USER_IPCAM_RECEIVE_FIRST_IFRAME doesn't return channel in CMD
                    if(gClientInfo[SID].avChannel == gClientInfo[SID].avIndex[ch])
                    {
                        rfiuCamFeedBackAPPStaCmd(ch, (gClientInfo[SID].sndBps/100+1), 0);
                        break;
                    }
                }
            	}


#if P2P_LIVEVIEW_FIND_PRE_I_FRAME
            if (gRfiuUnitCntl[ch].RFpara.BateryCam_support == 1)
            {
                OS_ENTER_CRITICAL();
                P2PVideoBufReadIdx[ch]  = rfiuRxVideoBufMngWriteIdx[ch];
                P2PAudioBufReadIdx[ch]  = rfiuRxIIsSounBufMngWriteIdx[ch];

                P2PVideoPresentTime[ch] = 100; //Lsk TODO: msut add av time difference
                P2PAudioPresentTime[ch] = 100;
                P2PChannelStart[ch]=1;

                P2PVideoBuf[ch] = rfiuRxVideoBufMng[ch];
                P2PAudioBuf[ch] = rfiuRxIIsSounBufMng[ch];
                OS_EXIT_CRITICAL();
                
                if(FindPreIFrameIndex(ch)>=0) 
		  {
									P2PVideoBufReadIdx[ch] = preIframeIndex[ch];
                IFrameSentStatus[SID] = PRE_I_FRAME_SENT; // Battery cam don't send pre i frame
                	printf("ch[%d] index %d\n",ch,P2PVideoBufReadIdx[ch]);             	
                }
            }
            gClientInfo[SID].appReceived1stIFrame = true;
#endif
            gClientInfo[SID].VOLSend = 1;
#endif
#if(DEVSTATUS_ACTIVE_UPDATE)
            sysback_Net_SetEvt(SYS_BACK_DEVSTATUS_UPDATE, 1, gClientInfo[SID].avChannel);
#endif
        }
        break;
        
        case IOTYPE_USER_IPCAM_APP_REPORT_BITRATE:
        {
            u32 kbps = 0, bstKbps = 0, avgKbps = 0;
#if (P2P_LV_RATECTL_SUPPORT == 1)
            int refKbps;
#endif
            SMsgAVIoctrlAppReportBitrate *p = (SMsgAVIoctrlAppReportBitrate *)buf;

            bstKbps = p->bstKbps;
            avgKbps = p->avgKbps;
            DEBUG_P2P("\nioType%XH OK[ch %d:%d] [B-%d:A-%d]\n", ioType, SID , p->channel, p->bstKbps, p->avgKbps);
#if (P2P_LV_RATECTL_SUPPORT == 1) && ENABLE_TUTK_RESEND
            if(( bstKbps < LOW_SPEED_RATE ) || (bstKbps > (avgKbps*2)))
            {//Low speed, rate control, skip pFrame, skip audio
                if(gClientInfo[SID].resend_buf_usage_rate > LOW_BIT_RATE_ENTER)
                {//Some problem here in Mayon environment, mark it now
                    gClientInfo[SID].localSendCount = LOW_BIT_RATE_LIMIT;
                    DEBUG_RED("Rbf[avCh:%d] %d%%, force LBR\n",
                            gClientInfo[SID].avChannel, gClientInfo[SID].resend_buf_usage_rate);
                }
                else
                {//Enter here LOW_BIT_RATE_LIMIT times continues means real low bit rate stat.
                    gClientInfo[SID].localSendCount++;
                    DEBUG_RED("Rbf[avCh:%d] %d%%, LBR mode detect: %d times\n",
                            gClientInfo[SID].avChannel, gClientInfo[SID].resend_buf_usage_rate, gClientInfo[SID].localSendCount);
                }
                rfiuCamFeedBackAPPStaCmd(p->channel, 2, 0);
                break;
            }
            
            if(avgKbps >= HIGH_SPEED_RATE)
            {
                DEBUG_RED("\nHigh speed\n");
                gClientInfo[SID].localSendCount = 0;//High speed, no limitation
                rfiuCamFeedBackAPPStaCmd(p->channel, 255, 0);
                break;
            }
                
            if(bstKbps > gClientInfo[SID].localMaxRate)
                gClientInfo[SID].localMaxRate = bstKbps;

            if(avgKbps > gClientInfo[SID].localAvgRate)
                gClientInfo[SID].localAvgRate = (gClientInfo[SID].localAvgRate + avgKbps)/2;

            refKbps = RateCtlCalculat(&rateCtl, bstKbps);
            DEBUG_RED("KAL in: %dKbps, KAL out: %dKbps\n", bstKbps, refKbps);
            kbps = (refKbps + gClientInfo[SID].localMaxRate + gClientInfo[SID].localAvgRate)/3;
            DEBUG_P2P("Rbf[avCh:%d] %d%%, rate adj: %dKbps\n",gClientInfo[SID].avChannel,
                                        gClientInfo[SID].resend_buf_usage_rate, kbps);

            gClientInfo[SID].localSendCount=0; //Medium speed, rate control
            rfiuCamFeedBackAPPStaCmd(p->channel, (kbps/100), 0);
            gClientInfo[SID].sndBps = kbps;
#endif
            memset(buf, 0, MAX_BUF_SIZE);
        }
        break;        

        case IOTYPE_USER_IPCAM_DEVINFO_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlDeviceInfoResp);
            //unsigned char model[16]="---";
            unsigned char vendor[16]="---";
            unsigned int version=atoi(uiVersionTime);
            FS_DISKFREE_T *diskInfo;
            u16 total_size=0;
            u16 usage_size=0;
            u16 remain_size=0;
            //SMsgAVIoctrlDeviceInfoReq *p = (SMsgAVIoctrlDeviceInfoReq *)buf;
            SMsgAVIoctrlDeviceInfoResp *q = (SMsgAVIoctrlDeviceInfoResp *)buf;
            //memset(q,0,size);
            DEBUG_P2P("IPCAM_DEVINFO_REQ OK \n");
            strcpy((char *)q->model,Model_name);
            strcpy((char *)q->vendor,(char *)vendor);
            q->version=version;
            //get the SD card information.
#if (HW_BOARD_OPTION == MR8211_ZINWELL)
            if((sysGetStorageStatus(SYS_I_STORAGE_MAIN) == SYS_V_STORAGE_READY)&&(got_disk_info!= 0)&&(MountMode == AVIOCTRL_SDCARD_MOUNT))
#else
            if((sysGetStorageStatus(SYS_I_STORAGE_MAIN) == SYS_V_STORAGE_READY)&&(got_disk_info!= 0))
#endif
            {
                diskInfo=&global_diskInfo;
                total_size=diskInfo->total_clusters*diskInfo->sectors_per_cluster/(1024*2);
                remain_size=diskInfo->avail_clusters*1000/diskInfo->total_clusters;
                usage_size=1000- remain_size;
            }
            else
            {
                total_size=0;
                usage_size=0;
                remain_size=0;
            }
            //DEBUG_P2P("total_size  : %d \n", total_size);
            //DEBUG_P2P("remain_size : %d \n", remain_size);
            //DEBUG_P2P("usage_size  : %d \n", usage_size);
            q->total=total_size;
            q->free=remain_size;
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_DEVINFO_RESP, (char *)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_DEVINFO_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_IPCAM_FORMATEXTSTORAGE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlFormatExtStorageResp);
            SMsgAVIoctrlFormatExtStorageReq *p = (SMsgAVIoctrlFormatExtStorageReq *)buf;
            SMsgAVIoctrlFormatExtStorageResp *q=(SMsgAVIoctrlFormatExtStorageResp *)buf;

            DEBUG_P2P("IPCAM_FORMATEXTSTORAGE_REQ OK \n");
            uiCaptureVideoStop();
#if MULTI_CHANNEL_VIDEO_REC
			while(MultiChannelCheckRecordChannel() != 0)
			{
				OSTimeDly(1);
			}
#endif

            sysSetEvt(SYS_EVT_PLAYBACK_FORMAT, 0);
            q->result=0;

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_FORMATEXTSTORAGE_RESP, (char *)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_FORMATEXTSTORAGE_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_IPCAM_LISTEVENT_REQ:
        {
            SMsgAVIoctrlListEventReq *p = (SMsgAVIoctrlListEventReq *)buf;
            DEBUG_P2P("IPCAM_LISTEVENT_REQ\n");
            gbSearchEvent=0;
            get_recorded_filelist(p,SID,avIndex);
            DEBUG_P2P("IPCAM_LISTEVENT_RESP OK \n\n");
#if 0//(UI_VERSION == UI_VERSION_MAYON) //Fixed non receive record stop issue, Paul, 2019/04/10
            if(gClientInfo[SID].playBackCh > 0)
            {
                OSTimeDly(2);//Give some time for SendIoCmd to APP
                Force_Stop_Playback(SID);
            }
#endif
        }
        break;

        case IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL:
        {
            SMsgAVIoctrlPlayRecord *p = (SMsgAVIoctrlPlayRecord *)buf;
            SMsgAVIoctrlPlayRecordResp *q=(SMsgAVIoctrlPlayRecordResp *)buf;
            u8 error;
            u32 *tmp;
            int ret;
            DEBUG_P2P("IPCAM_RECORD_PLAYCONTROL-%d\n",p->command);

            switch (p->command)
            {
                case AVIOCTRL_RECORD_PLAY_START :
                {
                    DEBUG_P2P("AVIOCTRL_RECORD_PLAY_START[%d]\n", SID);
                    #if (HW_BOARD_OPTION == MR9200_RX_TRANWO_D8796P)//Sean: 20171204 add.
                    // Check the file whether is exist or not. prevent app play the wrong file.
                    if(dcfItemExist(dcfPlaybackCurFile->pDirEnt->d_name, "rb") < 0)
                    {
                    	printf("\x1B[96mFileplaying: F:%d, R:%d\x1B[0m\n", Fileplaying, Remote_play);
                    	q->command=p->command;
						q->result = -1;
						if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp)) == AV_ER_NoERROR)
						{
							DEBUG_P2P("IOTYPE_IPCAM_RECORD_PLAYCONTROL_RESP OK \n\n");
						}
						break;
                    }
                    if(Fileplaying)
                    {
                        printf("\x1B[96mFileplaying\x1B[0m\n");
                        q->command=p->command;
                        q->result = -1;
                        if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp)) == AV_ER_NoERROR)
                        {
                            DEBUG_P2P("IOTYPE_IPCAM_RECORD_PLAYCONTROL_RESP OK \n\n");
                        }
                        break;
                    }
                    #endif
#if(UI_VERSION == UI_VERSION_MAYON)
					if((Fileplaying ==1) && (CurrPlaybackSID == SID)  &&  (Remote_play ==1))
					{
                        DEBUG_P2P("Receive same SID[%d] cmd AVIOCTRL_RECORD_PLAY_START\n", SID);
 //                       Force_Stop_Playback(SID);
					}
					else if(Remote_play ==0)
					{// That means RX playback.
						CurrPlaybackSID = -1;
					}
#endif
                    Remoteplayback_CH = p->channel;
                    gRemote_playfile = *p;
                    regedit_client_to_video(SID);
                    gClientInfo[SID].bPausePlayBack = 0;
                    gClientInfo[SID].bStopPlayBack = 0;
                    gClientInfo[SID].playBackCh = IOTC_Session_Get_Free_Channel(SID);
                    q->command = p->command;
                    q->result = gClientInfo[SID].playBackCh;
                    gPlaybackSID = SID;
                    P2PEnableplaybackStreaming++;
                    P2PPlaybackVideoStop = 0;
                    DEBUG_CYAN("Fileplaying= %d,Remote_play= %d \n",Fileplaying,Remote_play);

                    if(Fileplaying)
                    {
                        q->result = -1;
                        if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp)) == AV_ER_NoERROR)
                        {
                            DEBUG_P2P("IPCAM_RECORD_PLAYCONTROL_RESP OK \n\n");
                        }
                        Remoteplayback_busy();
                    }
                    else
                    {
                        get_recorded_filelist((SMsgAVIoctrlListEventReq *)p,SID,avIndex);
                        DEBUG_P2P("PLAY FILE: %d/%d/%d %d:%d:%d CH=%d.\n",gRemote_playfile.stTimeDay.year,gRemote_playfile.stTimeDay.month,gRemote_playfile.stTimeDay.day,gRemote_playfile.stTimeDay.hour,gRemote_playfile.stTimeDay.minute,gRemote_playfile.stTimeDay.second,gRemote_playfile.channel);
                        tmp=(u32 *)q->reserved;
                        *tmp=GetVideoDuration(dcfPlaybackCurFile->pDirEnt->d_name)*1000;
                        if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp)) == AV_ER_NoERROR)
                        {
                            DEBUG_GREEN("IPCAM_RECORD_PLAYCONTROL_RESP OK \n\n");
                            Fileplaying = 1;
                            Remote_play = 1;
                            gPlaybackTaskRunning = 1;
                            memset_hw(gP2PPlayfileTaskStack, 0, sizeof(gP2PPlayfileTaskStack));
                            error = OSTaskCreate(Task_remote_file_playback, (void *)SID, P2P_PLAYFILE_TASK_STACK, P2P_PLAYFILE_TASK_PRIORITY);
                            if(error != OS_NO_ERR)
                                DEBUG_P2P("OSTaskCreate error : %d\n",error);                            
                        }
                        else
                        {
                            DEBUG_RED("IPCAM_RECORD_PLAYCONTROL_RESP NG \n\n");
                        }

                    }
                }
                break;
                case AVIOCTRL_RECORD_PLAY_STOP:
                {
                    u8 err;
                    DEBUG_CYAN("AVIOCTRL_RECORD_PLAY_STOP[%d]\n", SID);

                    DEBUG_P2P("P2PEnableplaybackStreaming333=%d\n",P2PEnableplaybackStreaming);

                    if(gClientInfo[SID].bStopPlayBack<=0)
                    {
                        P2P_check=0;
                        P2PPlaybackVideoStop=1;
#if(UI_VERSION == UI_VERSION_MAYON)
                        CurrPlaybackSID=-1;
#else
                        CurrPlaybackSID=SID;
#endif
                        unregedit_client_from_video(SID);
                        gClientInfo[SID].bStopPlayBack = 1;
                        gClientInfo[SID].bPausePlayBack = 0;
                        avServStop(gClientInfo[SID].avChannel);
                        gClientInfo[SID].playBackCh=0;
                        
                        if(P2PVideoPlaybackCmpSemEvt)
                        {
                            OSSemSet(P2PVideoPlaybackCmpSemEvt, 0, &err);
                            if(err!= OS_NO_ERR)
                                printf("111Set P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
                        }
                        
                        if(P2PAudioPlaybackCmpSemEvt)
                        {
                            OSSemSet(P2PAudioPlaybackCmpSemEvt, 0, &err);						
                            if(err!= OS_NO_ERR)
                                printf("111Set P2PAudioPlaybackCmpSemEvt fail = %d\n", err);
                        }
                        
#ifndef SAFE_DEL_P2P_PLAYFILE_TASK
						P2PVideoPlaybackCmpSemEvt = OSSemDel(P2PVideoPlaybackCmpSemEvt, OS_DEL_ALWAYS, &err);
						if(err!= OS_NO_ERR)
							printf("Del P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
						P2PAudioPlaybackCmpSemEvt = OSSemDel(P2PAudioPlaybackCmpSemEvt, OS_DEL_ALWAYS, &err);
						if(err!= OS_NO_ERR)
							printf("Del P2PAudioPlaybackCmpSemEvt fail = %d\n", err);
#endif
                        DEBUG_P2P("Fileplaying=%d ,Remote_play=%d \n",Fileplaying,Remote_play);
                        if((Fileplaying)&&(Remote_play==1))
                        {
                            DEBUG_P2P("DELETE P2P PLAYFILE TASK5.\n");

#ifdef SAFE_DEL_P2P_PLAYFILE_TASK                            
                            SafeDelP2pPlayFileTask();
                            OSFlagPend(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_PLAY_FINISH, OS_FLAG_WAIT_CLR_ALL|OS_FLAG_CONSUME, OS_IPC_WAIT_FOREVER, &err);
                            DEBUG_P2P("pend FLAGSYS_RDYSTAT_PLAY_FINISH.\n");                            
#else                            
                            if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
                                DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
                            OSFlagPend(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_PLAY_FINISH, OS_FLAG_WAIT_CLR_ALL|OS_FLAG_CONSUME, OS_IPC_WAIT_FOREVER, &err);
                            DEBUG_P2P("pend FLAGSYS_RDYSTAT_PLAY_FINISH.\n");
                            if(OS_NO_ERR !=  OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY))
                                DEBUG_P2P("OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
#endif                            

                            Fileplaying=0;
                            Remote_play=0;
                            P2PEnableplaybackStreaming=0;
                            DEBUG_YELLOW("Fileplaying=%d ,Remote_play=%d \n",Fileplaying,Remote_play);
                            //OSTimeDly(10);
                        }
                    }
                    else
                        avServStop(gClientInfo[SID].avChannel);
#if(UI_VERSION == UI_VERSION_MAYON)
					gClientInfo[SID].avChannel = -1; //Clear TX channel when avChannel was stoped, Paul add, 180613
#endif
                }
                break;

                case AVIOCTRL_RECORD_PLAY_PAUSE:
                {
                    DEBUG_P2P("AVIOCTRL_RECORD_PLAY_PAUSE\n");
                    q->command=p->command;
                    q->result=0;
                    if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp)) == AV_ER_NoERROR)
                    {
                        DEBUG_P2P("IPCAM_RECORD_PLAYCONTROL_RESP OK \n\n");
                    }
                    gClientInfo[SID].bPausePlayBack = !gClientInfo[SID].bPausePlayBack;

                    if(gClientInfo[SID].bPausePlayBack)
                        P2PStartPauseTime = OSTimeGet();
                    else
                    {
                        P2PStopPauseTime = OSTimeGet();
                        P2PPauseTime = P2PStopPauseTime-P2PStartPauseTime;
                    }
                }
                break;

               case AVIOCTRL_RECORD_PLAY_DELFILE:
                {
                    DEBUG_P2P("AVIOCTRL_RECORD_PLAY_DELFILE\n");

#if PLAYBACK_FILE_DEL_SUPPORT
	                Remoteplayback_CH=p->channel;
	                gRemote_playfile = *p;
	                
	                q->command=p->command;
	                q->result=0;

					get_recorded_filelist((SMsgAVIoctrlListEventReq *)p,SID,avIndex);
					if(dcfItemExist(dcfPlaybackCurFile->pDirEnt->d_name, "r") < 1)
					{
						q->result = -1;
						DEBUG_P2P("Item Exist chk failed.\n");
					}

					if(dcfPlaybackDel() < 1)
					{
						q->result = -1;
						DEBUG_P2P("Play back Del failed.\n");
					}
#else
                    q->command=p->command;
                    q->result=0;

#endif
                    if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp)) == AV_ER_NoERROR)
                    {
                        DEBUG_P2P("IPCAM_RECORD_PLAYCONTROL_RESP OK \n\n");
                    }

                }
                break;

            }

        }
        break;
#if(HW_BOARD_OPTION != MR8211_ZINWELL)
        case IOTYPE_USER_IPCAM_GET_FLOWINFO_REQ:
        {
//            SMsgAVIoctrlGetFlowInfoReq *p = (SMsgAVIoctrlGetFlowInfoReq *)buf;
//            SMsgAVIoctrlGetFlowInfoResp *q = (SMsgAVIoctrlGetFlowInfoResp *)buf;
            DEBUG_P2P("IPCAM_GET_FLOWINFO_REQ OK \n");
        }
        break;
#endif
        case IOTYPE_USER_IPCAM_SET_TIMEZONE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlTimeZone);
            RTC_TIME_ZONE zone;
            SMsgAVIoctrlTimeZone *p = (SMsgAVIoctrlTimeZone *)buf;
            DEBUG_P2P("IPCAM_SET_TIMEZONE_REQ OK \n");
            p->nIsSupportTimeZone=1;
            p->cbSize=size;
            strcpy(timezone_des,p->szTimeZoneString);
            (p->nGMTDiff>0)?(zone.operator=0):(zone.operator=1);
            zone.hour=abs(p->nGMTDiff/60);
            zone.min=abs(p->nGMTDiff%60);
            DEBUG_P2P("Set TimeZone.hour:%d, min:%d\n",zone.hour,zone.min);
            RTC_Set_TimeZone(&zone);
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_SET_TIMEZONE_RESP, (char *)p, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_SET_TIMEZONE_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_GET_TIMEZONE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlTimeZone);
            RTC_TIME_ZONE zone;
            //char timezone_des[256]="Taiwan";

            SMsgAVIoctrlTimeZone *q = (SMsgAVIoctrlTimeZone *)buf;
            DEBUG_P2P("IPCAM_GET_TIMEZONE_REQ OK \n");
            RTC_Get_TimeZone(&zone);
            q->cbSize=size;
            zone.operator?(q->nGMTDiff=(0-zone.hour*60+zone.min)):(q->nGMTDiff=zone.hour*60+zone.min);
            DEBUG_P2P("Get TimeZone= %d minutes\n",q->nGMTDiff);
            q->nIsSupportTimeZone=1;
            strcpy(q->szTimeZoneString,timezone_des);
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_TIMEZONE_RESP, (char *)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_GET_TIMEZONE_RESP OK\n\n");
            }
        }
        break;
///////////////////////////////////////////////////////////

        case IOTYPE_USER_IPCAM_GET_SCHEDULESETTING_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetScheduleSettingResp);
            int cam,hour;
            u8 pdata;

            SMsgAVIoctrlGetScheduleSettingReq *p = (SMsgAVIoctrlGetScheduleSettingReq *)buf;
            SMsgAVIoctrlGetScheduleSettingResp *q = (SMsgAVIoctrlGetScheduleSettingResp *)buf;

            DEBUG_P2P("IPCAM_GET_SCHEDULESETTING_REQ OK \n");

            for(cam=0; cam<=3; cam++)
            {

                for(hour=0; hour<=23; hour++)
                {
                    sysGet_Schedule((u8)cam, (u8)p->dayOfWeek, (u8)hour, &pdata);
                    q->dayOfWeek=p->dayOfWeek;
                    q->rec[hour][cam]=pdata;
                    if(q->rec[hour][cam]==1)
                        DEBUG_P2P("day:%d, rec[%d][%d]=%d\n",q->dayOfWeek,hour,cam,pdata);
                }

            }
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_SCHEDULESETTING_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_GET_SCHEDULESETTING_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_IPCAM_SET_SCHEDULESETTING_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlSetScheduleSettingResp);
            int cam,day,hour;
            SMsgAVIoctrlSetScheduleSettingReq *p = (SMsgAVIoctrlSetScheduleSettingReq *)buf;
            SMsgAVIoctrlSetScheduleSettingResp *q = (SMsgAVIoctrlSetScheduleSettingResp *)buf;

            DEBUG_P2P("IPCAM_SET_SCHEDULESETTING_REQ OK \n");

            for(cam=0; cam<=3; cam++)
            {
                for(day=0; day<=6; day++)
                {
                    for(hour=0; hour<=23; hour++)
                    {
                        if(p->channel[cam]==1 && p->week[day]==1 && p->hour[hour]==1)
                        {
                            if(!sysSet_Schedule((u8)cam, (u8)day, (u8)hour, (u8)p->isSet))
                                DEBUG_P2P("USER_IPCAM_SET_SCHEDULESETTING Fail!! \n");
                            else
                                DEBUG_P2P("USER_IPCAM_SET_SCHEDULESETTING OK!! CH:%d, Day:%d, Hour:%d, isSet:%d\n",(u8)cam, (u8)day, (u8)hour, (u8)p->isSet);
                        }
                    }
                }
            }

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_SET_SCHEDULESETTING_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_SET_SCHEDULESETTING_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_GET_OVERWRITING_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetOverWritingResp);
            u8 isOverWriting;
//            SMsgAVIoctrlGetOverWritingReq *p = (SMsgAVIoctrlGetOverWritingReq *)buf;
            SMsgAVIoctrlGetOverWritingResp *q = (SMsgAVIoctrlGetOverWritingResp *)buf;

            DEBUG_P2P("IPCAM_GET_OVERWRITING_REQ OK \n");

            sysGet_Overwrite(&isOverWriting);
            if(isOverWriting==0)
                q->isOverWriting=1;
            else if(isOverWriting==1)
                q->isOverWriting=0;
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_OVERWRITING_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GET_OVERWRITING_RESP: channel:%d, isOverWriting:%d \n\n",q->channel,isOverWriting);
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_OVERWRITING_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlSetOverWritingResp);
            int tmp;
            SMsgAVIoctrlSetOverWritingReq *p = (SMsgAVIoctrlSetOverWritingReq *)buf;
            SMsgAVIoctrlSetOverWritingResp *q = (SMsgAVIoctrlSetOverWritingResp *)buf;

            DEBUG_P2P("IPCAM_SET_OVERWRITING_REQ OK: channel:%d, isOverWriting:%d \n",p->channel,p->isOverWriting);
            if(p->isOverWriting==0)
                tmp=1;
            else if(p->isOverWriting==1)
                tmp=0;
            if(!sysSet_Overwrite(tmp))
            {
                DEBUG_P2P("SET_OVERWRITING Fail!! \n");
            }
            else
            {
                DEBUG_P2P("SET_OVERWRITING OK!! \n");
            }

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_SET_OVERWRITING_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SET_OVERWRITING_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_RECORDINGDURATION_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlSetRecordingDurationResp);

            SMsgAVIoctrlSetRecordingDurationReq *p = (SMsgAVIoctrlSetRecordingDurationReq *)buf;
            SMsgAVIoctrlSetRecordingDurationResp *q = (SMsgAVIoctrlSetRecordingDurationResp *)buf;

            DEBUG_P2P("IPCAM_SET_RECORDINGDURATION_REQ OK: channel:%d, recordingDuration:%d \n",p->channel,p->recordingDuration);
            /*if(!sysSet_Seccion(p->recordingDuration))
            {
            	DEBUG_P2P("SET_RECORDINGDURATION Fail!! \n");
            }
            else
            {
            	DEBUG_P2P("SET_RECORDINGDURATION OK!! \n");
            }*/
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_SET_RECORDINGDURATION_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SET_RECORDINGDURATION_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_GET_RECORDINGDURATION_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetRecordingDurationResp);
            u32 recordingDuration;

//            SMsgAVIoctrlGetRecordingDurationReq *p = (SMsgAVIoctrlGetRecordingDurationReq *)buf;
            SMsgAVIoctrlGetRecordingDurationResp *q = (SMsgAVIoctrlGetRecordingDurationResp *)buf;

            DEBUG_P2P("IPCAM_GET_RECORDINGDURATION_REQ OK \n");

            sysGet_Seccion(&recordingDuration);
            //q->recordingDuration=recordingDuration;
            q->recordingDuration=10;
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_RECORDINGDURATION_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GET_RECORDINGDURATION_RESP OK: channel:%d, recordingDuration:%d\n\n",q->channel,recordingDuration);
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_PAIRING_REQ:// 20151127 Sean
        {
            SMsgAVIoctrlSetPairingReq *p = (SMsgAVIoctrlSetPairingReq *)buf;

            DEBUG_P2P("IPCAM_SET_PAIRING_REQ OK: channel:%d, isParing:%d\n",p->channel,p->isParing);

            if(!sysSet_Pair((p->channel)-1))
            {
                DEBUG_P2P("USER_IPCAM_SET_PAIRING Fail!! \n");
            }
            else
            {
                DEBUG_P2P("USER_IPCAM_SET_PAIRING OK!! \n");
            }
        }
        break;
        /*case IOTYPE_USER_IPCAM_GET_PAIRING_REQ:
        {
        	DEBUG_P2P("IPCAM_GET_PAIRING_REQ OK \n");
        }
        break;*/
        case IOTYPE_USER_IPCAM_GET_RECORDINGSETUP_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetRecordingSetupResp);
            u8 isCameraOn;

            SMsgAVIoctrlGetRecordingSetupReq *p = (SMsgAVIoctrlGetRecordingSetupReq *)buf;
            SMsgAVIoctrlGetRecordingSetupResp *q = (SMsgAVIoctrlGetRecordingSetupResp *)buf;

            DEBUG_P2P("IPCAM_GET_RECORDINGSETUP_REQ OK \n");

            sysGet_RecMode(p->channel,&isCameraOn);
            q->isCameraOn=isCameraOn;

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_RECORDINGSETUP_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GET_RECORDINGSETUP_RESP OK: channel:%d, isCameraOn:%d\n\n",q->channel, isCameraOn);
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_RECORDINGSETUP_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlSetRecordingSetupResp);

            SMsgAVIoctrlSetRecordingSetupReq *p = (SMsgAVIoctrlSetRecordingSetupReq *)buf;
            SMsgAVIoctrlSetRecordingSetupResp *q = (SMsgAVIoctrlSetRecordingSetupResp *)buf;

            DEBUG_P2P("IPCAM_SET_RECORDINGSETUP_REQ OK. channel:%d, isCameraOn:%d\n",p->channel, p->isCameraOn);
            if(!sysSet_RecMode(p->channel, p->isCameraOn))
            {
                DEBUG_P2P("USER_IPCAM_SET_RECORDINGSETUP Fail!! \n");
            }
            else
            {
                DEBUG_P2P("USER_IPCAM_SET_RECORDINGSETUP OK!! \n");
            }

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_SET_RECORDINGSETUP_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SET_RECORDINGSETUP_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_BRIGHTNESS_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlSetBrightnessResp);

            SMsgAVIoctrlSetBrightnessReq *p = (SMsgAVIoctrlSetBrightnessReq *)buf;
            SMsgAVIoctrlSetBrightnessResp *q = (SMsgAVIoctrlSetBrightnessResp *)buf;

            DEBUG_P2P("IPCAM_SET_BRIGHTNESS_REQ OK. channel:%d, brightnessValue:%d\n",p->channel, p->brightnessValue);

            if(!sysSet_Brightness(p->channel, p->brightnessValue))
            {
                DEBUG_P2P("USER_IPCAM_SET_BRIGHTNESS Fail!! \n");
            }
            else
            {
                DEBUG_P2P("USER_IPCAM_SET_BRIGHTNESS OK!! \n");
            }

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_SET_BRIGHTNESS_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SET_BRIGHTNESS_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_GET_BRIGHTNESS_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetBrightnessResp);
            u8 brightnessValue;

            SMsgAVIoctrlGetBrightnessReq *p = (SMsgAVIoctrlGetBrightnessReq *)buf;
            SMsgAVIoctrlGetBrightnessResp *q = (SMsgAVIoctrlGetBrightnessResp *)buf;

            DEBUG_P2P("IPCAM_GET_BRIGHTNESS_REQ OK \n");

            sysGet_Brightness(p->channel, &brightnessValue);
            q->brightnessValue=brightnessValue;

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_BRIGHTNESS_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GET_BRIGHTNESS_RESP OK: channel:%d, brightnessValue:%d\n\n",q->channel,brightnessValue);
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_RESOLUTION_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlSetResolutionResp);

            SMsgAVIoctrlSetResolutionReq *p = (SMsgAVIoctrlSetResolutionReq *)buf;
            SMsgAVIoctrlSetResolutionResp *q = (SMsgAVIoctrlSetResolutionResp *)buf;

            DEBUG_P2P("IPCAM_SET_RESOLUTION_REQ OK. channel:%d, Resolution:%d\n",p->channel,p->resolution);
#if GATEWAY_BOX	/*some APP will send IOTYPE_USER_IPCAM_SET_RESOLUTION_REQ, even not Gateway box.*/
            if(!sysSet_Resoultion(p->channel,p->resolution ))
            {
                DEBUG_P2P("USER_IPCAM_SET_RESOLUTION Fail!! \n");
            }
            else
            {
                DEBUG_P2P("USER_IPCAM_SET_RESOLUTION OK!! \n");
            }

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_SET_PAIRING_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SET_BRIGHTNESS_RESP OK\n\n");
            }
#endif
        }
        break;
        case IOTYPE_USER_IPCAM_GET_RESOLUTION_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetResolutionResp);
            u8 resolution;

            SMsgAVIoctrlGetResolutionReq *p = (SMsgAVIoctrlGetResolutionReq *)buf;
            SMsgAVIoctrlGetResolutionResp *q = (SMsgAVIoctrlGetResolutionResp *)buf;

            DEBUG_P2P("IPCAM_GET_RESOLUTION_REQ OK \n");

            sysGet_Resoultion(p->channel, &resolution);
            q->resolution=resolution;

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_RESOLUTION_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GET_RESOLUTION_RESP OK: channel:%d, resolution:%d\n\n",q->channel,resolution);
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_DEVICEALARM_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlSetDeviceAlarmResp);

            SMsgAVIoctrlSetDeviceAlarmReq *p = (SMsgAVIoctrlSetDeviceAlarmReq *)buf;
            SMsgAVIoctrlSetDeviceAlarmResp *q = (SMsgAVIoctrlSetDeviceAlarmResp *)buf;

            DEBUG_P2P("IPCAM_SET_DEVICEALARM_REQ: channel:%d, isDeviceAlarm:%d\n",p->channel,p->isDeviceAlarm);

            if(!sysSet_AlarmEnable(p->isDeviceAlarm))
            {
                DEBUG_P2P("USER_IPCAM_SET_RESOLUTION Fail!! \n");
            }
            else
            {
                DEBUG_P2P("USER_IPCAM_SET_RESOLUTION OK!! \n");
            }

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_SET_DEVICEALARM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SET_DEVICEALARM_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_GET_DEVICEALARM_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetDeviceAlarmResp);
            u8 isDeviceAlarm;
            SMsgAVIoctrlGetDeviceAlarmReq *p = (SMsgAVIoctrlGetDeviceAlarmReq *)buf;
            SMsgAVIoctrlGetDeviceAlarmResp *q = (SMsgAVIoctrlGetDeviceAlarmResp *)buf;

            DEBUG_P2P("IPCAM_GET_DEVICEALARM_REQ OK \n");

            sysGet_AlarmEnable(&isDeviceAlarm);
            q->isDeviceAlarm=isDeviceAlarm;

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_DEVICEALARM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GET_DEVICEALARM_RESP OK: channel:%d, isDeviceAlarm:%d\n\n",q->channel,isDeviceAlarm);
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_VIDEOOUT_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlSetVideoOutResp);

            SMsgAVIoctrlSetVideoOutReq *p = (SMsgAVIoctrlSetVideoOutReq *)buf;
            SMsgAVIoctrlSetVideoOutResp *q = (SMsgAVIoctrlSetVideoOutResp *)buf;

            DEBUG_P2P("IPCAM_SET_VIDEOOUT_REQ OK: channel:%d, videoOut:%d\n",p->channel, p->videoOut);

            if(!sysSet_TVOut(p->videoOut))
            {
                DEBUG_P2P("USER_USER_IPCAM_SET_VIDEOOUT Fail!! \n");
            }
            else
            {
                DEBUG_P2P("USER_USER_IPCAM_SET_VIDEOOUT OK!! \n");
            }

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_SET_VIDEOOUT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SET_VIDEOOUT_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_GET_VIDEOOUT_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetVideoOutResp);
            u8 vedioOut;
//            SMsgAVIoctrlGetVideoOutReq *p = (SMsgAVIoctrlGetVideoOutReq *)buf;
            SMsgAVIoctrlGetVideoOutResp *q = (SMsgAVIoctrlGetVideoOutResp *)buf;

            DEBUG_P2P("IPCAM_GET_VIDEOOUT_REQ OK \n");

            sysGet_TVOut(&vedioOut);
            q->videoOut=vedioOut;

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_VIDEOOUT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GET_VIDEOOUT_RESP OK: channel:%d, vedioOut:%d\n\n",q->channel,vedioOut);
            }
        }
        break;
        /*case IOTYPE_USER_IPCAM_SET_DEVICESHOW_REQ:
        {
        	DEBUG_P2P("IPCAM_SET_DEVICESHOW_REQ OK \n");
        }
        break;*/
        case IOTYPE_USER_IPCAM_GET_DEVICESHOW_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetDeviceShowResp);
            struct NetworkInfo info;
            SMsgAVIoctrlGetDeviceShowResp *q = (SMsgAVIoctrlGetDeviceShowResp *)buf;
            //memset(q,0,size);
            DEBUG_P2P("IPCAM_GET_DEVICESHOW_REQ OK \n");
            GetNetworkInfo(&info);
            sprintf((char *)q->ipAddress,"%d.%d.%d.%d",info.IPaddr[0],info.IPaddr[1],info.IPaddr[2],info.IPaddr[3]);
            sprintf((char *)q->getwayAddress,"%d.%d.%d.%d",info.Gateway[0],info.Gateway[1],info.Gateway[2],info.Gateway[3]);
            sprintf((char *)q->netMask,"%d.%d.%d.%d",info.Netmask[0],info.Netmask[1],info.Netmask[2],info.Netmask[3]);
            DEBUG_P2P("IP=%s\n",q->ipAddress);
            DEBUG_P2P("Netmask=%s\n",q->netMask);
            DEBUG_P2P("Gateway=%s\n",q->getwayAddress);

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_DEVICESHOW_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_GET_DEVICESHOW_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_DEVICEBUZZER_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlSetDeviceBuzzerResp);

            SMsgAVIoctrlSetDeviceBuzzerReq *p = (SMsgAVIoctrlSetDeviceBuzzerReq *)buf;
            SMsgAVIoctrlSetDeviceBuzzerResp *q = (SMsgAVIoctrlSetDeviceBuzzerResp *)buf;

            DEBUG_P2P("IPCAM_SET_DEVICEBUZZER_REQ OK: channel:%d, isDeviceBuzzer:%d\n",p->channel,p->isDeviceBuzzer);

            if(!sysSet_AlarmVal(p->isDeviceBuzzer))
            {
                DEBUG_P2P("SET_DEVICEBUZZER Fail!! \n");
            }
            else
            {
                DEBUG_P2P("SET_DEVICEBUZZER OK!! \n");
            }

            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_SET_DEVICEBUZZER_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SET_DEVICEBUZZER_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_GET_DEVICEBUZZER_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetDeviceBuzzerResp);
            u8 isDeviceBuzzer;

//            SMsgAVIoctrlGetDeviceBuzzerReq *p = (SMsgAVIoctrlGetDeviceBuzzerReq *)buf;
            SMsgAVIoctrlGetDeviceBuzzerResp *q = (SMsgAVIoctrlGetDeviceBuzzerResp *)buf;

            DEBUG_P2P("IPCAM_GET_DEVICEBUZZER_REQ OK \n");

            sysGet_AlarmVal(&isDeviceBuzzer);
            q->isDeviceBuzzer=isDeviceBuzzer;
            if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_DEVICEBUZZER_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GET_DEVICEBUZZER_RESP OK: channel:%d, isDeviceBuzzer:%d\n\n",q->channel,isDeviceBuzzer);
            }
        }
        break;

// ----------------------
// HU Light ]m 20150917 Sean
// ----------------------
#if (UI_LIGHT_SUPPORT)

		case IOTYPE_RDI_GETLIGHTCHECK_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetLightSupportResp);
			int i;
			SMsgAVIoctrlGetLightSupportReq	*p = (SMsgAVIoctrlGetLightSupportReq *)buf;
			SMsgAVIoctrlGetLightSupportResp *q = (SMsgAVIoctrlGetLightSupportResp*)buf;

			DEBUG_P2P("IOTYPE_RDI_GETLIGHTCHECK_REQ OK \n");

			if(p->channel == 255)
			{
				for(i=0;i<MAX_AV_CH;i++)
				{
					if(gRfiuUnitCntl[i].RFpara.TxCodeVersion[31] & UI_VERSION_BIT_LIGHT)
					{
						q->lightsupport = 1; //Support Light
						break;
					}
					else
						q->lightsupport = 0; //NOT Support Light
				}
			}
			else
			{
				if(gRfiuUnitCntl[p->channel].RFpara.TxCodeVersion[31] & UI_VERSION_BIT_LIGHT)
				{
					q->lightsupport = 1; //Support Light
				}
				else
					q->lightsupport = 0; //NOT Support Light
			}

			if(avSendIOCtrl3(avIndex, IOTYPE_RDI_GETLIGHTCHECK_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_RDI_GETLIGHTCHECK_RESP OK\n\n");
			}

		}
		break;

        case IOTYPE_RDI_GETLIGHTSTATUS_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetLightStatusResp);

            SMsgAVIoctrlGetLightStatusReq *p	 = (SMsgAVIoctrlGetLightStatusReq *)buf;
            SMsgAVIoctrlGetLightStatusResp *q  = (SMsgAVIoctrlGetLightStatusResp *)buf;

            DEBUG_P2P("IOTYPE_RDI_GETLIGHTSTATUS_REQ OK \n");

            Light_CHN =  p->channel;

            /*
            UI_LIGHT_OFF			=0
            UI_LIGHT_MANUAL_OFF	=1
            UI_LIGHT_TIMER_ON	=2
            UI_LIGHT_MANUAL_ON	=3
            UI_LIGHT_TRIGGER_ON	=4
            */
            if((iconflag[UI_MENU_SETIDX_CH1_LS_STATUS + Light_CHN])<2)
                q->status = 0;
            else
                q->status = 1;

            if(avSendIOCtrl3(avIndex, IOTYPE_RDI_GETLIGHTSTATUS_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_RDI_GETLIGHTSTATUS_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_RDI_SETLIGHTSTATUS_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetLightStatusResp);

            SMsgAVIoctrlSetLightStatusReq *p	 = (SMsgAVIoctrlSetLightStatusReq *)buf;
            SMsgAVIoctrlSetLightStatusResp *q  = (SMsgAVIoctrlSetLightStatusResp *)buf;

            DEBUG_P2P("IOTYPE_RDI_SETLIGHTSTATUS_REQ OK \n");

            Light_CHN =  p->channel;

            if(p->status == 0)
            {
                if(iconflag[UI_MENU_SETIDX_CH1_LS_STATUS+Light_CHN] >1) //Set Light OFF
                    uiCheckLightManualSwitchStatus(Light_CHN);
              #if UI_LIGHT_SUPPORT
                else //If App Setting & 8200 Setting are different, 8200 send sync to APP
                    UpdateAPPLightStatus(Light_CHN);
              #endif
                uiFlowSetRfLightStatus(Light_CHN, 0, 2);    //Set LCD icon OFF

                if(iconflag[UI_MENU_SETIDX_CH1_LS_STATUS+Light_CHN] < 2)
                    q->result = 0;
                else
                    q->result = 1;
            }
            if(p->status == 1)
            {
                if(iconflag[UI_MENU_SETIDX_CH1_LS_STATUS+Light_CHN] < 2) //Set Light ON
                    uiCheckLightManualSwitchStatus(Light_CHN);
              #if UI_LIGHT_SUPPORT
                else //If App Setting & 8200 Setting are different, 8200 send sync to APP
                    UpdateAPPLightStatus(Light_CHN);
              #endif
                uiFlowSetRfLightStatus(Light_CHN, 3, 2);    //Set LCD icon ON

                if(iconflag[UI_MENU_SETIDX_CH1_LS_STATUS+Light_CHN] > 1)
                    q->result = 0;
                else
                    q->result = 1;
            }

            if(avSendIOCtrl3(avIndex, IOTYPE_RDI_SETLIGHTSTATUS_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_RDI_SETLIGHTSTATUS_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_RDI_GETLIGHTCONFIG_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetLightConfigResp);

            SMsgAVIoctrlGetLightConfigReq *p	 = (SMsgAVIoctrlGetLightConfigReq *)buf;
            SMsgAVIoctrlGetLightConfigResp *q  = (SMsgAVIoctrlGetLightConfigResp *)buf;

            DEBUG_P2P("IOTYPE_RDI_GETLIGHTCONFIG_REQ OK \n");

            Light_CHN =  p->channel;
            q->st.repeat[6]=(iconflag[UI_MENU_SETIDX_CH1_LS_TIMER+ Light_CHN]&64)>0?1:0;
            q->st.repeat[5]=(iconflag[UI_MENU_SETIDX_CH1_LS_TIMER+ Light_CHN]&32)>0?1:0;
            q->st.repeat[4]=(iconflag[UI_MENU_SETIDX_CH1_LS_TIMER+ Light_CHN]&16)>0?1:0;
            q->st.repeat[3]=(iconflag[UI_MENU_SETIDX_CH1_LS_TIMER+ Light_CHN]&8)>0?1:0;
            q->st.repeat[2]=(iconflag[UI_MENU_SETIDX_CH1_LS_TIMER+ Light_CHN]&4)>0?1:0;
            q->st.repeat[1]=(iconflag[UI_MENU_SETIDX_CH1_LS_TIMER+ Light_CHN]&2)>0?1:0;
            q->st.repeat[0]=(iconflag[UI_MENU_SETIDX_CH1_LS_TIMER+ Light_CHN]&1)>0?1:0;
			#if (UI_LIGHT_TIME_MIN_FORMAT == UI_TIME_INTERVAL_01MIN)
            q->dimmer = iconflag[UI_MENU_SETIDX_CH1_LS_DIMMER  	+ Light_CHN];
            q->duration =iconflag[UI_MENU_SETIDX_CH1_LS_DURATION	+ Light_CHN];
			#endif
            q->st.lightonHour=		uiLightTimer[Light_CHN][0];
            q->st.lightonMinute=	uiLightTimer[Light_CHN][1];
            q->st.lightoffHour=	uiLightTimer[Light_CHN][2];
            q->st.lightoffMinute=	uiLightTimer[Light_CHN][3];

            if(avSendIOCtrl3(avIndex, IOTYPE_RDI_GETLIGHTCONFIG_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_RDI_GETLIGHTCONFIG_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_RDI_SETLIGHTCONFIG_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetLightConfigResp);
            u8 Repeat;

            SMsgAVIoctrlSetLightConfigReq *p	 = (SMsgAVIoctrlSetLightConfigReq *)buf;
            SMsgAVIoctrlSetLightConfigResp *q  = (SMsgAVIoctrlSetLightConfigResp *)buf;

            DEBUG_P2P("IOTYPE_RDI_SETLIGHTCONFIG_REQ OK \n");

            Light_CHN =  p->channel;
            Repeat = (64*(p->st.repeat[6])+32*(p->st.repeat[5])+16*(p->st.repeat[4])+8*(p->st.repeat[3])+4*(p->st.repeat[2])+2*(p->st.repeat[1])+(p->st.repeat[0]));
            if(Repeat != (iconflag[UI_MENU_SETIDX_CH1_LS_TIMER + Light_CHN]))
                iconflag[UI_MENU_SETIDX_CH1_LS_TIMER + Light_CHN] = Repeat;
#if (UI_LIGHT_TIME_MIN_FORMAT == UI_TIME_INTERVAL_01MIN)
            if(p->dimmer != (iconflag[UI_MENU_SETIDX_CH1_LS_DIMMER + Light_CHN]))
            {
                uiSetRfLightDimmerRxToTx(p->dimmer, Light_CHN);
                iconflag[UI_MENU_SETIDX_CH1_LS_DIMMER + Light_CHN] = p->dimmer;
            }

            if(p->duration != (iconflag[UI_MENU_SETIDX_CH1_LS_DURATION + Light_CHN]))
            {
                uiSetRfLightDurationRxToTx(p->duration, Light_CHN);
                iconflag[UI_MENU_SETIDX_CH1_LS_DURATION + Light_CHN] = p->duration;
            }
#endif
            uiLightTimer[Light_CHN][0] = p->st.lightonHour;
            uiLightTimer[Light_CHN][1] = p->st.lightonMinute;
            uiLightTimer[Light_CHN][2] = p->st.lightoffHour;
            uiLightTimer[Light_CHN][3] = p->st.lightoffMinute;

#if (UI_LIGHT_TIME_MIN_FORMAT == UI_TIME_INTERVAL_01MIN)
            uiSetRfLightTimerRxToTx(p->st.lightonHour, p->st.lightonMinute, p->st.lightoffHour, p->st.lightoffMinute, Repeat, Light_CHN, 1);
#elif (UI_LIGHT_TIME_MIN_FORMAT == UI_TIME_INTERVAL_30MIN)
            uiSyncLightTimer2LightInterval(Light_CHN, 1);
            {
                int i,j;
                for(i=0; i<7; i++)
                {
                    if((p->st.repeat[i]) == 1)
                        for(j=0; j<6; j++)
                            uiSetRfLightTimerRxToTx(i, uiLightInterval[Light_CHN][i][j], uiLightInterval[Light_CHN][i][j], uiLightInterval[Light_CHN][i][j], uiLightInterval[Light_CHN][i][j], uiLightInterval[Light_CHN][i][j], uiLightInterval[Light_CHN][i][j], Light_CHN, 1);
                }
            }
#endif

            Save_UI_Setting();

            q->result = 0;

            if(avSendIOCtrl3(avIndex, IOTYPE_RDI_SETLIGHTCONFIG_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_RDI_SETLIGHTCONFIG_RESP OK\n\n");
            }
        }
        break;
#endif

#if(UI_VERSION == UI_VERSION_MAYON)
		case IOTYPE_WALMART_GETPLAYBACKFPS_REQ: //Paul add for MWM903, copy from Walmart, 180518
		{
			SMsgAVIoctrlGetPlayBackFPSReq *p=(SMsgAVIoctrlGetPlayBackFPSReq *)buf;
#if ENABLE_TUTK_RESEND
			DEBUG_P2P("IOTYPE_WALMART_GETPLAYBACKFPS_REQ OK:%d, %d%%\n\n",p->FPS, 
               gClientInfo[SID].resend_buf_usage_rate);
#else
			DEBUG_P2P("IOTYPE_WALMART_GETPLAYBACKFPS_REQ OK:%d\n\n",p->FPS);
#endif
#if 0
            if((gClientInfo[SID].resend_buf_usage_rate > LOW_BIT_RATE_ENTER) &&
                        (gClientInfo[SID].bPausePlayBack == 0))
            {
                DEBUG_RED("LOW_BIT_RATE_ENTER:%d%%\n\n",gClientInfo[SID].resend_buf_usage_rate);
                gClientInfo[SID].bPausePlayBack = 1;
            }
            else if((gClientInfo[SID].resend_buf_usage_rate < LOW_BIT_RATE_LEAVE) &&
                        (gClientInfo[SID].bPausePlayBack == 1))
            {
                DEBUG_RED("LOW_BIT_RATE_LEAVE:%d%%\n\n",gClientInfo[SID].resend_buf_usage_rate);
                gClientInfo[SID].bPausePlayBack = 0;
            }
#endif
		}
		break;
		case IOTYPE_WALMART_GETPUSHMSGSTATUS_REQ: //Paul add for MWM903, copy from Walmart, 180904
		{
			SMsgAVIoctrlGetPushMsgtStatusResp *q=(SMsgAVIoctrlGetPushMsgtStatusResp *)buf;
			int size =  sizeof(SMsgAVIoctrlGetPushMsgtStatusResp);

			q->status = 0;//Need to modify here.

			DEBUG_P2P("IOTYPE_WALMART_GETPUSHMSGSTATUS_REQ OK:%d\n\n",q->status);

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_GETPUSHMSGSTATUS_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_WALMART_GETPUSHMSGSTATUS_RESP OK\n\n");
            }
		}
		break;
		case IOTYPE_WALMART_SETPUSHMSGSTATUS_REQ: //Paul add for MWM903, copy from Walmart, 180518
		{
			SMsgAVIoctrlSetPushMsgstatusReq *p=(SMsgAVIoctrlSetPushMsgstatusReq *)buf;
			SMsgAVIoctrlSetPushMsgstatusResp *q = (SMsgAVIoctrlSetPushMsgstatusResp *)buf;
			int size =  sizeof(SMsgAVIoctrlSetPushMsgstatusResp);

			DEBUG_P2P("IOTYPE_WALMART_SETPUSHMSGSTATUS_REQ OK:%d\n\n",p->status);

			q->result = 0;//Need to modify here.

			if(avSendIOCtrl3(avIndex, IOTYPE_WALMART_SETPUSHMSGSTATUS_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_USER_SETPUSHMSGSTATUS_RESP OK\n\n");
            }
		}
		break;
#endif

/////////////////////////////////////////////////////////////////

#if(HW_BOARD_OPTION == MR8211_ZINWELL)

        /*
        Used by Zinwell
        */
        case IOTYPE_ZW_PLUGCAM_GETCURRENTTEMP_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetCurrentTempResp);
            float tempture=0;
            SMsgAVIoctrlGetCurrentTempReq *p = (SMsgAVIoctrlGetCurrentTempReq *)buf;
            SMsgAVIoctrlGetCurrentTempResp *q=(SMsgAVIoctrlGetCurrentTempResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GETCURRENTTEMP_REQ OK \n");

            if(sysGet_CurrTemp(&tempture)<0)
            {
                DEBUG_P2P("GETCURRENTTEMP Fail!! \n");
                q->CurrentTemp=255;
            }
            else
                q->CurrentTemp=tempture;
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_GETCURRENTTEMP_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GETCURRENTTEMP_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_GETTEMPHIGHMARGIN_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetTempHighMarginResp);
            float temp;
            SMsgAVIoctrlGetTempHighMarginReq *p = (SMsgAVIoctrlGetTempHighMarginReq *)buf;
            SMsgAVIoctrlGetTempHighMarginResp *q=(SMsgAVIoctrlGetTempHighMarginResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GETTEMPHIGHMARGIN_REQ OK \n");
            if(sysGet_TempHighMargin(p->channel,&temp))
            {
                DEBUG_P2P("GET TEMP HIGH MARGIN Fail!! \n");
                q->CurrentTemp=-1;
            }
            else
            {
                DEBUG_P2P("GET TEMP HIGH MARGIN OK!! \n");
                q->CurrentTemp=temp;
            }

            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_GETTEMPHIGHMARGIN_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GETTEMPHIGHMARGIN_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SETTEMPHIGHMARGIN_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetTempHighMarginResp);

            SMsgAVIoctrlSetTempHighMarginReq *p = (SMsgAVIoctrlSetTempHighMarginReq *)buf;
            SMsgAVIoctrlSetTempHighMarginResp *q=(SMsgAVIoctrlSetTempHighMarginResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SETTEMPHIGHMARGIN_REQ OK \n");
            if(sysSet_TempHighMargin(p->channel,p->CurrentTemp))
            {
                DEBUG_P2P("SET TEMP HIGH MARGIN Fail!! \n");
            }
            else
            {
                DEBUG_P2P("SET TEMP HIGH MARGIN OK!! \n");
            }
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_SETTEMPHIGHMARGIN_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SETTEMPHIGHMARGIN_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_GETTEMPLOWMARGIN_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetTempLowMarginResp);
            float temp;
            SMsgAVIoctrlGetTempLowMarginReq *p = (SMsgAVIoctrlGetTempLowMarginReq *)buf;
            SMsgAVIoctrlGetTempLowMarginResp *q=(SMsgAVIoctrlGetTempLowMarginResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GETTEMPLOWMARGIN_REQ OK \n");
            if(sysGet_TempLowMargin(p->channel,&temp))
            {
                DEBUG_P2P("GET TEMP LOW MARGIN Fail!! \n");
                q->CurrentTemp=-1;
            }
            else
            {
                DEBUG_P2P("GET TEMP LOW MARGIN OK!! \n");
                q->CurrentTemp=temp;
            }
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_GETTEMPLOWMARGIN_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GETTEMPLOWMARGIN_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SETTEMPLOWMARGIN_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetTempLowMarginResp);

            SMsgAVIoctrlSetTempLowMarginReq *p = (SMsgAVIoctrlSetTempLowMarginReq *)buf;
            SMsgAVIoctrlSetTempLowMarginResp *q =(SMsgAVIoctrlSetTempLowMarginResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SETTEMPLOWMARGIN_REQ OK \n");
            if(sysSet_TempLowMargin(p->channel,p->CurrentTemp))
            {
                DEBUG_P2P("SET TEMP LOW MARGIN Fail!! \n");
            }
            else
            {
                DEBUG_P2P("SET TEMP LOW MARGIN OK!! \n");
            }
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_SETTEMPLOWMARGIN_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SETTEMPLOWMARGIN_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SETRESET_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetResetResp);

            SMsgAVIoctrlSetResetReq *p = (SMsgAVIoctrlSetResetReq *)buf;
            SMsgAVIoctrlSetResetResp *q = (SMsgAVIoctrlSetResetResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SETRESET_REQ OK \n");
            q->result=sysSet_ResetToDef();
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_SETRESET_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SETRESET_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SET_NIGHTMODE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetNightModeResp);

            SMsgAVIoctrlSetNightModeReq *p = (SMsgAVIoctrlSetNightModeReq *)buf;
            SMsgAVIoctrlSetNightModeResp *q = (SMsgAVIoctrlSetNightModeResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_NIGHTMODE_REQ OK \n");

            if(sysSetNightMode(p->mode)<0)
            {
                DEBUG_P2P("SET NIGHTMODE Fail!! \n");
                q->result=-1;
            }
            else
            {
                DEBUG_P2P("SET NIGHTMODE OK!! \n");
                q->result=0;
            }
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_SET_NIGHTMODE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_NIGHTMODE_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_GET_NIGHTMODE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetNightModeResp);
            unsigned char mode;
            SMsgAVIoctrlGetNightModeReq *p = (SMsgAVIoctrlGetNightModeReq *)buf;
            SMsgAVIoctrlGetNightModeResp *q = (SMsgAVIoctrlGetNightModeResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_NIGHTMODE_REQ OK \n");

            if(sysGetNightMode(&mode)<0)
            {
                DEBUG_P2P("GET NIGHTMODE Fail!! \n");
                q->mode=255;
            }
            else
            {
                DEBUG_P2P("GET NIGHTMODE OK!! \n");
                q->mode=mode;
            }
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_GET_NIGHTMODE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_NIGHTMODE_RESP OK\n\n");
            }
        }
        break;

        case  IOTYPE_ZW_PLUGCAM_GET_LIGHT_REQ :
        {
            int size =  sizeof(SMsgAVIoctrlGetLightResp);
            unsigned char CurrentValueR,CurrentValueG,CurrentValueB,CurrentValueL,status;
            SMsgAVIoctrlGetLightReq *p = (SMsgAVIoctrlGetLightReq *)buf;
            SMsgAVIoctrlGetLightResp *q = (SMsgAVIoctrlGetLightResp *)buf;

            DEBUG_P2P(" IOTYPE_ZW_PLUGCAM_GET_LIGHT_REQ  OK \n");

            if(sysGetLight(&CurrentValueR,&CurrentValueG,&CurrentValueB,&CurrentValueL,&status)<0)
            {
                DEBUG_P2P("GET LIGHT Fail!! \n");
                q->CurrentValueR=255;
                q->CurrentValueG=255;
                q->CurrentValueB=255;
                q->CurrentValueL=255;
                q->CurrentStatus=255;
            }
            else
            {
                DEBUG_P2P("GET LIGHT OK!! \n");
                q->CurrentStatus=status;
                q->CurrentValueR=CurrentValueR;
                q->CurrentValueG=CurrentValueG;
                q->CurrentValueB=CurrentValueB;
                q->CurrentValueL=CurrentValueL;
            }
            if(avSendIOCtrl3(avIndex,  IOTYPE_ZW_PLUGCAM_GET_LIGHT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P(" IOTYPE_ZW_PLUGCAM_GET_LIGHT_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SET_LIGHT_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetLightResp);

            SMsgAVIoctrlSetLightReq *p = (SMsgAVIoctrlSetLightReq *)buf;
            SMsgAVIoctrlSetLightResp *q = (SMsgAVIoctrlSetLightResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_LIGHT_REQ OK \n");

            if(sysSetLight(p->CurrentValueR,p->CurrentValueG,p->CurrentValueB,p->CurrentValueL,p->CurrentStatus)<0)
            {
                DEBUG_P2P("SET LIGHT Fail!! \n");
                q->Status=2;
            }
            else
            {
                DEBUG_P2P("SET LIGHT OK!! \n");
                q->Status=1;
            }
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_SET_LIGHT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_LIGHT_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SET_FILERECYCLE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetRecycleResp);

            SMsgAVIoctrlSetRecycleReq *p = (SMsgAVIoctrlSetRecycleReq *)buf;
            SMsgAVIoctrlSetRecycleResp *q = (SMsgAVIoctrlSetRecycleResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_FILERECYCLE_REQ OK \n");

            if(sysSetFileRecycle(p->Status)<0)
            {
                DEBUG_P2P("SET FILE RECYCLE Fail!! \n");
                q->Status=4;
            }
            else
            {
                DEBUG_P2P("SET FILE RECYCLE OK!! \n");
                q->Status=3;
            }
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_SET_FILERECYCLE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_FILERECYCLE_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_GET_FILERECYCLE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetRecycleResp);
            unsigned char status;
            SMsgAVIoctrlGetRecycleReq *p = (SMsgAVIoctrlGetRecycleReq *)buf;
            SMsgAVIoctrlGetRecycleResp *q = (SMsgAVIoctrlGetRecycleResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_FILERECYCLE_REQ OK \n");

            if(sysGetFileRecycle(&status)<0)
            {
                DEBUG_P2P("SET FILE RECYCLE Fail!! \n");
                q->Status=255;
            }
            else
            {
                DEBUG_P2P("SET FILE RECYCLE OK!! \n");
                q->Status=status;
            }
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_GET_FILERECYCLE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_FILERECYCLE_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_GET_SDCARDMUM_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetMUMSDCardResp);
            unsigned char mode;
            SMsgAVIoctrlGetMUMSDCardReq *p = (SMsgAVIoctrlGetMUMSDCardReq *)buf;
            SMsgAVIoctrlGetMUMSDCardResp *q = (SMsgAVIoctrlGetMUMSDCardResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_SDCARDMUM_REQ OK \n");

            if(sysGetMountSD(&mode)<0)
            {
                DEBUG_P2P("GET SD MOUNT INFO Fail!! \n");
                q->mode=255;
            }
            else
            {
                DEBUG_P2P("GET SD MOUNT INFO OK!! \n");
                q->mode=mode;
            }
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_GET_SDCARDMUM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_SDCARDMUM_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SET_SDCARDMUM_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetMUMSDCardResp);

            SMsgAVIoctrlSetMUMSDCardReq *p = (SMsgAVIoctrlSetMUMSDCardReq *)buf;
            SMsgAVIoctrlSetMUMSDCardResp *q = (SMsgAVIoctrlSetMUMSDCardResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_SDCARDMUM_REQ OK \n");

            if(sysSetMountSD(p->mode)<0)
            {
                DEBUG_P2P("SET SD MOUNT INFO Fail!! \n");
                q->result=255;
            }
            else
            {
                DEBUG_P2P("SET SD MOUNT INFO OK!! \n");
                q->result=0;
            }
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_SET_SDCARDMUM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_SDCARDMUM_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_GETFWVERSION_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetFWVersionResp);
            char version[16];

            SMsgAVIoctrlGetFWVersionReq *p = (SMsgAVIoctrlGetFWVersionReq *)buf;
            SMsgAVIoctrlGetFWVersionResp *q = (SMsgAVIoctrlGetFWVersionResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GETFWVERSION_REQ OK \n");

            if(sysGetFWver(version)<0)
            {
                DEBUG_P2P("GET FW VER Fail!! \n");
                //q->version=255;
            }
            else
            {
                DEBUG_P2P("GET FW VER OK!! \n");
                strcpy(q->version,version);
            }
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_GETFWVERSION_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GETFWVERSION_RESP OK\n\n");
            }
        }
        break;
        /*
        		case IOTYPE_ZW_PLUGCAM_GET_FWUPDATE_REQ:
        		{
        			int size =  sizeof(SMsgAVIoctrlGetFWVersionResp);
        			char version[16];

        			SMsgAVIoctrlGetFWVersionReq *p = (SMsgAVIoctrlGetFWVersionReq *)buf;
        			SMsgAVIoctrlGetFWVersionResp *q = (SMsgAVIoctrlGetFWVersionResp *)buf;

        			DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_FWUPDATE_REQ OK \n");
        			Check_fw_ver_net(Check_by_net);
        			strcpy(q->version,fw_version);
        			if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_GET_FWUPDATE_RESP, (char*)q, size)== AV_ER_NoERROR)
        			{
        				DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_FWUPDATE_RESP OK\n\n");
        			}
        		}
        		break;
        */
        case IOTYPE_ZW_PLUGCAM_SET_FWUPDATE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlFirmwareUpdateResp);

            SMsgAVIoctrlFirmwareUpdateReq *p = (SMsgAVIoctrlFirmwareUpdateReq *)buf;
            SMsgAVIoctrlFirmwareUpdateResp *q = (SMsgAVIoctrlFirmwareUpdateResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_FWUPDATE_REQ OK \n");

            Check_fw_ver_net(Check_by_net);
            OSTimeDly(10);
            Upgrade_fw_net();
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_SET_FWUPDATE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_FWUPDATE_RESP OK\n\n");
            }
        }
        break;

        /*
        case IOTYPE_USER_IPCAM_SET_MDREGION_REQ:
        {
        	int size =  sizeof(SMsgAVIoctrlSetMUMSDCardResp);

        	SMsgAVIoctrlSetMUMSDCardReq *p = (SMsgAVIoctrlSetMUMSDCardReq *)buf;
        	SMsgAVIoctrlSetMUMSDCardResp *q = (SMsgAVIoctrlSetMUMSDCardResp *)buf;

        	DEBUG_P2P("IPCAM_SET_MDREGION_REQ OK \n");

        	if(sysSetMountSD(p->mode)<0)
        	{
        		DEBUG_P2P("SET MDREGION Fail!! \n");
        		q->result=255;
        	}
        	else
        	{
        		DEBUG_P2P("SET MDREGION INFO OK!! \n");
        		q->result=0;
        	}
        	if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_SET_MDREGION_RESP, (char*)q, size)== AV_ER_NoERROR)
        	{
        		DEBUG_P2P("IPCAM_SET_MDREGION_RESP OK\n\n");
        	}
        }
        break;

        case IOTYPE_USER_IPCAM_GET_MDREGION_REQ:
        {
        	int size =  sizeof(SMsgAVIoctrlSetMUMSDCardResp);

        	SMsgAVIoctrlSetMUMSDCardReq *p = (SMsgAVIoctrlSetMUMSDCardReq *)buf;
        	SMsgAVIoctrlSetMUMSDCardResp *q = (SMsgAVIoctrlSetMUMSDCardResp *)buf;

        	DEBUG_P2P("IPCAM_GET_MDREGION_REQ OK \n");

        	if(sysSetMountSD(p->mode)<0)
        	{
        		DEBUG_P2P("SET MDREGION Fail!! \n");
        		q->result=255;
        	}
        	else
        	{
        		DEBUG_P2P("SET MDREGION INFO OK!! \n");
        		q->result=0;
        	}
        	if(avSendIOCtrl3(avIndex, IOTYPE_USER_IPCAM_GET_MDREGION_RESP, (char*)q, size)== AV_ER_NoERROR)
        	{
        		DEBUG_P2P("IPCAM_GET_MDREGION_RESP OK\n\n");
        	}
        }
        break;
        */

        case IOTYPE_ZW_PLUGCAM_SET_FREQUENCY_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetFrequencyResp);

            SMsgAVIoctrlSetFrequencyReq *p = (SMsgAVIoctrlSetFrequencyReq *)buf;
            SMsgAVIoctrlSetFrequencyResp *q = (SMsgAVIoctrlSetFrequencyResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_FREQUENCY_REQ OK \n");

            if(sysSetFrequency(p->channel,p->mode)<0)
            {
                DEBUG_P2P("SET FREQUENCY Fail!! \n");
                q->result=-1;
            }
            else
            {
                DEBUG_P2P("SET FREQUENCY OK!! \n");
                q->result=0;
            }
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_SET_FREQUENCY_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_FREQUENCY_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_GET_FREQUENCY_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetFrequencyResp);
            unsigned char mode;
            SMsgAVIoctrlGetFrequencyReq *p = (SMsgAVIoctrlGetFrequencyReq *)buf;
            SMsgAVIoctrlGetFrequencyResp *q = (SMsgAVIoctrlGetFrequencyResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_FREQUENCY_REQ OK \n");

            if(sysGetFrequency(p->channel,&mode)<0)
            {
                DEBUG_P2P("GET FREQUENCY Fail!! \n");
                q->mode=255;
            }
            else
            {
                DEBUG_P2P("GET FREQUENCY OK!! \n");
                q->mode=mode;
            }
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_GET_FREQUENCY_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_FREQUENCY_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SET_REBOOT_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetRebootResp);

            SMsgAVIoctrlSetRebootReq *p = (SMsgAVIoctrlSetRebootReq *)buf;
            SMsgAVIoctrlSetRebootResp *q = (SMsgAVIoctrlSetRebootResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_REBOOT_REQ OK \n");
            q->result=sysSet_Reset();
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_SET_REBOOT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_REBOOT_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_GET_NOISEALERT_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetNoiseAlertResp);
            unsigned char Status;
            SMsgAVIoctrlGetNoiseAlertReq *p = (SMsgAVIoctrlGetNoiseAlertReq *)buf;
            SMsgAVIoctrlGetNoiseAlertResp *q=(SMsgAVIoctrlGetNoiseAlertResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_NOISEALERT_REQ OK \n");
            if(sysGet_NoiseAlert(p->channel,&Status))
            {
                DEBUG_P2P("GET NOISE ALERT Fail!! \n");
                q->Status=-1;
            }
            else
            {
                DEBUG_P2P("GET NOISE ALERT OK!! \n");
                q->Status=Status;
            }

            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_GET_NOISEALERT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_NOISEALERT_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SET_NOISEALERT_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetNoiseAlertResp);

            SMsgAVIoctrlSetNoiseAlertReq *p = (SMsgAVIoctrlSetNoiseAlertReq *)buf;
            SMsgAVIoctrlSetNoiseAlertResp *q=(SMsgAVIoctrlSetNoiseAlertResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_NOISEALERT_REQ OK \n");
            if(sysSet_NoiseAlert(p->channel,p->Status))
            {
                DEBUG_P2P("SET NOISE ALERT Fail!! \n");
                q->Status=-1;
            }
            else
            {
                DEBUG_P2P("SET NOISE ALERT OK!! \n");
                q->Status=0;
            }
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_SET_NOISEALERT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_NOISEALERT_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_GET_TEMPALERT_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetTempAlertResp);
            unsigned char Status;
            SMsgAVIoctrlGetTempAlertReq *p = (SMsgAVIoctrlGetTempAlertReq *)buf;
            SMsgAVIoctrlGetTempAlertResp *q=(SMsgAVIoctrlGetTempAlertResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_TEMPALERT_REQ OK \n");
            if(sysGet_TempAlert(p->channel,&Status))
            {
                DEBUG_P2P("GET TEMPERATURE ALERT Fail!! \n");
                q->Status=-1;
            }
            else
            {
                DEBUG_P2P("GET TEMPERATURE ALERT OK!! \n");
                q->Status=Status;
            }

            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_GET_TEMPALERT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_TEMPALERT_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SET_TEMPALERT_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetTempAlertResp);

            SMsgAVIoctrlSetTempAlertReq *p = (SMsgAVIoctrlSetTempAlertReq *)buf;
            SMsgAVIoctrlSetTempAlertResp *q=(SMsgAVIoctrlSetTempAlertResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_TEMPALERT_REQ OK \n");
            if(sysSet_TempAlert(p->channel,p->Status))
            {
                DEBUG_P2P("SET TEMPERATURE ALERT Fail!! \n");
                q->Status=-1;
            }
            else
            {
                DEBUG_P2P("SET TEMPERATURE ALERT OK!! \n");
                q->Status=0;
            }
            if(avSendIOCtrl3(avIndex, IOTYPE_ZW_PLUGCAM_SET_TEMPALERT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_TEMPALERT_RESP OK\n\n");
            }
        }
        break;

#endif /*Only for Zinwell MR8211*/

        default:
            DEBUG_P2P("non-handle type[%X]\n", ioType);
            break;
    }
}


u8 AVServerStart(int SID)
{
    /**** avIndex ****
    SID 0 : 0, 1, 2, 3
    SID 1 : 4, 5, 6, 7
    SID 2 : 8, 9, A, B
    SID 3 : C, D, E, F
    *****************/
    int ret;
    int i=0;
    int nResend;
    struct st_SInfo Sinfo;    
#if ENABLE_TUTK_RESEND
    nResend = 0;
    ret = avServStart3(SID, AuthCallBackFn, 10, SERVTYPE_STREAM_SERVER, 0, &nResend);
#elif(UI_VERSION == UI_VERSION_MAYON)//Modify for relay mode connection lose issue. Add by Paul 2018.08.28
    ret=avServStart(SID, "admin", gP2PPassword,30, SERVTYPE_STREAM_SERVER, 0);
#else
    ret=avServStart(SID, "admin", gP2PPassword,10, SERVTYPE_STREAM_SERVER, 0);
#endif    
    if(ret < 0)
    {
        DEBUG_P2P("avServStart failed SID[%d] code[%d]!!!\n", SID, ret);
        IOTC_Session_Close(SID);
        return 1;
    }

    if (IOTC_Session_Check(SID, &Sinfo) == IOTC_ER_NoERROR)
	{
		const char *mode[3] = {"P2P", "RLY", "LAN"};
		printf("Client is from[IP:%s, Port:%d] Mode[%s] VPG[%d:%d:%d] VER[%X] NAT[%d] AES[%d]\n", Sinfo.RemoteIP, Sinfo.RemotePort, mode[(int)Sinfo.Mode], Sinfo.VID, Sinfo.PID, Sinfo.GID, Sinfo.IOTCVersion, Sinfo.NatType, Sinfo.isSecure);
#if (P2P_LV_RATECTL_SUPPORT == 1) && ENABLE_TUTK_RESEND
        gClientInfo[SID].connMode = (enum ConnectionMode)Sinfo.Mode;
#endif        
#if 0
		for(i = 0; i < ElemsOfArray(SID_IP_table); ++i)
		{
			if(!strcmp(SID_IP_table[i], Sinfo.RemoteIP))
			{
                if(i != SID)
                {                    
                    if(Clear_Session_Status(i) == 0) // Mark by Paul, it will make all user cannot connect from the same network, if need
                        DEBUG_RED("av:%d,%d\n", __LINE__, i);
                }
				break;
			}
		}
#endif        
		memcpy(SID_IP_table[SID], Sinfo.RemoteIP, sizeof(Sinfo.RemoteIP));		
	}
#if (P2P_LV_RATECTL_SUPPORT == 1) && ENABLE_TUTK_RESEND
    else
    {
        gClientInfo[SID].connMode = RLY_MODE;
    }
#endif

    gClientInfo[SID].avIndex[0] = ret;
    gClientInfo[SID].playBackCh = 0;
    regedit_client_to_avsession(SID, gClientInfo[SID].avIndex[0]);
    DEBUG_P2P("avServStart OK SID[%d] idx[%d] [%d]\n\n\n\n", SID, gClientInfo[SID].avIndex[0], gClientInfo[SID].bP2PConnected);
    for(i = 0; i < MAX_AV_CH; ++i)
    {
        uiSetP2PImageLevel(i,7);
#if ENABLE_TUTK_RESEND
        if(gClientInfo[SID].avIndex[i] >= 0)
            avServSetResendSize(gClientInfo[SID].avIndex[i], TUTK_RESEND_BUF_SIZE);        
#endif
    }
    return 1;
}


#if (VIDEO_CODEC_OPTION == H264_CODEC) //Multi-CH, Multi-Client
#if (VIDEO_APPEND_AUDIO_SUPPORT == 1)
void Task_SessionHandler(void* pData)
{
	extern u8 qetIP;

    u16 video_value[MAX_AV_CH]= {0};
    u16 video_value_max[MAX_AV_CH]= {0};
    u16 audio_value[MAX_AV_CH]= {0};
    u16 audio_value_max[MAX_AV_CH]= {0};
    u32 TimeShift[MAX_AV_CH]= {0};
    unsigned int t1[MAX_AV_CH];
//    unsigned int t2[MAX_AV_CH];
    RTC_DATE_TIME gP2PCheckTime;
    int i,ch;
    int ret;
    char IOCtrlBuf[MAX_BUF_SIZE];
    int SyncTime;
//    unsigned int dt;
    int DlyFlag,RunCount, DlyInterval = 10;
    int mostSemCntCh;
    u16 mostSemCnt;
    //---------------------------//
    INT8U os_err;
    gP2PStatus=0;// if

#if APP_KEEP_ALIVE
    RTC_DATE_TIME current_time;
#endif    
    
    OSFlagPend(gpiNetStatusFlagGrp, FLAGGPI_LWIP_IP_READY, OS_FLAG_WAIT_SET_ALL, OS_IPC_WAIT_FOREVER, &os_err);
    tutk_lib_init();
    timerCountRead(guiRFTimerID, &t1[0]);
    for(i=0; i<MAX_AV_CH; i++)
    {
        t1[i]=t1[0];
        TimeShift[i]=0;
    }
    RunCount=0;
    RTC_Get_Time(&gP2PCheckTime);
    IOTC_Get_Login_Info(&gP2PStatus);

    while(1)
    {
#if(HW_BOARD_OPTION == MR9200_RX_TRANWO_D8796P) //20171208 add.
    Reset_P2P_Connection_flag = 0;
#endif

#if(HOME_RF_SUPPORT)
        if(gAppPairFlag != 0)
        {
            int size =  sizeof(SMsgAVIoctrlSetAddSensorResp);
            SMsgAVIoctrlSetAddSensorResp q;
            sysAppAddSensor(&q);
            if(avSendIOCtrl2(gPairAvIndex, IOTYPE_USER_SETADDSENSOR_RESP, (char*)&q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETADDSENSOR_RESP OK\n\n");
            }
        }
#endif
        //if(gFlagLoginOK || gLoginFaileCnt < 10)
        if(gFlagLoginOK)
        {
            DEBUG_P2P("*****OSTaskDel(LOGIN_TASK_PRIORITY)*****\n");
            DEBUG_P2P("Login P2Pserve : %d.\n",gFlagLoginOK);

            if(gFlagLoginOK)
                SendRegister();//Register the device to APN server
            OSTaskDel(LOGIN_TASK_PRIORITY);
            gFlagLoginOK = 0;
            gLoginFaileCnt =0;
        }

        DlyFlag=1;
        
#if APP_KEEP_ALIVE
			/*===============================KEEP ALIVE==================================*/
		if((APPConnectIcon != 0) || (gOnlineNum > 0))
		{
			for(i = 0; i < MAX_CLIENT; ++i)
			{
				if(!gFlagKeepAlive[i])
				{                    
					if(Clear_Session_Status(i) == 0)
                        DEBUG_RED("av:%d\n", __LINE__);
				}
				else
				{
					RTC_Get_Time(&current_time);
					switch(i)
					{
						case 0:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime0))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[0] = 0;
							RTC_Get_Time(&gKeepAliveTime0);
						}
						break;
						case 1:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime1))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[1] = 0;
							RTC_Get_Time(&gKeepAliveTime1);
						}
						break;
						case 2:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime2))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[2] = 0;
							RTC_Get_Time(&gKeepAliveTime2);
						}
						break;
						case 3:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime3))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[3] = 0;
							RTC_Get_Time(&gKeepAliveTime3);
						}
						case 4:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime4))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[4] = 0;
							RTC_Get_Time(&gKeepAliveTime4);
						}
						break;
						default:
							break;
					}
					//printf("-%d-\n",gFlagKeepAlive);
				}
			}
		}
			/*===============================KEEP ALIVE==================================*/
#endif        
        

        for(ch=0; ch<MAX_AV_CH; ch++)
        {
            //------ Streaming video payload------//
            if(1)//((audio_value[ch] == 0) || (P2PAudioPresentTime[ch] >= P2PVideoPresentTime[ch]))
            {
                if(P2PEnableStreaming[ch])
                {
                
                    if(rfiuRxIIsSounBufMngWriteIdx[ch] < P2PAudioBufReadIdx[ch])
                		audio_value[ch] = ((rfiuRxIIsSounBufMngWriteIdx[ch] + IIS_BUF_NUM) - P2PAudioBufReadIdx[ch]);
                	else
                        audio_value[ch] = rfiuRxIIsSounBufMngWriteIdx[ch] - P2PAudioBufReadIdx[ch];
                    
                    if(rfiuRxVideoBufMngWriteIdx[ch] < P2PVideoBufReadIdx[ch])
                		video_value[ch] = ((rfiuRxVideoBufMngWriteIdx[ch] + VIDEO_BUF_NUM) - P2PVideoBufReadIdx[ch]);
                	else
                        video_value[ch] = rfiuRxVideoBufMngWriteIdx[ch] - P2PVideoBufReadIdx[ch];
                }
                else
                {
                    video_value[ch] = 0;
                    audio_value[ch] = 0;
                }
                
                if (video_value[ch] > 0)
                {
                    //DEBUG_P2P("ch[%d]=%d\n", ch, P2PVideoCmpSemEvt[ch]->OSEventCnt);
				    OSSemAccept(P2PVideoCmpSemEvt[ch]);
                    P2PVideoPresentTime[ch] += (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].time); //if use chunk time
                }
                for(i = 0; i < MAX_CLIENT; ++i)
                {
                    if((ret = Check_Session_Status(i)) < 0)
                    {
                        continue;
                    }
#if ENABLE_TUTK_RESEND
                    ResendBufUsageRateUpdate();
                    if( getResendBufUsage(gClientInfo[i].avChannel, 0) >= RESEND_BUF_MAX_USAGE_RATE)
                    {
                        int ret;
                        ret = avServResetBuffer(gClientInfo[i].avChannel, RESET_ALL, RESET_RESEND_BUF_TIMEOUT);
                        DEBUG_YELLOW("avServResetBuffer8 video sid[%d] err[%d] avIndex[%d]\n", i, ret, gClientInfo[i].avChannel);
                    }
#endif 
                    //aher test 20140316
                    if(gClientInfo[i].playBackCh!=0)
                    {
                        //Handle_IOCTRL_Cmd(i, gClientInfo[CurrPlaybackSID].avChannel, IOCtrlBuf);
                    }
                    Handle_IOCTRL_Cmd(i, gClientInfo[i].avIndex[ch], IOCtrlBuf);
                    //DEBUG_P2P("videoquality =%d\n",videoquality);
                    if((videoquality == 1) || (videoquality == 2))
                    {
                    //printf("%d, %d, %d, %d\n", gClientInfo[i].avIndex[ch], gClientInfo[i].avChannel, (gClientInfo[i].bEnableVideo), video_value[ch]);
#if (P2P_LV_RATECTL_SUPPORT == 1)
                        if((gClientInfo[i].playBackCh == 0 ) && LOW_BIT_RATE_MODE(i))
                        {
                            while(audio_value[ch] > 0)
                            {
                                OSSemAccept(P2PAudioCmpSemEvt[ch]);
                                P2PAudioPresentTime[ch] += (P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time);
                                P2PAudioBufReadIdx[ch] = (P2PAudioBufReadIdx[ch] + 1) % IIS_BUF_NUM;
                                audio_value[ch] = audio_value[ch]-1;
//                                DEBUG_YELLOW("drop Audio [%d], P2P R:%d, W:%d\n",audio_value[ch],P2PAudioBufReadIdx[ch], rfiuRxIIsSounBufMngWriteIdx[ch]);
                            }                        
                        }
#endif
                        if((gClientInfo[i].avIndex[ch] == gClientInfo[i].avChannel) && (gClientInfo[i].bEnableVideo) && (video_value[ch] > 0))
                        {
                          #if P2P_LIVEVIEW_FIND_PRE_I_FRAME
                            if(IFrameSentStatus[i] == I_FRAME_NOT_SEND_YET && (gRfiuUnitCntl[i].RFpara.BateryCam_support == 0)) // do it only for normal cam
                            {
                                UpdateH264Header(ch);
                                memcpy(p2plocal_buffer, H264_config, 0x18);
                                if((P2PVideoBuf[ch][preIframeIndex[ch]].offset+0x18) > (1920*1088*2))
                                    DEBUG_P2P("#0 offset %d\n",P2PVideoBuf[ch][preIframeIndex[ch]].offset);
                                memcpy_hw(p2plocal_buffer+0x18, P2PVideoBuf[ch][preIframeIndex[ch]].buffer, P2PVideoBuf[ch][preIframeIndex[ch]].offset);
                                SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][preIframeIndex[ch]].flag, P2PVideoBuf[ch][preIframeIndex[ch]].offset+0x18, (char *)p2plocal_buffer);
                                IFrameSentStatus[i] = PRE_I_FRAME_SENT;
                                DEBUG_P2P("Sent Pre I, cli:%d, ch:%d, PreIndex:%d, CurIndex:%d\n", i, ch, preIframeIndex[ch], P2PVideoBufReadIdx[ch]);
                            }
                          #endif
                            if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag)
                            {
                              #if(UI_VERSION == UI_VERSION_MAYON)
								if(gClientInfo[i].VOLSend==0)
								{
									DEBUG_P2P("-iF-%d\n",P2PVideoBufReadIdx[ch] );
                                    
								}
                              #endif
                                IFrameSentStatus[i] = LIVE_I_FRAME_SENT;
                                UpdateH264Header(ch);
                                if(audio_value[ch] > P2PTX_AUDIO_TIMESHFT)
                                {
                                    LiveviewLinkAV_config[0x04]=0x08*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT);
                                    
                                    memcpy_hw(p2plocal_buffer, LiveviewLinkAV_config, 0x06);
                                    memcpy_hw(p2plocal_buffer+0x06, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].size*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT));
                                    //DEBUG_YELLOW("== 111 %x %x==\n",LiveviewLinkAV_config[0x03],LiveviewLinkAV_config[0x04]); 
                                    
                                    memcpy(p2plocal_buffer+0x06+P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].size*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT), H264_config, 0x18);
                                    memcpy_hw(p2plocal_buffer+0x06+P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].size*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT)+0x18, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);

                                    SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, 
                                                       0x18+0x06+P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset+(P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].size*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT)), (char *)p2plocal_buffer);
                                    while(audio_value[ch] > P2PTX_AUDIO_TIMESHFT)
                                    {
                                        OSSemAccept(P2PAudioCmpSemEvt[ch]);
                                        P2PAudioPresentTime[ch] += (P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time);
                                        P2PAudioBufReadIdx[ch] = (P2PAudioBufReadIdx[ch] + 1) % IIS_BUF_NUM;
                                        audio_value[ch] = audio_value[ch]-1;
        //                                DEBUG_YELLOW("loss %d, P2P %d\n",audio_value[ch],P2PAudioBufReadIdx[ch]);
                                    }
                                    if(gClientInfo[i].playBackCh!=0)
                                    {
                                        Handle_IOCTRL_Cmd(i, gClientInfo[CurrPlaybackSID].avChannel, IOCtrlBuf);
                                    }
                                }
                                else
                                {
                                    //DEBUG_YELLOW("== 333 ==\n");
                                    memcpy(p2plocal_buffer, H264_config, 0x18);
                                    memcpy_hw(p2plocal_buffer+0x18, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                    SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, 0x18+P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, (char *)p2plocal_buffer);
                                }                                
                            }
                            else
                            {
                                //DEBUG_P2P("Pt=%lu\n",P2PVideoPresentTime[ch]);
                                if(audio_value[ch] > P2PTX_AUDIO_TIMESHFT)
                                {
                                    //DEBUG_YELLOW("== 222 ==\n");
                                    LiveviewLinkAV_config[0x04]=0x08*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT);
                                  
                                    memcpy_hw(p2plocal_buffer, LiveviewLinkAV_config, 0x06);
                                    memcpy_hw(p2plocal_buffer+0x06, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].size*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT));

                                    memcpy_hw(p2plocal_buffer+0x06+P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].size*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT), P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);

                                    if(IFrameSentStatus[i] == LIVE_I_FRAME_SENT)
                                        SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, 
                                                       0x06+P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset+(P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].size*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT)), (char *)p2plocal_buffer);                                                         		
        //                            P2PAudioPresentTime[ch] += (P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time);
        //                            P2PAudioBufReadIdx[ch] = (P2PAudioBufReadIdx[ch] + 1) % IIS_BUF_NUM;
                                    while(audio_value[ch] > P2PTX_AUDIO_TIMESHFT)
                                    {
                                        OSSemAccept(P2PAudioCmpSemEvt[ch]);
                                        P2PAudioPresentTime[ch] += (P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time);
                                        P2PAudioBufReadIdx[ch] = (P2PAudioBufReadIdx[ch] + 1) % IIS_BUF_NUM;
                                        audio_value[ch] = audio_value[ch]-1;
        //                                DEBUG_YELLOW("loss %d, P2P %d\n",audio_value[ch],P2PAudioBufReadIdx[ch]);
                                    }
                                    if(gClientInfo[i].playBackCh!=0)
                                    {
                                        Handle_IOCTRL_Cmd(i, gClientInfo[CurrPlaybackSID].avChannel, IOCtrlBuf);
                                    }
                                }
                                else
                                {
                                    //DEBUG_YELLOW("== 444 ==\n");
                                    if(IFrameSentStatus[i] == LIVE_I_FRAME_SENT)
                                        SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, (char *)P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer);
                                }
                            }
                            //DEBUG_P2P("V%d ",video_value[ch]);
                        }
                    }
                    else
                    {
                        if((gClientInfo[i].avIndex[ch] == gClientInfo[i].avChannel) && (gClientInfo[i].bEnableVideo) && (video_value[ch] > 0))
                        {
                            if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag)
                            {
                                UpdateH264Header(ch);
                                if(audio_value[ch] > P2PTX_AUDIO_TIMESHFT)
                                {
                                    LiveviewLinkAV_config[0x04]=0x08*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT);
                                    
                                    memcpy_hw(p2plocal_buffer, LiveviewLinkAV_config, 0x06);
                                    memcpy_hw(p2plocal_buffer+0x06, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].size*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT));
                                    //DEBUG_YELLOW("== 111 %d %x %x==\n",Link_AV[ch],LinkAV_config[0x03],LinkAV_config[0x04]); 
                                    
                                    memcpy(p2plocal_buffer+0x06+P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].size*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT), H264_config, 0x18);

                                    if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size == 0)
									{
                                        memcpy_hw(p2plocal_buffer+0x06+P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].size*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT)+0x18, 
                                            P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                        SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, 
                                                       0x18+0x06+P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset+(P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].size*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT)), (char *)p2plocal_buffer);
									}
									else
									{
                                        memcpy_hw(p2plocal_buffer+0x06+P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].size*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT)+0x18, 
                                            P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer+P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, 
                                            (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset));
                                        SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, 
                                                       0x18+0x06+(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset)+(P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].size*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT)), (char *)p2plocal_buffer);
									}
                                    
                                    while(audio_value[ch] > P2PTX_AUDIO_TIMESHFT)
                                    {
                                        OSSemAccept(P2PAudioCmpSemEvt[ch]);
                                        P2PAudioPresentTime[ch] += (P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time);
                                        P2PAudioBufReadIdx[ch] = (P2PAudioBufReadIdx[ch] + 1) % IIS_BUF_NUM;
                                        audio_value[ch] = audio_value[ch]-1;
        //                                DEBUG_YELLOW("loss %d, P2P %d\n",audio_value[ch],P2PAudioBufReadIdx[ch]);
                                    }
                                    if(gClientInfo[i].playBackCh!=0)
                                    {
                                        Handle_IOCTRL_Cmd(i, gClientInfo[CurrPlaybackSID].avChannel, IOCtrlBuf);
                                    }
                                }
                                else
                                {
                                    //DEBUG_YELLOW("== 333 ==\n");
                                    memcpy(p2plocal_buffer, H264_config, 0x18);
									if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size == 0)
									{
										memcpy_hw(p2plocal_buffer+0x18, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, 
                                          (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset));
										SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, 
                                          (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset)+0x18, (char *)p2plocal_buffer);
									}
									else
									{
										memcpy_hw(p2plocal_buffer+0x18, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, 
                                          (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset));
										SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, 
                                          (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset)+0x18, (char *)p2plocal_buffer);
									}
                                }
                            }
                            else
                            {
                                //DEBUG_P2P("Pt=%lu\n",P2PVideoPresentTime[ch]);
                                if(audio_value[ch] > P2PTX_AUDIO_TIMESHFT)
                                {
                                    //DEBUG_YELLOW("== 222 ==\n");
                                    LiveviewLinkAV_config[0x04]=0x08*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT);
                                  
                                    memcpy_hw(p2plocal_buffer, LiveviewLinkAV_config, 0x06);
                                    memcpy_hw(p2plocal_buffer+0x06, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer, 
                                        P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].size*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT));

                                    memcpy_hw(p2plocal_buffer+0x06+P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].size*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT), 
                                        P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, 
                                        (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset));

                                    if(IFrameSentStatus[i] == LIVE_I_FRAME_SENT)
                                        SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, 
                                                       0x06+(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset)+(P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].size*(audio_value[ch]-P2PTX_AUDIO_TIMESHFT)), (char *)p2plocal_buffer);
        //                            P2PAudioPresentTime[ch] += (P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time);
        //                            P2PAudioBufReadIdx[ch] = (P2PAudioBufReadIdx[ch] + 1) % IIS_BUF_NUM;
                                    while(audio_value[ch] > P2PTX_AUDIO_TIMESHFT)
                                    {
                                        OSSemAccept(P2PAudioCmpSemEvt[ch]);
                                        P2PAudioPresentTime[ch] += (P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time);
                                        P2PAudioBufReadIdx[ch] = (P2PAudioBufReadIdx[ch] + 1) % IIS_BUF_NUM;
                                        audio_value[ch] = audio_value[ch]-1;
        //                                DEBUG_YELLOW("loss %d, P2P %d\n",audio_value[ch],P2PAudioBufReadIdx[ch]);
                                    }
                                    if(gClientInfo[i].playBackCh!=0)
                                    {
                                        Handle_IOCTRL_Cmd(i, gClientInfo[CurrPlaybackSID].avChannel, IOCtrlBuf);
                                    }
                                }
                                else
                                {
                                    //DEBUG_YELLOW("== 444 ==\n");
                                    if(IFrameSentStatus[i] == LIVE_I_FRAME_SENT)
                                        SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, 
                                        (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset), 
                                        (char *)(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset));
                                }

                            }
                            //DEBUG_P2P("V%d ",video_value[ch]);
                        }
                    }
                }

                if (video_value[ch] > 0)
                {
                    P2PVideoBufReadIdx[ch] = (P2PVideoBufReadIdx[ch] + 1) % VIDEO_BUF_NUM;
                }
            }

            ///------------------- Bitstream buffer control---------------------------------//
            /*
                 Lsk: HVideo bitstream buffer indexlI,Yj ASF_DROP_FRAME_THRESHOLD
                         htLC,drop frame.

            */
            if( (P2PVideoCmpSemEvt[ch]->OSEventCnt > 60) )
            {
                DEBUG_P2P("\nP2P-%d DROP Video frame Start:(%d,%d) \n",ch,P2PVideoPresentTime[ch],P2PAudioPresentTime[ch]);
                SyncTime=0;
                //------Video-----//
                do
                {
                    video_value[ch] = OSSemAccept(P2PVideoCmpSemEvt[ch]);
                    //DEBUG_P2P("%d ",video_value[ch]);
                    if (video_value[ch] > 0)
                    {
                        if(video_value_max[ch] < video_value[ch])
                            video_value_max[ch] = video_value[ch];

                        P2PVideoPresentTime[ch] += P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].time;
                        SyncTime += P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].time;
                        P2PVideoBufReadIdx[ch] = (P2PVideoBufReadIdx[ch] + 1) % VIDEO_BUF_NUM;
                    }
                    else
                    {
                        DEBUG_P2P("Video buffer empty!\n");
                        //break;
                        OSTimeDly(1);
                    }
                }
                while(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag != FLAG_I_VOP);

                //------Audio-----//
                DEBUG_P2P("P2P-%d DROP Audio frame Start:%d,SyncTime=%d \n",ch,P2PAudioCmpSemEvt[ch]->OSEventCnt,SyncTime);

                do
                {
                    audio_value[ch] = OSSemAccept(P2PAudioCmpSemEvt[ch]);
                    //DEBUG_P2P("%d ",audio_value[ch]);

                    if (audio_value[ch] > 0)
                    {
                        if(audio_value_max[ch] < audio_value[ch])
                            audio_value_max[ch] = audio_value[ch];

                        P2PAudioPresentTime[ch] += P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time;
                        SyncTime -= P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time;
                        P2PAudioBufReadIdx[ch] = (P2PAudioBufReadIdx[ch] + 1) % IIS_BUF_NUM;
                    }
                    else
                    {
                        DEBUG_P2P("Audio buffer empty!\n");
                        break;
                    }

                    if(SyncTime < 0)
                        break;
                }
                while( (P2PAudioPresentTime[ch] < P2PVideoPresentTime[ch]) );

                //P2PAudioPresentTime[ch] = P2PVideoPresentTime[ch];
                DEBUG_P2P("P2P-%d DROP frame End:(%d,%d)!!\n\n",ch,P2PVideoPresentTime[ch],P2PAudioPresentTime[ch]);
                sysDeadLockMonitor_Reset();
                DlyFlag=0;
                RunCount=0;
                //OSTimeDly(1);
            }

            if ( (video_value[ch] > 0) || (audio_value[ch] > 0) )
                DlyFlag=0;
        }


	/*adjust delay interval, Delay too much will cause P2P liveView lag, Delay too less will cause Record and System cannot get any CPU resource*/
	 mostSemCnt = 0;
	 mostSemCntCh = -1;

	if((DlyFlag == 0) && ((RunCount % DlyInterval) == 0))
	{
		/* get the Channel, which has the most sem cnt */
	        for(ch=0; ch<MAX_AV_CH; ch++)
	        {
		        if(MultiChannelGetCaptureVideoStatus(ch))
			{
				if(VideoClipOption[ch].VideoCmpSemEvt->OSEventCnt > mostSemCnt)
				{
					mostSemCnt = VideoClipOption[ch].VideoCmpSemEvt->OSEventCnt;
					mostSemCntCh = ch;
				}
		        }
	        }
		 if(mostSemCntCh >= 0) //recording channel exists
		 {
		      if(mostSemCnt > 60)
			    DlyInterval = 3;
		      else if(mostSemCnt > 40)
			    DlyInterval = 5;
			else if(mostSemCnt > 20)
			    DlyInterval = 7;
			else 
			    DlyInterval = 10;
	         }
		  else  //no recording
	              DlyInterval = 10;
	 }

        if(DlyFlag)
        {
            RunCount=0;
            //DEBUG_P2P("&");
            OSTimeDly(1);

        }
        else
        {
            if( (RunCount % DlyInterval) == 0) //Lucian: release CPU power
            {
                //DEBUG_P2P("V=%d ",P2PVideoCmpSemEvt[ch]->OSEventCnt);
                //DEBUG_P2P("Rcnt=%d ",RunCount);
                if(RunCount>100)
                    sysDeadLockMonitor_Reset();
                OSTimeDly(1);
            }
        }

        RunCount ++;
    }
}
#else
void Task_SessionHandler(void* pData)
{
	extern u8 qetIP;
#if (HOME_RF_SUPPORT)
	extern char *Get_JSON_ADD_MessageString(SMsgAVIoctrlSetAddSensorResp *resp, char *JSON_buf);
#endif

    u16 video_value[MAX_AV_CH]= {0};
    u16 video_value_max[MAX_AV_CH]= {0};
    u16 audio_value[MAX_AV_CH]= {0};
    u16 audio_value_max[MAX_AV_CH]= {0};
    u32 TimeShift[MAX_AV_CH]= {0};
    unsigned int t1[MAX_AV_CH];
    unsigned int t2[MAX_AV_CH];
    RTC_DATE_TIME gP2PCheckTime;
    int i,ch;
    int ret;
    char IOCtrlBuf[MAX_BUF_SIZE];
    int SyncTime;
    unsigned int dt;
    RTC_DATE_TIME current_time;
    u8 gP2PCheckFail;
    int err;
    char    hostname_IP[HOSTNAME_IP_BUF_SIZE]="";
    char hostname[50];
    int DlyFlag,RunCount, DlyInterval = 10;
    u32 testime=0;
    int mostSemCntCh;
    u16 mostSemCnt;
#if (HOME_RF_SUPPORT)
    char JSON_buf[128];
#endif
    INT8U os_err;

    OSFlagPend(gpiNetStatusFlagGrp, FLAGGPI_LWIP_IP_READY, OS_FLAG_WAIT_SET_ALL, OS_IPC_WAIT_FOREVER, &os_err);
    tutk_lib_init();

    //---------------------------//
    gP2PStatus=0;// if
    timerCountRead(guiRFTimerID, &t1[0]);
    for(i=0; i<MAX_AV_CH; i++)
    {
        t1[i]=t1[0];
        TimeShift[i]=0;
    }
    RunCount=0;
    RTC_Get_Time(&gP2PCheckTime);
    IOTC_Get_Login_Info(&gP2PStatus);
    gP2PCheckFail=0;
    while(1)
    {

#if(HW_BOARD_OPTION == MR9200_RX_TRANWO_D8796P) //20171208 add.
    Reset_P2P_Connection_flag = 0;
#endif
#if(HOME_RF_SUPPORT)
//20181206 Sean Add for test
        if(gAppPairFlag != 0)
        {
		int size =  sizeof(SMsgAVIoctrlSetAddSensorResp);
		SMsgAVIoctrlSetAddSensorResp q;
		sysAppAddSensor(&q);

		memset(IOCtrlBuf, 0, sizeof(IOCtrlBuf));
		Get_JSON_ADD_MessageString(&q, JSON_buf);
            if(avSendIOCtrl2(gPairAvIndex, IOTYPE_HA_JASON_CMD_RESP, (char*)&JSON_buf, sizeof(JSON_buf))== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETADDSENSOR_RESP OK\n\n");
            }
        }
#endif

#if APP_KEEP_ALIVE
			/*===============================KEEP ALIVE==================================*/
		if((APPConnectIcon != 0) || (gOnlineNum > 0))
		{
			for(i=0;i<MAX_CLIENT+1;i++)
			{
				if(!gFlagKeepAlive[i])
				{
					Clear_Session_Status(i);
				}
				else
				{
					RTC_Get_Time(&current_time);
					switch(i)
					{
						case 0:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime0))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[0] = 0;
							RTC_Get_Time(&gKeepAliveTime0);
						}
						break;
						case 1:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime1))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[1] = 0;
							RTC_Get_Time(&gKeepAliveTime1);
						}
						break;
						case 2:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime2))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[2] = 0;
							RTC_Get_Time(&gKeepAliveTime2);
						}
						break;
						case 3:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime3))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[3] = 0;
							RTC_Get_Time(&gKeepAliveTime3);
						}
						case 4:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime4))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[4] = 0;
							RTC_Get_Time(&gKeepAliveTime4);
						}
						break;
						default:
							break;
					}
					//printf("-%d-\n",gFlagKeepAlive);
				}
			}
		}
			/*===============================KEEP ALIVE==================================*/
#endif

        //if(gFlagLoginOK || gLoginFaileCnt < 10)
        if(gFlagLoginOK)
        {
            DEBUG_P2P("*****OSTaskDel(LOGIN_TASK_PRIORITY)*****\n");
            DEBUG_P2P("Login P2Pserve : %d.\n",gFlagLoginOK);
            if(gFlagLoginOK)
                SendRegister();//Register the device to APN server
            
            OSTaskDel(LOGIN_TASK_PRIORITY);
            gFlagLoginOK = 0;
            gLoginFaileCnt =0;
        }

        DlyFlag=1;
        /*Try to reconnect the P2P server, when P2P info != 7.*/
        RTC_Get_Time(&current_time);
        if(net_link_status==NET_LINK_ON)
        {
            if(gOnlineNum==0)/*Don't check P2P server connection status, when APP is connecting.*/
            {
                if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gP2PCheckTime)))>30)
                {
                    IOTC_Get_Login_Info(&gP2PStatus);
                    RTC_Get_Time(&gP2PCheckTime);
                    if (gP2PStatus<7)
                    {
                        DEBUG_P2P("Retry p2p failed:%d.\n",gP2PCheckFail);
                        gP2PCheckFail++;
                    }
                    else
                        gP2PCheckFail=1;

                    if(gP2PCheckFail<15)    /* Re-open p2p socket, if Check p2p connection fail.*/
                    {
                        if ((gP2PCheckFail%3)==0)
                        {
							#if(HW_BOARD_OPTION == MR9200_RX_TRANWO_D8796P) //20171208 add.
							Reset_P2P_Connection_flag = 1;
							#endif

                            strcpy(hostname,TPNS_SERVER);
                            err=DN2IP(hostname, hostname_IP);
                            if(err!=0)
                                DEBUG_P2P("WAN is not ready...\n");
                            //else //20170216 Sean: this func cause APP can't connect, pbuf_alloc will fail.
                            //{
                            //    DEBUG_P2P("Renew ioctl module.\n");
                            //    renew_iotclModule(2123*gP2PCheckFail);
                            //}

							#if(HW_BOARD_OPTION == MR9200_RX_TRANWO_D8796P) //20171208 add.
							Reset_P2P_Connection_flag = 0;
							Reset_P2P_Connection_Stop_flag = 0;
							#endif
                        }
                    }
                    if(gP2PCheckFail==15) /*Re-new IP, if check p2p connection still fail after re-open socket.*/
                    {
                        ClearNetworkInfo();
                        #if(HW_BOARD_OPTION == MR9200_RX_TRANWO_D8796P) //20171208 add.
						Reset_P2P_Connection_Stop_flag = 1;
						#endif
						#if(HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) //20180201 add.
                        if(qetIP == 0 || SetLwIP(1)==-1)
						#else
                        if(SetLwIP(1)==-1)
                        #endif
                        {
                            DEBUG_P2P("Couldn't get IP, rebooting...\n");
							sysForceWDTtoReboot();
                        }
                        strcpy(hostname,TPNS_SERVER);
                        err=DN2IP(hostname, hostname_IP);
                        if(err!=0)
                            DEBUG_P2P("WAN is not ready...\n");
                        //else //20170216 Sean
                        //{
                        //    renew_iotclModule(45367);
                        //}
						#if(HW_BOARD_OPTION == MR9200_RX_TRANWO_D8796P) //20171208 add.
						Reset_P2P_Connection_flag = 0;
					    Reset_P2P_Connection_Stop_flag = 0;
					    #endif
                    }
                    if(gP2PCheckFail==30) /*Reboot device, if check p2p connection still fail after re-new ip.*/
                    {
                        DEBUG_P2P("P2P connection couldn't recovery, rebooting...\n");
						sysForceWDTtoReboot();
                    }
                }
            }
        }

        for(ch=0; ch<MAX_AV_CH; ch++)
        {
            // ------Streaming audio payload------//
            if((video_value[ch] == 0) || (P2PAudioPresentTime[ch] <= P2PVideoPresentTime[ch]))
            {
                audio_value[ch] = OSSemAccept(P2PAudioCmpSemEvt[ch]);
                if (audio_value[ch] > 0)
                {
                    if(audio_value_max[ch] < audio_value[ch])
                        audio_value_max[ch] = audio_value[ch];
                    //DEBUG_P2P("PAIdx = %d iisIdx = %d\n", P2PAudioBufReadIdx[ch], VideoClipOption[ch + 1].iisSounBufMngWriteIdx);
                }

                for(i=0; i<MAX_CLIENT; i++)
                {
                    if((ret = Check_Session_Status(i)) < 0) //session disconnected
                    {
                        continue;
                    }
                    
#if ENABLE_TUTK_RESEND
                    if( getResendBufUsage(gClientInfo[i].avChannel, 0) >= RESEND_BUF_MAX_USAGE_RATE)
                    {
                        const int ret = avServResetBuffer(gClientInfo[i].avChannel, RESET_ALL, RESET_RESEND_BUF_TIMEOUT);
                        lwip_mem_stat_disp();
                        DEBUG_YELLOW("avServResetBuffer9 video sid[%d] err[%d] avIndex[%d]\n", i, ret, gClientInfo[i].avChannel);
                        if(ret == AV_ER_INVALID_SID || ret == AV_ER_SESSION_CLOSE_BY_REMOTE || ret == AV_ER_REMOTE_TIMEOUT_DISCONNECT)
                        {
                            StopAndClearSession(i, ret);
                            continue;
                        }
                    }
#endif                    
                    
                    //aher test 20140316
                    if(gClientInfo[i].playBackCh!=0)
                    {
                        Handle_IOCTRL_Cmd(i, gClientInfo[CurrPlaybackSID].avChannel, IOCtrlBuf);
                    }

                    Handle_IOCTRL_Cmd(i, gClientInfo[i].avIndex[ch], IOCtrlBuf);


                    if((gClientInfo[i].avIndex[ch] == gClientInfo[i].avChannel) && (gClientInfo[i].bEnableAudio > 0) && (audio_value[ch] > 0))
                    {
                        //TUTK API only support 1024byte
                        /*
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]   , 1024, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+64, 1024, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+1024);
                        */
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]   , 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+20, 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+320);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+40, 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+640);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+60, 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+960);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+80, 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+1280);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+100,320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+1600);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+108, 128, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+1920);

                    }
                }

                if (audio_value[ch] > 0)
                {
#if( (SW_APPLICATION_OPTION == MR8200_RFCAM_RX1RX2) || (SW_APPLICATION_OPTION == MR9300_RFDVR_RX1RX2) || (SW_APPLICATION_OPTION == MR9300_NETBOX_RX1RX2) || (SW_APPLICATION_OPTION == MR9200_HDMI_RX1RX2) || (SW_APPLICATION_OPTION == MR9200_MIXCAM_RX1RX2) || (SW_APPLICATION_OPTION == MR8200_RFCAM_RX1) )
                    timerCountRead(guiRFTimerID, &t2[ch]);
                    if(P2PChannelStart[ch])
                    {
                        t1[ch]=t2[ch];
                        P2PChannelStart[ch]=0;
                        TimeShift[ch]=0;
                    }
                    if(t1[ch] >= t2[ch])
                        dt=t1[ch]-t2[ch];
                    else
                        dt=(t1[ch]+TimerGetTimerCounter(TIMER_7))-t2[ch];

                    if(dt > 20000)
                    {
                        TimeShift[ch] = dt/10;
                        if(P2PChannelStart[ch])
                            TimeShift[ch]=0;
                        else
                        {
                            P2PAudioPresentTime[ch] += (TimeShift[ch]+2000);
                            P2PVideoPresentTime[ch] += (TimeShift[ch]+2000);
                            DEBUG_P2P("--->P2P Ch-%d Shift=%d ms\n",ch,TimeShift[ch]);
                        }
                    }
                    else
                        TimeShift[ch]=0;
                    t1[ch]=t2[ch];
#else
                    TimeShift[ch]=0;
#endif

                    P2PAudioPresentTime[ch] += (P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time);    //if use chunk time
                    P2PAudioBufReadIdx[ch]   = (P2PAudioBufReadIdx[ch] + 1) % IIS_BUF_NUM;
                    //DEBUG_P2P("A%d ",audio_value[ch]);
                }
            }

            //------ Streaming video payload------//
            if(1)//((audio_value[ch] == 0) || (P2PAudioPresentTime[ch] >= P2PVideoPresentTime[ch]))
            {
                video_value[ch] = OSSemAccept(P2PVideoCmpSemEvt[ch]);
                if (video_value[ch] > 0)
                {
                    //DEBUG_P2P("ch[%d]=%d\n", ch, P2PVideoCmpSemEvt[ch]->OSEventCnt);
                    if(video_value_max[ch] < video_value[ch])
                        video_value_max[ch] = video_value[ch];
                    P2PVideoPresentTime[ch] += (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].time); //if use chunk time
                }
                for(i=0; i<MAX_CLIENT; i++)
                {
                    if((ret = Check_Session_Status(i)) < 0)
                    {
                        continue;
                    }
                    
#if ENABLE_TUTK_RESEND
                    ResendBufUsageRateUpdate();
                    if( getResendBufUsage(gClientInfo[i].avChannel, 0) >= RESEND_BUF_MAX_USAGE_RATE)
                    {
                        const int ret = avServResetBuffer(gClientInfo[i].avChannel, RESET_ALL, RESET_RESEND_BUF_TIMEOUT);
                        lwip_mem_stat_disp();
                        DEBUG_YELLOW("avServResetBuffer10 video sid[%d] err[%d] avIndex[%d]\n", i, ret, gClientInfo[i].avChannel);
                        if(ret == AV_ER_INVALID_SID || ret == AV_ER_SESSION_CLOSE_BY_REMOTE || ret == AV_ER_REMOTE_TIMEOUT_DISCONNECT)
                        {
                            StopAndClearSession(i, ret);
                            continue;
                        }
                    }
#endif
                    
                    //aher test 20140316
                    if(gClientInfo[i].playBackCh!=0)
                    {
                        Handle_IOCTRL_Cmd(i, gClientInfo[CurrPlaybackSID].avChannel, IOCtrlBuf);
                    }

                    Handle_IOCTRL_Cmd(i, gClientInfo[i].avIndex[ch], IOCtrlBuf);
#if( (SW_APPLICATION_OPTION == MR9300_RFDVR_RX1RX2) || (SW_APPLICATION_OPTION == MR9300_NETBOX_RX1RX2) )
                    //DEBUG_P2P("videoquality =%d\n",videoquality);
                    if(videoquality == 1)
                    {
#if (P2P_LV_RATECTL_SUPPORT == 1)
                        if((gClientInfo[i].playBackCh == 0 ) && LOW_BIT_RATE_MODE(i))
                        {
                            while(audio_value[ch] > 0)
                            {
                                OSSemAccept(P2PAudioCmpSemEvt[ch]);
                                P2PAudioPresentTime[ch] += (P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time);
                                P2PAudioBufReadIdx[ch] = (P2PAudioBufReadIdx[ch] + 1) % IIS_BUF_NUM;
                                audio_value[ch] = audio_value[ch]-1;
//                                DEBUG_YELLOW("drop Audio [%d], P2P R:%d, W:%d\n",audio_value[ch],P2PAudioBufReadIdx[ch], rfiuRxIIsSounBufMngWriteIdx[ch]);
                            }                        
                        }
#endif                        
                        
                        if((gClientInfo[i].avIndex[ch] == gClientInfo[i].avChannel) && (gClientInfo[i].bEnableVideo) && (video_value[ch] > 0))
                        {
                            if((gClientInfo[i].VOLSend == 0||gClientInfo[i].VOLSend == 5 ) && P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag)
                            {
                                if(P2P_AV_Source[ch] == Local_record)
                                    UpdateHeader(ch, USE_MPEG_QUANTIZATION);
                                else
                                    UpdateH264Header(ch);

                                if (h264header_updata[i] == 0)
                                {
                                    h264header_updata[i]++;
                                    memcpy(p2plocal_buffer, H264_config, 0x18);
                                    memcpy_hw(p2plocal_buffer+0x18, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                }
                                else
                                {
                                    memcpy_hw(p2plocal_buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                    //DEBUG_P2P("I=%2x%2x%2x%2x%2x\n",*(p2plocal_buffer+0x1d),*(p2plocal_buffer+0x1d+1),
                                    //*(p2plocal_buffer+0x1d+2),*(p2plocal_buffer+0x1d+3),*(p2plocal_buffer+0x1d+4));
                                }

                                //DEBUG_P2P("It=%lu\n",P2PVideoPresentTime[ch]);
                                gClientInfo[i].VOLSend = 1; //?????[ ,tutk ?S?^?? 20121404
                                SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset+0x18, p2plocal_buffer);
                                //Wait P2P client send the Ioctl command "IOTYPE_USER_IPCAM_RECEIVE_FIRST_IFRAME"
                                //Send the VOL pre second.

                                if(gClientInfo[i].VOLSend == 5)
                                    gClientInfo[i].VOLSend = 1;
                            }
                            else if(gClientInfo[i].VOLSend >= 1)
                            {
                                //DEBUG_P2P("Pt=%lu\n",P2PVideoPresentTime[ch]);
                                SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer);
                                if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag)
                                {
                                    gClientInfo[i].VOLSend++;
                                }
                            }
                            //DEBUG_P2P("V%d ",video_value[ch]);
                        }
                    }
                    else
                    {
                        if((gClientInfo[i].avIndex[ch] == gClientInfo[i].avChannel) && (gClientInfo[i].bEnableVideo) && (video_value[ch] > 0))
                        {
                            if((gClientInfo[i].VOLSend==0||gClientInfo[i].VOLSend==5 )&& P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag)
                            {
                                if(P2P_AV_Source[ch] == Local_record)
                                    UpdateHeader(ch, USE_MPEG_QUANTIZATION);
                                else
                                    UpdateH264Header(ch);

                                if (h264header_updata[i]==0)
                                {
                                    h264header_updata[i]++;
                                    memcpy(p2plocal_buffer, H264_config, 0x18);
                                    if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size == 0)
                                        memcpy_hw(p2plocal_buffer+0x18, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                    else
                                        memcpy_hw(p2plocal_buffer+0x18, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset));
                                }
                                else
                                {
                                    if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size == 0)
                                        memcpy_hw(p2plocal_buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                    else
                                        memcpy_hw(p2plocal_buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset));
                                    //DEBUG_P2P("I=%2x%2x%2x%2x%2x\n",*(p2plocal_buffer+0x1d),*(p2plocal_buffer+0x1d+1),
                                    //*(p2plocal_buffer+0x1d+2),*(p2plocal_buffer+0x1d+3),*(p2plocal_buffer+0x1d+4));
                                }

                                //DEBUG_P2P("It=%lu\n",P2PVideoPresentTime[ch]);
                                gClientInfo[i].VOLSend = 1; //?????[ ,tutk ?S?^?? 20121404
                                if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size == 0)
                                    SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset+0x18, p2plocal_buffer);
                                else
                                    SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset)+0x18, p2plocal_buffer);

                                //Wait P2P client send the Ioctl command "IOTYPE_USER_IPCAM_RECEIVE_FIRST_IFRAME"
                                //Send the VOL pre second.

                                if(gClientInfo[i].VOLSend == 5)
                                    gClientInfo[i].VOLSend = 1;
                            }
                            else if(gClientInfo[i].VOLSend >= 1)
                            {
                                //DEBUG_P2P("Pt=%lu\n",P2PVideoPresentTime[ch]);
                                if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size == 0)
                                    SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag,  P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer);
                                else
                                    SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset), P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag)
                                {
                                    gClientInfo[i].VOLSend++;
                                }
                            }
                            //DEBUG_P2P("V%d ",video_value[ch]);
                        }
                    }
#else
                    //DEBUG_P2P("videoquality =%d\n",videoquality);
                    if((videoquality == 1) || (videoquality == 2))
                    {
                        if((gClientInfo[i].avIndex[ch] == gClientInfo[i].avChannel) && (gClientInfo[i].bEnableVideo) && (video_value[ch] > 0))
                        {
                          #if P2P_LIVEVIEW_FIND_PRE_I_FRAME
                            if(IFrameSentStatus[i] == I_FRAME_NOT_SEND_YET && (gRfiuUnitCntl[i].RFpara.BateryCam_support == 0)) // do it only for normal cam
                            {
                                UpdateH264Header(ch);
                                memcpy(p2plocal_buffer, H264_config, 0x18);
                                if((P2PVideoBuf[ch][preIframeIndex[ch]].offset+0x18) > (1920*1088*2))
                                    DEBUG_P2P("#0 offset %d\n",P2PVideoBuf[ch][preIframeIndex[ch]].offset);
                                memcpy_hw(p2plocal_buffer+0x18, P2PVideoBuf[ch][preIframeIndex[ch]].buffer, P2PVideoBuf[ch][preIframeIndex[ch]].offset);
                                SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][preIframeIndex[ch]].flag, P2PVideoBuf[ch][preIframeIndex[ch]].offset+0x18, (char *)p2plocal_buffer);
                                IFrameSentStatus[i] = PRE_I_FRAME_SENT;
                                DEBUG_P2P("Sent Pre I, cli:%d, ch:%d, PreIndex:%d, CurIndex:%d\n", i, ch, preIframeIndex[ch], P2PVideoBufReadIdx[ch]);
                            }
                          #endif                            
                            if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag)
                            {
#if(UI_VERSION == UI_VERSION_MAYON)
								if(gClientInfo[i].VOLSend==0)
									DEBUG_P2P("-iF-\n");
#endif
                                if(h264header_updata[i] <= 5)
                                {
                                    if(P2P_AV_Source[ch] == Local_record)
                                        UpdateHeader(ch, USE_MPEG_QUANTIZATION);
                                    else
                                        UpdateH264Header(ch);
                                    h264header_updata[i]++;
                                    memcpy(p2plocal_buffer, H264_config, 0x18);
                                    if((P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset+0x18) > (1920*1088*2))
                                        printf("#1 offset %d\n",P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                    memcpy_hw(p2plocal_buffer+0x18, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                    SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset+0x18, p2plocal_buffer);
                                }
                                else
                                {
                                    if((P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset) > (1920*1088*2))
                                        printf("#2 offset %d\n",P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                    memcpy_hw(p2plocal_buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                    SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, p2plocal_buffer);
                                    //DEBUG_P2P("I=%2x%2x%2x%2x%2x\n",*(p2plocal_buffer+0x1d),*(p2plocal_buffer+0x1d+1),
                                    //*(p2plocal_buffer+0x1d+2),*(p2plocal_buffer+0x1d+3),*(p2plocal_buffer+0x1d+4));
                                }


                            }
                            else
                            {
                                //DEBUG_P2P("Pt=%lu,%d\n",P2PVideoBufReadIdx[ch], rfiuRxVideoBufMngWriteIdx[ch]);
                                SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer);
                            }
                            //DEBUG_P2P("V%d ",video_value[ch]);
                        }
                    }
                    else
                    {
                        if((gClientInfo[i].avIndex[ch] == gClientInfo[i].avChannel) && (gClientInfo[i].bEnableVideo) && (video_value[ch] > 0))
                        {
                            if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag)
                            {
                                if(h264header_updata[i] <= 5)
                                {
                                    if(P2P_AV_Source[ch] == Local_record)
                                        UpdateHeader(ch, USE_MPEG_QUANTIZATION);
                                    else
                                        UpdateH264Header(ch);
                                    h264header_updata[i]++;
                                    memcpy(p2plocal_buffer, H264_config, 0x18);
                                    if((P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset+0x18) > (1920*1088*2))
                                        printf("#1 size %d offset %d\n",P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size,P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
									/* Sean Edit 20160825 */
									if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size == 0)
									{
										memcpy_hw(p2plocal_buffer+0x18, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset));
										SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset)+0x18, p2plocal_buffer);
									}
									else
									{
										memcpy_hw(p2plocal_buffer+0x18, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset));
										SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset)+0x18, p2plocal_buffer);
									}
									/* Sean Edit End 20160825 */
                                }
                                else
                                {
                                    if((P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset) > (1920*1088*2))
                                        printf("#2 size %d offset %d\n",P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size,P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
									/* Sean Edit 20160825 */
									if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size == 0)
									{
										memcpy_hw(p2plocal_buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset));
										SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset), p2plocal_buffer);
									}
									else
									{
										memcpy_hw(p2plocal_buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset));
										SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset), p2plocal_buffer);
									}
									/* Sean Edit End 20160825 */

                                    //DEBUG_P2P("I=%2x%2x%2x%2x%2x\n",*(p2plocal_buffer+0x1d),*(p2plocal_buffer+0x1d+1),
                                    //*(p2plocal_buffer+0x1d+2),*(p2plocal_buffer+0x1d+3),*(p2plocal_buffer+0x1d+4));
                                }

                            }
                            else
                            {
                                //DEBUG_P2P("Pt=%lu\n",P2PVideoPresentTime[ch]);
                                SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset), P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                            }
                            //DEBUG_P2P("V%d ",video_value[ch]);
                        }
                    }
#endif
                }

                if (video_value[ch] > 0)
                {
                    P2PVideoBufReadIdx[ch] = (P2PVideoBufReadIdx[ch] + 1) % VIDEO_BUF_NUM;
                }
            }

            ///------------------- Bitstream buffer control---------------------------------//
            /*
                 Lsk: ?HVideo bitstream buffer ????index??l?????????I,?Y?j?? ASF_DROP_FRAME_THRESHOLD
                         ?h?????t??L?C,??drop frame.

            */
            if( (P2PVideoCmpSemEvt[ch]->OSEventCnt > 60) )
            {
                DEBUG_P2P("\nP2P-%d DROP Video frame Start:(%d,%d) \n",ch,P2PVideoPresentTime[ch],P2PAudioPresentTime[ch]);
                SyncTime=0;
                //------Video-----//
                do
                {
                    video_value[ch] = OSSemAccept(P2PVideoCmpSemEvt[ch]);
                    //DEBUG_P2P("%d ",video_value[ch]);
                    if (video_value[ch] > 0)
                    {
                        if(video_value_max[ch] < video_value[ch])
                            video_value_max[ch] = video_value[ch];

                        P2PVideoPresentTime[ch] += P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].time;
                        SyncTime += P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].time;
                        P2PVideoBufReadIdx[ch] = (P2PVideoBufReadIdx[ch] + 1) % VIDEO_BUF_NUM;
                    }
                    else
                    {
                        DEBUG_P2P("Video buffer empty!\n");
                        //break;
                        OSTimeDly(1);
                    }
                }
                while(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag != FLAG_I_VOP);

                //------Audio-----//
                DEBUG_P2P("P2P-%d DROP Audio frame Start:%d,SyncTime=%d \n",ch,P2PAudioCmpSemEvt[ch]->OSEventCnt,SyncTime);

                do
                {
                    audio_value[ch] = OSSemAccept(P2PAudioCmpSemEvt[ch]);
                    //DEBUG_P2P("%d ",audio_value[ch]);

                    if (audio_value[ch] > 0)
                    {
                        if(audio_value_max[ch] < audio_value[ch])
                            audio_value_max[ch] = audio_value[ch];

                        P2PAudioPresentTime[ch] += P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time;
                        SyncTime -= P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time;
                        P2PAudioBufReadIdx[ch] = (P2PAudioBufReadIdx[ch] + 1) % IIS_BUF_NUM;
                    }
                    else
                    {
                        DEBUG_P2P("Audio buffer empty!\n");
                        break;
                    }

                    if(SyncTime < 0)
                        break;
                }
                while( (P2PAudioPresentTime[ch] < P2PVideoPresentTime[ch]) );

                //P2PAudioPresentTime[ch] = P2PVideoPresentTime[ch];
                DEBUG_P2P("P2P-%d DROP frame End:(%d,%d)!!\n\n",ch,P2PVideoPresentTime[ch],P2PAudioPresentTime[ch]);
                sysDeadLockMonitor_Reset();
                DlyFlag=0;
                RunCount=0;
                //OSTimeDly(1);
            }

            if ( (video_value[ch] > 0) || (audio_value[ch] > 0) )
                DlyFlag=0;
        }


	/*adjust delay interval, Delay too much will cause P2P liveView lag, Delay too less will cause Record and System cannot get any CPU resource*/
	 mostSemCnt = 0;
	 mostSemCntCh = -1;

	if((DlyFlag == 0) && ((RunCount % DlyInterval) == 0))
	{
		/* get the Channel, which has the most sem cnt */
	        for(ch=0; ch<MAX_AV_CH; ch++)
	        {
		        if(MultiChannelGetCaptureVideoStatus(ch))
			{
				if(VideoClipOption[ch].VideoCmpSemEvt->OSEventCnt > mostSemCnt)
				{
					mostSemCnt = VideoClipOption[ch].VideoCmpSemEvt->OSEventCnt;
					mostSemCntCh = ch;
				}
		        }
	        }
		 if(mostSemCntCh >= 0) //recording channel exists
		 {
		      if(mostSemCnt > 60)
			    DlyInterval = 3;
		      else if(mostSemCnt > 40)
			    DlyInterval = 5;
			else if(mostSemCnt > 20)
			    DlyInterval = 7;
			else
			    DlyInterval = 10;
	         }
		  else  //no recording
	              DlyInterval = 10;
	 }

        if(DlyFlag)
        {
            RunCount=0;
            //DEBUG_P2P("&");
            OSTimeDly(1);

        }
        else
        {
            if( (RunCount % DlyInterval) == 0) //Lucian: release CPU power
            {
                //DEBUG_P2P("V=%d ",P2PVideoCmpSemEvt[ch]->OSEventCnt);
                //DEBUG_P2P("Rcnt=%d ",RunCount);
                if(RunCount>100)
                    sysDeadLockMonitor_Reset();
                OSTimeDly(1);
            }
        }

        RunCount ++;
    }
}
#endif
#else
void Task_SessionHandler(void* pData)
{
    u16 video_value[MAX_AV_CH]={0};
    u16 video_value_max[MAX_AV_CH]={0};
    u16 audio_value[MAX_AV_CH]={0};
    u16 audio_value_max[MAX_AV_CH]={0};
    u32 TimeShift[MAX_AV_CH]={0};
    unsigned int t1[MAX_AV_CH];
    unsigned int t2[MAX_AV_CH];
    RTC_DATE_TIME gP2PCheckTime;
    int i,ch;
    int ret;
    char IOCtrlBuf[MAX_BUF_SIZE];
    int SyncTime;
    unsigned int dt;
    RTC_DATE_TIME current_time;
    u8 gP2PCheckFail;
    int err;
    char    hostname_IP[HOSTNAME_IP_BUF_SIZE]="";
    char hostname[50];

    int DlyFlag,RunCount;
    
    OSFlagPend(gpiNetStatusFlagGrp, FLAGGPI_LWIP_IP_READY, OS_FLAG_WAIT_SET_ALL, OS_IPC_WAIT_FOREVER, &os_err);
    tutk_lib_init();    
    
    //---------------------------//
    gP2PStatus=0;// if
    timerCountRead(guiRFTimerID, &t1[0]);
    for(i=0;i<MAX_AV_CH;i++)
    {
        t1[i]=t1[0];
        TimeShift[i]=0;
    }
    RunCount=0;
    RTC_Get_Time(&gP2PCheckTime);
    IOTC_Get_Login_Info(&gP2PStatus);
    gP2PCheckFail=0;
    while(1)
    {
    #if((HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M721) && (PROJ_OPT == 5)) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M706) && (PROJ_OPT == 8))) //Sean: 20170621 add. //20171208 add M732HT
    Reset_P2P_Connection_flag = 0;
    #endif
    #if(HOME_RF_SUPPORT)
        if(gAppPairFlag != 0)
        {
            int size =  sizeof(SMsgAVIoctrlSetAddSensorResp);
            SMsgAVIoctrlSetAddSensorResp q;
            sysAppAddSensor(&q);
            if(avSendIOCtrl2(gPairAvIndex, IOTYPE_USER_SETADDSENSOR_RESP, (char*)&q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_SETADDSENSOR_RESP OK\n\n");
            }
        }
#endif
#if APP_KEEP_ALIVE
/*===============================KEEP ALIVE==================================*/
		if((APPConnectIcon != 0) || (gOnlineNum > 0))
		{
			for(i=0;i<MAX_CLIENT+1;i++)
			{
				if(!gFlagKeepAlive[i])
				{
					Clear_Session_Status(i);
				}
				else
				{
					RTC_Get_Time(&current_time);
					switch(i)
					{
						case 0:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime0))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[0] = 0;
							RTC_Get_Time(&gKeepAliveTime0);
						}
						break;
						case 1:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime1))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[1] = 0;
							RTC_Get_Time(&gKeepAliveTime1);
						}
						break;
						case 2:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime2))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[2] = 0;
							RTC_Get_Time(&gKeepAliveTime2);
						}
						break;
						case 3:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime3))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[3] = 0;
							RTC_Get_Time(&gKeepAliveTime3);
						}
						case 4:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime4))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[4] = 0;
							RTC_Get_Time(&gKeepAliveTime4);
						}
						break;
						default:
							break;
					}
					//printf("-%d-\n",gFlagKeepAlive);
				}
			}
		}
/*===============================KEEP ALIVE==================================*/
#endif

        //if(gFlagLoginOK || gLoginFaileCnt < 10)
        if(gFlagLoginOK)
        {
            DEBUG_P2P("*****OSTaskDel(LOGIN_TASK_PRIORITY)*****\n");
            DEBUG_P2P("Login P2Pserve : %d.\n",gFlagLoginOK);
            if(gFlagLoginOK)
                SendRegister();//Register the device to APN server
            OSTaskDel(LOGIN_TASK_PRIORITY);
            gFlagLoginOK = 0;
            gLoginFaileCnt =0;
        }

        DlyFlag=1;
        /*Try to reconnect the P2P server, when P2P info != 7.*/
        RTC_Get_Time(&current_time);
        if(net_link_status==NET_LINK_ON)
        {
        	#if(HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) //Sean: 20170608 add.
        	//Check all the time.
        	#else
            if(gOnlineNum==0)/*Don't check P2P server connection status, when APP is connecting.*/
            #endif
            {
                if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gP2PCheckTime)))>30)
                {
                    IOTC_Get_Login_Info(&gP2PStatus);
                    RTC_Get_Time(&gP2PCheckTime);
                    if (gP2PStatus<7)
                    {
                        DEBUG_P2P("Retry p2p failed.\n");
                        gP2PCheckFail++;
                    }
                    else
                        gP2PCheckFail=1;

                    if(gP2PCheckFail<15)    /* Re-open p2p socket, if Check p2p connection fail.*/
                    {
                        if ((gP2PCheckFail%3)==0)
                        {
							#if((HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M721) && (PROJ_OPT == 5)) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M706) && (PROJ_OPT == 8))) //Sean: 20170621 add. //20171208 add M732HT
							Reset_P2P_Connection_Stop_flag = 1;
							#endif

                            strcpy(hostname,TPNS_SERVER);
                            err=DN2IP(hostname, hostname_IP);
                            if(err!=0)
                                DEBUG_P2P("WAN is not ready...\n");
                            //else //20170216 Sean: this func cause APP can't connect, pbuf_alloc will fail.
                            //{
                            //#if(HW_BOARD_OPTION != MR8200_RX_TRANWO_SMH101_HA)
                            //    DEBUG_P2P("Renew ioctl module.\n");
                            //    renew_iotclModule(2123*gP2PCheckFail);
                            //#endif
                            //}
                            //Reset_P2P_Connection();

							#if((HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M721) && (PROJ_OPT == 5)) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M706) && (PROJ_OPT == 8))) //Sean: 20170621 add. //20171208 add M732HT
							Reset_P2P_Connection_flag = 0;
							Reset_P2P_Connection_Stop_flag = 0;
							#endif
                        }
                    }
                    if(gP2PCheckFail==15) /*Re-new IP, if check p2p connection still fail after re-open socket.*/
                    {
                        ClearNetworkInfo();
						#if((HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M721) && (PROJ_OPT == 5)) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M706) && (PROJ_OPT == 8))) //Sean: 20170621 add. //20171208 add M732HT
					    Reset_P2P_Connection_Stop_flag = 1;
					    #endif
                        if(SetLwIP(1)==-1)
                        {
                            DEBUG_P2P("Couldn't get IP, rebooting...\n");
							sysForceWDTtoReboot();
                        }

                        strcpy(hostname,TPNS_SERVER);
                        err = DN2IP(hostname, hostname_IP);
                        if(err!=0)
                            DEBUG_P2P("WAN is not ready...\n");
                        //else //20170216 Sean
                        //{
                        //	#if(HW_BOARD_OPTION != MR8200_RX_TRANWO_SMH101_HA)
                        //    renew_iotclModule(45367);
                        //    #endif
                        //}
						#if((HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M721) && (PROJ_OPT == 5)) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M706) && (PROJ_OPT == 8))) //Sean: 20170621 add. //20171208 add M732HT
						Reset_P2P_Connection_flag = 0;
					    Reset_P2P_Connection_Stop_flag = 0;
					    #endif
                    }
                    if(gP2PCheckFail==30) /*Reboot device, if check p2p connection still fail after re-new ip.*/
                    {
                        DEBUG_P2P("P2P connection couldn't recovery, rebooting...\n");
						sysForceWDTtoReboot();
                    }
                }
            }
        }

        for(ch=0; ch<MAX_AV_CH; ch++)
        {
            // ------Streaming audio payload------//
            if((video_value[ch] == 0) || (P2PAudioPresentTime[ch] <= P2PVideoPresentTime[ch]))
            {
                audio_value[ch] = OSSemAccept(P2PAudioCmpSemEvt[ch]);
                if (audio_value[ch] > 0)
                {
                    if(audio_value_max[ch] < audio_value[ch])
                        audio_value_max[ch] = audio_value[ch];
                    //DEBUG_P2P("PAIdx = %d iisIdx = %d\n", P2PAudioBufReadIdx[ch], VideoClipOption[ch + 1].iisSounBufMngWriteIdx);
                }

                for(i=0;i<MAX_CLIENT;i++)
                {
#if 1
                    if((ret = Check_Session_Status(i)) < 0) //session disconnected
                    {
                        continue;
                    }
                    //aher test 20140316
                    if(gClientInfo[i].playBackCh!=0)
                    {
                        Handle_IOCTRL_Cmd(i, gClientInfo[CurrPlaybackSID].avChannel, IOCtrlBuf);
                    }

                    Handle_IOCTRL_Cmd(i, gClientInfo[i].avIndex[ch], IOCtrlBuf);
#endif

                    if((gClientInfo[i].avIndex[ch] == gClientInfo[i].avChannel) && (gClientInfo[i].bEnableAudio > 0) && (audio_value[ch] > 0))
                    {
                        //TUTK API only support 1024byte
                        /*
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]   , 1024, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+64, 1024, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+1024);
                        */
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]   , 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+20, 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+320);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+40, 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+640);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+60, 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+960);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+80, 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+1280);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+100,320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+1600);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+108, 128, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+1920);

                    }
                }

                if (audio_value[ch] > 0)
                {
#if( (SW_APPLICATION_OPTION == MR8200_RFCAM_RX1RX2) || (SW_APPLICATION_OPTION == MR8200_RFCAM_RX1) || (SW_APPLICATION_OPTION == MR8100_BABYMONITOR) || (SW_APPLICATION_OPTION == MR8100_DUALMODE_VBM) )

                    timerCountRead(guiRFTimerID, &t2[ch]);
                    if(P2PChannelStart[ch])
                    {
                        t1[ch]=t2[ch];
                        P2PChannelStart[ch]=0;
                        TimeShift[ch]=0;
                    }
                    if(t1[ch] >= t2[ch])
                        dt=t1[ch]-t2[ch];
                    else
                        dt=(t1[ch]+TimerGetTimerCounter(TIMER_7))-t2[ch];

                    if(dt > 20000)
                    {
                        TimeShift[ch] = dt/10;
                        if(P2PChannelStart[ch])
                            TimeShift[ch]=0;
                        else
                        {
                            P2PAudioPresentTime[ch] += (TimeShift[ch]+2000);
                            P2PVideoPresentTime[ch] += (TimeShift[ch]+2000);
                            DEBUG_P2P("--->P2P Ch-%d Shift=%d ms\n",ch,TimeShift[ch]);
                        }
                    }
                    else
                        TimeShift[ch]=0;
                    t1[ch]=t2[ch];
#else
                    TimeShift[ch]=0;
#endif

                    P2PAudioPresentTime[ch] += (P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time);    //if use chunk time
                    P2PAudioBufReadIdx[ch]   = (P2PAudioBufReadIdx[ch] + 1) % IIS_BUF_NUM;
                    //DEBUG_P2P("A%d ",audio_value[ch]);
                }
            }

            //------ Streaming video payload------//
            if((audio_value[ch] == 0) || (P2PAudioPresentTime[ch] >= P2PVideoPresentTime[ch]))
            {
                video_value[ch] = OSSemAccept(P2PVideoCmpSemEvt[ch]);
                if (video_value[ch] > 0)
                {
                    //DEBUG_P2P("P2PVideoCmpSemEvt[%d]=%d\n", ch, P2PVideoCmpSemEvt[ch]->OSEventCnt);
                    if(video_value_max[ch] < video_value[ch])
                        video_value_max[ch] = video_value[ch];
                    P2PVideoPresentTime[ch] += (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].time); //if use chunk time
                }
                for(i=0;i<MAX_CLIENT;i++)
                {
                    if((ret = Check_Session_Status(i)) < 0)
                    {
                        continue;
                    }
                    
#if ENABLE_TUTK_RESEND
                    if( getResendBufUsage(gClientInfo[i].avChannel, 0) >= RESEND_BUF_MAX_USAGE_RATE)
                    {
                        const int ret = avServResetBuffer(gClientInfo[i].avChannel, RESET_ALL, RESET_RESEND_BUF_TIMEOUT);
                        lwip_mem_stat_disp();
                        DEBUG_YELLOW("avServResetBuffer11 video sid[%d] err[%d] avIndex[%d]\n", i, ret, gClientInfo[i].avChannel);
                        if(ret == AV_ER_INVALID_SID || ret == AV_ER_SESSION_CLOSE_BY_REMOTE || ret == AV_ER_REMOTE_TIMEOUT_DISCONNECT)
                        {
                            StopAndClearSession(i, ret);
                            continue;
                        }
                    }
#endif                    
                    
                    //aher test 20140316
                    if(gClientInfo[i].playBackCh!=0)
                    {
                        //Handle_IOCTRL_Cmd(i, gClientInfo[CurrPlaybackSID].avChannel, IOCtrlBuf);
                    }

                    Handle_IOCTRL_Cmd(i, gClientInfo[i].avIndex[ch], IOCtrlBuf);
                    if((gClientInfo[i].avIndex[ch] == gClientInfo[i].avChannel) && (gClientInfo[i].bEnableVideo) && (video_value[ch] > 0))
                    {
                        if((gClientInfo[i].VOLSend==0||gClientInfo[i].VOLSend==5 )&& P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag)
                        {
                            if(P2P_AV_Source[ch] == Local_record)
                                UpdateHeader(ch, USE_MPEG_QUANTIZATION);
                            else
                            {
                                if(gFirstConnect==0)//??APP??@???s?u,?NVOL?]??VGA
                                {//Paul modify for D8530
#if (HW_BOARD_OPTION == MR8202A_RX_TARNWO_D8530)
                                    gPlaybackWidth=1280;
                                    gPlaybackHeight=720;
#else
                                    gPlaybackWidth=640;
                                    gPlaybackHeight=480;
#endif
                                    gFirstConnect=1;
                                    UpdateHeader(6,USE_MPEG_QUANTIZATION);
                                }
                                else
                                    UpdateHeader(ch,gRfiuUnitCntl[ch].TX_Status & RFIU_TX_STA_MPEG_Q);
                            }

                            memcpy(p2plocal_buffer, MPEG4_config, 0x1d);
                            memcpy_hw(p2plocal_buffer+0x1d, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size);
                            SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, 0x1d+P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size, p2plocal_buffer);
                            //Wait P2P client send the Ioctl command "IOTYPE_USER_IPCAM_RECEIVE_FIRST_IFRAME"
                            //Send the VOL pre second.
                            if(gClientInfo[i].VOLSend==5)
                                gClientInfo[i].VOLSend = 1;
                        }
                        else if(gClientInfo[i].VOLSend>=1)
                        {
                            SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer);
                            if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag)
                            {
                                gClientInfo[i].VOLSend++;
                            }
                        }
                        //DEBUG_P2P("V%d ",video_value[ch]);
                    }


                }

                if (video_value[ch] > 0)
                {
                P2PVideoBufReadIdx[ch] = (P2PVideoBufReadIdx[ch] + 1) % VIDEO_BUF_NUM;
                }
            }

            ///------------------- Bitstream buffer control---------------------------------//
            /*
            Lsk: ?Video bitstream buffer ??index???F????E,?L?? ASF_DROP_FRAME_THRESHOLD
            ????????,?drop frame.

            */
            if( (P2PVideoCmpSemEvt[ch]->OSEventCnt > 60) )
            {
                DEBUG_P2P("\nP2P-%d DROP Video frame Start:(%d,%d) \n",ch,P2PVideoPresentTime[ch],P2PAudioPresentTime[ch]);
                SyncTime=0;
                //------Video-----//
                do
                {
                    video_value[ch] = OSSemAccept(P2PVideoCmpSemEvt[ch]);
                    //DEBUG_P2P("%d ",video_value[ch]);
                    if (video_value[ch] > 0)
                    {
                        if(video_value_max[ch] < video_value[ch])
                            video_value_max[ch] = video_value[ch];

                        P2PVideoPresentTime[ch] += P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].time;
                        SyncTime += P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].time;
                        P2PVideoBufReadIdx[ch] = (P2PVideoBufReadIdx[ch] + 1) % VIDEO_BUF_NUM;
                    }
                    else
                    {
                        DEBUG_P2P("Video buffer empty!\n");
                        //break;
                        OSTimeDly(1);
                    }
                } while(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag != FLAG_I_VOP);

                //------Audio-----//
                DEBUG_P2P("P2P-%d DROP Audio frame Start:%d,SyncTime=%d \n",ch,P2PAudioCmpSemEvt[ch]->OSEventCnt,SyncTime);

                do
                {
                    audio_value[ch] = OSSemAccept(P2PAudioCmpSemEvt[ch]);
                    //DEBUG_P2P("%d ",audio_value[ch]);

                    if (audio_value[ch] > 0)
                    {
                        if(audio_value_max[ch] < audio_value[ch])
                            audio_value_max[ch] = audio_value[ch];

                        P2PAudioPresentTime[ch] += P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time;
                        SyncTime -= P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time;
                        P2PAudioBufReadIdx[ch] = (P2PAudioBufReadIdx[ch] + 1) % IIS_BUF_NUM;
                    }
                    else
                    {
                        DEBUG_P2P("Audio buffer empty!\n");
                        break;
                    }

                    if(SyncTime < 0)
                        break;
                }while( (P2PAudioPresentTime[ch] < P2PVideoPresentTime[ch]) );

                //P2PAudioPresentTime[ch] = P2PVideoPresentTime[ch];
                DEBUG_P2P("P2P-%d DROP frame End:(%d,%d)!!\n\n",ch,P2PVideoPresentTime[ch],P2PAudioPresentTime[ch]);
                sysDeadLockMonitor_Reset();
                DlyFlag=0;
                RunCount=0;
                //OSTimeDly(1);
            }

            if ( (video_value[ch] > 0) || (audio_value[ch] > 0) )
                DlyFlag=0;
        }

        if(DlyFlag)
        {
            RunCount=0;
            //DEBUG_P2P("&");
            OSTimeDly(1);

        }
        else
        {
            if( (RunCount & 0x03) == 0) //Lucian: release CPU power
            {
                //DEBUG_P2P("A=%d ",P2PAudioCmpSemEvt[0]->OSEventCnt);
                //DEBUG_P2P("Rcnt=%d ",RunCount);
                if(RunCount>100)
                    sysDeadLockMonitor_Reset();
                OSTimeDly(1);
            }
        }

        RunCount ++;
    }
}

#endif

void ClearP2PConnection()
{
    int i;
    u8 err;
    DEBUG_P2P("All device connection timeout.\n");
    if(gOnlineNum<=0)
    {
        /*Reset the counter of remote playback*/
        if(Fileplaying&&Remote_play)
        {
            //OSFlagPend(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_PLAY_START, OS_FLAG_WAIT_SET_ALL, OS_IPC_WAIT_FOREVER, &err);
#ifdef SAFE_DEL_P2P_PLAYFILE_TASK
            SafeDelP2pPlayFileTask();
            OSFlagPend(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_PLAY_FINISH, OS_FLAG_WAIT_CLR_ALL|OS_FLAG_CONSUME, OS_IPC_WAIT_FOREVER, &err);
            DEBUG_P2P("pend FLAGSYS_RDYSTAT_PLAY_FINISH.\n");
#else            
            if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
                DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");

            OSFlagPend(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_PLAY_FINISH, OS_FLAG_WAIT_CLR_ALL|OS_FLAG_CONSUME, OS_IPC_WAIT_FOREVER, &err);
            DEBUG_P2P("pend FLAGSYS_RDYSTAT_PLAY_FINISH.\n");

            if(OS_NO_ERR !=  OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY))
                DEBUG_P2P("OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
#endif            
            
            Fileplaying=0;
            Remote_play=0;
#if(UI_VERSION == UI_VERSION_MAYON)
			CurrPlaybackSID = -1;
#endif
        }
        gOnlineNum=0;
        gFirstConnect=0;
        videoquality=2;

        for (i = 0; i < MAX_CLIENT; i++)
        {
            P2PEnableStreaming[i]=0;
            if(gClientInfo[i].bEnableSpeaker>0)
                Kill_Task_Speaker(i);
        }
    }
#if RFIU_RX_WAKEUP_TX_SCHEME

	gAppWakeCamflag = 0;
	for (i = 0; i < MAX_AV_CH; i++)
		gRfiuUnitCntl[i].WakeUpTxEn = 0;

#endif

}


u32 netdev_getallnetdev(struct netdev *pdev, u32 num_of_pdev)
{
    extern struct netif *netif_list;
    struct netif *netif;
    u32 num = 0;
    if ((pdev == NULL) ||(num_of_pdev == 0))
        return 0;

    for(netif=netif_list; ((num < num_of_pdev) && (netif!=NULL)); netif=netif->next)
    {
        memcpy((void *)&pdev[num].name, (void *)&netif->name, sizeof(netif->name));
        memcpy((void *)&pdev[num].hwmac, (void *)&netif->hwaddr, sizeof(netif->hwaddr));
        pdev[num].flags = netif->flags;
        pdev[num].ipaddr = netif->ip_addr.addr;
        pdev[num].gw = netif->gw.addr;
        pdev[num].netmask = netif->netmask.addr;
        pdev[num].mtu = netif->mtu;
        num++;
    }
    return num;
}

void PrintErrHandling(int nErr)
{
    switch (nErr)
    {
    case IOTC_ER_SERVER_NOT_RESPONSE:
        //-1 IOTC_ER_SERVER_NOT_RESPONSE
        printf("[Error code : %d]\n", IOTC_ER_SERVER_NOT_RESPONSE);
        printf("Master doesn't respond.\n");
        printf("Please check the network wheather it could connect to the Internet.\n");
        break;
    case IOTC_ER_FAIL_RESOLVE_HOSTNAME:
        //-2 IOTC_ER_FAIL_RESOLVE_HOSTNAME
        printf("[Error code : %d]\n", IOTC_ER_FAIL_RESOLVE_HOSTNAME);
        printf("Can't resolve hostname.\n");
        break;
    case IOTC_ER_ALREADY_INITIALIZED:
        //-3 IOTC_ER_ALREADY_INITIALIZED
        printf("[Error code : %d]\n", IOTC_ER_ALREADY_INITIALIZED);
        printf("Already initialized.\n");
        break;
    case IOTC_ER_FAIL_CREATE_MUTEX:
        //-4 IOTC_ER_FAIL_CREATE_MUTEX
        printf("[Error code : %d]\n", IOTC_ER_FAIL_CREATE_MUTEX);
        printf("Can't create mutex.\n");
        break;
    case IOTC_ER_FAIL_CREATE_THREAD:
        //-5 IOTC_ER_FAIL_CREATE_THREAD
        printf("[Error code : %d]\n", IOTC_ER_FAIL_CREATE_THREAD);
        printf("Can't create thread.\n");
        break;
    case IOTC_ER_UNLICENSE:
        //-10 IOTC_ER_UNLICENSE
        printf("[Error code : %d]\n", IOTC_ER_UNLICENSE);
        printf("This UID is unlicense.\n");
        printf("Check your UID.\n");
        break;
    case IOTC_ER_NOT_INITIALIZED:
        //-12 IOTC_ER_NOT_INITIALIZED
        printf("[Error code : %d]\n", IOTC_ER_NOT_INITIALIZED);
        printf("Please initialize the IOTCAPI first.\n");
        break;
    case IOTC_ER_TIMEOUT:
        //-13 IOTC_ER_TIMEOUT
        break;
    case IOTC_ER_INVALID_SID:
        //-14 IOTC_ER_INVALID_SID
        printf("[Error code : %d]\n", IOTC_ER_INVALID_SID);
        printf("This SID is invalid.\n");
        printf("Please check it again.\n");
        break;
    case IOTC_ER_EXCEED_MAX_SESSION:
        //-18 IOTC_ER_EXCEED_MAX_SESSION
        printf("[Error code : %d]\n", IOTC_ER_EXCEED_MAX_SESSION);
        printf("[Warning]\n");
        printf("The amount of session reach to the maximum.\n");
        printf("It cannot be connected unless the session is released.\n");
        break;
    case IOTC_ER_CAN_NOT_FIND_DEVICE:
        //-19 IOTC_ER_CAN_NOT_FIND_DEVICE
        printf("[Error code : %d]\n", IOTC_ER_CAN_NOT_FIND_DEVICE);
        printf("Device didn't register on server, so we can't find device.\n");
        printf("Please check the device again.\n");
        printf("Retry...\n");
        break;
    case IOTC_ER_SESSION_CLOSE_BY_REMOTE:
        //-22 IOTC_ER_SESSION_CLOSE_BY_REMOTE
        printf("[Error code : %d]\n", IOTC_ER_SESSION_CLOSE_BY_REMOTE);
        printf("Session is closed by remote so we can't access.\n");
        printf("Please close it or establish session again.\n");
        break;
    case IOTC_ER_REMOTE_TIMEOUT_DISCONNECT:
        //-23 IOTC_ER_REMOTE_TIMEOUT_DISCONNECT
        printf("[Error code : %d]\n", IOTC_ER_REMOTE_TIMEOUT_DISCONNECT);
        printf("We can't receive an acknowledgement character within a TIMEOUT.\n");
        printf("It might that the session is disconnected by remote.\n");
        printf("Please check the network wheather it is busy or not.\n");
        printf("And check the device and user equipment work well.\n");
        break;
    case IOTC_ER_DEVICE_NOT_LISTENING:
        //-24 IOTC_ER_DEVICE_NOT_LISTENING
        printf("[Error code : %d]\n", IOTC_ER_DEVICE_NOT_LISTENING);
        printf("Device doesn't listen or the sessions of device reach to maximum.\n");
        printf("Please release the session and check the device wheather it listen or not.\n");
        break;
    case IOTC_ER_CH_NOT_ON:
        //-26 IOTC_ER_CH_NOT_ON
        printf("[Error code : %d]\n", IOTC_ER_CH_NOT_ON);
        printf("Channel isn't on.\n");
        printf("Please open it by IOTC_Session_Channel_ON() or IOTC_Session_Get_Free_Channel()\n");
        printf("Retry...\n");
        break;
    case IOTC_ER_SESSION_NO_FREE_CHANNEL:
        //-31 IOTC_ER_SESSION_NO_FREE_CHANNEL
        printf("[Error code : %d]\n", IOTC_ER_SESSION_NO_FREE_CHANNEL);
        printf("All channels are occupied.\n");
        printf("Please release some channel.\n");
        break;
    case IOTC_ER_TCP_TRAVEL_FAILED:
        //-32 IOTC_ER_TCP_TRAVEL_FAILED
        printf("[Error code : %d]\n", IOTC_ER_TCP_TRAVEL_FAILED);
        printf("Device can't connect to Master.\n");
        printf("Don't let device use proxy.\n");
        printf("Close firewall of device.\n");
        printf("Or open device's TCP port 80, 443, 8080, 8000, 21047.\n");
        break;
    case IOTC_ER_TCP_CONNECT_TO_SERVER_FAILED:
        //-33 IOTC_ER_TCP_CONNECT_TO_SERVER_FAILED
        printf("[Error code : %d]\n", IOTC_ER_TCP_CONNECT_TO_SERVER_FAILED);
        printf("Device can't connect to server by TCP.\n");
        printf("Don't let server use proxy.\n");
        printf("Close firewall of server.\n");
        printf("Or open server's TCP port 80, 443, 8080, 8000, 21047.\n");
        printf("Retry...\n");
        break;
    case IOTC_ER_NO_PERMISSION:
        //-40 IOTC_ER_NO_PERMISSION
        printf("[Error code : %d]\n", IOTC_ER_NO_PERMISSION);
        printf("This UID's license doesn't support TCP.\n");
        break;
    case IOTC_ER_NETWORK_UNREACHABLE:
        //-41 IOTC_ER_NETWORK_UNREACHABLE
        printf("[Error code : %d]\n", IOTC_ER_NETWORK_UNREACHABLE);
        printf("Network is unreachable.\n");
        printf("Please check your network.\n");
        printf("Retry...\n");
        break;
    case IOTC_ER_FAIL_SETUP_RELAY:
        //-42 IOTC_ER_FAIL_SETUP_RELAY
        printf("[Error code : %d]\n", IOTC_ER_FAIL_SETUP_RELAY);
        printf("Client can't connect to a device via Lan, P2P, and Relay mode\n");
        break;
    case IOTC_ER_NOT_SUPPORT_RELAY:
        //-43 IOTC_ER_NOT_SUPPORT_RELAY
        printf("[Error code : %d]\n", IOTC_ER_NOT_SUPPORT_RELAY);
        printf("Server doesn't support UDP relay mode.\n");
        printf("So client can't use UDP relay to connect to a device.\n");
        break;

    default:
        break;
    }
}

int AuthCallBackFnNew(char *viewAcc, char *viewPwd)
{
printf("viewPwd:%s, %s\n",viewPwd, UI_P2P_PSW);
    if (strcmp(viewAcc, avID) == 0 && strcmp(viewPwd, (char *)UI_P2P_PSW) == 0)
        return 1;

    return 0;
}


int gettimeofday(struct timeval *time, void *tz)
{
    u32 tmp = 0;
    
    if(!time)
        return 0;
    
    timerCountRead(guiRFTimerID, (u32*)&tmp);
    tmp = 0xFFFFFFFF - tmp;
    time->tv_sec = tmp/10000;
    time->tv_usec = (tmp%10000)*100;
    return 0;
}


int32_t g_nAudioPreSample = 0;
int32_t g_nAudioIndex = 0;

//For DASA -- start
//For DASA -- end

void av_sample_task_init()
{
    int i, j;
    for (i = 0; i < MAX_CLIENT; i++)
    {
        memset(&gClientInfo[i], 0, sizeof(gClientInfo[0]));
#if 0        
        for(j = 0; j < MAX_AV_CH; ++j)
        	gClientInfo[i].avIndex[j] = -1;
        gClientInfo[i].playBackCh = 1;//Should not be 0, unsigned char
        gClientInfo[i].sLock = OSSemCreate(1);
#endif        
    }
    
}

void av_sample_task_deinit()
{
    int i, j;
    u8 err;
    
    memset(gClientInfo, 0, sizeof(gClientInfo));
    for (i = 0; i < MAX_CLIENT; i++)
    {
        
        for(j = 0; j < MAX_AV_CH; ++j)
            gClientInfo[i].avIndex[j] = -1;
    }
}

void LoginInfoCB(unsigned int nLoginInfo)
{
    if ((nLoginInfo & 0x04))
        printf("I can be connected via Internet\n");
    else if ((nLoginInfo & 0x08))
        printf("I am be banned by IOTC Server because UID multi-login\n");
}

#if TEST_RECV_AUDIO_DELAY
int ntp_client(char *host_name, struct tm *timeinfo)
{
    int sockfd = -1, n = 0, result = 0, retry = 0; // Socket file descriptor and the n return result from writing/reading from the socket.
    int portno = 123;							   // NTP UDP port number.
    //char *host_name = "192.168.1.101";			   // NTP server host-name.
    fd_set readfds;
    struct timeval tv;
    struct sockaddr_in serv_addr; // Server address data structure.
    uint32_t txTm;
    struct tm *tmp_timeinfo;

    // Structure that defines the 48 byte NTP packet protocol.
    typedef struct
    {

        uint8_t li_vn_mode; // Eight bits. li, vn, and mode.
        // li.   Two bits.   Leap indicator.
        // vn.   Three bits. Version number of the protocol.
        // mode. Three bits. Client will pick mode 3 for client.

        uint8_t stratum;   // Eight bits. Stratum level of the local clock.
        uint8_t poll;	  // Eight bits. Maximum interval between successive messages.
        uint8_t precision; // Eight bits. Precision of the local clock.

        uint32_t rootDelay;		 // 32 bits. Total round trip delay time.
        uint32_t rootDispersion; // 32 bits. Max error aloud from primary clock source.
        uint32_t refId;			 // 32 bits. Reference clock identifier.

        uint32_t refTm_s; // 32 bits. Reference time-stamp seconds.
        uint32_t refTm_f; // 32 bits. Reference time-stamp fraction of a second.

        uint32_t origTm_s; // 32 bits. Originate time-stamp seconds.
        uint32_t origTm_f; // 32 bits. Originate time-stamp fraction of a second.

        uint32_t rxTm_s; // 32 bits. Received time-stamp seconds.
        uint32_t rxTm_f; // 32 bits. Received time-stamp fraction of a second.

        uint32_t txTm_s; // 32 bits and the most important field the client cares about. Transmit time-stamp seconds.
        uint32_t txTm_f; // 32 bits. Transmit time-stamp fraction of a second.

    } ntp_packet; // Total: 384 bits or 48 bytes.

    // Create and zero out the packet. All 48 bytes worth.
    ntp_packet packet = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    memset(&packet, 0, sizeof(ntp_packet));

    // Set the first byte's bits to 00,011,011 for li = 0, vn = 3, and mode = 3. The rest will be left set to zero.
    *((char *)&packet + 0) = 0x1b; // Represents 27 in base 10 or 00011011 in base 2.

    // Create a UDP socket, convert the host-name to an IP address, set the port number,
    // connect to the server, send the packet, and then read in the return packet.

    sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); // Create a UDP socket.

    if (sockfd < 0)
        printf("ERROR opening socket\n");

    serv_addr.sin_family = AF_INET;
    inet_aton(host_name, (struct in_addr *)&serv_addr.sin_addr.s_addr);
    serv_addr.sin_port = htons(portno);

    // Call up the server using its IP address and port number.
    if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)
        printf("ERROR connecting\n");

    // Send it the NTP packet it wants. If n == -1, it failed.
    n = send(sockfd, (char *)&packet, sizeof(ntp_packet), 0);
    if (n < 0)
        printf("ERROR writing to socket\n");

    // Wait and receive the packet back from the server. If n == -1, it failed.
    n = 0;
    for (retry = 0; retry < 5; retry++)
    {
        FD_ZERO(&readfds);
        FD_SET(sockfd, &readfds);
        memset(&tv, 0, sizeof(tv));
        tv.tv_sec = 1;
        tv.tv_usec = 0;
        result = select((int)sockfd + 1, &readfds, NULL, NULL, (struct timeval *)&tv);
        if (result > 0)
        {
            if (FD_ISSET(sockfd, &readfds))
            {
                n = recv(sockfd, &packet, sizeof(ntp_packet), 0);
                break;
            }
            else
            {
                printf("ERROR FD_ISSET\n");
                break;
            }
        }
        else if (result == 0)
        {
            printf("TIMEOUT, retry again\n");
            n = send(sockfd, (char *)&packet, sizeof(ntp_packet), 0);
            if (n < 0)
            {
                printf("ERROR writing to socket\n");
                break;
            }
        }
        else
        {
            printf("ERROR select\n");
            break;
        }
    }

    close(sockfd);
    if (n <= 0)
    {
        printf("ERROR recv\n");
        return -1;
    }

    // These two fields contain the time-stamp seconds as the packet left the NTP server.
    // The number of seconds correspond to the seconds passed since 1900.
    // ntohl() converts the bit/byte order from the network's to host's "endianness".

    packet.txTm_s = ntohl(packet.txTm_s); // Time-stamp seconds.
    packet.txTm_f = ntohl(packet.txTm_f); // Time-stamp fraction of a second.

    // Extract the 32 bits that represent the time-stamp seconds (since NTP epoch) from when the packet left the server.
    // Subtract 70 years worth of seconds from the seconds since 1900.
    // This leaves the seconds since the UNIX epoch of 1970.
    // (1900)------------------(1970)**************************************(Time Packet Left the Server)

    txTm = (uint32_t)(packet.txTm_s - NTP_TIMESTAMP_DELTA);
    //txTm += 28800; //UTC+8

    // Print the time we got from the server, accounting for local timezone and conversion from UTC time.

    //printf("NTP Time: %u.%u\n", txTm, packet.txTm_f);
    //printf("Time: %s", ctime((const time_t *)&txTm));
    tmp_timeinfo = localtime((const time_t *)&txTm);
    tmp_timeinfo->tm_year += 1900;
    tmp_timeinfo->tm_mon += 1;
    memcpy(timeinfo, tmp_timeinfo, sizeof(struct tm));
    //printf("year=%d, month=%d, day=%d, hour=%d, min=%d, sec=%d\n\n", timeinfo->tm_year, timeinfo->tm_mon, timeinfo->tm_mday, timeinfo->tm_hour, timeinfo->tm_min, timeinfo->tm_sec);
    if (txTm > 2000000000)
    {
        //overflow
        return -1;
    }

    return 0;
}

unsigned long getTimeMs()
{
    //struct timeval tv;
    //gettimeofday(&tv, NULL);
    //return (tv.tv_sec * 1000) + (tv.tv_usec / 1000);

    struct timeval tv;
    long nowtime = 0;
    gettimeofday(&tv, NULL);
    nowtime = (tv.tv_sec * 1000 + tv.tv_usec / 1000);
    return timebase_sec * 1000 + (nowtime - timebase_msec);
}

void getTestMode(char *mode)
{
    int sockFd = -1, ret;
    struct sockaddr_in dest;
    char msg[2048] = {0};
    fd_set readfds;
    struct timeval tv;
    int result = 0;
    char buf[1024] = {0};
    char *delim = "=", *pch = NULL;

    sockFd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockFd < 0)
    {
        printf("create socket error, ret:%d \n", sockFd);
        return;
    }
    dest.sin_family = AF_INET;
    dest.sin_port = htons(TEST_CLIENT_PORT);
    inet_aton(TEST_CLIENT_IP, (struct in_addr *)&dest.sin_addr.s_addr);

    ret = connect(sockFd, (struct sockaddr *)&dest, sizeof(struct sockaddr_in));
    if (ret < 0)
    {
        close(sockFd);
        printf("connect error, ret:%d\n", ret);
        return;
    }

    sprintf(msg, "GET_TEST_MODE");

    ret = send(sockFd, msg, strlen(msg), 0);

    FD_ZERO(&readfds);
    FD_SET(sockFd, &readfds);
    memset(&tv, 0, sizeof(tv));
    tv.tv_sec = 2;
    result = select((int)sockFd + 1, &readfds, NULL, NULL, &tv);
    if (result > 0)
    {
        if (FD_ISSET(sockFd, &readfds))
        {
            recv(sockFd, buf, 1024, 0);
            pch = strtok(buf, delim);
            while (pch != NULL)
            {
                if (!strcmp(pch, "TEST_MODE"))
                {
                    strncpy(mode, pch + strlen("TEST_MODE="), 4);
                    mode[4] = '\0';
                    break;
                }
                pch = strtok(NULL, delim);
            }
        }
        else
        {
            printf("recv error\n");
        }
    }
    else if (result == 0)
    {
        printf("select timeout \n");
    }
    else
    {
        printf("recv error\n");
    }
    close(sockFd);
}

int getTestSerial()
{
    int sockFd = -1, ret;
    struct sockaddr_in dest;
    char msg[2048] = {0};
    fd_set readfds;
    struct timeval tv;
    int result = 0;
    char buf[1024] = {0};
    char *delim = "=", *pch = NULL;
    int testSerial = -1;

    sockFd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockFd < 0)
    {
        printf("create socket error, ret:%d \n", sockFd);
        return -1;
    }
    dest.sin_family = AF_INET;
    dest.sin_port = htons(TEST_CLIENT_PORT);
    inet_aton(TEST_CLIENT_IP, (struct in_addr *)&dest.sin_addr.s_addr);

    ret = connect(sockFd, (struct sockaddr *)&dest, sizeof(struct sockaddr_in));
    if (ret < 0)
    {
        close(sockFd);
        printf("connect error, ret:%d\n", ret);
        return -1;
    }

    sprintf(msg, "GET_TEST_SERIAL");

    ret = send(sockFd, msg, strlen(msg), 0);

    FD_ZERO(&readfds);
    FD_SET(sockFd, &readfds);
    memset(&tv, 0, sizeof(tv));
    tv.tv_sec = 2;
    result = select((int)sockFd + 1, &readfds, NULL, NULL, &tv);
    if (result > 0)
    {
        if (FD_ISSET(sockFd, &readfds))
        {
            recv(sockFd, buf, 1024, 0);
            pch = strtok(buf, delim);
            while (pch != NULL)
            {
                if (!strcmp(pch, "TEST_SERIAL"))
                {
                    testSerial = atoi(pch + strlen("TEST_SERIAL="));
                    break;
                }
                pch = strtok(NULL, delim);
            }
        }
        else
        {
            printf("recv error\n");
        }
    }
    else if (result == 0)
    {
        printf("select timeout \n");
    }
    else
    {
        printf("recv error\n");
    }
    close(sockFd);

    return testSerial;
}

void getMsg(char *msg, int test_serial, int delay_ms, char *mode)
{
    char json_msg[1024] = {0};
    struct timeval tv;
    struct tm timeinfo;

    gettimeofday(&tv, NULL);
    ntp_client(NTP_SERVER_IP, &timeinfo);

    sprintf(json_msg, "{ \"test_serial\" : %d, \"client_no\" : 0, \"post_date\" : \"%04d-%02d-%02d %02d:%02d:%02d.%03dZ\", \"network_mode\" : \"%s\", \"video_delay\" : 0, \"audio_delay\" : %d, \"video_audio_diff\" : 0 }",
            test_serial,
            timeinfo.tm_year, timeinfo.tm_mon, timeinfo.tm_mday, timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec, (int)tv.tv_usec / 1000,
            mode,
            delay_ms);

    sprintf(msg, "POST /testprocedure/speakertest/ HTTP/1.1\r\n"
            "User-Agent: curl/7.35.0\r\n"
            "Host: %s:%d \r\n"
            "Accept: */*\r\n"
            "Content-Type: application/json\r\n"
            "Content-Length:%d\r\n"
            "\r\n"
            "%s",
            TEST_CLIENT_IP, TEST_KIBANA_SERVER_PORT, (int)strlen(json_msg), json_msg);
}

int sendSpeakerDelayResult(int nAudioDelayMs)
{
    int sockFd = -1, ret;
    struct sockaddr_in dest;
    char msg[2048] = {0};
    fd_set readfds;
    struct timeval tv;
    int result = 0, testSerial = -1;
    char buf[1024] = {0};
    char mode[4] = {0};

    testSerial = getTestSerial();
    getTestMode(mode);

    sockFd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockFd < 0)
    {
        printf("create socket error, ret:%d \n", sockFd);
        return -1;
    }
    dest.sin_family = AF_INET;
    dest.sin_port = htons(TEST_KIBANA_SERVER_PORT);
    inet_aton(TEST_CLIENT_IP, (struct in_addr *)&dest.sin_addr.s_addr);

    ret = connect(sockFd, (struct sockaddr *)&dest, sizeof(struct sockaddr_in));
    if (ret < 0)
    {
        printf("connect error, ret:%d\n", ret);
        close(sockFd);
        return -1;
    }

    printf("connect ok!!\n");

    getMsg(msg, testSerial, nAudioDelayMs, mode);
    ret = send(sockFd, msg, strlen(msg), 0);

    FD_ZERO(&readfds);
    FD_SET(sockFd, &readfds);
    memset(&tv, 0, sizeof(tv));
    tv.tv_sec = 2;
    result = select((int)sockFd + 1, &readfds, NULL, NULL, &tv);
    if (result > 0)
    {
        if (FD_ISSET(sockFd, &readfds))
        {
            recv(sockFd, buf, 1024, 0);
            // printf("[%s:%d] buf = %s\n", __FUNCTION__, __LINE__, buf);
        }
        else
        {
            printf("recv error\n");
        }
    }
    else if (result == 0)
    {
        printf("select timeout \n");
    }
    else
    {
        printf("recv error\n");
    }

    close(sockFd);

    return 0;
}


#endif

time_t time_to_epoch(const struct tm *ltm, int utcdiff)
{
    const int mon_days[] =
    {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    long tyears, tdays, leaps, utc_hrs;
    int i;

    tyears = ltm->tm_year - 1970; // tm->tm_year is from 1900.
    leaps = (tyears + 2) / 4;	 // no of next two lines until year 2100.
    //i = (ltm->tm_year V 100) / 100;
    //leaps -= ( (i/4)*3 + i%4 );
    tdays = 0;
    for (i = 0; i < ltm->tm_mon - 1; i++)
        tdays += mon_days[i];

    tdays += ltm->tm_mday - 1; // days of month passed.
    tdays = tdays + (tyears * 365) + leaps;

    utc_hrs = ltm->tm_hour + utcdiff; // for your time zone.
    return (tdays * 86400) + (utc_hrs * 3600) + (ltm->tm_min * 60) + ltm->tm_sec;
}
extern INT32U 	 gSessionTaskStack[TASK_SESSION_STACK_SIZE];
#if(DEVSTATUS_ACTIVE_UPDATE)
/*
u32 isLiveview: 0 = Check dev status, 1 = Start LV, 2 = Stop LV, 3 = Reset LV
u32 isRecvAck:  if Start/Stop LV, this params is avIndex
                if Check dev status, this params is acked avIndex by bit shift
*/
#define CHECK_ACK(mask, val, shift)     ((mask & val) >> shift ) & 0x1
#define SET_ACK(mask, val, shift)       mask & (val | (0x1 << shift))
#define CLR_ACK(mask, val, shift)       mask & (val & ~(0x1 << shift))

void devStatusDump(SMsgAVIoctrlGetDevStatusResp *q, SMsgAVIoctrlGetDevStatusResp *r)
{
    DEBUG_YELLOW("ch-%d:%d rec-%d:%d bat-%d:%d rf-%d:%d light-%d:%d alm-%d:%d mo-%d:%d \n",
                q->channel,   r->channel,
                q->rec_sta,   r->rec_sta, 
                q->bat_sta,   r->bat_sta, 
                q->rf_sta,    r->rf_sta, 
                q->light_sta, r->light_sta, 
                q->alarm_sta, r->alarm_sta, 
                q->motion_sta,r->motion_sta );
}

u8 getTxChannelByAvIndex(u32 SID, u32 avIdx)
{
    int i;
    for(i =0; i<MAX_AV_CH;i++)
    {
        if(avIdx == gClientInfo[SID].avIndex[i])
            return i;
    }
    return 0xFF;//Error
}

void getTxChannelStatus(SMsgAVIoctrlGetDevStatusResp *q,u8 channel)
{
    q->channel = channel;
#if  RFIU_RX_WAKEUP_TX_SCHEME
    if( gRfiuUnitCntl[channel].RFpara.BateryCam_support)
    {
        if (gRfiuUnitCntl[channel].RFpara.TxBatteryLev >= UI_BATTERY_LV4)
      		q->bat_sta = 3;
        else
    	    q->bat_sta= gRfiuUnitCntl[channel].RFpara.TxBatteryLev;
    }
    else
#endif
    q->bat_sta=0xFF;
    uiFlowGetUISetting(channel, UI_KEY_CAM_MANUAL_AREC, &(q->motion_sta));
    q->rec_sta= (MultiChannelGetCaptureVideoStatus(channel) == 1) ? 1 : 0;
    
    q->rf_sta= RfIntensity(channel);
#if UI_CAMERA_ALARM_SUPPORT	  
    q->alarm_sta= uiGetAlarmStatusAPP(channel);
#else
    q->alarm_sta=0xFF;
#endif

#if UI_CAMERA_LIGHT_SUPPORT
    q->light_sta= uiGetLightStatusAPP(channel);
#else
    q->light_sta=0xFF;
#endif
}

s32 sysBack_DevStatus(u32 isLiveview, u32 isRecvAck)
{
    u8 i = 0;
    u8 err, channel;
    u8 isSkipUpdate = 0;
    u8 isSkipResend = 0;
#if (MAX_CLIENT == 4)
    static u8 onlineClientCh[MAX_CLIENT+1] = {0xFF,0xFF,0xFF,0xFF,0xFF};
#elif (MAX_CLIENT == 3)
    static u8 onlineClientCh[MAX_CLIENT+1] = {0xFF,0xFF,0xFF,0xFF};
#endif
    static u16 needAckMask=0;
    static u16 waitAck=0;
    static u32 dbgTimeCnt=0;
    static u8 pauseResume=0;
    int size = sizeof(SMsgAVIoctrlGetDevStatusResp);
	SMsgAVIoctrlGetDevStatusResp q = {0, 0, 0xFF, 0, 0xFF, 0xFF, 0};
    static SMsgAVIoctrlGetDevStatusResp lastDevSta[MAX_AV_CH]={
    // Index, recoding status, Battery status, RF status, light status, alarm status, motion status
            {0, 0, 0xFF, 0, 0xFF, 0xFF, 0},
            {0, 0, 0xFF, 0, 0xFF, 0xFF, 0},
            {0, 0, 0xFF, 0, 0xFF, 0xFF, 0},
            {0, 0, 0xFF, 0, 0xFF, 0xFF, 0},
        };

    if(dbgTimeCnt++ >= 0xFFFFFFFE)
        dbgTimeCnt = 0;

    switch(isLiveview)
    {
      case SYS_BACK_DEVSTATUS_START://RECEIVE FIRST IFRAME
      {
        needAckMask |= (1<<isRecvAck);
        dbgTimeCnt= 0;
        for(i =0; i < MAX_CLIENT; i++)
        {
            if((gClientInfo[i].avChannel == isRecvAck) &&
                        (gClientInfo[i].bEnableVideo))
            {
                waitAck = SET_ACK(needAckMask, waitAck, gClientInfo[i].avChannel);
                onlineClientCh[i] = getTxChannelByAvIndex(i, isRecvAck);
            }
        }
        DEBUG_YELLOW("[P2P] SYSBAK_DEVSTA_START needAckMask=0x%X, waitAck=0x%X\n",needAckMask,waitAck);
        break;
//        return 0;
      }
      case SYS_BACK_DEVSTATUS_STOP://IPCAM_STOP
      {
        needAckMask &= ~(1<<isRecvAck);

        for(i =0; i < MAX_CLIENT; i++)
        {
            if((onlineClientCh[i] == getTxChannelByAvIndex(i, isRecvAck)) ||
                                (gClientInfo[i].bEnableVideo != 1) )
            {
                waitAck = CLR_ACK(needAckMask, waitAck, gClientInfo[i].avChannel);//Client waitAck
                onlineClientCh[i] = 0xFF;
            }
        }
        DEBUG_YELLOW("[P2P] SYSBAK_DEVSTA_STOP needAck=0x%X, waitAck=0x%X\n",needAckMask,waitAck);
        return 0;
      }
      case SYS_BACK_DEVSTATUS_CLEAR://All client leave
      {
        needAckMask = 0;
        waitAck =0;
        memset(onlineClientCh, 0xFF, sizeof(onlineClientCh));
        OSFlagPost(gP2pDevStatusFlagGrp, 0xFFFFFFFF, OS_FLAG_CLR, &err);
        DEBUG_YELLOW("[P2P] SYSBAK_DEVSTA_CLEAR\n");
        return 0;
      }
      case SYS_BACK_DEVSTATUS_PAUSE_RESUME:
      {
        pauseResume = (pauseResume)?0:1;
        DEBUG_YELLOW("[P2P] DEV status active update %s\n", (pauseResume)?"PAUSE":"RESUME");
        return 0;
      }
    }

    if(pauseResume)
        return 0;
    if((dbgTimeCnt %5) != 0)// Update status per 5 sec;
        return 0;
#if 0
    if((dbgTimeCnt++ %10) == 0)
        DEBUG_RED("\nneedAckMask =\t0x%08X\nwaitAck =\t0x%08X\nisRecvAck =\t0x%08X\n\n",
                        needAckMask, waitAck, isRecvAck);
#endif
//Check & update Tx status
    for(i = 0; i < MAX_CLIENT ; i++)
    {
        if(onlineClientCh[i] == 0xFF)
            continue;

        memset(&q, 0, sizeof(SMsgAVIoctrlGetDevStatusResp));
        if((channel = onlineClientCh[i]) == 0xFF)//No exist channel
            continue;
            
        getTxChannelStatus(&q,channel);

//        if((dbgTimeCnt %4))// Update RF per 4 sec
//            q.rf_sta = lastDevSta[channel].rf_sta;
        if(memcmp(&lastDevSta[channel], &q, sizeof(SMsgAVIoctrlGetDevStatusResp)) == 0)
        {
            isSkipUpdate |= (1 <<i);//Mark which SID need skip update
//            DEBUG_P2P("[P2P] Skip Ch[%d] update(0x%08X)\n", channel, isSkipUpdate);
        }
        else
        {
            devStatusDump(&q, &lastDevSta[channel]);
            memcpy(&lastDevSta[channel], &q, sizeof(SMsgAVIoctrlGetDevStatusResp) );//Update ch status
        }
        
        if(((CHECK_ACK(needAckMask, waitAck, gClientInfo[i].avChannel)) == 0) || //Means dont need to check Ack
            ((CHECK_ACK(waitAck, isRecvAck, gClientInfo[i].avChannel)) != 0))//Means received Ack
        {
            isSkipResend |= (1 <<i);
            waitAck = CLR_ACK(needAckMask, waitAck, gClientInfo[i].avChannel);//Client waitAck
            OSFlagPost(gP2pDevStatusFlagGrp, 0x1 << gClientInfo[i].avChannel, OS_FLAG_CLR, &err);
//            DEBUG_P2P("[P2P] Skip SID[%d] resend(0x%08X)\n",i, isSkipResend);
        }
    }
#if 0
//    if((isSkipUpdate != 0) || (isSkipResend !=0))
        DEBUG_RED("[P2P] Received ACK(0x%08X), waitAck(0x%08X)\nSikp update(0x%08X), skip resend(0x%08X)\n",
                        isRecvAck, waitAck, isSkipUpdate, isSkipResend);
#endif

//Ready to send DevStatus if need
    for(i = 0; i < MAX_CLIENT ; i++)
    {
        if(onlineClientCh[i] == 0xFF)
            continue;
#if 0
        DEBUG_P2P("===>onlineClientCh[%d] = %d\n", i, onlineClientCh[i]);
#endif
        if((isSkipResend >> i) & 0x01)//Means received ack, skip send
        {
            if((isSkipUpdate >> i) & 0x01)//Means same status,skip send
                continue;
        }

        if (avSendIOCtrl2(gClientInfo[i].avChannel, IOTYPE_WALMART_GETDEVSTATUS_RESP,
                            (char*)&lastDevSta[onlineClientCh[i]], size) == AV_ER_NoERROR)
        {
            DEBUG_P2P("IOTYPE_WALMART_GETDEVSTATUS_RESP[SID:%d AvIdx:%d] OK\n\n", i, gClientInfo[i].avChannel);
            waitAck = SET_ACK(needAckMask, waitAck, gClientInfo[i].avChannel);
#if 0
            DEBUG_RED("\nneedAckMask =\t0x%08X\nwaitAck =\t0x%08X\nisRecvAck =\t0x%08X\n\n",
                        needAckMask, waitAck, isRecvAck);
            DEBUG_RED("Sikp update(0x%08X), skip resend(0x%08X)\n",isSkipUpdate, isSkipResend);
            devStatusDump(&lastDevSta[onlineClientCh[i]], &lastDevSta[onlineClientCh[i]]);
            DEBUG_P2P("[P2P-sended] Received ACK(0x%08X), waitAck(0x%08X)\n",
                                                i, isRecvAck, waitAck);
#endif
        }
    }
    return 0;
}
#endif

void Task_Login(void *UID) //  when succeed deleted by other task
{
    INT8U err;
    int ret = -1;

    DEBUG_P2P("### Task_Login start wait get IP.......\n");
    OSFlagPend(gpiNetStatusFlagGrp, FLAGGPI_LWIP_IP_READY|FLAGGPI_TUTK_READY, OS_FLAG_WAIT_SET_ALL, OS_IPC_WAIT_FOREVER, &err);
    DEBUG_P2P("### Task_Login start running[%s].......\n", gUID);
    //DEBUG_P2P("### MyIp %u.%u.%u.%u\n", my_ipaddr[0], my_ipaddr[1], my_ipaddr[2], my_ipaddr[3]);

    while(1)
    {
        ret = IOTC_Device_Login((char *)gUID, NULL, NULL);
        DEBUG_P2P("@@@ IOTC_Device_Login() ret = %d\n", ret);

        if(ret == IOTC_ER_NoERROR)
        {
            gFlagLoginOK = 1;
            OSTimeDly(65000);  // switch to other task
            DEBUG_P2P("OSTimeDly break\n");
        }
        else
        {
            gLoginFaileCnt++;
            OSTimeDly(200);
        }
    }
}


void Task_Listen(void *pdata)
{
    int SID;
    INT8U err;
    int i;
    int ret;
    struct st_SInfo Sinfo;
#if (UI_VERSION == UI_VERSION_MAYON) //Fixed task delete fail issue, Paul, 2019/04/10
    OS_TCB* pb_task_info;
#endif
    DEBUG_P2P("Task_Listen start wait get IP.......\n");    
    OSFlagPend(gpiNetStatusFlagGrp, FLAGGPI_LWIP_IP_READY|FLAGGPI_TUTK_READY, OS_FLAG_WAIT_SET_ALL, OS_IPC_WAIT_FOREVER, &err);

    while(1)
    {

		// Accept connection only when IOTC_Listen() calling
		DEBUG_P2P("+++IOTC_Listen calling.....\n");
		
		SID = IOTC_Listen(0);
		if((SID == 5) || (gOnlineNum >= MAX_CLIENT))
        {
        	printf("Can't be Connected![SID:%d]\n", SID);
//            err_cnt++;
        	OSTimeDly(200);
        	continue;
        }

        DEBUG_P2P("+++IOTC_Listen ret[%d].....\n", SID);

#if APP_KEEP_ALIVE
        /*==============================KEEP ALIVE==================================*/
        switch(SID)
        {
            case 0:
                RTC_Get_Time(&gKeepAliveTime0);
                break;
            case 1:
                RTC_Get_Time(&gKeepAliveTime1);
                break;
            case 2:
                RTC_Get_Time(&gKeepAliveTime2);
                break;
            case 3:
                RTC_Get_Time(&gKeepAliveTime3);
                break;
            case 4:
				RTC_Get_Time(&gKeepAliveTime4);
            default:
                break;
        }
        gFlagKeepAlive[SID] = 1;
        /*===============================KEEP ALIVE==================================*/
#endif

        if(SID > -1)
        {
            //aher test for encryption
            // cause 9200 network crash problem
            ret=IOTC_Set_Partial_Encryption(SID,1);
            DEBUG_P2P("Set partial encryption = %d\n",ret);
            DEBUG_P2P("IOTC_Listen ret SID[%d]\n", SID);

            client_p2pconnected(SID);
            AVServerStart(SID);

        }
        else if(SID == IOTC_ER_EXCEED_MAX_SESSION)
        {
            DEBUG_P2P("Listen fail : IOTC_ER_EXCEED_MAX_SESSION.\n");
            //for (i=0;i<MAX_CLIENT;i++)
            //client_p2pdisconnected(i);
            OSTimeDly(200);
        }

    }
}


#if ENABLE_TUTK_RESEND
void gResendInit()
{
    int i;
    for(i = 0; i < MAX_CLIENT; i++)
        gClientInfo[i].resend_buf_usage_rate = 0;
#if P2P_LV_RATECTL_SUPPORT
    RateCtlInit(&rateCtl);
#endif
}
#endif

void tutk_av_sample(void)
{
    int ret;//, SID;
//    struct timeval tv;

//    int count = 0;
    extern OS_FLAG_GRP  *gpiNetStatusFlagGrp;
    u8 err;
#if(DEVSTATUS_ACTIVE_UPDATE)
    gP2pDevStatusFlagGrp = OSFlagCreate(0x00000000, &err);
#endif
#if REMOTE_FILE_PLAYBACK
    SERVTYPE_STREAM_SERVER=38880;	//5920//5984//6112 	// Disable WiFi setting,Format SDCard function,Record setting function. 			aher 2013/06/04
#else
    SERVTYPE_STREAM_SERVER=38904;//6136; 	// Disable WiFi setting,Format SDCard function,Record setting,File playback function.
#endif

#if GATEWAY_BOX
    SERVTYPE_STREAM_SERVER=SERVTYPE_STREAM_SERVER&0x7eff;
#endif

#if NIC_TIMEZONE_DISABLE
    SERVTYPE_STREAM_SERVER=SERVTYPE_STREAM_SERVER|0x20000;
#endif

#if(HW_BOARD_OPTION == MR8211_ZINWELL)
    SERVTYPE_STREAM_SERVER=0;
#endif
#if ((HW_BOARD_OPTION == MR8200_RX_TRANWO_D8593) || (HW_BOARD_OPTION == MR8200_RX_TRANWO_BOX))
    SERVTYPE_STREAM_SERVER=SERVTYPE_STREAM_SERVER|0x02;
#endif

    tutk_task_init();
    av_sample_task_init();
    Init_P2P_Session();
    memset(gClientInfo, 0, sizeof(gClientInfo));
    memset(gPushMsgSrvAddr, 0, sizeof(gPushMsgSrvAddr));
    
    if(OSTaskCreate(Task_Login, (void *)0, LOGIN_TASK_STACK, LOGIN_TASK_PRIORITY) != OS_NO_ERR)
    {
        DEBUG_P2P("OSTaskCreate Task_Login failed!!!!!!!!!!!!!!!!!!!\n");
        return;
    }

    if(OSTaskCreate(Task_SessionHandler, (void *)0, SESSION_TASK_STACK, SESSION_TASK_PRIORITY) != OS_NO_ERR)
    {
        DEBUG_P2P("OSTaskCreate Task_SessionHandler failed[%d]!!!!!!!!!!!!!!!!\n", SESSION_TASK_PRIORITY);
        return;
    }

    if(OSTaskCreate(Task_Listen, (void *)0, LISTEN_TASK_STACK, LISTEN_TASK_PRIORITY) != OS_NO_ERR)
    {
        DEBUG_P2P("OSTaskCreate Task_Listen failed[%d]!!!!!!!!!!!!!!!!!!!\n", LISTEN_TASK_PRIORITY);
        return;
    }    
}


void SendRegister(void)
{
    int skt, i;
    static char *tpns_svr_list[MAX_PUSH_MSG_SVR] = {TPNS_SERVER, TPNS_SERVER2};
    
    
    for(i = 0; i < MAX_PUSH_MSG_SVR; ++i)
    {
        char hostname_IP[HOSTNAME_IP_BUF_SIZE]="";
        int err;
        
        err = DN2IP(tpns_svr_list[i], hostname_IP);
        if(err == 0)
        {
            DEBUG_P2P("Get TPNS_SERVER IP = %s\n", hostname_IP);
            SendRegisterInternal(hostname_IP, i);
        }
        else
        {
            DEBUG_P2P("Parse TPNS_SERVER fail...\n");
        }
    }
}


#if UI_LIGHT_SUPPORT
void UpdateAPPLightStatus(u8 Camid)
{
    AppLightStatus = Camid+1;
}

#endif


int DN2IP(char * URL, char * realIP)
{
    u32_t host;
    int rv;
    struct addrinfo *servinfo, *p;
    
    if(URL == 0 || realIP == 0)
        return -1;

    host = inet_addr(URL);
    if (host != INADDR_NONE)
        return -1;

    rv = lwip_getaddrinfo(URL, 0, 0, &servinfo);
    if(rv != 0)
        return -1;

    for(p = servinfo; p != NULL; p = p->ai_next) 
    {
        struct sockaddr_in *sin = (struct sockaddr_in *) p->ai_addr;
        inet_ntoa_r(sin->sin_addr, realIP, HOSTNAME_IP_BUF_SIZE);
    }

    lwip_freeaddrinfo(servinfo);

    return 0;    
}


#if(HW_BOARD_OPTION == MR9200_RX_TRANWO_D8796P) //20171208 add.
void Reset_P2P_Connection(void)
{
    u8 i;

    DEBUG_P2P("\x1B[96mReset_P2P_Connection.\x1B[0m\n");
    OSTaskDel(SESSION_TASK_PRIORITY);

    for(i=0;i<5;i++)
    {
        Clear_Session_Status(i);
        avServExit(i,0);
    }
    Reset_P2P_Session();

    OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY);
    OSTimeDly(10);

	if(OSTaskCreate(Task_SessionHandler, (void *)0, SESSION_TASK_STACK, SESSION_TASK_PRIORITY) != OS_NO_ERR)
	{
		DEBUG_P2P("OSTaskCreate Task_SessionHandler failed[%d]!!!!!!!!!!!!!!!!\n", SESSION_TASK_PRIORITY);
	}

    gOnlineNum = 0;
}

#endif



#if P2P_LIVEVIEW_FIND_PRE_I_FRAME
int FindPreIFrameIndex(u8 ch)
{
    u32 numFrameSearch = 0;
    /*Found Pre I Frame*/
    preIframeIndex[ch] = P2PVideoBufReadIdx[ch];
    while(1){
        if(P2PVideoBuf[ch][preIframeIndex[ch]].flag == 1)
        {
            DEBUG_P2P("ch:%d, pre IFrame Found:%d\n", ch, preIframeIndex[ch]);
            return 0;
        }
        else
        {
            numFrameSearch++;
            if(preIframeIndex[ch] > 0)
                preIframeIndex[ch]--;
            else
                preIframeIndex[ch] = (VIDEO_BUF_NUM - 1);
            if(numFrameSearch > 100)
            {
                DEBUG_P2P("I frame not found\n");
                return -1;
            }
        }
    }
}
#endif


void tutk_lib_init(void)
{    
    int avVer = avGetAVApiVer();
    unsigned int iotcVer;
    unsigned int pnVersion;
    unsigned char *p = (unsigned char *)&iotcVer;
    unsigned char *p2 = (unsigned char *)&avVer;
    char szIOTCVer[16], szAVVer[16];    
    INT8U err;
    int ret;
    
    printf("IOTCAPIs_Device start... from 0x%X, size 0x%X\n", (u32)iotcBuf, IOTC_BUF_SIZE);
    memset(iotcBuf, 0, IOTC_BUF_SIZE);
    ret = IOTC_Mem_Init((char*)iotcBuf, IOTC_BUF_SIZE);
    if (ret != IOTC_ER_NoERROR)
    {
        DEBUG_RED("IOTC_Mem_Init, ret=[%d]\n", ret);
        return;
    }
    DEBUG_P2P("tutkSampleInit entry...\n");
    IOTC_Get_Version(&pnVersion);
    DEBUG_P2P("AVAPIver=%x,IOTCver=%x\n",avVer,pnVersion);
    gUID = uiP2PID;
    DEBUG_P2P("gUID = %s\n",uiP2PID);
    IOTC_Set_Max_Session_Number(MAX_CLIENT);
#if ENABLE_TUTK_RESEND
    gResendInit();
#endif
    // use which Master base on location, port 0 means to get a random port
    ret = IOTC_Initialize2(0);
    if (ret != IOTC_ER_NoERROR)
    {
        DEBUG_RED("  [] IOTC_Initialize2(), ret=[%d]\n", ret);
        PrintErrHandling(ret);
        av_sample_task_deinit();
        while(1)
            OSTimeDly(1000);
    }

    adj_conn(1,0,0,1);
    // Versoin of IOTCAPIs & AVAPIs

    IOTC_Get_Version(&iotcVer);

    snprintf(szIOTCVer, sizeof(szIOTCVer), "%d.%d.%d.%d", p[3], p[2], p[1], p[0]);
    snprintf(szAVVer, sizeof(szAVVer), "%d.%d.%d.%d", p2[3], p2[2], p2[1], p2[0]);
    printf("IOTCAPI version[%s] AVAPI version[%s]\n", szIOTCVer, szAVVer);

    IOTC_Get_Login_Info_ByCallBackFn(LoginInfoCB);
    // alloc MAX_CLIENT_NUMBER*3 for every session av data/speaker/play back
    avInitialize((MAX_CLIENT* MAX_AV_CH)+1);
    IOTC_Setup_Session_Alive_Timeout(TUTK_SESSION_ALIVE_TIMEOUT);
#if ENABLE_TUTK_RESEND
    IOTC_Set_Pbuf_Threshold_Count(PBUF_POOL_SIZE / 10 * 6);//Set to 60%
#endif
#if (P2P_IOCMD_TIMEOUT_HANDLE == 1)
    TmrInit();
    TmrCfgFnct(1, ShowOnlineUserNum, 0);
    TmrSetT(1, 100);
    TmrStart(1);
    #if 0
    TmrCfgFnct(1, ShowLwipBufUsage, 0);
    TmrSetT(1, 30);
    TmrStart(1);
    #endif
#endif
    memset(chk_session_cnt, 0, sizeof(chk_session_cnt));
    if(!ResendBufUsageSem)
        ResendBufUsageSem = OSSemCreate(1);
    OSFlagPost(gpiNetStatusFlagGrp, FLAGGPI_TUTK_READY, OS_FLAG_SET, &err);
    DEBUG_BLUE("init tutk ok\n");
}


typedef struct{
    int id;
    unsigned int type;
    const char *data;
    int data_size;
}SendIOCtrlDebugRecord;


#if 0
int avSendIOCtrl2(int nAVChannelID, unsigned int nIOCtrlType, const char *cabIOCtrlData, int nIOCtrlDataSize)
{
    int ret;
    static SendIOCtrlDebugRecord debugonly;
    
#if (P2P_IOCMD_TIMEOUT_HANDLE == 1)
    debugonly.id = nAVChannelID;
    debugonly.type = nIOCtrlType;
    debugonly.data = cabIOCtrlData;
    debugonly.data_size = nIOCtrlDataSize;

    //TmrCfgFnct(AV_SENDIOCTRL_TIMEOUT_TMR_ID, StopSendIOCtrl, (void*)nAVChannelID);
    TmrCfgFnct(AV_SENDIOCTRL_TIMEOUT_TMR_ID, StopSendIOCtrl, (void*)&debugonly);
    TmrSetT(AV_SENDIOCTRL_TIMEOUT_TMR_ID, AV_SENDIOCTRL_TIMEOUT);
    TmrStart(AV_SENDIOCTRL_TIMEOUT_TMR_ID);
#endif
    ret = avSendIOCtrl(nAVChannelID, nIOCtrlType, cabIOCtrlData, nIOCtrlDataSize);
#if (P2P_IOCMD_TIMEOUT_HANDLE == 1)
    TmrStop(AV_SENDIOCTRL_TIMEOUT_TMR_ID);
#endif
    
    return ret;
}
#endif


void StopSendIOCtrl(void *arg)
{
    //avSendIOCtrlExit((int)arg);
    SendIOCtrlDebugRecord *dbg = (SendIOCtrlDebugRecord*)arg;
    DEBUG_P2P("\navSendIOCtrlExit:%d,%d,%p,%d\n", dbg->id, dbg->type, dbg->data, dbg->data_size);
    avSendIOCtrlExit(dbg->id);
}

#ifdef SAFE_DEL_P2P_PLAYFILE_TASK
void SafeDelP2pPlayFileTask(void)
{
    OS_TCB task_data;
    INT8U os_err;
    int cnt;
    static const int max_cnt = (TUTK_SESSION_ALIVE_TIMEOUT*1000/2/50);
    
    os_err = OSTaskQuery(P2P_PLAYFILE_TASK_PRIORITY, &task_data);
    if(os_err != OS_NO_ERR)
    {
        DEBUG_YELLOW("playback task doesn't exist!\n");
        return;
    }
    
    gPlaybackTaskRunning = false;
    cnt = 0;
    while(++cnt <= max_cnt)
    {
        os_err = OSTaskQuery(P2P_PLAYFILE_TASK_PRIORITY, &task_data);
        if(os_err != OS_NO_ERR)
            break;
        OSTimeDly(1);
    }
    
#if 0    
    if(cnt <= max_cnt)
    {
        SafeDelSem(&P2PVideoPlaybackCmpSemEvt);
        SafeDelSem(&P2PAudioPlaybackCmpSemEvt);
    }
    else
    {
        DEBUG_RED("\nerror: failed to delete playback task\n");
    }
#endif    
}

bool SafeDelSem(OS_EVENT **sem)
{
    INT8U os_err;
    static const int max_cnt = (TUTK_SESSION_ALIVE_TIMEOUT*1000/2/50);
    int cnt = 0;
    
    if(*sem == 0)
        return true;
    
    do{
        *sem = OSSemDel(*sem, OS_DEL_ALWAYS, &os_err);
    }while(++cnt < max_cnt && os_err != OS_NO_ERR);
    
    if(cnt >= max_cnt)
        DEBUG_RED("can't del sem %p\n", sem);
    
    return (cnt < max_cnt);
}


#endif

void StopAndClearSession(int SID, int reason)
{
    int i;
    INT8U err;
    
    if(gClientInfo[SID].bEnableSpeaker>0)
    {
        Kill_Task_Speaker(SID);
    }
    
    DEBUG_LIGHTCYAN("Check Session : Session close [%d] SID[%d]\n", reason, SID);
    client_p2pdisconnected(SID);

    /*Close remote playback task.*/
    if(gClientInfo[SID].playBackCh!=0)
    {
        for(i = 0; i<MAX_AV_CH; i++)
        {
            if(gClientInfo[SID].avIndex[i] == gClientInfo[SID].avChannel)
                Stop_P2P_Session(i);
        }
        
        avServStop(gClientInfo[SID].avChannel);
        P2PPlaybackVideoStop = 1;
        unregedit_client_from_video(SID);
        gClientInfo[SID].bStopPlayBack = 1;
        gClientInfo[SID].bPausePlayBack = 0;
        P2PEnableplaybackStreaming--;
        DEBUG_P2P("P2PEnableplaybackStreaming5555=%d\n",P2PEnableplaybackStreaming);
        P2PEnableplaybackStreaming=0;
        
        OSSemSet(P2PVideoPlaybackCmpSemEvt, 0, &err);
        if(err!= OS_NO_ERR)
            printf("222Set P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
        OSSemSet(P2PAudioPlaybackCmpSemEvt, 0, &err);
        if(err!= OS_NO_ERR)
            printf("222Set P2PAudioPlaybackCmpSemEvt fail = %d\n", err);
        P2PVideoPlaybackCmpSemEvt=OSSemDel(P2PVideoPlaybackCmpSemEvt, OS_DEL_ALWAYS, &err);
        if(err!= OS_NO_ERR)
            printf("222Del P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
        P2PAudioPlaybackCmpSemEvt=OSSemDel(P2PAudioPlaybackCmpSemEvt, OS_DEL_ALWAYS, &err);
        if(err!= OS_NO_ERR)
            printf("222Del P2PAudioPlaybackCmpSemEvt fail = %d\n", err);
        gClientInfo[SID].playBackCh=0;
        DEBUG_P2P("Fileplaying= %d ,Remote_play= %d \n",Fileplaying,Remote_play);
        if((Fileplaying)&&(Remote_play==1))
        {
            DEBUG_P2P("DELETE P2P PLAYFILE TASK.\n");
#if (UI_VERSION == UI_VERSION_MAYON) //Fixed task delete fail issue, Paul, 2019/04/10
            err = Stop_Task_by_Prio(P2P_PLAYFILE_TASK_PRIORITY, &(gClientInfo[SID].bStopPlayBack),
                                      P2PVideoPlaybackStopSemEvt, NULL, FLAGSYS_RDYSTAT_PLAY_FINISH );
            if(err != OS_NO_ERR)
                DEBUG_P2P("DELETE P2P PLAYFILE TASK ERROR: %d\n", err);
            gClientInfo[SID].bStopPlayBack = 0;
#else
            if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
                DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");

            OSFlagPend(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_PLAY_FINISH, OS_FLAG_WAIT_CLR_ALL|OS_FLAG_CONSUME, OS_IPC_WAIT_FOREVER, &err);
            DEBUG_P2P("pend FLAGSYS_RDYSTAT_PLAY_FINISH.\n");

            if(OS_NO_ERR !=  OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY))
                DEBUG_P2P("OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
        /*
        error=OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY);
        if(error!=OS_NO_ERR)
            DEBUG_P2P("OSTaskDel error : %d\n",error);
        */
#endif
            Fileplaying=0;
            Remote_play=0;
        }
#if(UI_VERSION == UI_VERSION_MAYON)
        CurrPlaybackSID = -1;
#endif
    }

    //for check device connect timeout by aher 2012/12/21
    if(gOnlineNum<=0)
    {
        if(gFirstConnect)
        {
            if(gClientInfo[SID].bEnableSpeaker>0)
            {
                Kill_Task_Speaker(SID);
            }
            /*Close remote playback task.*/
            if((Fileplaying)&&(Remote_play==1))
            {
                P2PPlaybackVideoStop=1;
                unregedit_client_from_video(SID);
#if (UI_VERSION == UI_VERSION_MAYON) //Fixed task delete fail issue, Paul, 2019/04/10
#else
                gClientInfo[SID].bStopPlayBack = 1;
#endif
                gClientInfo[SID].bPausePlayBack = 0;
                P2PEnableplaybackStreaming=0;
                OSSemSet(P2PVideoPlaybackCmpSemEvt, 0, &err);
                if(err!= OS_NO_ERR)
                    printf("333Set P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
                OSSemSet(P2PAudioPlaybackCmpSemEvt, 0, &err);
                if(err!= OS_NO_ERR)
                    printf("333Set P2PAudioPlaybackCmpSemEvt fail = %d\n", err);
                P2PVideoPlaybackCmpSemEvt=OSSemDel(P2PVideoPlaybackCmpSemEvt, OS_DEL_ALWAYS, &err);
                if(err!= OS_NO_ERR)
                    printf("333Del P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
                P2PAudioPlaybackCmpSemEvt=OSSemDel(P2PAudioPlaybackCmpSemEvt, OS_DEL_ALWAYS, &err);
                if(err!= OS_NO_ERR)
                    printf("333Del P2PAudioPlaybackCmpSemEvt fail = %d\n", err);
                DEBUG_P2P("Fileplaying= %d ,Remote_play= %d \n",Fileplaying,Remote_play);
                DEBUG_P2P("DELETE P2P PLAYFILE TASK.\n");
#if (UI_VERSION == UI_VERSION_MAYON) //Fixed task delete fail issue, Paul, 2019/04/10
                err = Stop_Task_by_Prio(P2P_PLAYFILE_TASK_PRIORITY, &(gClientInfo[SID].bStopPlayBack),
                          P2PVideoPlaybackStopSemEvt, NULL, FLAGSYS_RDYSTAT_PLAY_FINISH );
                if(err != OS_NO_ERR)
                    DEBUG_P2P("DELETE P2P PLAYFILE TASK ERROR: %d\n", err);
                gClientInfo[SID].bStopPlayBack = 0;
#else
                if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
                    DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");

                OSFlagPend(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_PLAY_FINISH, OS_FLAG_WAIT_CLR_ALL|OS_FLAG_CONSUME, OS_IPC_WAIT_FOREVER, &err);
                DEBUG_P2P("pend FLAGSYS_RDYSTAT_PLAY_FINISH.\n");

                if(OS_NO_ERR !=  OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY))
                    DEBUG_P2P("OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
#endif
                /*
                error=OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY);
                if(error!=OS_NO_ERR)
                        DEBUG_P2P("OSTaskDel error : %d\n",error);
                */
                Fileplaying=0;
                Remote_play=0;
                search_dir_start.YMD=0;
                search_dir_start.HMS=0;
                search_dir_end.YMD=0;
                search_dir_end.HMS=0;
            }
            //gFirstConnect=0;
        }
        for (i = 0; i < MAX_AV_CH; i++)
            uiSetP2PImageLevel(i,0);
    }    

    if((reason == IOTC_ER_REMOTE_TIMEOUT_DISCONNECT) ||
        (reason == IOTC_ER_SESSION_CLOSE_BY_REMOTE) ||
        (reason == IOTC_ER_INVALID_SID))
        IOTC_Session_Close(SID);
}


void SendRegisterInternal(const char *hostname_IP, int pushMsgSvrIdx)
{
    int skt;
    
    DEBUG_P2P("Register the %s servre.\n", hostname_IP);
    gPushMsgSrvAddr[pushMsgSvrIdx].sin_addr.s_addr = inet_addr(hostname_IP);
    gPushMsgSrvAddr[pushMsgSvrIdx].sin_port        = htons(PORT_TPNS);
    gPushMsgSrvAddr[pushMsgSvrIdx].sin_family      = AF_INET;
    
    skt = TcpConnect2((struct sockaddr *)&gPushMsgSrvAddr[pushMsgSvrIdx], PUSH_MSG_SVR_CONNECT_TIMEOUT, 0, 0);
    if(skt >= 0)
    {
        int msglen;
        const char *msg = GetRegMessageString(gUID, &msglen, pushMsgSvrIdx);
        
        TcpSetSendTimeout(skt, SEND_REG_TIMEOUT);
        if(TcpSendAll(skt, msg, msglen) != msglen)
            DEBUG_RED("Register %s Fail\n", hostname_IP);
        else
            DEBUG_BLUE("Register %s OK\n", hostname_IP);
        
        close(skt);
        skt = INVALID_SOCKET;
    }
    else
    {
        DEBUG_RED("%s Connnection fail.\n", hostname_IP);
    }    
}


#ifdef LWIP_BUF_STAT
void ShowLwipBufUsage(void *arg)
{
    DispLwipBufStat();
    TmrReset(1);
    TmrStart(1);
}
#endif


void ShowOnlineUserNum(void *arg)
{
    printf("OnlineNum=%d\n", gOnlineNum);
    cmd_s_chk();
    printf("check session[%d,%d,%d]\n", chk_session_cnt[0], chk_session_cnt[1], chk_session_cnt[2]);
    TmrReset(1);
    TmrStart(1);
}

//Add by Paul for stop task, 2019/04/09
static INT8U Stop_Task_by_Prio(INT8U prio, INT8U* u8TskStopFlag, OS_EVENT *pevent, OS_FLAG_GRP *pgrp, OS_FLAGS flags)
{
    INT8U err;
    INT8U tmpStat = *u8TskStopFlag;
    OS_TCB *pb_task_info;

    err = OSTaskQuery (prio, pb_task_info);
    DEBUG_RED("OSTaskQuery: %d\n",err);
    if(err != OS_PRIO_ERR) // Means task was create already
        DEBUG_P2P("Task prio %d exist : %d\n",prio, err);
    else
        return OS_NO_ERR;// Means task is not exist

    *u8TskStopFlag =1;//Ask task into save loop
    OSSemPend(pevent, 0, &err);//Task save now
    DEBUG_P2P("Suspend %d.\n", prio);
    err =  OSTaskSuspend(prio);
    if(err != OS_NO_ERR)
        goto TASK_DEL_ERR;

    if(pgrp != NULL)//Wait for other flag release, for example, playback task file flag
        OSFlagPend(pgrp, flags, OS_FLAG_WAIT_CLR_ALL|OS_FLAG_CONSUME, OS_IPC_WAIT_FOREVER, &err);
    DEBUG_MAGENTA("av:%d\n", __LINE__);
    err =  OSTaskDel(prio);

TASK_DEL_ERR:
    *u8TskStopFlag = tmpStat;
    P2PVideoPlaybackStopSemEvt = OSSemDel(P2PVideoPlaybackStopSemEvt, OS_DEL_ALWAYS, &err);
    return err;
}

static void Force_Stop_Playback(int SID)
{
    u8 err;
    int error;

    DEBUG_P2P("Force_Stop_Playback[%d]\n", SID);
    DEBUG_P2P("P2PEnableplaybackStreaming333=%d\n",P2PEnableplaybackStreaming);

    P2P_check=0;
    P2PPlaybackVideoStop=1;

    unregedit_client_from_video(SID);
    gClientInfo[SID].bPausePlayBack = 0;
    gClientInfo[SID].playBackCh=0;
	OSSemSet(P2PVideoPlaybackCmpSemEvt, 0, &err);
	if(err!= OS_NO_ERR)
		DEBUG_P2P("111Set P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
	OSSemSet(P2PAudioPlaybackCmpSemEvt, 0, &err);
	if(err!= OS_NO_ERR)
		DEBUG_P2P("111Set P2PAudioPlaybackCmpSemEvt fail = %d\n", err);
	P2PVideoPlaybackCmpSemEvt = OSSemDel(P2PVideoPlaybackCmpSemEvt, OS_DEL_ALWAYS, &err);
	if(err!= OS_NO_ERR)
		DEBUG_P2P("Del P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
	P2PAudioPlaybackCmpSemEvt = OSSemDel(P2PAudioPlaybackCmpSemEvt, OS_DEL_ALWAYS, &err);
	if(err!= OS_NO_ERR)
		DEBUG_P2P("Del P2PAudioPlaybackCmpSemEvt fail = %d\n", err);

    DEBUG_P2P("Fileplaying=%d ,Remote_play=%d \n",Fileplaying,Remote_play);
    if((Fileplaying)&&(Remote_play==1))
    {
        DEBUG_P2P("DELETE P2P PLAYFILE TASK .\n");
        err = Stop_Task_by_Prio(P2P_PLAYFILE_TASK_PRIORITY, &(gClientInfo[SID].bStopPlayBack),
                  P2PVideoPlaybackStopSemEvt, NULL, FLAGSYS_RDYSTAT_PLAY_FINISH );
        if(err != OS_NO_ERR)
            DEBUG_P2P("DELETE P2P PLAYFILE TASK ERROR: %d\n", err);
        gClientInfo[SID].bStopPlayBack = 0;

        Fileplaying=0;
        Remote_play=0;
        P2PEnableplaybackStreaming=0;
        OSTimeDly(10);
    }
#if (UI_VERSION == UI_VERSION_MAYON)
    CurrPlaybackSID=-1;
    gClientInfo[SID].avChannel = -1; //Clear TX channel when avChannel was stoped, Paul add, 180613
#else
    CurrPlaybackSID=SID;
#endif
}


int avSendIOCtrlWithTimeout(int nAVChannelID, unsigned int nIOCtrlType, const char *cabIOCtrlData, int nIOCtrlDataSize, u16 timeout)
{
    int ret;
    static SendIOCtrlDebugRecord debugonly;
    
#if (P2P_IOCMD_TIMEOUT_HANDLE == 1)
    debugonly.id = nAVChannelID;
    debugonly.type = nIOCtrlType;
    debugonly.data = cabIOCtrlData;
    debugonly.data_size = nIOCtrlDataSize;    

    //TmrCfgFnct(AV_SENDIOCTRL_TIMEOUT_TMR_ID, StopSendIOCtrl, (void*)nAVChannelID);
    TmrCfgFnct(AV_SENDIOCTRL_TIMEOUT_TMR_ID, StopSendIOCtrl, (void*)&debugonly);
    TmrSetT(AV_SENDIOCTRL_TIMEOUT_TMR_ID, timeout);
    TmrStart(AV_SENDIOCTRL_TIMEOUT_TMR_ID);
#endif
    ret = avSendIOCtrl(nAVChannelID, nIOCtrlType, cabIOCtrlData, nIOCtrlDataSize);
#if (P2P_IOCMD_TIMEOUT_HANDLE == 1)
    TmrStop(AV_SENDIOCTRL_TIMEOUT_TMR_ID);
#endif
    
    return ret;
}


float my_ui2f(unsigned int value)
{
    if(++my_ui2f_cnt == 2)
        resend_buffering_data_size = value;
    return __aeabi_ui2f(value);
}


void reset_my_ui2f_cnt(void)
{
    my_ui2f_cnt = 0;
}


u32 getResendBufUsage(int avCh, int *buffering)
{
    u32 result;
    INT8U err;
    
    OSSemPend(ResendBufUsageSem, 0, &err);
    reset_my_ui2f_cnt();
    avResendBufUsageRate(avCh);
    if(buffering)
        *buffering = resend_buffering_data_size;
    
    result = (resend_buffering_data_size*120/(TUTK_RESEND_BUF_SIZE*1024));
    OSSemPost(ResendBufUsageSem);
    return result;
}

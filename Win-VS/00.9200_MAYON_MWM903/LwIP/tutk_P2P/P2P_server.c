#include "general.h"
#include "board.h"
#if ((TUTK_SUPPORT) && !ICOMMWIFI_SUPPORT)
#include "TUTKIOTCAPI.h"
#include "TUTKAVAPI.h"
#include "AVFRAMEINFO.h"
#include "AVIOCTRLDEFs.h"
#include "gpiapi.h"
#include "lwipapi.h"
#include "Task.h"
#include "MPEG4api.h"
#include "IISapi.h"
#include "UIapi.h"
#include "rfiuapi.h"
#include "uiKey.h"
#include "sysapi.h"
#include "fsapi.h"
#include "GlobalVariable.h"
#include <../rfiu/inc/rfiu.h>
#include "Dcfapi.h"
#include "timerapi.h"
#include <lwip/sockets.h>
#include "rtcapi.h"
#include "p2pserver_api.h"
#include <../LwIP/netif/ppp/md5.h>
#include "ispapi.h"
#include "../../ui/inc/ui.h"
#include "../../ui/inc/ui_project.h"
#include "encrptyapi.h"
#if HOME_RF_SUPPORT
#include "MR8200def_homeautomation.h"
#include "jsmn.h"
#endif
#include "iduapi.h"

/*
 *********************************************************************************************************
 *  SYS Constant
 *********************************************************************************************************
 */

#define MAX_SIZE_IOCTRL_BUF		1024
#define MAX_BUF_SIZE 5120

#define Local_record   0
#define Local_playback 1
#define RX_receive     2
#define RX_transcoder  3

#define MAX_CLIENT 4
//#if (RFI_TEST_4TX_2RX_PROTOCOL == 1) //4 4T2R
#define MAX_AV_CH 4
#define BUFF_FOR_AUDIO  1024

#define FW_SERVER2	"ota.mars-semi.com.tw" //China Server
#if DOOR_BELL_SUPPORT
#define RDI_PUSHMSG_PREFIX  (1 << 30)
#endif


//Multi-user related
typedef struct _AV_Client
{
    int avIndex[MAX_AV_CH];
    int avChannel;
    int speakerAvIndex;
    unsigned char bEnableVideo;
    unsigned char bEnableAudio;
    unsigned char bShowInfo;
    unsigned char bP2PConnected;
    unsigned char VOLSend;
    unsigned char bEnableSpeaker;
    unsigned char speakerCh;
    unsigned char bPausePlayBack;
    unsigned char bStopPlayBack;
    unsigned char playBackCh;
    //aher 20130801
    unsigned char getsupportstream;
} AV_Client;

typedef struct _AudioIn
{
    int SID;
    int ch;
    int avIndex;
    unsigned long srvType;
    int dspFd;
} AudioIn;


/*
 *********************************************************************************************************
 * Variables
 *********************************************************************************************************
 */

static unsigned char MPEG4_config[0x1d] =
{
    0x00, 0x00, 0x01, 0xB0,
    0x03, 0x00, 0x00, 0x01,
    0xB5, 0x09,
    0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x01, 0x20,
    0x00, 0xc4, 0x88, 0xba,
    0x98, 0x50, 0x00, 0x40,
    0x01, 0x44, 0x3f
};
static unsigned char H264_config[0x18] =
{
    0x00, 0x00, 0x00, 0x01, 0x67,
    0x42, 0x00, 0x1E, 0xDA, 0x01,
    0x40, 0x16, 0xE4, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x01, 0x68,
    0xCE, 0x38, 0x80,
};
static unsigned char MPEG4_NoCam_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x1e,0xda,0x05,0x07,0xe4,0x00,0x00,0x00,0x01,
    0x68,0xce,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x0a,0x7f,0xff,0xe1,0xe8,
    0xa0,0x00,0x67,0xdf,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,
    0x7d,0xf5,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5f,0xfb,0x17,0xa2,0x56,0x14,0xc0,0x09,0x79,0x72,0x03,0xe2,0x5b,0x02,0x33,0x69,
    0xfa,0x71,0x70,0xa4,0x11,0xb1,0xc1,0x2f,0xba,0x3d,0x1a,0x06,0x17,0xf0,0x3e,0x4d,
    0xfa,0xca,0x20,0xa3,0x74,0xbb,0x3b,0x82,0x38,0xdd,0xb4,0x6e,0x7f,0xfd,0xdf,0x29,
    0xbe,0x46,0xf1,0xf0,0xfa,0x06,0x57,0xc8,0x99,0xbd,0xcf,0x00,0x33,0x04,0xdc,0x0f,
    0x18,0x7e,0x80,0xa8,0xf5,0xe9,0x6e,0xdf,0xf4,0x0c,0xf1,0x6c,0x8c,0x7e,0x70,0xa9,
    0xb9,0x28,0x4c,0xae,0x50,0x3a,0xe9,0x2c,0x5e,0x8a,0xf9,0xd7,0x1e,0x73,0xe7,0x91,
    0xc6,0x4a,0x2b,0xbd,0x06,0xfb,0xca,0x23,0x7e,0xf7,0xff,0xd7,0x65,0x84,0xcf,0xc3,
    0x71,0xca,0x66,0x68,0x9f,0x30,0xa5,0xd1,0x33,0x51,0xf0,0xce,0x09,0x16,0xc4,0x95,
    0x3d,0x0d,0x44,0xda,0x46,0x73,0xc1,0x0a,0x56,0xd9,0xa2,0x3b,0xaf,0x37,0x46,0x99,
    0xc5,0x16,0x09,0x75,0x80,0x7f,0xce,0xc0,0x07,0xc9,0x08,0x58,0xfb,0xfc,0x30,0xba,
    0xb9,0xdf,0xeb,0x6f,0xfe,0x2c,0xe6,0x28,0x08,0x2b,0x61,0x71,0xb8,0x03,0x23,0x8b,
    0x3a,0xb0,0xf8,0x61,0x93,0xf3,0x93,0xfe,0xe2,0xb7,0x3e,0x05,0xc5,0xf2,0x7d,0xe0,
    0x40,0xcb,0xeb,0xe1,0x0e,0xb0,0x6b,0xaf,0x07,0x0d,0xf6,0xd1,0xbf,0xe1,0x60,0xda,
    0xf8,0x8b,0x59,0x47,0xb0,0x43,0xff,0x96,0xad,0xb8,0x0a,0x8b,0x6b,0x52,0x9b,0xef,
    0xbe,0x86,0xc7,0xce,0x81,0x7b,0x20,0x54,0x72,0xf2,0xf4,0xec,0x39,0x94,0x99,0xd0,
    0x7f,0xba,0x80,0x9b,0x33,0x60,0xa7,0xdc,0x1b,0xcf,0xa6,0x4e,0xb3,0xf0,0xe8,0x6e,
    0xe8,0xbf,0xbe,0xaa,0xc8,0x3c,0x67,0x8b,0x39,0x4d,0x3b,0x6d,0x2a,0xa4,0xf0,0x27,
    0x82,0xec,0xb5,0xb6,0x1c,0x3e,0xe7,0x9a,0x35,0x56,0xff,0xe5,0xe8,0x29,0xa9,0x68,
    0x32,0x3d,0xe8,0xc9,0x7c,0xff,0xfa,0xd8,0x2b,0x83,0xab,0x47,0xf5,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0xf5,0xdf,0x7d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x78,
};

static unsigned char MPEG4_OutOfRange_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x1e,0xda,0x05,0x07,0xe4,0x00,0x00,0x00,0x01,
    0x68,0xce,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x0a,0x7f,0xff,0xe1,0xe8,
    0xa0,0x00,0x67,0xdf,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,
    0x7d,0xf5,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0xff,0x2f,0xa5,0x61,0x4c,0x02,0x3d,0x7d,0xb4,0x6c,0x18,0xf4,0xac,0xb5,0xc8,0xaf,
    0xc3,0x4b,0x8f,0xae,0xbf,0x11,0x74,0x18,0xa0,0x41,0xec,0xaf,0x71,0xe2,0x43,0xd2,
    0xc0,0x3b,0xda,0x4f,0x36,0xa6,0x1c,0xab,0xb0,0x01,0x9a,0x9c,0xf5,0x1c,0xb9,0x2d,
    0xb0,0x67,0xdb,0x9d,0x0f,0x84,0xd9,0x5b,0x91,0xe6,0x00,0xf0,0x90,0x98,0x55,0x14,
    0xab,0x43,0xcf,0x4f,0x10,0xd0,0xda,0x9a,0x20,0x1a,0x45,0x89,0x4c,0x78,0x7c,0x44,
    0x69,0x6f,0x05,0xfc,0xd4,0xcb,0x38,0xef,0x9d,0x2e,0x4a,0x33,0xb3,0xc4,0x56,0xae,
    0xa6,0xae,0x7e,0x4a,0x43,0xef,0x15,0x93,0x06,0x00,0x00,0xb7,0x85,0x3a,0x27,0x40,
    0x00,0x20,0x12,0xdc,0xc0,0xe2,0x0c,0x95,0x30,0x04,0xc3,0x74,0xfc,0xe1,0x08,0x76,
    0xea,0x4b,0x01,0x9f,0x12,0xff,0x01,0x86,0x6e,0x7a,0xe1,0x03,0x98,0xde,0xeb,0x1f,
    0x4a,0x96,0xf0,0x85,0x3c,0xad,0x79,0xb3,0xf8,0xab,0xa8,0xc5,0x50,0x15,0xc4,0x84,
    0xae,0x03,0x82,0x63,0x92,0x58,0x4b,0xb8,0xd7,0x33,0xe0,0xd4,0x00,0x06,0x6d,0x4c,
    0xf5,0x81,0xc9,0x2d,0xf5,0x0f,0x44,0x54,0x96,0x00,0x63,0x64,0xb7,0xcb,0xbf,0x04,
    0xbe,0x60,0xd3,0x74,0xc1,0x56,0x9c,0x7e,0x0c,0x9d,0xf0,0x9e,0x8f,0x13,0x37,0x53,
    0x3a,0xc1,0xd2,0x3b,0x5b,0xff,0x4e,0x96,0x2d,0xe7,0x94,0x8f,0x9b,0x2d,0x56,0x81,
    0xd2,0x64,0xa2,0x8e,0xfa,0x4f,0xd2,0x85,0x52,0xdf,0xe2,0xb0,0x50,0x28,0x23,0x28,
    0xdc,0x61,0x1e,0x56,0xcf,0xbe,0xb9,0xa5,0x83,0x00,0xc8,0x99,0xa4,0x4c,0x04,0x83,
    0xe7,0xca,0x11,0x4d,0xb7,0xc2,0x31,0xef,0x71,0x8d,0x22,0x30,0xd0,0xc7,0xb1,0x88,
    0x18,0x6d,0x72,0x0f,0x85,0xe8,0x04,0xb7,0x2e,0x1e,0x3e,0xbf,0x57,0xdd,0xb5,0xc1,
    0x32,0x4d,0xc0,0xdd,0xed,0xa5,0xe5,0x19,0x91,0x07,0x73,0xcb,0x4e,0xa6,0x2a,0xb7,
    0x5a,0xf7,0xd3,0xcd,0x70,0x54,0xe6,0xef,0x70,0x08,0xcb,0x4d,0x2a,0xf0,0x3e,0xd9,
    0x10,0xfa,0x3f,0x25,0xb6,0x41,0x9a,0x91,0x2f,0x6e,0x57,0x5b,0xc3,0xf8,0x8d,0xcb,
    0x3d,0xa1,0x08,0x1e,0xe0,0x8f,0x5a,0xf8,0x3a,0xa7,0x2d,0x20,0xdd,0xc9,0x98,0x01,
    0xb6,0x40,0x70,0xfb,0x26,0xf6,0x6b,0x90,0x75,0xee,0x94,0x72,0xc7,0x3e,0x35,0xaf,
    0x7b,0xf2,0xde,0x91,0x50,0xbc,0xc8,0xec,0xa8,0x5c,0x41,0xff,0x1b,0xf9,0xfe,0x06,
    0xa9,0x95,0xc6,0xee,0xaf,0xf5,0xb6,0x2c,0xf8,0xd2,0xa2,0x00,0xfb,0x84,0x47,0xe9,
    0x3f,0xbe,0x56,0xe9,0x69,0xc1,0xf0,0x32,0xe3,0x3f,0xf3,0x66,0x50,0x64,0x37,0x97,
    0x68,0x04,0x53,0x39,0x34,0xff,0xd6,0xd8,0xbd,0xb1,0x33,0x45,0x8a,0x25,0x4f,0x69,
    0x97,0x44,0x46,0x02,0x40,0x67,0x56,0x34,0xa9,0x90,0x6c,0xbb,0x31,0xb7,0xf4,0x19,
    0x0f,0x91,0x29,0x63,0x20,0xa3,0xa6,0x19,0xcc,0xb0,0x0a,0x01,0x04,0x1b,0xa7,0x27,
    0x0f,0xc1,0xd6,0x21,0xe9,0x2f,0xc2,0x70,0x11,0x55,0xb4,0xd2,0x5d,0xaf,0xa1,0xd4,
    0x6d,0xd8,0x5c,0xbe,0xfb,0x2f,0xd9,0x51,0xac,0x33,0xfd,0x3e,0xf6,0xcf,0xdd,0x7d,
    0xc7,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xfd,0xfb,0xf7,0xfb,0xfd,
    0xf7,0xfa,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
    0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
    0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
    0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
    0xc0,0x00,0x00,0x00,
};
#if((UI_VERSION == UI_VERSION_RDI) || (UI_VERSION == UI_VERSION_RDI_2) || (UI_VERSION == UI_VERSION_RDI_3))
static unsigned char MPEG4_OutOfRange_Japan_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xf4,0x0a,0x0f,0xc8,0x00,0x00,0x00,0x01,
    0x68,0xce,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x02,0x13,0x14,0x00,0x04,
    0x37,0xef,0xbe,0xfb,0xef,0xbe,0xfb,0xef,0xbe,0xfb,0xef,0xbe,0xfb,0xef,0xbe,0xfa,
    0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
    0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
    0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
    0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
    0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xbf,
    0x84,0x58,0xf9,0x94,0x77,0x80,0x0a,0xc1,0x2e,0x15,0x2e,0x29,0xa5,0xb8,0xf5,0x7b,
    0xe0,0x0b,0x41,0x1d,0xe0,0x06,0xb4,0x23,0xf0,0xf1,0xb3,0xb5,0x83,0x10,0xbb,0x4d,
    0x33,0x5c,0x5d,0x38,0xdd,0xae,0x06,0x1d,0xcf,0x6c,0x8c,0xb7,0xa3,0x98,0x79,0xbb,
    0x7f,0xf6,0x80,0x82,0x2b,0xfc,0x3b,0x19,0x5f,0x16,0x42,0xf6,0xf6,0xe0,0x00,0xd9,
    0xb2,0x68,0x6d,0xd0,0xa8,0xce,0x9a,0x07,0x85,0x85,0x52,0xcf,0x29,0x74,0x2b,0xeb,
    0xeb,0x40,0xd8,0x17,0xc7,0x2c,0x43,0x12,0xda,0x7b,0xcb,0xdf,0xdf,0x07,0xf1,0x70,
    0x31,0x02,0x4a,0xb1,0xe7,0xb8,0x0b,0x30,0x13,0x8c,0xc4,0xa1,0xbe,0xff,0x2c,0xac,
    0x58,0x98,0x03,0xb8,0x42,0x9e,0x87,0xa5,0xc7,0xab,0xc0,0xc4,0x06,0x98,0x03,0x2d,
    0xcb,0x7d,0x96,0xf5,0x7f,0x06,0x37,0x60,0x46,0x82,0x54,0x15,0x2e,0x29,0xa5,0xb0,
    0xf5,0x7b,0xfc,0x00,0xe2,0x28,0x0c,0x8d,0x1d,0x37,0xd2,0xd4,0xa8,0x88,0xb5,0x80,
    0x8c,0x3e,0x2d,0x1d,0xeb,0x83,0xcf,0x3f,0xfe,0xc0,0xc0,0x10,0xc4,0x61,0x2b,0x9b,
    0xe3,0x2d,0xd1,0xed,0x12,0x80,0x00,0x5f,0xc4,0x10,0x4c,0xb4,0xf3,0x19,0x3b,0x34,
    0x78,0xca,0x98,0x9c,0xae,0xd5,0xdf,0xdf,0xb8,0x91,0x11,0x21,0x20,0xe0,0xc6,0xb9,
    0x67,0xf2,0xd0,0xb9,0x8c,0xff,0x38,0xbc,0xb7,0xd3,0x7f,0xfe,0xfb,0x9b,0x26,0x86,
    0xdd,0x0a,0x8c,0xf8,0x3f,0x70,0x07,0x89,0xc4,0xaa,0x77,0x80,0x0b,0xd1,0x84,0x51,
    0x68,0xa7,0x16,0xd7,0x1b,0xb4,0x08,0x91,0x06,0x41,0x68,0xb7,0x14,0xd7,0x1b,0xb5,
    0xc0,0x87,0x1b,0x9f,0x41,0x04,0x31,0x9e,0x42,0x1b,0x21,0xbf,0xe6,0x80,0x81,0xad,
    0xdc,0x10,0xc3,0x36,0x9f,0xd9,0xba,0x1e,0xe6,0x62,0x5c,0x52,0x76,0x3b,0x10,0xac,
    0x0f,0xa1,0x38,0xe5,0x3a,0x8f,0x10,0x9f,0xa7,0x7f,0xad,0xf9,0xf0,0x00,0x00,0xec,
    0x30,0x00,0x48,0x79,0x16,0x84,0xbd,0xcd,0xe1,0x1c,0xd4,0x03,0xe6,0x7b,0xcd,0xa5,
    0xf1,0x38,0x00,0xb6,0x60,0x0a,0x61,0x0b,0x7a,0x5a,0x87,0x1e,0xaf,0x78,0x18,0x45,
    0x25,0xe9,0x11,0xea,0xca,0x52,0x24,0x41,0x75,0xb8,0x04,0x1b,0x3b,0x85,0x6e,0x0d,
    0xfe,0xbe,0x71,0x2f,0x6f,0xf3,0xcf,0x22,0x15,0xf4,0x84,0x33,0x12,0x0f,0xc0,0x85,
    0x62,0x1e,0x8d,0xef,0xcb,0xbb,0xcd,0xcf,0x00,0xc1,0x58,0x95,0x12,0x9b,0x59,0xaf,
    0xff,0xb6,0x15,0x6a,0x20,0xc8,0x3d,0x16,0xe2,0x9a,0xc3,0x76,0x80,0x00,0x03,0xf5,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x77,0xdf,0xef,0xbf,0xd7,
    0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xe0,
};
static unsigned char MPEG4_OutOfRange_German_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xda,0x05,0x07,0xe4,0x00,0x00,0x00,0x01,
    0x68,0xce,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x11,0xff,0xff,0x87,0xa2,
    0x80,0x00,0x80,0x8f,0xbc,0x56,0xf7,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,
    0x7d,0xf7,0xdf,0x7d,0x62,0xb5,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xad,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0xfe,0x89,0xe2,0x9d,0xf8,0x00,0x20,0x8f,0xc2,0xe7,0x5f,0xba,
    0xb2,0x33,0xc7,0xbc,0x00,0x1e,0x1f,0x0e,0x26,0xb3,0xbb,0x55,0xad,0xfc,0x69,0xff,
    0x9d,0xf8,0xb3,0x40,0x0c,0x44,0xa1,0x62,0x3e,0x9f,0xde,0x60,0x93,0x92,0x3a,0x7f,
    0xff,0xbf,0xbe,0x4c,0x00,0x44,0x4b,0x8e,0xee,0x16,0xf7,0xab,0x61,0x83,0x80,0x32,
    0x01,0x41,0x22,0xab,0xf7,0xb6,0xd1,0x27,0xc3,0xe1,0xa4,0xd3,0xda,0x17,0x00,0x06,
    0xe9,0x93,0x62,0x7c,0x85,0x47,0x64,0xf2,0x43,0x22,0xdf,0x99,0xd7,0xa3,0xe4,0x0c,
    0x3f,0x01,0x18,0xce,0x8f,0x87,0x7d,0x60,0xba,0x5a,0xcf,0x71,0x99,0xe6,0xd9,0x84,
    0x25,0xdc,0xb1,0x1a,0xd6,0x3d,0xcc,0xe2,0x35,0x4d,0x51,0xea,0xf6,0x0e,0x02,0x28,
    0x8a,0x5d,0x52,0xf6,0x46,0xbf,0xde,0xb4,0x61,0xe1,0x1e,0x57,0x23,0x08,0xc2,0x63,
    0x3d,0xfe,0x02,0x46,0x7c,0xef,0xcf,0xc8,0x62,0x1c,0xdb,0xdf,0xff,0xfe,0x01,0x86,
    0xf5,0x6d,0x56,0xa8,0x9e,0x2f,0x1f,0xfa,0x60,0x78,0x68,0x72,0x3d,0x97,0xa9,0x84,
    0xbd,0xef,0xff,0xf5,0x88,0xa9,0x0a,0x3e,0x10,0xde,0xdc,0xc4,0xe7,0xc2,0x29,0xeb,
    0x51,0xbb,0x40,0x43,0x5b,0x65,0x3c,0x6c,0x54,0x6b,0x09,0xe0,0x63,0x28,0x5b,0x36,
    0xdd,0xe5,0xa6,0xbb,0x4d,0x82,0x43,0x15,0xdc,0x31,0x2b,0xc7,0x63,0xff,0xeb,0x08,
    0xe2,0x47,0xda,0xe9,0x4d,0xb5,0x1b,0xb4,0x05,0xf3,0x5c,0x69,0x3b,0xbf,0x7f,0xf8,
    0x4a,0x8c,0x2d,0xc4,0x48,0x96,0xf1,0x6a,0xc7,0xa0,0xf8,0x16,0x1e,0x1e,0x8e,0x6d,
    0xe2,0x61,0x0f,0x7b,0xfe,0x01,0xea,0x8c,0x19,0x11,0x17,0x2b,0x7e,0x5f,0xfb,0xc3,
    0xf3,0x62,0x2a,0x4d,0xdd,0x36,0x56,0xea,0x18,0x7f,0x01,0x37,0x0e,0x14,0x0d,0xfc,
    0x00,0x0a,0x43,0x63,0x81,0xc4,0xf7,0x5e,0x91,0x46,0xba,0x08,0xdc,0x04,0x3a,0xa3,
    0xd7,0xc9,0x51,0xbb,0x40,0x23,0x48,0xd3,0x13,0xe5,0x22,0xab,0x2f,0x92,0x19,0x16,
    0xfc,0xce,0xbd,0x1f,0x6d,0x2a,0x70,0x63,0xfd,0xc1,0x3f,0x53,0xfe,0x83,0x80,0x3b,
    0x11,0x52,0x6e,0xec,0x99,0x5b,0xac,0x30,0xc0,0x02,0xcb,0x05,0x87,0xa3,0x9b,0x7c,
    0x98,0xe8,0xdf,0x7f,0xc6,0x12,0xe1,0x2e,0xfe,0x48,0x64,0x5b,0xf3,0x3a,0xf4,0x7c,
    0x96,0xe6,0x27,0x3e,0x11,0x4f,0x5a,0x8d,0xda,0x0c,0x01,0xd8,0xca,0xb3,0x67,0x60,
    0x95,0x9c,0x11,0x41,0xe0,0x00,0x81,0x07,0xe9,0x30,0x00,0x7d,0x08,0xab,0x3f,0x66,
    0x5c,0x8f,0xd0,0x40,0x00,0x10,0x10,0x00,0x46,0x34,0x06,0x2e,0xa5,0x3f,0xdf,0x9b,
    0x9a,0x8c,0xf7,0x80,0x91,0x97,0x3a,0xd3,0xf2,0x18,0x87,0x32,0x7b,0xff,0xf5,0x34,
    0x69,0x0d,0xaa,0x91,0x59,0xd7,0xc3,0x70,0x27,0x61,0x96,0xb7,0x2c,0xda,0x9b,0x40,
    0x38,0x3e,0xce,0x5e,0x35,0xb2,0x89,0x47,0xfd,0x7f,0xe2,0xd5,0x88,0x02,0x05,0xf0,
    0xbd,0x84,0x71,0x23,0xed,0x74,0xa7,0xda,0x8d,0xda,0x07,0x66,0x27,0x3e,0x11,0x4f,
    0x5b,0xbb,0xe7,0xec,0x84,0x42,0xdc,0xe0,0x51,0x72,0x84,0x33,0xfd,0xd8,0x4f,0x03,
    0x19,0x42,0xd9,0xb6,0xef,0x2d,0x35,0xc0,0x43,0x5b,0x65,0x3c,0x6c,0x54,0x69,0xc0,
    0x00,0x4e,0xc3,0xad,0x5c,0xa4,0x1d,0x5a,0x6c,0x12,0x18,0xae,0xe1,0x89,0x5e,0x3b,
    0x1f,0xff,0x07,0xe6,0xc4,0x54,0x9b,0xbb,0x26,0x56,0xaf,0x81,0x60,0xb0,0xf4,0x73,
    0x6f,0x13,0x08,0x7b,0xdf,0x87,0xfc,0x03,0xd5,0x18,0x32,0x22,0x2e,0x56,0x4e,0x5f,
    0xfb,0xcd,0x88,0xa9,0x37,0x76,0x4c,0xad,0xd4,0x30,0xf5,0x1f,0x44,0xe1,0x00,0xb8,
    0x08,0x9a,0x34,0x0d,0xdb,0xa9,0x02,0x1f,0xe4,0x6d,0xcd,0x71,0xa4,0xee,0xfd,0xfe,
    0x60,0x00,0x40,0x83,0xb6,0x99,0xe6,0xc6,0x55,0x9b,0x3b,0xae,0x46,0xca,0x07,0xcc,
    0x4e,0x70,0xc2,0x39,0xaf,0xa4,0x51,0xae,0x10,0x09,0x9c,0x75,0x29,0xe6,0x8a,0xbe,
    0x6c,0x65,0x59,0xb3,0xb0,0x4a,0xce,0x08,0xae,0x91,0xb1,0xea,0x28,0xbc,0xa7,0x49,
    0x57,0xee,0xd1,0x87,0x84,0x79,0x5c,0x8c,0x23,0x09,0x8c,0xf7,0xfa,0x80,0x43,0x57,
    0xd2,0xfe,0xe5,0x6a,0x7f,0xd7,0xd7,0xff,0xd4,0xd1,0xa4,0x36,0xaa,0x45,0x67,0x5f,
    0x36,0x22,0xa4,0xdd,0xd9,0x32,0xb5,0x70,0xc3,0x85,0x07,0x6b,0x26,0xc3,0xdf,0xc0,
    0x01,0xba,0x64,0xd8,0x9f,0x21,0x51,0xd9,0x00,0x91,0xb0,0x1d,0x7f,0x31,0x3c,0x2b,
    0xb1,0x65,0x2b,0xff,0xa4,0x01,0x18,0xba,0xf7,0x89,0xc5,0x97,0x11,0xd5,0x9e,0x48,
    0x64,0x5b,0xf3,0x3a,0xf4,0x7c,0x86,0x00,0x02,0x04,0x1e,0xc4,0xb6,0x86,0x57,0x55,
    0xea,0x3a,0x4c,0x2f,0x11,0x1f,0xbe,0x30,0x00,0x0f,0x01,0x5e,0x00,0xb9,0x6d,0x0a,
    0x03,0x21,0x1d,0xd2,0x9a,0x94,0x5e,0xfd,0x50,0x98,0x2c,0x3c,0x22,0xf6,0x61,0xff,
    0xde,0x5f,0xfc,0x54,0x1d,0x32,0x33,0x81,0x22,0x99,0xeb,0xfc,0x40,0x00,0x1e,0x02,
    0xbd,0xa8,0x7c,0x64,0x07,0x18,0x40,0x0b,0xdc,0x07,0x82,0x61,0xfd,0x4a,0x78,0xe3,
    0x72,0x0a,0x85,0xce,0xcf,0xb9,0x84,0x78,0xb3,0x7f,0xf6,0xc0,0x93,0x4a,0x9a,0x04,
    0x90,0x44,0x2e,0x94,0xa4,0x18,0x00,0x07,0x40,0x8c,0x12,0x98,0x05,0x32,0x86,0xa4,
    0x5e,0xd1,0x5f,0xfd,0x87,0x80,0x02,0x04,0x1e,0xc4,0xb1,0x80,0x00,0x81,0x07,0x88,
    0xa6,0x0f,0x00,0x03,0xc0,0x57,0x80,0x2e,0x5b,0x03,0xf4,0xe2,0xda,0xb2,0x2d,0x6a,
    0x63,0xdd,0xff,0xdc,0x99,0xb4,0x26,0xca,0x55,0x66,0x5f,0x0f,0x4c,0xd8,0x02,0x25,
    0x0c,0xb7,0x3d,0x32,0x9c,0xd1,0x00,0x00,0x78,0x0a,0xf6,0xbf,0xc2,0x9f,0xff,0x84,
    0xfc,0x00,0xf2,0x1a,0xa2,0x2d,0x10,0x8e,0xd5,0x77,0x7f,0xff,0xf3,0x1f,0x8a,0x57,
    0x7d,0x93,0x2e,0x65,0x0c,0x3a,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xbe,0xfa,0xeb,
    0xbe,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
    0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
    0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
    0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
    0xae,0xbc,
};
static unsigned char MPEG4_OutOfRange_French_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xDA,0x05,0x07,0xE4,0x00,0x00,0x00,0x01,
    0x68,0xCE,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x11,0xFF,0xFF,0x87,0xA2,
    0x80,0x00,0x80,0x8F,0xBC,0x56,0xF7,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,
    0x7D,0xF7,0xDF,0x7D,0x62,0xB5,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAD,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0xFF,0x0F,0xE1,0x0A,0x60,0x38,0x00,0x20,0x41,0xEC,0x26,0x78,
    0x00,0x36,0x4C,0xDA,0x13,0x65,0x2A,0xB3,0x2C,0x38,0x78,0x08,0xF0,0x41,0xEF,0x80,
    0xE0,0x00,0x78,0x0A,0xF1,0x09,0x80,0x38,0x00,0x1F,0x02,0xB8,0x44,0xB0,0x22,0x58,
    0x18,0xEB,0xBE,0x5F,0x29,0x46,0xED,0x00,0x0C,0xDA,0x24,0xC6,0xFD,0x08,0x8E,0xE9,
    0xEE,0x4C,0xDC,0x26,0xCA,0x55,0x46,0x53,0x00,0x00,0xF0,0x15,0xEA,0x4C,0x30,0x00,
    0x10,0x20,0xFD,0xA6,0x06,0x00,0xCC,0x64,0x4B,0xB3,0xBA,0x75,0x6C,0xB0,0xF0,0x19,
    0x0D,0x56,0x21,0xCC,0x78,0xB1,0xEF,0xF9,0xE1,0x1F,0x95,0x04,0x4F,0xBA,0xF0,0xB8,
    0x67,0xD7,0x87,0xC0,0x60,0x3C,0x00,0x53,0xBF,0x9A,0x11,0x56,0x5E,0xCC,0xB9,0x17,
    0xEB,0x5A,0x1B,0x9B,0x8A,0xA7,0xA9,0x46,0xED,0x7B,0x9B,0x26,0x86,0xD7,0x15,0x19,
    0xDA,0xD6,0x3D,0xCC,0xE6,0x15,0x4F,0x3C,0xF5,0x78,0x78,0x00,0x20,0x41,0xAB,0x4B,
    0x70,0x02,0xD4,0x13,0x8F,0xE3,0xC0,0x90,0xEC,0x7A,0x40,0x22,0x48,0x92,0x13,0x64,
    0x22,0x33,0x27,0x93,0x19,0x12,0xEC,0xEA,0x9D,0x5B,0x2F,0x90,0xF5,0x52,0x3B,0x6E,
    0x9D,0x72,0xA0,0x61,0x98,0x00,0x07,0x80,0xAF,0x5C,0xB5,0x9B,0x9F,0x41,0x18,0x47,
    0x6F,0xEF,0xD7,0xFD,0x8B,0x8C,0xBA,0x06,0xF0,0x00,0x6C,0x99,0xB0,0x6C,0xD9,0x4A,
    0x10,0xFE,0x22,0xF9,0xD8,0x31,0x92,0xC9,0xDD,0x7E,0xF6,0xB6,0x17,0x8E,0x8B,0x00,
    0xB0,0x91,0x3D,0x30,0x00,0x20,0x41,0xCC,0x26,0x00,0x0C,0x9A,0x34,0x0D,0xDB,0xA9,
    0x02,0x1F,0xE4,0x07,0xE6,0x3D,0x10,0xA0,0xDD,0x4A,0x22,0x89,0x59,0xD9,0xCB,0x7A,
    0x71,0x31,0x3D,0x42,0xB6,0x80,0x08,0xF6,0x53,0xB9,0x22,0x6E,0x1F,0x87,0x38,0x7E,
    0x02,0x26,0x8D,0x21,0xB7,0x52,0x2B,0x3A,0xE8,0xC3,0xC2,0x3C,0xAE,0x46,0x11,0x84,
    0xC5,0x7B,0xFC,0x1F,0xD7,0xD7,0xF0,0x66,0x2B,0xED,0xCD,0x71,0xA4,0xEE,0xFD,0xFF,
    0xF8,0x48,0x19,0x8C,0x73,0x87,0x5A,0xE8,0xA8,0xEF,0xDE,0x00,0x09,0xB1,0x15,0x21,
    0xFB,0xB2,0x60,0x87,0xD9,0x1D,0x73,0x5C,0x69,0x3B,0xAF,0xDE,0x6C,0x65,0x59,0xB3,
    0xB0,0x4A,0xCE,0x08,0xA9,0x80,0x00,0x7C,0x0A,0xE5,0x26,0x50,0x08,0x6A,0xFA,0x5F,
    0xDC,0xAD,0x4F,0xFA,0xFA,0xFF,0xFC,0x04,0xD9,0xD0,0x3F,0x75,0xCE,0xA0,0x9B,0xF2,
    0x30,0x11,0x0F,0x52,0x29,0xCE,0x7A,0xB1,0xEF,0xF9,0xCF,0x5B,0x79,0x21,0x35,0x42,
    0x26,0x0F,0x5E,0x3A,0x3E,0x10,0xDF,0xD4,0xD1,0xA0,0x6E,0xDD,0x48,0x10,0xFF,0x23,
    0x6E,0x6B,0x8D,0x27,0x77,0xEF,0xF3,0x00,0x02,0x04,0x1D,0xB4,0xC3,0x00,0x00,0xF8,
    0x15,0xCA,0x4C,0x04,0x11,0xC4,0x8F,0xB5,0xD2,0x9F,0x6A,0x37,0x68,0x2C,0x00,0x13,
    0x30,0xCB,0x5C,0xFA,0x8C,0xB7,0x93,0x11,0x16,0xEE,0xE0,0xE3,0xE7,0x4B,0x6A,0x86,
    0x00,0x01,0xE0,0x2B,0xCE,0x4C,0xD1,0x87,0x84,0x79,0x5C,0x8C,0x23,0x09,0x8C,0xF7,
    0xFB,0x80,0x9A,0x85,0xBC,0xC8,0x5A,0xED,0x1A,0xCB,0xFF,0xF7,0x87,0xE6,0xC4,0x54,
    0x9B,0xBA,0x6C,0xAD,0x56,0xC9,0x82,0x39,0x8C,0x73,0x98,0xFB,0xFE,0xFB,0x87,0xF1,
    0x11,0x85,0x80,0x61,0x41,0xEE,0x20,0x13,0x38,0xEA,0x53,0xCD,0x15,0x40,0xD0,0xDD,
    0xCE,0x15,0x75,0x5B,0xA4,0x15,0x8F,0xFF,0x50,0x03,0x8B,0x45,0x2B,0x37,0x03,0x13,
    0x5B,0x67,0xE5,0xAC,0x7A,0x99,0xCC,0x2A,0x1E,0xA3,0xD5,0xEF,0x01,0xC0,0x01,0x02,
    0x0F,0x62,0x58,0x32,0x76,0x0C,0x64,0xB3,0x77,0x7D,0x18,0x00,0x07,0x01,0xDE,0x00,
    0x99,0x6B,0x30,0x04,0x22,0xE1,0x45,0xBB,0xD7,0x5E,0x7B,0xFA,0xF7,0x00,0x8F,0x65,
    0x3F,0x93,0x80,0x7D,0xB0,0xEF,0xFD,0x5F,0xA6,0x09,0xF7,0xA6,0x1E,0x37,0x88,0x00,
    0x03,0xC0,0x57,0xB5,0xFF,0xA7,0xDB,0xFC,0x27,0xE0,0x07,0x90,0xD5,0x11,0x68,0x84,
    0x76,0xAB,0xBB,0xFF,0xFF,0x98,0xFC,0x52,0xBB,0xEC,0x99,0x73,0x20,0x61,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xDF,0x7D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5E,
};
static unsigned char MPEG4_OutOfRange_Italy_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xDA,0x05,0x07,0xE4,0x00,0x00,0x00,0x01,
    0x68,0xCE,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x11,0xFF,0xFF,0x87,0xA2,
    0x80,0x00,0x80,0x8F,0xBC,0x56,0xF7,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,
    0x7D,0xF7,0xDF,0x7D,0x62,0xB5,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAD,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0xFF,0x0F,0xE1,0x0A,0x60,0x38,0x00,0x20,0x41,0xEC,0x26,0x78,
    0x00,0x36,0x4C,0xDA,0x13,0x65,0x2A,0xB3,0x2C,0x3D,0xEF,0x87,0xD2,0x18,0xA8,0x38,
    0x00,0x40,0x83,0x99,0x96,0x00,0x23,0xBD,0x22,0xDE,0x26,0x22,0x34,0x0E,0x00,0x07,
    0xC0,0xAE,0x11,0x2D,0x83,0x6F,0x63,0xFA,0x21,0xCE,0x57,0xEF,0xDB,0xDE,0x99,0x36,
    0x27,0xC8,0x54,0x76,0x4F,0x24,0x32,0x2D,0xF9,0x9D,0x7A,0x3E,0x40,0xC3,0x00,0x0B,
    0x61,0xE1,0x1E,0x57,0x23,0x08,0xE2,0x63,0x3D,0xFE,0x02,0x46,0x7C,0xEF,0xCF,0xC8,
    0x62,0x1C,0xDB,0xDF,0xFF,0xFC,0x54,0x75,0xD1,0xC2,0x10,0x0B,0xFA,0x9A,0x34,0x0D,
    0xDB,0xA9,0x02,0x1B,0xE4,0x6D,0xCD,0x71,0xA4,0xEE,0xFD,0xFE,0x60,0x00,0x40,0x83,
    0xB6,0x98,0x60,0x00,0x1F,0x02,0xB9,0x49,0x80,0x82,0x38,0x91,0xF6,0xBA,0x53,0xED,
    0x46,0xED,0x00,0xF8,0x05,0xDE,0xF5,0x0D,0xF6,0xC9,0xB6,0x7E,0xF2,0x62,0x22,0xDD,
    0xDC,0x1C,0x7C,0xE9,0x6D,0x50,0x80,0x00,0x3C,0x05,0x7A,0x67,0x46,0x1E,0x11,0xE5,
    0x72,0x30,0x8C,0x26,0x33,0xDF,0xEE,0x02,0x6A,0x16,0xF3,0x29,0x6B,0xB4,0x6B,0x2F,
    0xFF,0xDD,0x87,0xE6,0xC4,0x54,0x9B,0xBA,0x6C,0xAD,0x57,0xC9,0x8C,0x89,0x76,0x77,
    0x4E,0xAD,0x94,0x30,0xFE,0xE0,0xA3,0x48,0x00,0xF7,0x0C,0x00,0x19,0xB4,0x49,0x8D,
    0xFA,0x11,0x1D,0xD3,0x30,0x00,0x0F,0x01,0x5E,0xA4,0xCE,0x59,0x63,0x59,0x42,0x88,
    0xDF,0x92,0xAA,0x37,0xAD,0xA2,0x4C,0x6F,0xD0,0x88,0xEE,0x9E,0x4D,0x0A,0xAC,0x2D,
    0x50,0xD1,0x25,0x9F,0x16,0x13,0xE1,0x21,0x6F,0xAA,0x52,0xC0,0x93,0xFD,0x6C,0x18,
    0x02,0xC6,0x43,0x55,0x88,0x73,0x1E,0x2C,0x7B,0xFE,0x7F,0x00,0x19,0xA0,0x8A,0xAC,
    0x49,0x62,0x65,0xED,0x3C,0xDE,0x0C,0xD8,0x26,0xFD,0x73,0xD5,0xB3,0xBC,0xF1,0xFE,
    0x1C,0x1D,0xC0,0x38,0x61,0xC2,0xFE,0xE4,0xCD,0xC2,0x6C,0xA5,0x54,0x65,0x30,0x00,
    0x10,0x20,0xD5,0x13,0x34,0x8D,0xC2,0x06,0x25,0x24,0x4B,0xCC,0x4A,0xFB,0xC1,0xE0,
    0x38,0x00,0x20,0x41,0xEC,0x26,0x7C,0x00,0x66,0x82,0x2A,0xB9,0x25,0x89,0x97,0x30,
    0xF3,0x00,0x99,0x33,0x68,0x4D,0x94,0xAA,0xC8,0xBE,0x18,0x60,0x00,0xD9,0x33,0x68,
    0x4D,0x94,0xAA,0xCC,0xB0,0xFF,0x88,0xE1,0xFB,0x80,0xB0,0x00,0x9D,0xC6,0x5A,0xBD,
    0x48,0x3A,0x80,0x1D,0x08,0xAB,0x3F,0x66,0x5C,0x8F,0xD3,0xFD,0xCD,0x93,0x43,0x6A,
    0x85,0x46,0x74,0xF7,0x26,0x6C,0x1B,0x36,0x52,0x84,0x3F,0x88,0xF5,0x34,0x68,0x1B,
    0xB7,0x52,0x04,0x3F,0xC8,0x30,0x00,0x10,0x20,0xF5,0xD3,0x3D,0x49,0x12,0x42,0x6C,
    0x84,0x46,0x60,0x00,0x10,0x15,0xF2,0x63,0x22,0x5D,0x9D,0x53,0xAB,0x65,0xF2,0x63,
    0x22,0x5D,0x9D,0xD3,0xAB,0x65,0x0C,0x3F,0x72,0x66,0xD0,0x9B,0x29,0x55,0x99,0x43,
    0x0F,0x1C,0x0E,0x3F,0x2F,0x76,0x01,0x30,0xFE,0xA5,0x3C,0x71,0xB9,0x05,0x42,0xE7,
    0x67,0xDC,0xC2,0x3C,0x59,0xBF,0xFB,0x62,0x00,0x00,0x80,0x80,0x02,0x30,0x3C,0x00,
    0x0E,0x81,0x18,0x25,0x30,0x0A,0x65,0x0D,0x48,0xBD,0xA2,0xBF,0xFB,0x0F,0x00,0x04,
    0x08,0x3D,0x89,0x63,0x00,0x01,0x02,0x0F,0x11,0x4C,0x1E,0x00,0x07,0x80,0xAF,0x00,
    0x5C,0xB0,0x02,0x02,0x76,0x19,0x6B,0x72,0xCD,0xA9,0x80,0x4C,0x99,0xB4,0x26,0xCA,
    0x55,0x66,0x5F,0x0F,0x4C,0xD8,0x02,0x25,0x0C,0xB7,0x3D,0x32,0x9C,0xD1,0x00,0x00,
    0x78,0x0A,0xF6,0xBF,0xC2,0x9F,0xC3,0xF0,0x9F,0x80,0x1E,0x43,0x54,0x45,0xA2,0x11,
    0xDA,0xAE,0xEF,0xFF,0xFE,0x63,0xF1,0x4A,0xEF,0xB2,0x65,0xCC,0xA1,0x87,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0xF7,0xDF,0x5D,0xF7,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x78,
};
static unsigned char MPEG4_OutOfRange_Netherland_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xDA,0x05,0x07,0xE4,0x00,0x00,0x00,0x01,
    0x68,0xCE,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x11,0xFF,0xFF,0x87,0xA2,
    0x80,0x00,0x80,0x8F,0xBC,0x56,0xF7,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,
    0x7D,0xF7,0xDF,0x7D,0x62,0xB5,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAD,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5F,0xC0,0x50,0x03,0x80,0x0F,0x78,0x00,0x14,0x86,0xC7,0x03,
    0x89,0xEE,0xBD,0x22,0x8D,0x74,0x11,0xB8,0x08,0x75,0x47,0xAF,0x92,0xA3,0x76,0xBC,
    0x00,0x3A,0x3F,0x9C,0xE2,0xE1,0x55,0x09,0xC2,0x3A,0x01,0x33,0x64,0xE1,0xB7,0x42,
    0xA3,0x3A,0x5A,0x87,0xB1,0xD4,0xA2,0xAD,0xEB,0x3D,0x5E,0x81,0x3A,0x06,0x87,0x0D,
    0xDE,0xAC,0x51,0x2F,0xC7,0xFF,0xBE,0x18,0x90,0x5C,0x18,0x42,0xDB,0x2E,0x97,0x87,
    0x13,0x88,0xE1,0x80,0x5F,0xC0,0x01,0xBB,0x60,0x17,0xEE,0xFC,0x22,0x48,0xFF,0x23,
    0xCF,0x14,0xCB,0x61,0x73,0xB3,0xEE,0x61,0x1E,0x2C,0xDF,0xFD,0xB0,0x29,0x94,0x35,
    0x22,0xF6,0x8A,0xFF,0xEC,0x60,0x00,0x1D,0x02,0x30,0xF4,0xC3,0x00,0x01,0x02,0x0F,
    0x11,0x4C,0x00,0xF0,0x23,0xD9,0x4E,0xE4,0x89,0xB8,0x7E,0x1C,0xE1,0xE1,0x3B,0x0C,
    0xB5,0xB9,0x66,0xD4,0xDF,0xE0,0x26,0x4C,0xDA,0x13,0x65,0x2A,0xB3,0x2E,0xBD,0x30,
    0x04,0x63,0x9B,0x1C,0x15,0x74,0x2B,0xDF,0xF8,0x7F,0xF1,0x02,0x88,0x43,0x00,0xB8,
    0xF0,0x00,0x40,0x83,0xD8,0x96,0x00,0x19,0xB4,0x49,0x8D,0xFA,0x11,0x1D,0xD4,0x78,
    0x00,0x1E,0x02,0xBC,0x01,0x72,0xDE,0xA6,0x8D,0x21,0xB7,0x00,0x32,0x37,0xBC,0x8F,
    0x53,0x46,0xA1,0xB7,0x52,0x2A,0x3A,0x87,0xEA,0x44,0x09,0x20,0x42,0x23,0x2B,0x1E,
    0xF1,0xE6,0x00,0x04,0x08,0x39,0x84,0xC2,0x00,0x00,0xF0,0x15,0xED,0x6C,0x3F,0x4E,
    0x2D,0xAB,0x2D,0x6A,0x61,0xEF,0xEB,0xFF,0x0C,0x00,0x64,0xD1,0xA4,0x36,0xEA,0x45,
    0x67,0x58,0x7E,0x2B,0xFD,0xD0,0x37,0x80,0x01,0xCC,0x4E,0x70,0xC2,0x39,0xAF,0xA4,
    0x51,0xAE,0xC0,0x1D,0x8C,0xAB,0x36,0x76,0x09,0x59,0xC1,0x15,0x02,0xF9,0xAE,0x34,
    0x9D,0xDF,0xBF,0xC0,0x44,0xD1,0xA0,0x6E,0xDD,0x48,0x10,0xFF,0x20,0xC0,0x00,0x3E,
    0x05,0x72,0x93,0x3C,0xC7,0xA2,0x14,0x1B,0xA9,0x44,0x51,0x2B,0x3B,0x03,0xC0,0x04,
    0x6A,0x2A,0xAB,0x56,0x50,0x99,0x7F,0x4F,0x37,0xFC,0x09,0xA8,0x5B,0xCC,0xA5,0xAE,
    0xD1,0x1A,0xCB,0xD1,0x87,0x84,0x79,0x5C,0x8C,0x23,0x09,0x8C,0xF7,0xF8,0x3F,0xAF,
    0x8A,0xE1,0x04,0xF7,0xDB,0x9A,0xE3,0x49,0xDD,0xFB,0xFC,0x01,0xD8,0x8A,0x90,0xFD,
    0xD9,0x30,0x43,0xEC,0x8C,0x24,0x0C,0xC6,0x39,0xC3,0xAD,0x74,0x54,0x77,0xEF,0x36,
    0x32,0xAC,0xD9,0xD8,0x25,0x67,0x04,0x57,0xD6,0xD1,0x26,0x37,0xE8,0x44,0x77,0x5F,
    0x72,0x66,0xE1,0x36,0x52,0xAA,0x32,0xE9,0xAA,0x60,0x32,0x70,0x31,0x36,0xF3,0x59,
    0xFE,0xD6,0xB1,0xE3,0x39,0x85,0x94,0x3D,0x47,0xA2,0x80,0x43,0x57,0xD2,0xFE,0xE5,
    0x6A,0x7F,0xD7,0xD7,0xD4,0xD1,0xA4,0x36,0xAA,0x45,0x67,0x5F,0x0F,0x01,0x90,0xD5,
    0x62,0x1C,0xC7,0xCB,0x1E,0xFF,0x90,0x01,0x1E,0xCA,0x6F,0x26,0xF8,0x3F,0x0E,0x7F,
    0xFE,0x18,0x16,0x41,0x4F,0x78,0x00,0x02,0x78,0xE3,0x2D,0x5E,0x83,0x5D,0x43,0xC0,
    0x00,0xF8,0x15,0xC7,0x26,0x06,0x00,0x71,0x98,0xCE,0x77,0xDB,0x62,0x1C,0xE6,0xFF,
    0xD0,0x00,0xFA,0x11,0x56,0x7E,0xCC,0xB9,0x1F,0xA0,0x7A,0x03,0x17,0x52,0x9F,0xEF,
    0xCD,0xCD,0x46,0x7B,0xDE,0x00,0xCC,0x64,0x4B,0xB3,0xBA,0x75,0x6C,0xBC,0xC4,0x59,
    0x25,0x50,0x72,0x7B,0x7E,0xCD,0x83,0x0F,0x80,0x2A,0xE3,0xA6,0xA9,0xBB,0xB3,0xBD,
    0x3B,0xE0,0xC3,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,
    0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,
    0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,
    0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,
    0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,
    0xBA,0xF0,
};
static unsigned char MPEG4_OutOfRange_Spanish_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xDA,0x05,0x07,0xE4,0x00,0x00,0x00,0x01,
    0x68,0xCE,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x11,0xFF,0xFF,0x87,0xA2,
    0x80,0x00,0x80,0x8F,0xBC,0x56,0xF7,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,
    0x7D,0xF7,0xDF,0x7D,0x62,0xB5,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAD,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0xFF,0x0F,0xE1,0x0A,0x60,0x00,0x52,0x1B,0x1C,0x0E,0x27,0xBA,
    0xF4,0x8A,0x35,0xD0,0x46,0xE0,0x21,0xD5,0x1E,0xBE,0x4A,0x8D,0xDA,0x80,0x3B,0x11,
    0x52,0x6E,0xEC,0x99,0x5B,0xAC,0x38,0x98,0x00,0x84,0x45,0x3E,0x17,0xF0,0x00,0xBC,
    0x90,0x6B,0x2E,0x4B,0x48,0x53,0xFF,0xBC,0x00,0xE2,0xF1,0x0A,0x8F,0xF2,0xE4,0xEC,
    0xA3,0x2B,0x80,0x8D,0xA2,0x4C,0x6F,0xD0,0x99,0xDF,0x06,0x18,0x0E,0x00,0x08,0x10,
    0x7A,0xE9,0x81,0x80,0x07,0x8C,0x86,0xAB,0x10,0xE6,0x3C,0x58,0xF7,0xFC,0xF8,0x1A,
    0x03,0x34,0x11,0x55,0x8B,0x2C,0x4C,0xB9,0xC7,0x9A,0xD6,0x3D,0xCC,0xC7,0x15,0x4E,
    0x59,0xEA,0xF7,0xF8,0x43,0x00,0x04,0x80,0x83,0x44,0xDA,0x1B,0x2D,0x65,0x0D,0x4B,
    0x9D,0x03,0x80,0x02,0x04,0x1F,0x2C,0x00,0x86,0xD1,0x26,0x37,0xE8,0x44,0x77,0x20,
    0x00,0x0F,0x01,0x5F,0x2F,0x94,0xD1,0xA4,0x36,0xE0,0x06,0x46,0xF7,0xB0,0x13,0xB8,
    0xCB,0x53,0xC6,0xD4,0xC0,0x84,0xD1,0xA0,0x6E,0xDD,0x48,0x10,0xFF,0xE5,0x24,0x49,
    0x09,0xB2,0x11,0x19,0xA4,0x00,0xB3,0x98,0xE3,0x1C,0xE5,0x7B,0xFD,0xFA,0x90,0x00,
    0x07,0x80,0xAF,0x97,0x81,0xFA,0x71,0x6D,0x5E,0x22,0x7B,0xD7,0xF7,0xBF,0x0C,0x09,
    0x33,0xE2,0x20,0xA5,0x73,0xAB,0x0A,0x27,0x9F,0xFF,0x7E,0xB7,0xD6,0xA1,0x0A,0x38,
    0x6F,0xB7,0x35,0xC6,0x93,0xBB,0xF7,0xFF,0xF0,0x97,0xB0,0x89,0x80,0xE4,0xC4,0x12,
    0x67,0x7F,0x83,0x00,0x15,0x98,0x9C,0xF8,0x45,0x3D,0x6A,0x37,0x68,0x07,0xE6,0xB8,
    0xC0,0x00,0x40,0x08,0x3D,0xC4,0xAC,0x47,0xE2,0x00,0x00,0xF8,0x15,0xC9,0x9F,0x36,
    0x19,0x6F,0xDE,0x81,0x06,0xDA,0x1F,0x8C,0xB4,0x19,0xF3,0xBF,0x3F,0x21,0x88,0x73,
    0x4F,0x7F,0xFF,0xF0,0x03,0x96,0x1E,0x1E,0x8E,0x6D,0xE2,0x61,0x11,0xBE,0xE0,0x01,
    0x35,0x8D,0x13,0x1C,0x21,0x2B,0xB9,0xCF,0xFE,0xF0,0xF5,0x8E,0x14,0x7F,0xEF,0x6E,
    0x62,0x73,0xE1,0x14,0xF5,0xA8,0xDD,0xA0,0x21,0xAD,0xB2,0x9E,0x36,0x2A,0x35,0x84,
    0xF0,0x31,0x94,0x2D,0x9B,0x6E,0xF2,0xD3,0x5D,0xA6,0xC1,0x21,0x8A,0xEE,0x18,0x95,
    0xE3,0xB1,0xFF,0xF0,0x60,0x00,0x9A,0x11,0x56,0x7E,0xCC,0xB9,0x1F,0xA7,0xFB,0x9B,
    0x26,0x86,0xD5,0x0A,0x8C,0xE9,0x81,0x61,0xE1,0xE8,0xE6,0xDE,0x26,0x10,0xF7,0xBF,
    0xE0,0x1E,0xA8,0xC1,0x91,0x11,0x72,0xB7,0xE5,0xFF,0xBC,0x30,0xFC,0x98,0xC8,0x97,
    0x67,0x74,0xEA,0xD9,0x61,0xF7,0x58,0xD5,0x88,0x21,0x85,0xED,0x68,0x6E,0x6E,0x2A,
    0x9E,0xA5,0x1B,0xB4,0x3C,0x00,0x10,0x20,0xF5,0xA5,0xBA,0xB6,0x86,0x74,0xF8,0x78,
    0x85,0xC7,0xEE,0x0C,0xAD,0xD9,0x46,0x22,0xE6,0xD6,0x09,0xD7,0x7F,0xE0,0x01,0x9B,
    0x44,0x98,0xDF,0xA1,0x11,0xDD,0x7D,0x4D,0x1A,0x86,0xDD,0x48,0xA8,0xEA,0x20,0x00,
    0x08,0x08,0x01,0x18,0xE2,0x22,0x88,0x89,0x24,0x41,0x0D,0x00,0x07,0xDC,0x9D,0xC4,
    0xDA,0x19,0x05,0x87,0x7F,0xFF,0xE9,0x00,0x8F,0x65,0x3B,0x92,0x26,0xFB,0x1C,0x5C,
    0xE0,0x7F,0x0F,0x09,0xD8,0x65,0xAD,0xCD,0x36,0xA6,0x0F,0xF0,0xC5,0x60,0x34,0x0D,
    0x18,0xAE,0x18,0x00,0x32,0x68,0xD0,0x37,0x6E,0xA4,0x08,0x7F,0x90,0x60,0x00,0x40,
    0x83,0x98,0x4C,0x30,0x00,0x20,0x41,0xDB,0x4C,0x92,0x86,0x47,0x23,0xBC,0xA3,0xFE,
    0xFE,0x80,0x89,0xA3,0x40,0xDD,0xBA,0x90,0x21,0xFE,0x40,0x08,0x92,0x24,0x84,0xD9,
    0x08,0x8C,0x88,0x60,0x00,0x40,0x83,0xB6,0x98,0x00,0x32,0x68,0xD2,0x1B,0x75,0x22,
    0xB3,0xAE,0x8C,0x3C,0x23,0xCA,0xE4,0x61,0x18,0x4C,0x67,0xBF,0xC1,0x81,0xA4,0x66,
    0x86,0x10,0xB7,0x55,0x2C,0xA1,0x0F,0xFF,0xFB,0xBC,0xC7,0xE2,0x95,0xDF,0x44,0xCB,
    0x99,0x34,0x61,0xE1,0x1E,0x57,0x23,0x08,0xC2,0x63,0x3D,0xFE,0xD0,0x67,0x7A,0x57,
    0xF7,0xAE,0xDF,0xFF,0xB8,0x1E,0xBF,0xDB,0xFC,0x27,0xDB,0x9A,0xE3,0x49,0xDD,0xFB,
    0xFF,0xCC,0x00,0x03,0xE0,0x57,0x29,0x33,0xC0,0x44,0x3D,0x48,0xA7,0x39,0xEA,0xC7,
    0xBF,0xE7,0xFD,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x77,0xDF,0x7D,0xF5,
    0xDF,0x7D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xE0,
};
static unsigned char MPEG4_NoCam_Japan_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xf4,0x0a,0x0f,0xc8,0x00,0x00,0x00,0x01,
    0x68,0xce,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x02,0x13,0x14,0x00,0x04,
    0x37,0xef,0xbe,0xfb,0xef,0xbe,0xfb,0xef,0xbe,0xfb,0xef,0xbe,0xfb,0xef,0xbe,0xfa,
    0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
    0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
    0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
    0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
    0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xbf,0xff,0xe3,0xc2,
    0x9e,0x00,0x0c,0xd9,0x09,0x39,0x4b,0xd8,0xcc,0x52,0xb4,0x38,0x00,0x22,0x0f,0x57,
    0x31,0x49,0xbb,0x2b,0xe2,0xb6,0x37,0x5b,0x9a,0x10,0x8b,0x03,0x35,0xc0,0x10,0x02,
    0x32,0x4b,0x73,0x8b,0x71,0xb5,0x30,0x02,0x98,0x66,0x6b,0xb1,0x4a,0xca,0xe4,0xcf,
    0x40,0xca,0x3a,0x46,0x26,0xef,0xbc,0x9e,0x7d,0x7b,0xf8,0x87,0xf8,0xaf,0x12,0xa2,
    0x24,0xd0,0x42,0x91,0xd0,0xbf,0x13,0x2c,0xcc,0x53,0xd3,0x90,0xec,0xd7,0x8d,0x04,
    0x77,0xdf,0x90,0x8e,0x8c,0x5e,0xde,0xb0,0xca,0xa0,0xa6,0xab,0xcb,0xda,0x66,0x02,
    0x03,0xbe,0x04,0xec,0xae,0xa0,0x3c,0xc0,0xe6,0xf4,0xdd,0x2a,0x70,0x01,0xb6,0x29,
    0xbb,0x82,0x87,0xc7,0x78,0xfe,0x0f,0xc0,0x00,0x06,0xca,0x50,0x14,0x6c,0x73,0x97,
    0x83,0x6d,0x5a,0x01,0x14,0x33,0xbd,0xcc,0xa4,0x77,0x08,0x9a,0xff,0xbd,0xea,0x44,
    0x24,0xc4,0x26,0x63,0x21,0x08,0xde,0x61,0xa9,0x1c,0x0a,0x5e,0x65,0xf8,0xf9,0x37,
    0x19,0xf2,0x83,0x60,0x2b,0xcf,0x47,0xf5,0xf9,0x54,0x76,0xe0,0xb0,0x95,0xcf,0x6d,
    0xa2,0xfe,0x97,0xdb,0xff,0xfb,0x82,0x1b,0x14,0x8b,0x7d,0xb1,0xb5,0xa4,0x1f,0xbf,
    0xde,0x3f,0x20,0x68,0x56,0xe1,0xd8,0x02,0x02,0x8d,0x7d,0xec,0x9e,0x17,0x50,0x90,
    0x10,0x10,0x63,0xee,0xe0,0x5d,0xcf,0x80,0xe0,0x00,0x48,0x06,0x0e,0x71,0x30,0x80,
    0x00,0x26,0x00,0x06,0x01,0xe8,0x00,0x11,0x18,0xe1,0x93,0x53,0xa4,0x42,0x1b,0xa7,
    0xaa,0xad,0xe1,0x2f,0x11,0x0e,0x29,0x85,0x30,0xf5,0x7b,0x00,0x0f,0x0f,0x5d,0xaa,
    0x59,0xf7,0x85,0xdb,0xf7,0xb0,0x7f,0x80,0x03,0x81,0x85,0x4c,0x98,0x49,0x9b,0x7b,
    0x0d,0xeb,0x65,0xe7,0x88,0xb0,0x69,0x4d,0xfc,0x00,0x11,0x07,0xbb,0x98,0xa4,0xdd,
    0x95,0xd0,0xac,0x00,0x08,0x90,0x66,0x7b,0xf1,0x0a,0xea,0xc5,0xcc,0x1f,0x81,0x94,
    0xa8,0xe8,0xdb,0x00,0xa7,0xce,0x5b,0x0e,0xf1,0x87,0xf3,0x9c,0x05,0x4d,0x57,0x61,
    0xc1,0x78,0x50,0x00,0x56,0x09,0x70,0xe9,0x71,0x4d,0x2d,0x87,0xab,0xc1,0xf0,0x10,
    0xc8,0xd3,0x49,0xb6,0xd6,0xfc,0x06,0x5a,0xb5,0xac,0x34,0xe2,0x25,0xc5,0xb8,0xb7,
    0x1e,0xaf,0x78,0x62,0xbd,0x7b,0x5a,0x5b,0xec,0x74,0xf1,0xb3,0x18,0x00,0x00,0x04,
    0x0b,0x7c,0x68,0xa0,0xf2,0xee,0x8a,0x83,0x0b,0x37,0x8c,0x00,0x01,0x00,0x70,0x1c,
    0xa7,0x4b,0x70,0xe0,0x75,0x65,0x60,0x57,0xbe,0x18,0x00,0x22,0x0b,0x56,0x30,0x0a,
    0x8b,0xbf,0xd3,0xd8,0x93,0x80,0x01,0xba,0x31,0x2f,0x21,0x73,0x1d,0x8a,0x46,0x0f,
    0xc4,0x12,0x56,0x33,0x13,0x8c,0x76,0xe5,0x8c,0x5b,0x83,0x61,0x38,0x97,0xa5,0x02,
    0x7f,0x4f,0xdb,0x5c,0x6c,0xd0,0x4b,0x87,0x4b,0x8a,0x79,0x6e,0x3d,0x5e,0x00,0x1d,
    0x87,0xf3,0x9c,0xa5,0xd9,0x91,0xd0,0x89,0xe0,0x05,0x81,0x11,0x29,0xbf,0x36,0x8d,
    0xa9,0xee,0xef,0x6d,0xa8,0xdb,0x04,0x49,0x28,0x41,0x11,0x0f,0x8d,0x9d,0x04,0x3d,
    0x64,0x3d,0xbe,0xbd,0xfe,0xd0,0x19,0xc7,0x4a,0xef,0x6f,0x73,0xf7,0x2f,0xfb,0x7a,
    0xe7,0x02,0x7b,0x5f,0x7f,0xd6,0xc8,0x49,0xca,0x5e,0xc6,0x62,0x95,0x3d,0xe8,0xcb,
    0xd0,0xf2,0x2c,0xba,0x78,0x0c,0xa2,0x16,0xe9,0xc2,0xc4,0xfe,0xab,0x38,0xff,0xf7,
    0x9e,0x1e,0x80,0x01,0x01,0x5e,0x1b,0x24,0x23,0x55,0x69,0x8b,0x6f,0x1d,0x02,0x1b,
    0x80,0x10,0x77,0x52,0x5e,0x87,0xb0,0xdd,0xac,0x22,0x22,0x12,0x64,0x4d,0xa6,0x7f,
    0xff,0xff,0xfc,0x02,0x0c,0xb5,0x25,0xc8,0x8e,0xb8,0xfc,0x49,0x0e,0x0c,0x1f,0xe3,
    0xac,0x64,0xa8,0x0e,0xd7,0xc0,0x01,0x36,0xcc,0x6b,0xca,0x5e,0xe7,0x00,0x06,0x4a,
    0x40,0xc0,0x47,0x80,0x05,0x71,0x3d,0x9d,0xf2,0x02,0x90,0x9a,0x1b,0xf8,0xc0,0x00,
    0x24,0x03,0x07,0x3c,0x98,0x18,0x00,0xbc,0x82,0x5c,0x2a,0x5c,0x53,0x4b,0x71,0xea,
    0xf0,0x00,0x5b,0x78,0x08,0x29,0x99,0xda,0x69,0xa6,0x5e,0x57,0x86,0x3d,0xd1,0xab,
    0xba,0x2e,0xb6,0xc8,0x05,0x5a,0xb8,0xf1,0x3b,0xd9,0xc4,0x1c,0x95,0xcb,0xff,0xe0,
    0x61,0x80,0x02,0x6f,0x2c,0xde,0x24,0x21,0xab,0x19,0xbc,0x34,0x3d,0x88,0xaf,0xbc,
    0x00,0x1b,0xa3,0x12,0xf2,0x17,0x31,0xd8,0xa4,0x60,0x70,0x00,0x10,0x07,0x01,0xca,
    0x19,0x2d,0x20,0x00,0x12,0x18,0xb4,0xc3,0x5e,0x88,0x72,0xe7,0x07,0x00,0x50,0x5b,
    0xb1,0x80,0x54,0x6d,0xfe,0x9e,0xe4,0x99,0xa0,0x66,0x08,0xbf,0x58,0x5e,0x24,0x93,
    0xfe,0x6d,0xef,0xf4,0x00,0xb1,0x8e,0x89,0x71,0x22,0x12,0x9d,0x7e,0xcb,0xcf,0xff,
    0xfb,0xbc,0x44,0x19,0x9e,0xfc,0x42,0xba,0xb1,0x51,0x3c,0x11,0x9b,0x06,0x28,0xf5,
    0x7c,0xb5,0x2f,0x08,0x6b,0x78,0x08,0x47,0x4f,0x6a,0xb7,0x51,0xdb,0x8d,0xad,0x18,
    0x05,0x10,0x74,0xd2,0x2f,0xf9,0x71,0x9f,0xbd,0x60,0x33,0x9d,0xdd,0x7f,0x49,0x29,
    0xff,0xf5,0x06,0x08,0x6d,0x00,0x20,0xee,0xa4,0xbd,0x0f,0x61,0xbb,0x5c,0x38,0x77,
    0x09,0xb3,0xdc,0x00,0x1b,0xa3,0x12,0xf2,0x17,0x31,0xd8,0xa4,0x60,0xe4,0x00,0x02,
    0x43,0x16,0x98,0x6b,0xd1,0x0e,0x5c,0xe0,0x05,0x07,0xbb,0x98,0xa4,0xdd,0x95,0xf1,
    0x53,0x2f,0x35,0x00,0x7e,0x82,0x5c,0x2a,0x5c,0x53,0x4b,0x71,0xea,0xf0,0x61,0x80,
    0xbf,0x8b,0x2e,0x1b,0x9c,0xaf,0xd5,0x6f,0xc1,0xe0,0x2c,0x20,0x0b,0xcc,0xfe,0x23,
    0x09,0x7c,0xca,0xc6,0x7e,0x00,0x04,0x31,0x1b,0x65,0x16,0x79,0xbd,0x5e,0xf7,0x84,
    0x71,0x2e,0x52,0x22,0xa4,0x2c,0x9a,0x6d,0xff,0xff,0x87,0x9f,0xa1,0x28,0x45,0x7f,
    0x01,0xc0,0x00,0x40,0x1c,0x07,0x28,0x74,0xb6,0x01,0x00,0x03,0x29,0x80,0x65,0x20,
    0xbd,0x1c,0x90,0xe3,0xef,0xe7,0x00,0xa6,0x51,0x25,0x84,0x1d,0x82,0xfb,0x04,0x3d,
    0xca,0x40,0x24,0xbc,0xaf,0x9f,0x82,0x01,0x0a,0xd2,0x4e,0x40,0x00,0x00,0x3f,0xe0,
    0x0c,0x2a,0x64,0xc2,0x4c,0xdb,0xd8,0x6f,0x5b,0x2f,0x18,0x7e,0x39,0xca,0x5d,0x99,
    0x1f,0x11,0x3b,0x30,0x7e,0x3f,0x13,0x80,0x03,0x36,0x42,0x4e,0x52,0xf6,0x33,0x14,
    0xad,0xe2,0x0b,0x56,0x30,0x0a,0x8d,0xbf,0xd3,0xdc,0x93,0x3c,0x60,0x0b,0xc3,0x94,
    0x01,0x5b,0x0d,0x52,0xbd,0x4c,0x80,0xe6,0x00,0x00,0x80,0x38,0x0e,0x50,0xe9,0x6c,
    0x3d,0x60,0x03,0x20,0xda,0xe1,0x19,0x79,0x2f,0xc9,0x3f,0x6f,0x06,0x00,0x85,0xc4,
    0x47,0x9a,0xf2,0xd3,0x5f,0x1e,0x52,0x39,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x77,0xdf,
    0xef,0xf7,0x86,0xf0,0xdf,0xef,0xf7,0x86,0xf0,0xdf,0x7d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x78,
};
static unsigned char MPEG4_NoCam_German_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xda,0x05,0x07,0xe4,0x00,0x00,0x00,0x01,
    0x68,0xce,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x11,0xff,0xff,0x87,0xa2,
    0x80,0x00,0x80,0x8f,0xbc,0x56,0xf7,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,
    0x7d,0xf7,0xdf,0x7d,0x62,0xb5,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xad,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5f,0xff,0xff,0x04,0x3c,0x00,0x13,0x42,0x2a,0xcf,0xd9,
    0x97,0x23,0xf4,0xf5,0xb4,0x49,0x8d,0xfa,0x11,0x1d,0xd1,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0xf8,0x14,0x7c,0x4f,0x85,0x3e,0xb6,
    0x89,0x31,0xbd,0x42,0x23,0xba,0x58,0x02,0x66,0x8b,0x22,0xac,0xb4,0xff,0xff,0xfd,
    0xe4,0x3d,0x54,0x8e,0xd8,0x81,0x6f,0x68,0xa2,0x74,0x11,0x8e,0xc7,0x6d,0xf7,0x29,
    0xcd,0x7f,0xf5,0x46,0x80,0xa7,0x38,0xcb,0xf5,0x7b,0xeb,0xbb,0xb0,0x45,0x22,0x2a,
    0x7c,0xb2,0xd3,0xff,0xea,0xff,0xc6,0x03,0xd0,0xba,0x77,0x02,0x46,0x63,0x39,0xdf,
    0x6d,0x88,0x73,0x93,0xff,0x40,0x82,0x3b,0xc3,0x08,0xb7,0xdd,0x2a,0xcf,0xff,0xfb,
    0xe0,0x33,0x19,0xce,0xfb,0x6c,0x43,0x9d,0xff,0xff,0xe7,0xe6,0x2f,0x10,0xa0,0xff,
    0x75,0xb4,0x4a,0xb0,0xa0,0x14,0x9f,0x95,0x23,0xe3,0x28,0x4c,0x2d,0xf9,0xfb,0x02,
    0x3b,0xc3,0x08,0x53,0xee,0x96,0x5a,0x9f,0xff,0xf7,0x18,0x00,0x10,0x28,0xc6,0x53,
    0x01,0xbe,0x04,0x76,0x42,0xb7,0xd0,0xb2,0x92,0xbf,0xf6,0x82,0x3a,0x42,0x8e,0x9e,
    0xb4,0x26,0x46,0x4f,0xdf,0xf8,0x7f,0x66,0x80,0xa7,0x38,0xea,0xf5,0x72,0xcf,0x57,
    0x80,0x86,0xf4,0xe2,0x62,0x7a,0x85,0x4d,0xe1,0xf1,0x0f,0x02,0x80,0xa7,0x70,0x34,
    0xce,0xd4,0xc2,0x94,0xeb,0xb5,0x96,0xa7,0xff,0xfd,0xc2,0x01,0x33,0x8e,0xa5,0x3c,
    0xd1,0x54,0xf0,0x00,0x10,0x1f,0xf8,0xf0,0x00,0x3c,0x05,0x7a,0xa5,0x80,0x0f,0xa8,
    0x83,0x60,0xf6,0x45,0x61,0x7f,0x97,0x81,0xc0,0x00,0xf8,0x15,0xc2,0x25,0xad,0xe2,
    0xfc,0xce,0x71,0x14,0xf5,0x9e,0xaf,0x06,0x00,0x16,0xd8,0xe6,0x2d,0x02,0x41,0x48,
    0xe4,0x4f,0xf7,0xef,0x98,0x00,0x07,0xc0,0xae,0x64,0xb6,0x92,0x50,0x4c,0x1a,0xd1,
    0x90,0x57,0xf5,0xef,0xe6,0xe2,0x6b,0x08,0x1c,0x07,0xdc,0x0c,0x80,0x7a,0x84,0x96,
    0x45,0x42,0x53,0xa8,0xff,0xec,0x00,0x8b,0x1d,0x94,0x2a,0x99,0xd7,0xb1,0xad,0xd7,
    0x00,0x00,0x03,0x02,0x03,0xbc,0x00,0x22,0x8b,0x6a,0x2a,0xf6,0x74,0x98,0xa7,0xcc,
    0x06,0x45,0xe6,0x31,0xd2,0x2c,0x3c,0x6f,0xfc,0xfc,0x25,0x81,0x8e,0xb9,0x9e,0x5f,
    0x21,0x4d,0x77,0x86,0x02,0x8e,0x8a,0x97,0x2d,0x57,0x7b,0x1b,0x91,0x9e,0x87,0xa0,
    0x37,0x3b,0x1f,0xbf,0x1d,0x4b,0x83,0xab,0xff,0xdf,0xff,0x11,0x01,0xe8,0x41,0x11,
    0xee,0x00,0x16,0x33,0x19,0xce,0xfb,0x6c,0x43,0x9c,0xdf,0xfa,0x04,0x11,0xde,0x18,
    0x45,0xbe,0xe9,0x56,0x7f,0xff,0xdc,0x0d,0x19,0x8c,0xe7,0x7d,0xb6,0x21,0xce,0xff,
    0xff,0xf3,0xf3,0x17,0x88,0x50,0x7f,0xba,0xda,0x25,0x58,0x50,0x2e,0x60,0x77,0x18,
    0x65,0xf2,0xfd,0xf5,0xdd,0x82,0xb0,0xbe,0x3b,0x98,0x45,0xbd,0x47,0xab,0xc1,0xf8,
    0x12,0x23,0xb4,0x2b,0x79,0x97,0xed,0xff,0xdd,0xa0,0x8e,0x90,0xa3,0xa7,0xad,0x0b,
    0xb1,0x93,0xf7,0xff,0xfe,0x04,0x88,0xe6,0x63,0xb7,0xdf,0x14,0xc7,0x02,0xff,0xe8,
    0x05,0x09,0xcc,0xa7,0x1d,0xf5,0x78,0xbd,0x15,0x7a,0x77,0x87,0x01,0x69,0xca,0x5d,
    0xbd,0xc0,0x46,0xd1,0x26,0x37,0xe8,0x44,0x77,0x43,0x00,0x00,0xf0,0x15,0xea,0x96,
    0xe6,0x98,0x77,0x3c,0x50,0x91,0x9d,0x24,0xf9,0x40,0x3c,0x05,0x60,0x9d,0x01,0x72,
    0x80,0x0b,0xda,0x64,0xf4,0xeb,0x9f,0xff,0xff,0xff,0xf7,0xc6,0x8d,0x90,0x73,0x1f,
    0x15,0x30,0x7e,0xe6,0xc9,0xa1,0xb7,0x42,0xa3,0x3a,0x18,0x00,0x07,0xc0,0xae,0x54,
    0xb0,0x7e,0xaa,0x92,0x45,0x49,0x57,0xfd,0xff,0xfa,0xeb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xbe,0xfa,0xef,0xbe,0xfa,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
    0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
    0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
    0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
    0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xaf,
};
static unsigned char MPEG4_NoCam_French_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xDA,0x05,0x07,0xE4,0x00,0x00,0x00,0x01,
    0x68,0xCE,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x11,0xFF,0xFF,0x87,0xA2,
    0x80,0x00,0x80,0x8F,0xBC,0x56,0xF7,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,
    0x7D,0xF7,0xDF,0x7D,0x62,0xB5,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAD,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x7F,0x07,0x50,0xCF,0x57,0xEF,0x00,0x07,0xD0,0x08,0xA1,
    0x62,0xD5,0xD9,0x5B,0xE5,0x91,0xFF,0x43,0xE1,0x83,0x7E,0xE5,0x4B,0x65,0x12,0x7D,
    0xBF,0xEE,0x00,0x0B,0x22,0x99,0x23,0x65,0x89,0x19,0x7E,0x0C,0x38,0x00,0x6A,0xC9,
    0xC2,0x52,0x3D,0xCE,0x9A,0xF8,0x12,0x33,0xCD,0xC7,0x65,0x54,0x27,0x64,0xDF,0xFB,
    0x80,0x50,0x04,0xC6,0x9E,0x27,0x3C,0xF3,0xA2,0xFF,0xF7,0x87,0xA8,0xC5,0x4C,0x89,
    0xF0,0x80,0x5E,0xDC,0xC4,0xE7,0xC2,0x29,0xEB,0x51,0xBB,0x40,0x43,0x5B,0x65,0x3C,
    0x6C,0x54,0x68,0x01,0x06,0xD8,0x29,0x37,0xDD,0x77,0xAC,0xCB,0xFD,0xB3,0x50,0x10,
    0xCB,0x14,0xCD,0xF7,0x79,0x9B,0xB7,0xF6,0x11,0xC4,0x8F,0xB5,0xD2,0x9B,0x6A,0x37,
    0x68,0x08,0x6B,0x6C,0xA7,0x86,0xC5,0x44,0xBC,0x59,0x05,0x6C,0x55,0x05,0x1F,0x09,
    0x4D,0x6F,0x7B,0x9B,0x26,0x86,0xC0,0x62,0x53,0x9C,0x7E,0x70,0x5B,0x8A,0xA6,0xA9,
    0x4B,0x5A,0xE9,0x75,0x7F,0xFF,0xF8,0x00,0x4D,0x63,0x44,0xC7,0x08,0x4A,0x76,0x73,
    0xFF,0x83,0x0F,0xCD,0x88,0xA9,0x37,0x76,0x4C,0xAD,0xD7,0xC9,0x8C,0x89,0x76,0x75,
    0xDD,0x5B,0x28,0x61,0xF8,0x6D,0xC2,0x90,0xDF,0xDC,0x99,0xB0,0x6C,0xD9,0x4A,0x10,
    0xFE,0x20,0x33,0x00,0x01,0x02,0x0F,0x5D,0x33,0x80,0xE0,0x00,0x81,0x07,0xAD,0x2C,
    0x00,0x64,0xEC,0x18,0xC9,0x66,0xEE,0xFA,0x00,0x00,0x04,0x10,0xFE,0xE4,0xCD,0xA1,
    0x36,0x52,0xAB,0x32,0x86,0x1C,0x08,0x6F,0x4E,0x26,0x22,0xD4,0x2A,0x62,0x00,0x00,
    0xF0,0x15,0xED,0x43,0xFF,0xEC,0x10,0xF8,0x98,0x02,0xA1,0x73,0xB3,0xEE,0x61,0x1E,
    0x2F,0x4D,0xF7,0x01,0x99,0x83,0x67,0x03,0x2D,0x4C,0x11,0xF9,0xEA,0xFC,0x58,0x00,
    0x08,0x08,0x03,0x30,0x60,0x00,0x20,0x41,0xE1,0x94,0xC1,0x20,0x83,0x78,0x85,0xB6,
    0x2E,0x59,0xE0,0x00,0x20,0x57,0x80,0x12,0xE9,0x81,0xBA,0x33,0x80,0x32,0xBD,0x9F,
    0x1F,0xBD,0xC9,0x9B,0x42,0x6C,0xA5,0x56,0x65,0x0C,0x35,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x77,0xDF,0x7D,0xF5,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x78,
};
static unsigned char MPEG4_NoCam_Italy_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xDA,0x05,0x07,0xE4,0x00,0x00,0x00,0x01,
    0x68,0xCE,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x11,0xFF,0xFF,0x87,0xA2,
    0x80,0x00,0x80,0x8F,0xBC,0x56,0xF7,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,
    0x7D,0xF7,0xDF,0x7D,0x62,0xB5,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAD,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x7F,0x07,0x50,0xCF,0x57,0xEF,0x00,0x07,0xD0,0x08,0xA1,
    0x62,0xD5,0xD9,0x5B,0xE5,0x91,0xFF,0x43,0xE1,0x83,0x7E,0xE5,0x4B,0x65,0x12,0x7D,
    0xBF,0xEE,0x00,0x0B,0x22,0x99,0x23,0x65,0x89,0x19,0x7E,0x0C,0x38,0x00,0x6A,0xC9,
    0xC2,0x52,0x3D,0xCE,0x9A,0xF8,0x12,0x33,0xCD,0xC7,0x65,0x54,0x27,0x64,0xDF,0xFB,
    0x80,0x50,0x04,0xC6,0x9E,0x27,0x3C,0xF3,0xA2,0xFF,0xF7,0x87,0xA8,0xC5,0x4C,0x89,
    0xF0,0x80,0x5E,0xDC,0xC4,0xE7,0xC2,0x29,0xEB,0x51,0xBB,0x40,0x43,0x5B,0x65,0x3C,
    0x6C,0x54,0x68,0x01,0x06,0xD8,0x29,0x37,0xDD,0x77,0xAC,0xCB,0xFD,0xB3,0x50,0x10,
    0xCB,0x14,0xCD,0xF7,0x79,0x9B,0xB7,0xF6,0x11,0xC4,0x8F,0xB5,0xD2,0x9B,0x6A,0x37,
    0x68,0x08,0x6B,0x6C,0xA7,0x86,0xC5,0x44,0xBC,0x59,0x05,0x6C,0x55,0x05,0x1F,0x09,
    0x4D,0x6F,0x7B,0x9B,0x26,0x86,0xC0,0x62,0x53,0x9C,0x7E,0x70,0x5B,0x8A,0xA6,0xA9,
    0x4B,0x5A,0xE9,0x75,0x7F,0xFF,0xF8,0x00,0x4D,0x63,0x44,0xC7,0x08,0x4A,0x76,0x73,
    0xFF,0x83,0x0F,0xCD,0x88,0xA9,0x37,0x76,0x4C,0xAD,0xD7,0xC9,0x8C,0x89,0x76,0x75,
    0xDD,0x5B,0x28,0x61,0xF8,0x6D,0xC2,0x90,0xDF,0xDC,0x99,0xB0,0x6C,0xD9,0x4A,0x10,
    0xFE,0x20,0x33,0x00,0x01,0x02,0x0F,0x5D,0x33,0x80,0xE0,0x00,0x81,0x07,0xAD,0x2C,
    0x00,0x64,0xEC,0x18,0xC9,0x66,0xEE,0xFA,0x00,0x00,0x04,0x10,0xFE,0xE4,0xCD,0xA1,
    0x36,0x52,0xAB,0x32,0x86,0x1C,0x08,0x6F,0x4E,0x26,0x22,0xD4,0x2A,0x62,0x00,0x00,
    0xF0,0x15,0xED,0x43,0xFF,0xEC,0x10,0xF8,0x98,0x02,0xA1,0x73,0xB3,0xEE,0x61,0x1E,
    0x2F,0x4D,0xF7,0x01,0x99,0x83,0x67,0x03,0x2D,0x4C,0x11,0xF9,0xEA,0xFC,0x58,0x00,
    0x08,0x08,0x03,0x30,0x60,0x00,0x20,0x41,0xE1,0x94,0xC1,0x20,0x83,0x78,0x85,0xB6,
    0x2E,0x59,0xE0,0x00,0x20,0x57,0x80,0x12,0xE9,0x81,0xBA,0x33,0x80,0x32,0xBD,0x9F,
    0x1F,0xBD,0xC9,0x9B,0x42,0x6C,0xA5,0x56,0x65,0x0C,0x35,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x77,0xDF,0x7D,0xF5,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x78,
};
static unsigned char MPEG4_NoCam_Netherland_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xDA,0x05,0x07,0xE4,0x00,0x00,0x00,0x01,
    0x68,0xCE,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x11,0xFF,0xFF,0x87,0xA2,
    0x80,0x00,0x80,0x8F,0xBC,0x56,0xF7,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,
    0x7D,0xF7,0xDF,0x7D,0x62,0xB5,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAD,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x7F,0x07,0x50,0xCF,0x57,0xEF,0x00,0x07,0xD0,0x08,0xA1,
    0x62,0xD5,0xD9,0x5B,0xE5,0x91,0xFF,0x43,0xE1,0x83,0x7E,0xE5,0x4B,0x65,0x12,0x7D,
    0xBF,0xEE,0x00,0x0B,0x22,0x99,0x23,0x65,0x89,0x19,0x7E,0x0C,0x38,0x00,0x6A,0xC9,
    0xC2,0x52,0x3D,0xCE,0x9A,0xF8,0x12,0x33,0xCD,0xC7,0x65,0x54,0x27,0x64,0xDF,0xFB,
    0x80,0x50,0x04,0xC6,0x9E,0x27,0x3C,0xF3,0xA2,0xFF,0xF7,0x87,0xA8,0xC5,0x4C,0x89,
    0xF0,0x80,0x5E,0xDC,0xC4,0xE7,0xC2,0x29,0xEB,0x51,0xBB,0x40,0x43,0x5B,0x65,0x3C,
    0x6C,0x54,0x68,0x01,0x06,0xD8,0x29,0x37,0xDD,0x77,0xAC,0xCB,0xFD,0xB3,0x50,0x10,
    0xCB,0x14,0xCD,0xF7,0x79,0x9B,0xB7,0xF6,0x11,0xC4,0x8F,0xB5,0xD2,0x9B,0x6A,0x37,
    0x68,0x08,0x6B,0x6C,0xA7,0x86,0xC5,0x44,0xBC,0x59,0x05,0x6C,0x55,0x05,0x1F,0x09,
    0x4D,0x6F,0x7B,0x9B,0x26,0x86,0xC0,0x62,0x53,0x9C,0x7E,0x70,0x5B,0x8A,0xA6,0xA9,
    0x4B,0x5A,0xE9,0x75,0x7F,0xFF,0xF8,0x00,0x4D,0x63,0x44,0xC7,0x08,0x4A,0x76,0x73,
    0xFF,0x83,0x0F,0xCD,0x88,0xA9,0x37,0x76,0x4C,0xAD,0xD7,0xC9,0x8C,0x89,0x76,0x75,
    0xDD,0x5B,0x28,0x61,0xF8,0x6D,0xC2,0x90,0xDF,0xDC,0x99,0xB0,0x6C,0xD9,0x4A,0x10,
    0xFE,0x20,0x33,0x00,0x01,0x02,0x0F,0x5D,0x33,0x80,0xE0,0x00,0x81,0x07,0xAD,0x2C,
    0x00,0x64,0xEC,0x18,0xC9,0x66,0xEE,0xFA,0x00,0x00,0x04,0x10,0xFE,0xE4,0xCD,0xA1,
    0x36,0x52,0xAB,0x32,0x86,0x1C,0x08,0x6F,0x4E,0x26,0x22,0xD4,0x2A,0x62,0x00,0x00,
    0xF0,0x15,0xED,0x43,0xFF,0xEC,0x10,0xF8,0x98,0x02,0xA1,0x73,0xB3,0xEE,0x61,0x1E,
    0x2F,0x4D,0xF7,0x01,0x99,0x83,0x67,0x03,0x2D,0x4C,0x11,0xF9,0xEA,0xFC,0x58,0x00,
    0x08,0x08,0x03,0x30,0x60,0x00,0x20,0x41,0xE1,0x94,0xC1,0x20,0x83,0x78,0x85,0xB6,
    0x2E,0x59,0xE0,0x00,0x20,0x57,0x80,0x12,0xE9,0x81,0xBA,0x33,0x80,0x32,0xBD,0x9F,
    0x1F,0xBD,0xC9,0x9B,0x42,0x6C,0xA5,0x56,0x65,0x0C,0x35,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x77,0xDF,0x7D,0xF5,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x78,
};
static unsigned char MPEG4_NoCam_Spanish_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xDA,0x05,0x07,0xE4,0x00,0x00,0x00,0x01,
    0x68,0xCE,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x11,0xFF,0xFF,0x87,0xA2,
    0x80,0x00,0x80,0x8F,0xBC,0x56,0xF7,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,
    0x7D,0xF7,0xDF,0x7D,0x62,0xB5,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAD,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5F,0xFC,0x3E,0x7C,0x29,0x80,0x03,0x8B,0x87,0xEE,0x59,0x4A,
    0xA5,0xA5,0x76,0xB1,0x1E,0x87,0x00,0x0D,0x84,0x43,0xEE,0x65,0x55,0x45,0x47,0x7F,
    0xC2,0xA2,0xE2,0x39,0x04,0x2E,0x60,0x00,0x40,0x83,0xB5,0x2C,0x01,0x00,0xC7,0xAE,
    0xB5,0xF5,0xC2,0xD4,0xFF,0xAF,0xAF,0xE0,0x22,0x68,0xD0,0x37,0x6E,0xA4,0x08,0x7F,
    0x91,0xB7,0x35,0xC6,0x93,0xBB,0xF7,0xFD,0x01,0x33,0x98,0xE3,0x1C,0xE5,0x7A,0xDF,
    0xF7,0xEA,0xE1,0x2F,0x61,0x13,0x01,0xC9,0x88,0x24,0xCE,0xFF,0x0F,0x00,0x03,0xC0,
    0x57,0xAA,0x58,0x01,0x63,0x39,0xDC,0xEF,0xFF,0xE4,0x31,0x9F,0xFF,0xFE,0x7F,0xF0,
    0x6E,0xC4,0x41,0x4A,0xBA,0xAC,0x28,0x9E,0xAF,0xFF,0xB4,0x19,0xF3,0xBF,0x3F,0x21,
    0x88,0x73,0x4F,0x7F,0xE1,0xFF,0xAA,0xCB,0x80,0x61,0xB8,0x03,0xB1,0x15,0x21,0xFB,
    0xB2,0x60,0x87,0xD9,0x0C,0x02,0x67,0x1D,0x4A,0x79,0xA2,0xAF,0x9B,0x19,0x56,0x6C,
    0xEC,0x12,0xB3,0x82,0x2B,0xA5,0xA1,0x17,0x0A,0x68,0xB9,0xCB,0xA8,0x53,0xDC,0x04,
    0x35,0xB6,0x53,0xC6,0xC5,0x46,0x83,0x20,0x00,0x0F,0x01,0x5E,0x99,0xFD,0x4D,0x1A,
    0x43,0x6A,0xA4,0x56,0x75,0xF3,0x62,0x2A,0x4D,0xDD,0x13,0x2B,0x57,0x0C,0x3F,0x26,
    0x32,0x25,0xD9,0xDD,0x3A,0xB6,0x50,0xC3,0xE7,0xC0,0x34,0x0F,0x0B,0x80,0x0B,0x20,
    0x75,0x7F,0xBB,0x96,0xA7,0x9E,0x19,0xE7,0xC0,0x64,0x8C,0x5D,0x28,0x46,0x71,0x51,
    0x13,0xFE,0xC3,0xC0,0x00,0xF0,0x15,0xEB,0x4C,0x20,0x00,0x0F,0x01,0x5E,0x99,0x01,
    0x1B,0x44,0x98,0xDF,0xA1,0x11,0xDD,0x03,0x0C,0x07,0x00,0x04,0x08,0x3D,0x84,0xC0,
    0x01,0xE6,0x32,0x25,0xD9,0xDD,0x3A,0xB6,0x5C,0x06,0x43,0x55,0x88,0x73,0x1E,0x2C,
    0x7B,0xFE,0x07,0xE0,0x68,0x0C,0xD0,0x45,0x56,0x2C,0xB1,0x32,0xE6,0x9E,0x6B,0x58,
    0xF7,0x33,0x1C,0x55,0x39,0x67,0xAB,0xDF,0xE1,0x0C,0x00,0x12,0x02,0x0D,0x13,0x68,
    0x6C,0xB5,0x94,0x35,0x2E,0x74,0x0E,0x00,0x08,0x10,0x7C,0xB0,0x02,0x1B,0x44,0x98,
    0xDF,0xA1,0x11,0xDC,0x80,0x00,0x3C,0x05,0x7C,0xBE,0x53,0x46,0x90,0xDB,0x80,0x19,
    0x1B,0xDE,0xC0,0x4E,0xE3,0x2D,0x4F,0x1B,0x53,0x02,0x13,0x46,0x81,0xBB,0x75,0x20,
    0x43,0xFF,0x94,0x91,0x24,0x26,0xC8,0x44,0x66,0x90,0x02,0xCE,0x63,0x8C,0x73,0x95,
    0xEF,0xF7,0xEA,0x40,0x00,0x1E,0x02,0xBE,0x5E,0x07,0xE9,0xC5,0xB5,0x78,0x89,0xEF,
    0x5F,0xDE,0xFC,0x30,0x24,0xCF,0x88,0x82,0x95,0xCE,0xAC,0x28,0x9E,0x7F,0xFD,0xFA,
    0xDF,0xE1,0x0F,0xC2,0x7D,0xB9,0xAE,0x34,0x9D,0xDF,0xBF,0xFF,0x84,0xBD,0x84,0x4C,
    0x07,0x26,0x20,0x93,0x3B,0xFC,0x1E,0x83,0x3E,0x77,0xE7,0xE4,0x31,0x0E,0x69,0xEF,
    0xFF,0xFE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEF,0xBE,0xFB,0xEF,
    0xBE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,
    0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,
    0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,
    0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,
    0xC0,
};
#endif
#if (UI_VERSION == UI_VERSION_TRANWO)
// TRANWO "Sorry, this event is currently being played on another device."
unsigned char MPEG4_Playback_black_QVGA[] =
{
	0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xf4,0x0a,0x0f,0xc8,0x00,0x00,0x00,0x01,
	0x68,0xce,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x02,0x13,0x14,0x00,0x04,
	0x37,0xef,0xbe,0xfb,0xef,0xbe,0xfb,0xef,0xbe,0xfb,0xef,0xbe,0xfb,0xef,0xbe,0xfa,
	0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
	0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
	0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
	0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
	0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xaf,0xff,0xff,0x82,
	0x1c,0x00,0x31,0xf9,0xae,0x72,0x72,0xd4,0x21,0x51,0x51,0xba,0xbd,0x7e,0xaa,0x47,
	0x40,0x8b,0xe0,0x01,0xd7,0x08,0x53,0x1d,0x76,0x95,0x8f,0x91,0x2d,0xfc,0x06,0x52,
	0x85,0x3a,0xc1,0xfe,0x59,0x4b,0x4e,0x02,0xf3,0xeb,0xc0,0x0c,0x5e,0xd0,0x2a,0xb5,
	0x20,0x69,0x44,0x25,0xa8,0x3a,0x77,0xbf,0xb6,0x0d,0x19,0x03,0x4c,0x24,0x71,0x2c,
	0x29,0x76,0x10,0x85,0xac,0xc2,0xd5,0x7a,0x21,0x68,0x7e,0x05,0x40,0x0c,0xc3,0x96,
	0xc1,0xf1,0x30,0x3e,0x7a,0x40,0x43,0xf0,0x9c,0xc1,0x70,0xcb,0x78,0xde,0xb4,0xe3,
	0x88,0x21,0xe3,0xaf,0x8c,0x67,0xf9,0x75,0xff,0x5a,0x4d,0x83,0x30,0xaa,0x97,0x7f,
	0x9f,0xf2,0xff,0xc7,0xaa,0x24,0x2b,0xd2,0xa2,0x41,0x8b,0x68,0x80,0xdb,0xce,0xdd,
	0xc0,0x27,0x66,0x8a,0x43,0x33,0x0f,0xe5,0x28,0x9d,0xe0,0xb7,0x2b,0xc8,0x36,0xfb,
	0xfd,0x84,0x8c,0x25,0x8c,0xfe,0xaa,0x23,0xff,0xbd,0xc5,0x09,0x6a,0x05,0xa5,0xca,
	0x4c,0x16,0xe5,0xb7,0x24,0x64,0x31,0x52,0xd8,0xe4,0x93,0x03,0x16,0x6d,0x01,0xad,
	0x49,0x94,0xea,0x41,0xd5,0xb6,0xa4,0x44,0x32,0x6a,0x18,0xec,0xc1,0xa6,0x5f,0xdf,
	0xcc,0x33,0x60,0xf7,0xe0,0x03,0x69,0x8f,0xc2,0x23,0xba,0x5f,0x60,0x09,0xba,0x2a,
	0x63,0x52,0x20,0xa4,0x2c,0xf3,0xc2,0x83,0x0c,0x09,0x16,0x47,0xc5,0xa3,0x36,0x3f,
	0x01,0x67,0x3e,0x80,0xb1,0xa5,0x99,0x13,0xf2,0x9d,0xf0,0xc5,0x2e,0x4a,0x0d,0xca,
	0x95,0x04,0xaf,0xe3,0x1d,0x85,0x3b,0xfd,0x19,0x0b,0xa1,0x30,0x1a,0x1c,0x56,0x90,
	0xa1,0x78,0x5f,0x36,0x38,0x3c,0x48,0x64,0xb9,0x27,0x54,0x0b,0x2b,0x21,0x98,0xf0,
	0x99,0x50,0x5f,0x55,0x2e,0x55,0xf7,0xbf,0xf0,0x97,0xc5,0xf0,0x04,0x02,0x27,0x20,
	0xd6,0xa4,0xc3,0x6a,0x6f,0xc1,0x62,0xa5,0x70,0x90,0x49,0x6f,0xe1,0xdb,0xf8,0x05,
	0xc0,0x89,0x94,0x42,0xfb,0x16,0x95,0xbc,0xf0,0x33,0xff,0xf4,0x82,0x15,0x3b,0x4c,
	0xb7,0x2e,0x5c,0x33,0x14,0x16,0x9f,0x29,0x91,0x76,0x45,0xb6,0xbf,0x61,0xe3,0xa5,
	0xac,0x6a,0xf4,0x65,0x1e,0x01,0x60,0x6f,0x20,0xcb,0xa2,0x21,0xf8,0x25,0x53,0x1f,
	0xfe,0x70,0x43,0x3a,0x10,0xa6,0x22,0x0e,0xad,0x1d,0x18,0x88,0x07,0x76,0x39,0x35,
	0xc2,0xcf,0xfb,0xab,0x98,0x2c,0x61,0x5e,0x80,0x64,0xf4,0x3e,0xba,0xfd,0xa5,0xc1,
	0xc5,0xbc,0x06,0x28,0x54,0x16,0xdb,0x05,0xfc,0x8a,0x5b,0xed,0xc1,0xf4,0x11,0x08,
	0x44,0xd6,0xa6,0xfc,0x40,0xad,0x00,0x00,0x15,0x4e,0x05,0xd5,0xb0,0x25,0x08,0xc0,
	0x0c,0x81,0x17,0x95,0x85,0x7c,0x98,0xc2,0x4b,0xa0,0x8e,0x28,0xc4,0x0a,0x6f,0x4d,
	0x79,0x45,0xe1,0x62,0xbb,0x84,0x13,0x2d,0x42,0x6e,0x19,0x24,0x24,0x79,0x77,0x10,
	0x3e,0x2d,0x23,0x19,0x14,0xd2,0xc6,0xe0,0x47,0x7f,0xc2,0x1b,0x4a,0x33,0x80,0x02,
	0x50,0xc9,0xff,0x44,0x7e,0xac,0x54,0x64,0xd7,0x19,0xf9,0xc1,0x4c,0x68,0x12,0x44,
	0xc1,0x55,0xab,0x1c,0x00,0x49,0xf2,0x16,0x9c,0x53,0x1e,0xbb,0x3d,0x65,0x03,0x1c,
	0x04,0xd4,0x54,0x56,0xd1,0xb5,0x34,0x82,0x81,0xb1,0x48,0x91,0xd9,0xfd,0x6d,0xe0,
	0xd9,0xf2,0x43,0xce,0x19,0x12,0x9a,0x10,0xd7,0x4a,0x1e,0xa4,0x8a,0xd5,0xe1,0xdb,
	0xb8,0xb3,0xf0,0xa8,0x9c,0xb6,0x7e,0xaf,0xae,0xb9,0x5b,0x36,0x41,0x65,0x7c,0xe1,
	0xf8,0x81,0x87,0x8b,0xe0,0x0e,0xe2,0xc2,0xce,0x25,0x69,0x31,0xc4,0xfb,0xf4,0x84,
	0xaf,0x1c,0x57,0x88,0x9f,0x08,0xa0,0x90,0x00,0xa2,0x0f,0xa0,0xe7,0xa2,0xd5,0x7e,
	0x6b,0x50,0x56,0x2a,0x0e,0x44,0x38,0x9b,0x79,0xff,0x5c,0x16,0xfd,0xf0,0x25,0x31,
	0xff,0xd5,0x9f,0xf8,0x30,0x00,0x46,0x41,0x48,0x43,0x8d,0xe9,0xa3,0xcf,0x5f,0x03,
	0x3b,0x7e,0x6b,0x9c,0x9c,0xdc,0x88,0x27,0x12,0xc9,0x0a,0xee,0xdb,0x61,0xdf,0xf0,
	0xd9,0x5c,0x30,0xaf,0x49,0xec,0x2c,0x2e,0x15,0xce,0x3d,0xec,0x7e,0x02,0x09,0x91,
	0x20,0x95,0x28,0xca,0x14,0x44,0x4f,0x61,0x26,0x3e,0xea,0xa5,0x0b,0x9d,0x2f,0xd7,
	0x61,0x9c,0x16,0xa4,0x08,0x9b,0xda,0xfe,0x78,0xc1,0x4e,0xcb,0xc6,0xec,0x13,0xc7,
	0x54,0x76,0x59,0x78,0x7a,0x6c,0x04,0x09,0x6d,0x35,0x9e,0x2c,0xa3,0x0a,0x20,0xf6,
	0xa6,0xe2,0x0f,0xfd,0x66,0x69,0x31,0x6a,0xf1,0x52,0x37,0x77,0xff,0x41,0xa8,0x61,
	0x58,0x13,0x02,0xbf,0x0f,0xbf,0x46,0x61,0x49,0x1e,0xe0,0x06,0x47,0x90,0x03,0x03,
	0xe4,0xe6,0xf4,0x15,0x69,0x80,0x48,0xc0,0x23,0xd1,0x01,0x3f,0x0e,0x36,0x71,0x03,
	0xe2,0xd2,0x31,0x91,0x4d,0x2c,0x6e,0x04,0x76,0x14,0xc1,0xe0,0x92,0x26,0x0a,0xad,
	0x38,0xe0,0x02,0x4f,0x91,0x78,0xb2,0x41,0x29,0xd3,0x54,0xa7,0x38,0x21,0x53,0xb6,
	0x5c,0x6d,0x4d,0x8d,0x90,0x36,0x29,0x12,0xe2,0xc6,0x7f,0xcf,0x3f,0x86,0x73,0x68,
	0xbe,0x00,0x2c,0xb9,0x0a,0x52,0x62,0xf8,0x73,0x7f,0xed,0xc0,0x58,0x48,0x8b,0x0f,
	0xc7,0xf7,0x98,0x73,0xbc,0x1b,0x3e,0x48,0x24,0x5a,0x7e,0x7b,0xc1,0xc5,0xbc,0x86,
	0x95,0xc8,0xe4,0xca,0x9d,0xf1,0xdb,0x84,0xcd,0xc2,0x56,0x47,0x09,0x7e,0xd4,0x7a,
	0xc6,0x27,0xbb,0xed,0x77,0x86,0xfe,0xf5,0x82,0x95,0x80,0x67,0x3d,0x1f,0x48,0x0a,
	0x6f,0xa0,0x05,0x44,0x1c,0x29,0xc7,0x5c,0x2b,0xdf,0x63,0x92,0xa6,0x00,0x68,0xc8,
	0x1f,0xb6,0xd6,0x31,0x79,0x18,0xaa,0x98,0x7f,0xdf,0xa3,0xc3,0xc0,0xf3,0x3a,0xc5,
	0xf0,0x00,0xb1,0xcf,0x89,0x24,0xa1,0x92,0x78,0x92,0x0f,0x78,0x30,0x40,0x01,0x6b,
	0x69,0xb0,0x39,0xc4,0x1b,0x83,0x37,0x78,0x07,0x6b,0x49,0xbb,0x6a,0x77,0x13,0x34,
	0xd0,0x08,0x9d,0x40,0x3d,0xe8,0x44,0x38,0x05,0x1f,0x26,0x04,0x6c,0x99,0xe7,0xbb,
	0xd6,0x3d,0xe5,0x83,0x12,0xff,0xf9,0x76,0x5a,0x78,0x2b,0xdb,0x75,0x61,0x72,0x30,
	0x29,0x1c,0x23,0x32,0xe3,0x3b,0x47,0x08,0x13,0x21,0x6b,0xd4,0x0d,0x57,0x4c,0xef,
	0xef,0xf8,0x38,0x54,0x69,0x17,0xc0,0x04,0x10,0x2c,0x2d,0xcd,0x25,0xa9,0x30,0xc6,
	0xfd,0xa4,0x7b,0x0c,0xa1,0x97,0xc7,0xb8,0xe7,0xe0,0x24,0x6f,0x91,0x9d,0x87,0x81,
	0x4f,0xaf,0x0b,0xef,0xf6,0x9a,0x59,0xc6,0x51,0x82,0x55,0xdf,0xbe,0xc1,0x20,0x72,
	0xd0,0x96,0xd8,0xd8,0xab,0xfc,0x05,0xb0,0xd4,0x42,0x68,0x66,0x2f,0xa6,0xeb,0xf0,
	0x07,0x60,0x39,0xc1,0x69,0x5a,0x40,0xbd,0xa7,0xcf,0xec,0x04,0xe9,0xfa,0x30,0xf1,
	0x17,0xc9,0x6f,0x77,0x84,0xb2,0x27,0xce,0x2a,0x04,0xb5,0xce,0xc7,0x1f,0xfc,0xbf,
	0x04,0x1c,0xbc,0xfc,0xd1,0x46,0x44,0xfd,0xde,0xff,0xf2,0xbd,0x39,0x34,0xd4,0x1a,
	0xeb,0xae,0xba,0xeb,0xbe,0xff,0x80,0x64,0xbf,0xf3,0x8a,0xf8,0x0e,0xc3,0xd4,0x93,
	0xb5,0x78,0x56,0xe8,0x7c,0x42,0x6a,0xbc,0xff,0x0a,0xf2,0xc8,0x22,0x2b,0x3f,0x21,
	0xa2,0x15,0x61,0x67,0xea,0x0f,0xf0,0x03,0xf9,0xb4,0x46,0x6a,0x3e,0x0e,0x85,0x11,
	0xc3,0x9a,0x61,0x81,0xb6,0xab,0x3e,0xe1,0xff,0xc3,0xdd,0xc6,0x89,0x54,0xaf,0xbf,
	0x07,0xf8,0x70,0x0f,0xf3,0xc2,0xbe,0x00,0x2b,0xac,0xe2,0x00,0x14,0x05,0x3c,0xc1,
	0x61,0x45,0x26,0xd2,0x73,0x5f,0xfc,0xfb,0xc3,0x7f,0xc3,0xc3,0xfc,0xf0,0xaf,0x80,
	0x0c,0xa4,0xe0,0x64,0x32,0x02,0xb4,0xa6,0xed,0x81,0x63,0x25,0x8d,0x19,0x6f,0x6d,
	0xaf,0x87,0x00,0xff,0xe0,0x87,0xc0,0x0f,0xe6,0xd1,0x19,0xa8,0xfb,0xe0,0x1e,0x1f,
	0x82,0x0e,0x07,0x89,0x34,0x87,0xa0,0xf3,0xa7,0x62,0xbe,0x01,0xb9,0x7f,0xf1,0x30,
	0xc0,0x86,0x43,0xdc,0xd1,0x5a,0xbc,0x3b,0x74,0x3c,0x22,0x8f,0x60,0x33,0xb8,0x5b,
	0x57,0x37,0xe8,0x3f,0xe0,0x0f,0x12,0x00,0x41,0xcb,0x28,0xba,0x5b,0xc0,0x70,0x0d,
	0x47,0xff,0x87,0xe0,0x4f,0x02,0xb1,0xd2,0x98,0xe2,0xc9,0x79,0xbf,0xb6,0xdb,0x13,
	0x41,0x51,0x0f,0xd7,0xaf,0xfe,0xf7,0xfc,0xbf,0xff,0xc3,0xde,0xc6,0x92,0xa5,0x54,
	0x0c,0x3a,0xeb,0xae,0xba,0xeb,0xae,0xbe,0xf0,0x50,0xf8,0x38,0x77,0x08,0xb8,0xcf,
	0xc8,0x01,0x24,0x9a,0x39,0x90,0x64,0xb7,0x44,0xbb,0x01,0x0f,0xb9,0x49,0x18,0xd4,
	0xcc,0x73,0xdd,0xf3,0xec,0x62,0x59,0x59,0xe8,0xba,0x65,0x16,0xfe,0xa5,0x71,0x9c,
	0x25,0x2e,0xd5,0xeb,0x1c,0x05,0x20,0x16,0x65,0x30,0xdd,0xdb,0xf6,0x1a,0x11,0x6a,
	0x59,0x4c,0x3d,0xf3,0xf3,0xf0,0x01,0x95,0xaa,0xf9,0xef,0xf7,0x64,0x86,0xc0,0x8b,
	0x69,0x12,0x4b,0x07,0x3e,0xdb,0xbf,0xdb,0x13,0xc3,0xb0,0x3f,0xcc,0x68,0xa2,0x48,
	0x0d,0xb2,0xf7,0x02,0x49,0xda,0x45,0x0b,0xdc,0xa3,0xc5,0xdc,0x51,0x00,0x6a,0x18,
	0x91,0xb9,0x71,0xee,0x24,0xd1,0x7a,0xe1,0x60,0xf8,0x7f,0xbb,0x24,0xbd,0x66,0xf1,
	0x5f,0xd8,0x34,0x76,0x85,0x49,0xc4,0x24,0x5f,0xfb,0x7b,0xa0,0xef,0x50,0x98,0xcf,
	0x20,0xf3,0x83,0x6b,0xc6,0x0e,0x92,0x29,0x04,0xff,0x9b,0x1f,0x95,0x3d,0x6c,0x89,
	0x4a,0x2d,0xaf,0x70,0x11,0x43,0x7b,0x75,0x61,0x58,0x3a,0x96,0xf2,0xb1,0xe3,0x30,
	0xbe,0x8c,0x97,0x10,0x90,0xff,0xd6,0xd8,0x1e,0x23,0x19,0xe8,0x74,0x8f,0x8c,0x63,
	0xaf,0xfc,0x7a,0x8e,0x04,0x9e,0x98,0x87,0x7b,0x7c,0x9b,0xeb,0xfc,0x89,0x40,0x39,
	0x06,0x2b,0xdf,0x6c,0xc4,0xcb,0xff,0x40,0x99,0xa2,0x49,0x2f,0x38,0x46,0x33,0x6c,
	0x6c,0x50,0x09,0x8d,0x16,0x5f,0x56,0x87,0x9a,0x91,0x10,0x39,0x5a,0xd5,0xfa,0x3f,
	0x94,0x26,0x06,0xa2,0x4b,0xd2,0xa1,0x7e,0xdc,0xfc,0x0e,0x00,0x16,0x8c,0x1f,0x82,
	0x15,0x8b,0xad,0x2d,0xe2,0xa0,0x16,0xcd,0x95,0xe6,0x43,0x44,0xb6,0x3c,0x29,0xc1,
	0x6d,0x85,0x4c,0xbf,0xb4,0x00,0x00,0x08,0x01,0xc1,0xdd,0x96,0xf1,0x12,0xb3,0xb6,
	0xbe,0x00,0x00,0x1d,0xeb,0x2e,0xaf,0xaf,0x70,0xc0,0xfb,0x80,0x2d,0x96,0xd9,0x18,
	0x0a,0x0b,0x8b,0xb8,0x57,0x88,0x94,0x6c,0x13,0x19,0xca,0xa0,0xa2,0xf0,0x53,0xd3,
	0x30,0x91,0x68,0x91,0x6e,0x17,0x28,0xca,0x5f,0xe1,0x51,0xef,0x24,0x11,0xee,0xc7,
	0xb0,0x57,0xbe,0x0a,0x9a,0x3a,0x1f,0xfc,0x06,0xc5,0xe1,0xca,0x23,0x96,0x4b,0x0f,
	0x57,0xa8,0xe2,0x1d,0xf9,0xd1,0xd1,0xff,0xd4,0xd8,0x4e,0xe0,0x94,0x85,0x31,0x4f,
	0x1e,0xdf,0xff,0x8d,0x52,0xa5,0x25,0x86,0x1f,0xed,0x3d,0xee,0x84,0x1e,0x2f,0x80,
	0x77,0x03,0x10,0x79,0x71,0x46,0xd1,0x17,0x8e,0x0a,0xef,0x81,0x6c,0x10,0x8c,0xa3,
	0xf8,0xb1,0xbb,0x38,0xf2,0xf1,0x8c,0xe8,0x4d,0x49,0x46,0xad,0x33,0x7c,0xed,0x26,
	0x8b,0x60,0x7b,0x76,0x0a,0xce,0xa0,0x35,0x1c,0x80,0x30,0xda,0x5c,0xb4,0xd2,0x8c,
	0x40,0x14,0xee,0x46,0x81,0xa7,0xec,0xb2,0x4b,0xa0,0xef,0xa4,0x51,0x98,0x51,0x8b,
	0x48,0xb9,0xda,0xd6,0x17,0x0a,0xc9,0x58,0x8a,0x67,0xfe,0xad,0xc1,0xa5,0x57,0xdf,
	0xc1,0xbc,0xff,0x8d,0x93,0x44,0xd3,0xf3,0xf9,0x54,0xcc,0x2e,0xf8,0x07,0x13,0xf1,
	0x46,0x13,0x9a,0x91,0x4e,0x10,0x91,0x4c,0xc7,0x1a,0xae,0xcc,0x84,0x00,0x21,0x9a,
	0xba,0x55,0xfd,0x96,0x10,0xb1,0x8d,0xeb,0xb4,0x4d,0xbf,0xf3,0x79,0x10,0xf5,0xff,
	0x84,0x80,0x45,0x7c,0x9e,0xaf,0xc6,0x19,0x9b,0x36,0xf8,0x06,0xd2,0x76,0xf7,0x62,
	0x21,0x67,0xad,0x14,0x2a,0x7d,0x7f,0xdd,0xa0,0x99,0x89,0x94,0xc2,0xc2,0x6b,0x78,
	0x01,0x27,0x61,0xdf,0x59,0x87,0xaf,0x4b,0xf7,0xf0,0xf8,0x32,0xa7,0xe7,0xf8,0x72,
	0x8b,0xbf,0x58,0x5c,0x10,0xc8,0xc1,0xa8,0x8d,0x8d,0x0b,0xc0,0x97,0xe6,0x00,0x45,
	0x12,0x3f,0xcc,0xc2,0xda,0xcf,0x4a,0x06,0x68,0x5d,0xf3,0x09,0x16,0x53,0x54,0x6c,
	0x06,0xf3,0x07,0x04,0x7a,0xb1,0x61,0x0f,0x15,0xff,0x9d,0xca,0x66,0x90,0xee,0x4a,
	0xb5,0x93,0xb0,0x78,0x27,0xc2,0x57,0xaa,0xdf,0x44,0xfb,0xc1,0x80,0x8e,0x38,0x98,
	0x06,0x41,0x5a,0x2a,0x9f,0x60,0xc0,0x60,0x34,0x92,0x50,0xf8,0x3f,0xfa,0x2e,0xe7,
	0x6b,0x69,0xd0,0xe0,0xf4,0x91,0x5c,0x79,0x77,0xd8,0xd5,0x0c,0xae,0x84,0x29,0xdb,
	0xdf,0xc0,0xe0,0x5b,0x0b,0x5d,0x6d,0xc9,0x7b,0x97,0x0d,0x02,0x0f,0xf7,0x0c,0x62,
	0xd7,0x93,0x91,0xf6,0x86,0x41,0x65,0x09,0xcc,0x57,0x38,0x4f,0x15,0x80,0x0d,0x90,
	0x31,0x2b,0x71,0x39,0x3c,0xf1,0x69,0x8a,0x69,0xd0,0xd6,0x41,0x3f,0x9f,0x5a,0x8f,
	0x36,0xe4,0xa0,0x17,0x01,0x9f,0x28,0x34,0xb7,0x58,0x14,0x45,0x3d,0xa1,0x77,0xc5,
	0x10,0x71,0x7d,0xa1,0xe3,0xdd,0xb3,0x71,0x46,0xd4,0xdf,0x87,0x7d,0xef,0x56,0x0a,
	0x99,0x8b,0x86,0x3e,0xfa,0x97,0x20,0x8c,0x48,0x03,0x93,0xb9,0x1f,0xbc,0x04,0x47,
	0x4d,0x20,0x22,0x16,0x96,0xb4,0xbb,0x08,0xfa,0x8c,0x8f,0x1a,0x46,0x3d,0x6a,0xec,
	0x26,0x75,0x00,0xd8,0x40,0x84,0x7e,0xd3,0xdf,0xab,0x0d,0x22,0x7c,0x3e,0x99,0x0d,
	0x51,0xff,0xad,0x80,0x54,0x5e,0x98,0x39,0x8a,0x19,0xa3,0x76,0x7b,0xf7,0x20,0x59,
	0x34,0x75,0x50,0x8f,0x6b,0x7c,0xc7,0x46,0x01,0xdc,0xc9,0x18,0xa0,0x40,0xfa,0x1d,
	0x06,0x36,0x4d,0x13,0x4f,0xcf,0x80,0x00,0x06,0xff,0x7b,0xe9,0x6f,0x48,0x92,0x87,
	0x08,0xfd,0xff,0xc2,0x70,0xee,0xc1,0x04,0x83,0x78,0xd5,0xda,0xdb,0xdd,0xb1,0xb4,
	0x48,0xda,0x9b,0xfe,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
	0xfb,0xef,0xbe,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
	0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
	0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
	0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
	0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
	0xae,0xbc
};
unsigned char MPEG4_Playback_black_Spanish_QVGA[] =
{
	0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xf4,0x0a,0x0f,0xc8,0x00,0x00,0x00,0x01,
	0x68,0xce,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x02,0x13,0x14,0x00,0x04,
	0x37,0xef,0xbe,0xfb,0xef,0xbe,0xfb,0xef,0xbe,0xfb,0xef,0xbe,0xfb,0xef,0xbe,0xfa,
	0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
	0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
	0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
	0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
	0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xff,0xff,0x87,0x0a,0x78,
	0x00,0x3c,0xb8,0x8c,0x23,0xd4,0x08,0xf5,0x8f,0x25,0xf4,0xc0,0x16,0xce,0x99,0x00,
	0x1b,0xe6,0x8c,0x08,0x46,0x28,0xb5,0x97,0x99,0x5f,0xfa,0x03,0xd2,0xd1,0x7f,0x52,
	0x39,0xb0,0x37,0x67,0x17,0x44,0x7e,0xfe,0xf0,0x4c,0x00,0x2e,0x64,0x37,0x89,0x4c,
	0x12,0xcb,0x0b,0x7b,0xf5,0xb6,0xbc,0x09,0x90,0xc6,0xc0,0x02,0xb0,0x0f,0xde,0xe2,
	0x90,0xc5,0xae,0x95,0xb1,0x3e,0x84,0x88,0xfe,0x03,0x71,0xb1,0xcc,0x3d,0xa0,0x57,
	0x74,0x8d,0x9a,0x60,0x0c,0xf4,0x30,0x7d,0x04,0x93,0x98,0x58,0x9b,0xfe,0xfe,0xd1,
	0xcc,0x92,0x54,0x7b,0xff,0xd3,0x0c,0x2b,0x00,0x3c,0xc8,0x09,0x9c,0x74,0x68,0x98,
	0x6d,0x51,0x8e,0xfe,0x01,0x07,0x14,0xf1,0x72,0x0c,0x31,0x4d,0xff,0x2a,0x70,0x82,
	0x51,0x1a,0xe5,0xf1,0x6f,0x9d,0x97,0xf5,0x81,0x32,0x3e,0x76,0x09,0x4d,0x19,0x7a,
	0xbf,0x2e,0x38,0x76,0x63,0x2a,0x15,0x81,0x6e,0x0e,0xfb,0x41,0xcb,0x03,0xc3,0xbc,
	0x26,0x29,0xd2,0x05,0x16,0x86,0x5d,0xb1,0xc9,0x60,0xe1,0x73,0xa4,0x9b,0x16,0x20,
	0xd2,0x4d,0x11,0x07,0xf4,0xc9,0xdf,0xf5,0xd3,0x15,0xbf,0x00,0x0a,0xe5,0x79,0x43,
	0xe7,0x41,0x50,0xad,0xa8,0x40,0x1a,0x87,0x28,0xa1,0x72,0xc0,0xc2,0x46,0x3c,0x18,
	0x9b,0x6d,0x30,0x43,0x55,0xe9,0xa2,0x1b,0x3a,0x3d,0x47,0xa2,0x02,0x88,0x74,0x9a,
	0x40,0x9a,0x9c,0xe4,0x1a,0xcd,0xdd,0xb2,0x54,0x6b,0x65,0x91,0x67,0xe0,0x44,0xae,
	0xd2,0x0f,0x57,0x43,0xa0,0x7e,0x6a,0xc2,0x8e,0x7f,0x7c,0x06,0xc8,0x80,0xe9,0x68,
	0x23,0xda,0x86,0x00,0x8e,0x75,0x47,0xe0,0x5c,0xf0,0x13,0xd8,0x30,0x87,0xfb,0x47,
	0x26,0x01,0x41,0x34,0xc1,0x45,0x78,0xa3,0x19,0xff,0xc5,0x91,0x53,0x0a,0xc1,0x11,
	0x00,0xd4,0x3c,0x0a,0xff,0xed,0x06,0xb8,0x06,0x0c,0x74,0xec,0x59,0x03,0x25,0x96,
	0xeb,0x8d,0xb6,0x92,0x6d,0x80,0x2a,0x02,0x64,0xc2,0xbe,0xff,0xf9,0xd0,0x42,0xa1,
	0x5e,0x85,0x04,0x57,0xe4,0x38,0xe8,0x13,0xa0,0xd0,0xed,0xfd,0x00,0x23,0xd8,0x34,
	0xe7,0x80,0x98,0x01,0x4f,0x70,0xb5,0x65,0x07,0xfb,0x7b,0xd3,0x07,0x3b,0x0c,0xa9,
	0x8e,0x09,0x5d,0x62,0x3f,0xd2,0xc0,0x21,0x55,0xd2,0x95,0xcd,0xe3,0x41,0xab,0xfe,
	0xb5,0x3d,0x1a,0x15,0x82,0xf6,0x12,0xbd,0xe8,0x08,0x72,0xdf,0xeb,0x9f,0xe2,0x21,
	0x5f,0xc6,0x26,0x16,0x73,0x9f,0xae,0x27,0x1b,0xe3,0x1b,0x1a,0xac,0x68,0x70,0x00,
	0x77,0x35,0x84,0x37,0x27,0x12,0x58,0xf3,0x56,0x02,0x13,0x30,0x14,0x9b,0x05,0xe2,
	0x6c,0xc3,0x3f,0xb6,0xe3,0x40,0x2e,0x62,0xf3,0xa5,0xd7,0x70,0x7d,0x0c,0x88,0x2d,
	0xab,0xc9,0x3f,0x61,0x17,0xf0,0xc1,0x6a,0x6e,0xf1,0x7e,0x00,0x1b,0x43,0xbf,0x25,
	0x32,0x0a,0xb5,0x7c,0xe1,0xa1,0x02,0xe2,0x7e,0xbe,0x1f,0x3f,0x00,0x08,0xe8,0x10,
	0x3f,0x4f,0x84,0xd3,0x0e,0x76,0x98,0x7a,0x03,0xbb,0xa9,0x1e,0x6b,0x70,0x1d,0xf5,
	0xad,0x81,0x71,0x73,0x37,0x48,0x25,0x5d,0x4f,0xfc,0x06,0xb4,0xc8,0x90,0x00,0x45,
	0x7d,0x41,0x65,0xff,0x60,0x16,0x4c,0x05,0x75,0xdc,0x55,0x16,0xc5,0x1d,0x68,0xa1,
	0x9d,0x01,0x0f,0xed,0xc2,0xec,0xdb,0xeb,0xda,0x12,0x30,0x9d,0x7f,0x17,0xaf,0x35,
	0x83,0x7f,0xf5,0x44,0x45,0x46,0x85,0x76,0x8b,0xe3,0x9c,0x33,0xad,0x62,0x52,0x70,
	0x05,0x66,0xe1,0xd8,0x22,0xe3,0x07,0xbc,0x99,0x0f,0xfd,0x6b,0xd1,0x18,0x4b,0x50,
	0xe4,0x73,0x44,0x75,0x84,0x82,0x31,0xa3,0xe9,0x47,0x7e,0xee,0x21,0x3a,0xa6,0x75,
	0xc3,0x99,0xea,0x0d,0x1a,0xfd,0x60,0x6d,0xa2,0x60,0x39,0xb4,0x39,0x7c,0xb7,0xb1,
	0x7c,0x82,0xe8,0x94,0x66,0x96,0x94,0x33,0x33,0xc8,0x9a,0x04,0xcb,0xdb,0xfe,0xa2,
	0xae,0x31,0xc6,0x78,0x00,0x6d,0x0e,0xfc,0x94,0xc8,0x2a,0xd9,0xf0,0x16,0xa0,0x57,
	0xa8,0x07,0x96,0xc8,0x21,0xfb,0x60,0x04,0x3c,0xa3,0x5f,0x27,0xf7,0x47,0x4d,0x79,
	0xdd,0xce,0x35,0x64,0x62,0x34,0x5c,0x60,0x2c,0x15,0xff,0xff,0x82,0x28,0x2a,0x52,
	0xa5,0x72,0x4c,0x82,0x61,0xfb,0x60,0xad,0x81,0x87,0xe4,0x28,0x98,0x2d,0x8e,0xe8,
	0x60,0x03,0xe9,0xe1,0x94,0x31,0xce,0xc2,0x6e,0x40,0x90,0x32,0xf0,0x5a,0x66,0x59,
	0x70,0x84,0xe4,0x51,0xa9,0xa9,0x23,0xc9,0xaa,0x8f,0xbf,0xe6,0xa2,0xfc,0x61,0x58,
	0x0b,0x8f,0x22,0x71,0x8e,0xe7,0xa6,0x5c,0x2e,0xd5,0xa9,0x06,0x22,0x51,0xc6,0xaa,
	0x9c,0x7f,0xeb,0xcf,0x48,0xd0,0x1d,0x22,0x01,0xf9,0x70,0x6b,0x96,0x9e,0x32,0x20,
	0x11,0x84,0x84,0xf3,0xc9,0xdf,0x9b,0xa9,0x71,0x9f,0x90,0x02,0x4d,0x30,0x16,0x93,
	0x31,0x78,0xf9,0xda,0x00,0x23,0x83,0xe0,0x39,0x01,0x64,0xab,0xea,0x51,0x2d,0xed,
	0x39,0xff,0x1d,0xae,0x98,0x57,0xc3,0x23,0x85,0x50,0x35,0x93,0x2b,0x24,0xf4,0x7d,
	0xe5,0x93,0x05,0x63,0x92,0x9d,0x02,0xd8,0xc1,0x0d,0x36,0x43,0x71,0x8b,0xc5,0xa0,
	0xb2,0x8b,0x35,0xf7,0xb4,0x26,0xc4,0xc3,0xfc,0x7b,0x4b,0xd8,0x46,0x91,0x3b,0x41,
	0x94,0x23,0xa5,0xa2,0x52,0x00,0x9c,0xf0,0xf1,0x9f,0x46,0x1d,0x98,0x3f,0xaa,0x3d,
	0x11,0x89,0x6e,0x2a,0x19,0x82,0x39,0x05,0x8c,0x98,0x01,0x79,0x2f,0x7e,0x77,0xfd,
	0x58,0x9e,0x1d,0xf8,0x00,0x43,0x29,0x66,0x7a,0x16,0x55,0xdd,0x0e,0x86,0x8c,0x58,
	0xe4,0x63,0x3c,0x1a,0x00,0x49,0x6c,0x1f,0x4c,0x09,0xa1,0xae,0xef,0x1b,0x22,0xf6,
	0x18,0xe9,0x04,0x5a,0x28,0x59,0xaf,0xc2,0x00,0x87,0x66,0xa9,0x6b,0xef,0x84,0x93,
	0xe4,0x22,0x3a,0xf4,0xa4,0x14,0x64,0xba,0xb6,0xa1,0xb2,0x35,0xa1,0x35,0xe8,0x42,
	0xd0,0x48,0x45,0xc0,0x0f,0xec,0x8c,0x31,0xa1,0x86,0xa0,0x3a,0xf2,0xaf,0x87,0x33,
	0x4c,0x24,0xe5,0xea,0xc4,0xe9,0x32,0x5e,0x89,0x93,0x60,0x6a,0xf8,0xe6,0x9f,0x07,
	0x8d,0xff,0xd7,0xba,0x3c,0x2b,0xad,0xfa,0xfe,0x7b,0xfd,0xc0,0x67,0x70,0x03,0x82,
	0x3d,0xef,0x6a,0x94,0x01,0x1c,0x9a,0x5d,0xa9,0xc3,0x9f,0xdc,0xe2,0xc6,0x98,0x36,
	0xad,0x08,0x41,0xaa,0xdd,0xc0,0x28,0xe9,0x8c,0x77,0x81,0xb5,0x72,0x95,0xe8,0x04,
	0x5f,0x24,0x88,0x8b,0xd0,0xe3,0x40,0x9c,0xd2,0x97,0x50,0x11,0xd4,0xf8,0x3d,0x74,
	0xab,0x84,0x44,0x62,0x45,0x70,0xe4,0x52,0x7e,0xcf,0xf7,0xfd,0xd0,0x02,0x29,0x85,
	0x7e,0xc9,0x92,0x61,0x68,0xba,0x15,0x54,0xe9,0x4b,0xfa,0x83,0xd6,0x9e,0xfc,0x34,
	0x13,0xa3,0xc7,0xb9,0xb1,0x55,0x11,0x04,0x41,0x76,0xf4,0xe3,0x3d,0xcd,0x8f,0xbd,
	0x30,0x4e,0x3a,0x9c,0xc5,0xdf,0x68,0x55,0xd4,0x7d,0x2f,0xf0,0x57,0xe1,0xb1,0x44,
	0x00,0x9d,0xe8,0x78,0x3f,0x1b,0x24,0x29,0xa8,0xd6,0x58,0x51,0xdc,0x84,0xfd,0xc3,
	0x07,0xb6,0x7b,0xfa,0x48,0x0a,0x86,0x19,0x14,0xa6,0xcc,0x60,0xb9,0xf7,0xfc,0x36,
	0x33,0x0c,0x5f,0x80,0x03,0xe4,0x32,0x27,0xd9,0x87,0x71,0x24,0x89,0x35,0x79,0x6c,
	0x03,0x5c,0xc6,0x81,0xbb,0xce,0x85,0x8b,0xd8,0x8d,0x36,0x3e,0x34,0xb9,0xc5,0x7f,
	0x38,0xf6,0x04,0xaa,0xa1,0x1d,0xd8,0x74,0x9a,0x27,0xfd,0xe6,0xa5,0xc0,0x02,0xd0,
	0x1b,0x12,0x7e,0x6f,0x82,0x94,0x2c,0xe0,0x1e,0x24,0xef,0x8d,0x01,0xd1,0x32,0xf2,
	0x05,0x17,0xe4,0x04,0xb7,0x7c,0xe0,0xaf,0x9c,0x24,0x1e,0xa2,0x14,0x5c,0x3f,0x9e,
	0x58,0x6f,0x28,0xdf,0xae,0xeb,0x3d,0x0c,0x8f,0xf9,0x9a,0x00,0x80,0x35,0xf8,0x02,
	0x21,0x86,0xb4,0x3c,0xb7,0x20,0xea,0xc7,0x53,0x93,0x24,0x83,0xab,0xc0,0x70,0x2e,
	0xaf,0x45,0xb5,0x0b,0x46,0xd6,0x16,0xfb,0x1a,0x1c,0x71,0x70,0x47,0x15,0x48,0xfb,
	0x4f,0xb6,0xb2,0xb5,0xcc,0xd8,0x86,0x00,0xac,0xb5,0x5f,0xdf,0x27,0x4a,0x72,0x21,
	0x89,0x94,0x29,0x42,0x29,0xcd,0x8d,0x62,0x98,0xc1,0x2b,0x16,0x69,0x32,0xf8,0xcc,
	0x09,0x88,0xd2,0x0f,0x99,0xcc,0xfe,0x28,0x10,0xb9,0xf9,0x6c,0x52,0xd4,0x49,0x20,
	0x97,0x87,0x3a,0x36,0x62,0xd6,0x50,0xa2,0xef,0x0c,0x7f,0xa0,0x18,0x00,0xd1,0xa3,
	0x38,0x00,0x5c,0xf5,0x02,0x75,0x11,0x4b,0x48,0xb6,0x3d,0x01,0x17,0x8e,0xd2,0xd6,
	0x35,0x7a,0x32,0x9e,0x78,0xe6,0xcf,0x18,0x3e,0x93,0x2a,0x10,0x5b,0xe6,0x01,0x32,
	0xf8,0x71,0xce,0xed,0xf4,0x04,0x6c,0x87,0x01,0x36,0xd5,0x04,0x1e,0x82,0x67,0x6e,
	0x58,0x0f,0x25,0x28,0x84,0xaa,0x34,0x23,0xc7,0x37,0x3d,0x87,0x4a,0x50,0x5b,0x19,
	0x9c,0xeb,0x6a,0x5e,0xb8,0x0f,0xee,0xc4,0x02,0x0c,0xd5,0xff,0x1a,0xf2,0x3d,0xf8,
	0x24,0x22,0xca,0xe1,0x34,0x7e,0xdb,0xc7,0x40,0x8e,0x43,0x56,0x10,0x75,0xd1,0x6a,
	0x08,0xff,0xe8,0xc7,0xf0,0x41,0xc2,0x1d,0x42,0x90,0xb8,0x02,0x2e,0x0b,0x77,0xbc,
	0xd2,0xd7,0xc7,0xbd,0x60,0xed,0x30,0xd7,0x98,0x62,0x4b,0xab,0x90,0xd7,0x5d,0xf7,
	0xfb,0xc3,0x78,0x7f,0xff,0xc3,0x04,0x1e,0x00,0x06,0xac,0x6a,0x48,0xf1,0x8a,0xcf,
	0xfc,0xfd,0x96,0xe3,0xff,0xc2,0x7d,0xad,0xa9,0x8a,0xa1,0xc8,0x72,0x7f,0x7b,0xb1,
	0x54,0x95,0x55,0x7f,0xff,0xf0,0xf8,0x00,0x54,0x73,0xe2,0x49,0x28,0x64,0x9e,0x24,
	0x87,0xcf,0xfc,0x7f,0xe1,0xf0,0x41,0xc0,0x06,0xd3,0x1d,0x84,0x62,0xba,0x5f,0x7b,
	0xc1,0xe3,0xe1,0xff,0xc1,0x0f,0x00,0x06,0xe9,0x93,0x62,0x7c,0x85,0x47,0x64,0x0f,
	0xff,0xff,0x04,0x3e,0x00,0x17,0x8f,0x2a,0x11,0x98,0xa3,0x24,0xf3,0x42,0x3e,0xbe,
	0x01,0xff,0xc1,0x07,0x01,0xf6,0x25,0x22,0x21,0x07,0xc7,0xa5,0x26,0x03,0xc3,0xac,
	0x3f,0xe1,0x4f,0xf3,0xdc,0x43,0xa6,0xa4,0x1e,0xe9,0xf4,0x87,0xc0,0x05,0x31,0xb0,
	0x93,0x88,0x6a,0x4d,0x28,0x9f,0x4b,0xff,0xfc,0x27,0xf2,0x89,0x10,0x31,0x75,0x11,
	0x8c,0xfe,0x62,0x03,0x0f,0x83,0x69,0x8f,0xc2,0x23,0xba,0x5f,0x02,0x26,0xc6,0xc2,
	0x62,0x1a,0x93,0x4c,0x37,0x69,0xe1,0xbf,0xdf,0xef,0x0d,0x75,0xd7,0x5d,0x7f,0xd0,
	0x9b,0xc7,0xc3,0xf0,0x00,0x7c,0x22,0x61,0x89,0x95,0xa7,0xa0,0xf2,0x52,0x02,0xbd,
	0x69,0x80,0xfd,0x40,0xce,0x49,0x6f,0x0a,0x73,0xd0,0xfb,0x82,0xa5,0x94,0xe6,0xc4,
	0x6d,0xe7,0x78,0x3b,0x0d,0x70,0x95,0x6c,0x1d,0xb4,0x7d,0xc9,0xcc,0x0e,0xe6,0x81,
	0x0e,0x1c,0x25,0x03,0x38,0x20,0xff,0x75,0xc4,0x8c,0x2b,0xe5,0x54,0x35,0x87,0x9f,
	0x05,0x84,0x13,0xed,0x47,0x04,0x6f,0xf6,0xa6,0xd0,0x13,0x7a,0xc1,0x56,0xf3,0xab,
	0xbf,0x71,0xc4,0xcc,0x51,0xe3,0x09,0xb6,0xbc,0xf0,0x04,0x8d,0x00,0x3e,0x33,0x5e,
	0xf1,0x6e,0xf0,0x86,0x21,0x10,0x2f,0xec,0x9f,0x65,0xac,0xc0,0xee,0xfb,0x8d,0x6b,
	0x41,0x98,0x72,0xd9,0x29,0x31,0x57,0x8b,0x81,0xbe,0x64,0x88,0x8c,0x3e,0x92,0x45,
	0x7d,0x70,0x0c,0x03,0x84,0xa0,0x0c,0x04,0xbf,0xf0,0xf2,0xbe,0x43,0x86,0xdf,0xe2,
	0x5d,0xe6,0xf4,0xd1,0xcc,0xaf,0xfa,0xc1,0x8b,0x1a,0xec,0xcf,0x74,0x88,0xa7,0xfb,
	0xe6,0x96,0x9c,0x24,0xbd,0xd5,0x58,0x8f,0xdc,0x44,0x1b,0x67,0x24,0x63,0x8c,0x7b,
	0xc7,0x88,0x3d,0xd3,0x40,0x62,0xe7,0x43,0xca,0x09,0x51,0x5f,0x7c,0xb0,0xa2,0xd2,
	0x57,0xa2,0xe7,0xf7,0x7a,0xd9,0x13,0xc8,0x3e,0xcf,0x97,0x6d,0x22,0x84,0xa0,0x1e,
	0x1c,0x25,0xc1,0xa0,0x62,0xbc,0xae,0x1b,0x65,0x7b,0xa5,0x80,0x02,0xe1,0x6c,0x0c,
	0x7c,0x42,0xf5,0x72,0x3e,0x22,0xdc,0x9b,0x20,0xad,0x83,0xea,0xab,0xe7,0x3f,0xfb,
	0xae,0x19,0x94,0x90,0xe3,0x87,0x66,0xb2,0x8f,0xf7,0xd8,0xc2,0x7e,0x7c,0x6a,0x48,
	0x81,0x2a,0xdc,0x63,0x8e,0xf2,0x43,0x1f,0x91,0x61,0x79,0x80,0xa7,0xf7,0x90,0x23,
	0x0f,0x53,0x45,0xe1,0x22,0xac,0xff,0x53,0x85,0x08,0x77,0x11,0xd6,0x7d,0x2d,0xb5,
	0xe3,0x40,0x0c,0x3c,0x25,0xd0,0x59,0x0f,0x8b,0x1c,0x32,0x6f,0x43,0x6d,0xf7,0xf0,
	0x18,0x00,0x65,0x58,0x3f,0x95,0xdb,0x52,0x25,0xfe,0xfe,0xc4,0xc2,0x9e,0x23,0xbb,
	0x2d,0xcd,0xff,0x7a,0x24,0xf0,0x88,0x03,0x90,0xe8,0x6c,0x98,0x4f,0x40,0x0e,0x1a,
	0x74,0x0a,0xdd,0x64,0x13,0x69,0x3c,0xe0,0x77,0x51,0x4b,0x29,0xdc,0xc3,0x42,0xde,
	0x8d,0xe1,0xc7,0xc2,0x23,0x2b,0x7d,0x86,0xbc,0xb7,0x82,0x7a,0x3f,0x91,0x0c,0xcf,
	0x50,0x54,0x2a,0x88,0xf8,0x27,0x87,0x84,0xbc,0x80,0xba,0xf0,0x5a,0xfa,0xc5,0x1e,
	0x97,0x81,0x1d,0xec,0x58,0xe9,0x3e,0x86,0x1d,0x82,0xfe,0xa8,0x87,0x39,0x0f,0x89,
	0x0e,0xa6,0x43,0x42,0x56,0x2e,0xc0,0xce,0x12,0xf6,0x38,0xc5,0xf2,0x4d,0x9f,0xbe,
	0xe8,0x3c,0xe5,0x1c,0x8e,0x1b,0x65,0xfb,0x84,0xb2,0x79,0xf6,0xbe,0x4c,0xc2,0x6b,
	0x61,0xe9,0xb1,0x6a,0x7f,0xf7,0x6f,0xcd,0x73,0x97,0x33,0x44,0x00,0x0f,0x80,0x70,
	0x94,0x00,0x6a,0x14,0x41,0x1e,0xaf,0xf8,0x16,0xcd,0x78,0x6b,0x8f,0x19,0x11,0x65,
	0x14,0xe6,0xa6,0xda,0x19,0xed,0x6a,0x44,0x01,0x99,0x44,0x65,0xe9,0x5c,0xee,0x68,
	0x83,0x2e,0x7a,0x1c,0x33,0x79,0xd1,0x08,0x7d,0xc1,0x24,0x89,0xd8,0x5c,0x08,0xe7,
	0xeb,0x66,0x7e,0xb0,0x74,0x6a,0x49,0x2a,0xeb,0x29,0x83,0x5d,0xfb,0x4e,0x9c,0x20,
	0x92,0xfb,0x97,0xe1,0x17,0xd6,0x48,0xe6,0x02,0x15,0xb5,0x8a,0xf3,0xfe,0x57,0x34,
	0x0b,0xd6,0x18,0x78,0x4a,0x00,0xe0,0x49,0xe6,0x16,0x8d,0x87,0x2c,0x5f,0x10,0xce,
	0x6f,0x0f,0x11,0xef,0x22,0x35,0xbd,0xc1,0x18,0xb9,0x1d,0x20,0x67,0x27,0xdb,0x1b,
	0x1b,0x35,0x0e,0x0d,0xa4,0x2d,0xff,0xe8,0x07,0x50,0x6f,0x13,0x6c,0x1a,0xcd,0x1a,
	0xd7,0xde,0x5d,0xa0,0x33,0xae,0x09,0xee,0x4b,0x04,0xaf,0xcd,0x85,0x7a,0x18,0x55,
	0xe5,0xfb,0x2a,0xd8,0xcb,0x89,0x5a,0xc9,0x1b,0x28,0x91,0xdd,0x61,0x34,0x00,0x20,
	0xe4,0xdc,0x57,0x44,0x61,0x62,0xc2,0x39,0xc8,0x1c,0x9f,0x0a,0x40,0x4e,0x45,0x00,
	0x21,0x48,0x59,0xf3,0x52,0xbe,0xbe,0xc1,0x19,0x52,0x0e,0xb3,0xbb,0x33,0x7b,0xdc,
	0x21,0xb4,0x4c,0x3f,0x12,0x6d,0x29,0x6d,0x8f,0xc0,0x27,0x07,0x8e,0x85,0x5e,0xc1,
	0x0a,0x1f,0x95,0x44,0xb8,0x82,0xb5,0xa0,0x89,0x4d,0x15,0xa7,0x3c,0x7f,0xfe,0xa2,
	0x50,0x3c,0x4c,0x7c,0x0c,0x63,0xf2,0xf1,0x20,0xd4,0xeb,0x06,0x23,0x0a,0x4c,0x55,
	0x81,0x60,0xb7,0x88,0x84,0x1a,0xad,0xc3,0xce,0xf3,0xbb,0xc3,0x20,0xd2,0x47,0x29,
	0xc5,0x0d,0xbc,0x3a,0x28,0x19,0x39,0x83,0xbe,0x21,0xc2,0x5f,0x43,0xf7,0xb2,0x8c,
	0x76,0x1b,0x29,0x7b,0xc2,0x35,0x9e,0x56,0x38,0xb6,0xca,0x37,0xbd,0xdf,0xff,0x39,
	0xe1,0x33,0xa3,0x07,0xb7,0x08,0xca,0x0d,0xc5,0xaf,0xc1,0x04,0x8b,0x40,0xfb,0xe6,
	0x70,0x6b,0xe0,0x09,0x04,0xd9,0xcc,0x0b,0xd4,0x9d,0x79,0x64,0xe0,0x19,0xaf,0x60,
	0x8a,0x4e,0xc3,0x38,0x59,0x16,0x6b,0x6c,0x07,0x60,0xeb,0x9f,0xc2,0x58,0x4c,0x21,
	0xf8,0xb4,0x62,0xdf,0xe5,0x6a,0x61,0x59,0xeb,0xb5,0xdc,0xec,0x01,0x87,0x84,0xb8,
	0x16,0x4f,0x8b,0x46,0x2f,0xf1,0xa2,0x9f,0xf9,0xda,0x66,0xf3,0x01,0xc2,0x46,0x17,
	0x02,0xd7,0xde,0xca,0x47,0x08,0x59,0x57,0xed,0x75,0xff,0x79,0x13,0x9c,0x53,0xc8,
	0x07,0x4a,0x37,0x00,0x22,0x48,0xe2,0x21,0xea,0x9a,0xf3,0x89,0xd1,0xa2,0x3c,0x23,
	0x1a,0x30,0xe4,0x29,0x06,0xa8,0xb5,0x06,0xea,0xc6,0x86,0xa9,0x87,0x61,0xf5,0xc1,
	0x0e,0xf5,0x93,0x0e,0xaf,0x6c,0xb0,0x22,0x9f,0xe6,0xba,0xab,0x6b,0xff,0x84,0xbd,
	0x64,0x21,0x4f,0x33,0x9a,0xd1,0xab,0x91,0x8a,0x9a,0xc6,0x27,0xe6,0x77,0x0b,0x1a,
	0x67,0x16,0xbd,0xf1,0x82,0x98,0xe4,0x3c,0x1a,0xe4,0xe5,0x60,0xc2,0x49,0x43,0xb4,
	0xd5,0xed,0xa5,0x0c,0xbe,0x0a,0x13,0x55,0xa8,0x1e,0xde,0x53,0xa7,0xae,0xba,0xeb,
	0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
	0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
	0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
	0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
	0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
	0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xc0
};
unsigned char MPEG4_Playback_black_Japan_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xda,0x05,0x07,0xe4,0x00,0x00,0x00,0x01,
    0x68,0xce,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x11,0xff,0xff,0x87,0xa2,
    0x80,0x00,0x80,0x8f,0xbc,0x56,0xf7,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,
    0x7d,0xf7,0xdf,0x7d,0x62,0xb5,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xad,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0xc4,0x02,0xb7,0x0c,0x3e,0x26,0x02,0x33,0x7c,0xfc,0xd6,0xc3,0xa4,
    0xc8,0x80,0x31,0x92,0x85,0xf3,0x71,0x40,0x48,0xce,0x83,0x90,0x26,0xe6,0x07,0x56,
    0xbb,0x15,0x18,0x8b,0xe0,0x03,0xe2,0x8d,0x00,0x40,0x3b,0x5f,0x61,0x97,0xd7,0xff,
    0x27,0xb6,0xc1,0x68,0xcc,0x00,0xe4,0x6e,0x41,0x09,0xf6,0x57,0x80,0x01,0xed,0xeb,
    0x00,0x84,0x85,0x89,0xdc,0x94,0x7b,0x7e,0xc9,0xb6,0x8c,0x30,0xcc,0xc2,0xdc,0xf6,
    0xfd,0x00,0x2b,0xe6,0xc5,0x2d,0x7b,0x72,0x18,0xbb,0xbe,0x6e,0xf3,0xf4,0xb1,0xe4,
    0x14,0x93,0xde,0xbd,0x0c,0x50,0x11,0x67,0x52,0x06,0x9e,0x5e,0xb7,0x2d,0xe9,0x5c,
    0x09,0x8a,0xed,0x4f,0xb7,0xd1,0x52,0x5c,0xf4,0x2a,0x40,0x2f,0x47,0xed,0x11,0xee,
    0xdd,0x6d,0x70,0x2b,0xc8,0x2b,0x26,0x23,0xbd,0x5b,0x26,0xc0,0xa7,0x72,0x3e,0xcb,
    0x83,0x9a,0xa3,0x92,0xcd,0xbe,0xf3,0xe7,0xa4,0xa2,0x20,0xcf,0x79,0xe7,0xde,0xec,
    0xe1,0xde,0x03,0x03,0x37,0x7b,0x30,0x46,0xc5,0x0e,0xca,0xbc,0x8c,0xc6,0xc7,0x81,
    0xbc,0xdc,0xf8,0x1a,0xb0,0xb7,0x22,0x95,0x03,0x90,0xe3,0x97,0x8c,0x91,0x9d,0x6f,
    0xa8,0x1f,0x13,0xde,0xe3,0xf0,0xdc,0x00,0x8a,0x03,0x64,0x1b,0x9e,0xd6,0x0b,0x72,
    0x08,0x1d,0x1a,0x3d,0x66,0x44,0xd1,0x81,0x1c,0x00,0x59,0xb6,0x52,0x1e,0x26,0xd0,
    0x1d,0xef,0xa0,0x3f,0xd2,0x57,0x21,0x13,0x24,0x0c,0xf0,0x03,0x08,0xe8,0xa6,0xd1,
    0x80,0x03,0x18,0x91,0x66,0x0c,0x81,0xd0,0x40,0x0d,0xe4,0x41,0x58,0x6b,0x1e,0xef,
    0x01,0xf5,0x1e,0xcc,0xc7,0x70,0x33,0x00,0xc4,0xde,0xdc,0x5a,0xae,0xd4,0x55,0xef,
    0xb8,0x90,0xb6,0x34,0x8d,0x36,0xdf,0x80,0x04,0xe9,0x59,0x8f,0xb1,0xb3,0x95,0x91,
    0x4e,0xb7,0x49,0xff,0x68,0x5f,0x03,0x76,0x1d,0x02,0x22,0x74,0xbf,0xc0,0x03,0x36,
    0xdb,0xd1,0x4d,0xa6,0xad,0xbb,0xe0,0x46,0x94,0x79,0xbd,0x77,0xbb,0x42,0x90,0x8c,
    0x7e,0xae,0xb8,0x6e,0xf6,0x3b,0x10,0xff,0xb7,0x03,0xf2,0x55,0x07,0xaa,0x8a,0x70,
    0xbc,0x00,0x28,0x7d,0xa6,0xf3,0x28,0xd2,0x59,0x22,0x30,0x1f,0x26,0x8f,0x5b,0x24,
    0x33,0xed,0x1c,0xf4,0x36,0xec,0x16,0x63,0x9c,0x68,0xc4,0xe4,0x52,0x93,0x1c,0x19,
    0xf5,0x42,0x9f,0x7d,0x3b,0xc9,0x11,0x22,0x5a,0xbd,0xe1,0x83,0x65,0x68,0x7a,0x26,
    0x39,0xfb,0xbd,0xc4,0x53,0xd7,0x8f,0xef,0xd0,0x65,0x10,0x51,0x70,0xa0,0xf7,0xe0,
    0x03,0x3b,0x64,0xc9,0x32,0x6d,0x0d,0x3f,0x91,0x48,0x5d,0x88,0x31,0x98,0x01,0x63,
    0x10,0x21,0xe7,0x87,0xc1,0xe7,0x88,0x00,0x8e,0xe9,0x54,0xf3,0xdf,0x5f,0xbd,0x83,
    0x37,0x04,0x23,0x82,0x4d,0xf6,0xc0,0x05,0xcc,0x76,0x08,0x86,0xa5,0x40,0xe0,0x45,
    0x94,0xac,0x01,0x9f,0x09,0xdb,0xcd,0x73,0xec,0x06,0xbd,0x5c,0x03,0x20,0x8e,0xfa,
    0x15,0x2a,0x9b,0x4f,0x75,0x46,0x82,0x65,0x06,0x6b,0x77,0x86,0x34,0xcf,0xfc,0x3c,
    0x24,0x50,0xa6,0x13,0x3e,0xd6,0x00,0x05,0xd1,0x99,0x83,0x3a,0x80,0x46,0x83,0x0f,
    0xa2,0x1f,0xab,0x5f,0x9e,0x01,0x32,0x96,0x67,0xa1,0x65,0x54,0x00,0x22,0x2f,0x95,
    0xf5,0xf5,0x88,0xa2,0x51,0x80,0x1b,0xb3,0x62,0x50,0x5a,0x7b,0x1a,0x9f,0x08,0xb8,
    0x3a,0x9d,0x2c,0x00,0x8b,0xee,0xbb,0xa7,0xc0,0x66,0xcd,0x97,0x84,0x1b,0x0b,0x2d,
    0xd7,0xf6,0x95,0xad,0xbd,0x01,0x38,0x23,0x31,0xeb,0x56,0xa6,0x78,0x3c,0x34,0x1f,
    0xbb,0x41,0xd1,0x52,0x60,0x11,0xd8,0x4f,0x2d,0xf7,0x7a,0x04,0x73,0xbb,0xe3,0x91,
    0xab,0x40,0x05,0xdb,0xb8,0x63,0x21,0x22,0xd6,0x7e,0xee,0xc3,0x17,0xef,0xb7,0x79,
    0xfb,0x93,0x8a,0x92,0xb0,0x5a,0x85,0xbc,0x00,0xe4,0x6e,0x41,0x09,0xf6,0x57,0x80,
    0x01,0xed,0xeb,0x00,0x84,0x85,0x89,0xdc,0x94,0x7b,0x7e,0xc9,0xb6,0x8c,0x30,0xcc,
    0xc2,0xdc,0xf6,0xfd,0x47,0xed,0x11,0xee,0xdd,0x6d,0x70,0x2b,0xc8,0x2b,0x26,0x23,
    0xbd,0x5b,0x26,0xc0,0xa7,0x72,0x3e,0xca,0x58,0xf2,0x0a,0x49,0xef,0x5e,0x86,0x28,
    0x08,0xb3,0xa9,0x03,0x4f,0x2f,0x5b,0x96,0xf4,0xae,0x04,0xc5,0x76,0xa7,0xdb,0xe9,
    0xe9,0x28,0x88,0x33,0xde,0x79,0xf7,0xbb,0x38,0x77,0x80,0xc0,0xcd,0xde,0xcc,0x11,
    0xb1,0x43,0xb2,0xb9,0x80,0xc2,0x90,0x4f,0xbe,0x00,0x38,0x36,0x4e,0x86,0x52,0x8a,
    0xa9,0xe0,0x73,0x54,0x72,0x59,0xb7,0xde,0x75,0xe2,0xc3,0x37,0x6a,0xf6,0x51,0xfd,
    0xfc,0x19,0x02,0xdd,0x66,0x25,0xff,0x30,0x11,0xed,0x30,0x4b,0x10,0x53,0xcc,0xab,
    0xfa,0x44,0x86,0x97,0xb4,0x2b,0x0e,0xfb,0x96,0x21,0x18,0x79,0x9c,0x54,0xd3,0x0b,
    0x39,0xfd,0x79,0x19,0x8d,0x8f,0x03,0x79,0xb9,0xf1,0x88,0x9d,0x13,0x1c,0xbc,0x64,
    0x8c,0xeb,0x7d,0x40,0x2c,0x7c,0x25,0xb1,0x49,0xe4,0x15,0x18,0x1e,0x00,0xc0,0x4a,
    0x86,0x5e,0xf3,0x57,0x3b,0x18,0x71,0x41,0x2a,0x15,0x17,0xb0,0xf7,0x77,0x32,0xd9,
    0x40,0xb1,0x16,0x9e,0x95,0x26,0x36,0x10,0x57,0x10,0x1e,0x3f,0x65,0x15,0x4f,0x72,
    0x00,0xbd,0x52,0x3c,0x3b,0xc8,0x8e,0x42,0xe6,0x29,0x09,0x5f,0xd4,0x06,0x25,0xb6,
    0x2e,0x17,0xfd,0xee,0x1c,0xb8,0x90,0xe0,0xe9,0xa5,0xc5,0x3b,0xaa,0xf9,0x6a,0x6c,
    0xc1,0xf3,0x90,0x11,0x42,0x0f,0x57,0xbc,0x00,0xe0,0x2e,0xcc,0x08,0x79,0xe2,0x03,
    0x6d,0x40,0x4f,0x48,0x0a,0xa5,0x77,0x2a,0xb1,0x15,0x76,0x83,0x03,0x59,0xf1,0x6b,
    0xb8,0x60,0xe0,0x00,0x20,0x28,0x01,0x53,0x0c,0x01,0x02,0x99,0x29,0x9a,0x79,0x0d,
    0xf2,0x2b,0x99,0x10,0xe5,0x73,0x58,0x0d,0x33,0x98,0xc7,0xfa,0x60,0x02,0x02,0xb9,
    0x49,0x83,0x5f,0xff,0xff,0x00,0x0d,0xfe,0x0b,0xe3,0x30,0x0c,0x34,0x71,0xd0,0x16,
    0x9e,0x19,0x8b,0x12,0xe2,0xa7,0xbe,0xc2,0x5c,0x90,0x21,0x22,0xcc,0x49,0x80,0xf9,
    0x33,0x20,0x35,0x08,0x82,0x73,0xc1,0x23,0x78,0x58,0x34,0x28,0xfc,0x07,0xda,0x0e,
    0x1f,0xba,0x02,0x10,0x9a,0x02,0x6b,0xec,0x5d,0x99,0x20,0x46,0xca,0x0d,0xe0,0x10,
    0xf1,0xf6,0x38,0x82,0x65,0x58,0x8d,0x97,0xe1,0xff,0xd7,0xb8,0x00,0xa6,0x3d,0xcc,
    0xc7,0x15,0x0e,0x69,0xea,0xf7,0xe6,0x0b,0xdc,0x01,0xd2,0x83,0x71,0x86,0xa8,0xb5,
    0x2b,0x47,0x80,0x0c,0x41,0x4c,0x06,0x80,0xac,0x31,0xd9,0xbe,0xad,0xcf,0x01,0x4d,
    0x8e,0xf9,0x78,0x15,0xbc,0x99,0x88,0x80,0x3f,0x8c,0x73,0x22,0x64,0xc2,0x25,0x66,
    0xa3,0xef,0xad,0xef,0x57,0xc7,0xa9,0xf4,0x8d,0x8a,0x44,0xbe,0xff,0x81,0x9a,0xdc,
    0xce,0x01,0x10,0x2b,0x5d,0xfe,0x6a,0x1d,0x71,0x00,0x1f,0x13,0x00,0x1a,0x69,0x98,
    0x49,0xf9,0xc8,0xe0,0xe8,0xe2,0x3b,0xe1,0x9b,0xfd,0x5d,0x13,0x23,0x61,0x9b,0x3f,
    0xa1,0x88,0x91,0x02,0x5f,0x94,0xbe,0x7f,0xe0,0x2f,0xe4,0x80,0xae,0xce,0xa2,0xed,
    0x28,0x0f,0x03,0x6c,0xa6,0x66,0x07,0xf9,0x82,0x40,0x00,0x20,0x14,0x1d,0x32,0xfc,
    0x15,0xcd,0xec,0x59,0xbb,0x82,0xe7,0xa6,0x88,0xf2,0xff,0x97,0x5d,0x75,0xd7,0xa2,
    0x8c,0x03,0xff,0x87,0xa0,0xae,0xc5,0x6a,0xf7,0x24,0xdf,0x02,0x19,0x2f,0x98,0x0c,
    0xb0,0x7f,0xef,0xfa,0x26,0x6d,0xff,0xc2,0x50,0x05,0x53,0xa6,0xa4,0x1d,0x53,0xe5,
    0x77,0x57,0xbf,0xff,0xdd,0xf0,0x9b,0xa2,0x85,0xea,0x3b,0x7f,0x61,0x4a,0x67,0xa8,
    0x17,0x32,0xbf,0xef,0xef,0xfe,0xae,0x41,0xff,0xc2,0x50,0x63,0x12,0x44,0x65,0x81,
    0xb8,0x87,0xf4,0x13,0xf3,0x0f,0x52,0x07,0xf8,0x03,0x0f,0xba,0xe5,0xda,0x5f,0xbf,
    0x88,0xc5,0x4a,0x8f,0xbf,0xf7,0xc3,0xed,0x16,0xff,0xf0,0x96,0x06,0xd9,0xfc,0x2b,
    0x22,0xf8,0xff,0xba,0x0a,0x71,0x40,0xe1,0xe1,0x81,0x1a,0x3f,0xfa,0x05,0xba,0xba,
    0x33,0x7f,0xc0,0x7f,0x06,0xff,0xf1,0x5e,0x8c,0xbb,0x0a,0x27,0x15,0x2c,0x5b,0xbc,
    0xfc,0xda,0xca,0x16,0xee,0x3e,0x13,0x7f,0xf0,0x01,0x56,0x50,0xb1,0x44,0x93,0xda,
    0x28,0x5f,0xae,0xcd,0xf3,0xf8,0x26,0x80,0xd0,0x24,0x8e,0x30,0x03,0x8a,0x33,0x7b,
    0xfe,0x07,0x0f,0x80,0x1c,0x12,0x32,0x00,0x87,0x2c,0x85,0xf3,0x03,0x18,0x51,0xf5,
    0x1d,0xdf,0xfd,0xfc,0xbe,0x1e,0x1f,0xe0,0x03,0xfe,0x36,0x65,0x05,0x88,0x4f,0xca,
    0x1f,0xe1,0xe2,0xb0,0x02,0x80,0xb3,0x5b,0x9f,0xce,0xfa,0xfc,0x0e,0x1b,0xce,0xa6,
    0x65,0x6f,0xee,0x0d,0x11,0x58,0xf6,0x2f,0x7f,0xb8,0x41,0xe0,0x0a,0xa8,0x01,0x02,
    0xc1,0xa6,0x1b,0x53,0x02,0xeb,0x36,0x41,0x45,0x74,0x32,0xb0,0x04,0x4f,0x57,0xc3,
    0x70,0x70,0x83,0xbe,0xe4,0xcf,0x9f,0xff,0x81,0x26,0xb2,0x4c,0x79,0x64,0x3b,0x37,
    0xbf,0xd3,0xe5,0x7d,0x77,0xbb,0xbf,0xf0,0x85,0x83,0x86,0xf6,0xe7,0x7f,0x84,0x26,
    0x21,0x65,0x22,0x2d,0xfc,0x17,0x8b,0x45,0xa3,0xd3,0xd8,0xe5,0x9f,0x36,0xf5,0x7f,
    0x08,0x05,0xee,0xf8,0x4d,0xd1,0x42,0xe5,0x1d,0xbf,0xb0,0xa5,0x33,0xd4,0x0b,0x99,
    0x5f,0xf7,0xf7,0xf8,0x31,0x89,0x22,0x32,0xc0,0xdc,0x43,0xfa,0x09,0xf9,0x87,0xa9,
    0x03,0xfc,0x01,0x87,0xdd,0x72,0xed,0x2f,0xdf,0xc7,0x00,0x51,0x64,0x4c,0x69,0x1e,
    0xfc,0xc2,0x09,0x00,0xf8,0x24,0x8f,0x77,0xd8,0x08,0xe8,0xef,0xff,0x09,0x61,0x54,
    0x94,0x63,0x3f,0xd9,0x79,0xd9,0x8a,0x50,0xb5,0x57,0x4e,0xb9,0x80,0xf5,0x53,0x9e,
    0xb3,0x21,0x7c,0xa5,0x93,0x40,0xa7,0x00,0x49,0xe7,0xaf,0x9b,0x5b,0x70,0x62,0x88,
    0x9d,0x35,0x3e,0x4a,0x7f,0xdf,0xd9,0xfc,0x84,0x9d,0x4c,0x7f,0x4f,0x36,0xcc,0x6b,
    0xba,0x7f,0xc2,0x5b,0x2f,0x02,0x34,0xcf,0x5c,0x21,0xc5,0xfe,0x59,0x9c,0xe4,0xde,
    0x08,0x66,0xf3,0x0b,0xad,0x93,0x12,0x27,0x77,0xff,0x8b,0xb6,0x3f,0x54,0x16,0x0a,
    0x7b,0x98,0x32,0xf8,0x98,0x48,0xbe,0xf3,0xea,0xf7,0xe6,0xc4,0xac,0xff,0xfd,0xd4,
    0xca,0x61,0xa2,0xe5,0xf3,0x50,0x1f,0x0f,0xfe,0x12,0x80,0x07,0xcd,0x6d,0x90,0x24,
    0x08,0xd2,0x77,0xe8,0xba,0xd7,0xbf,0x69,0xd4,0xc4,0xdd,0x3c,0x09,0x06,0x00,0x2b,
    0x18,0x5b,0xa2,0x14,0xb3,0x8b,0x27,0xd0,0xdd,0x93,0x75,0xff,0x84,0xbe,0x02,0x45,
    0xd3,0x8f,0x00,0x75,0x71,0x98,0xa3,0x4e,0xdf,0x03,0x87,0x33,0x7e,0x90,0x69,0xea,
    0x61,0x58,0x57,0x05,0xea,0x22,0x5a,0xf7,0x0c,0x06,0x55,0x47,0xc8,0xed,0xcb,0x87,
    0x90,0x59,0x18,0x0f,0xfe,0x12,0xdb,0x96,0xc0,0xf9,0x1d,0x45,0x24,0xfd,0xed,0x46,
    0x9a,0x0e,0x99,0x5c,0x21,0x5f,0xab,0xf7,0xa0,0xde,0x84,0x48,0xc3,0xf0,0x0c,0x11,
    0x60,0xbc,0x8f,0x83,0xba,0xb0,0xd7,0x03,0xe6,0x2e,0xca,0x54,0x41,0xd5,0xff,0x53,
    0x36,0xff,0xf8,0x7a,0x04,0xae,0x27,0x8d,0x39,0x9c,0xac,0x01,0x2f,0xec,0x6a,0x06,
    0xcd,0x76,0xd4,0x74,0x37,0xef,0xb7,0x44,0xa9,0x14,0x85,0x91,0x31,0x75,0xd7,0x5d,
    0x75,0xd7,0x7e,0x1d,0x8e,0xd3,0xe3,0xdf,0x80,0x07,0xa6,0x39,0x64,0xac,0x21,0x22,
    0x5a,0x3f,0xf0,0x30,0x87,0xd2,0x00,0x3e,0xa7,0x23,0xf7,0xb0,0x19,0xbe,0xc8,0x80,
    0x32,0xda,0x05,0x2b,0xdd,0x89,0x7a,0xd8,0x91,0xad,0x09,0x7f,0xda,0xa6,0x48,0x51,
    0x94,0xae,0x2b,0x5c,0xd0,0x3d,0x76,0x34,0x7e,0x84,0xac,0xb7,0xc8,0x00,0x02,0xf4,
    0x16,0x86,0x01,0x02,0x9b,0xc9,0x97,0xe6,0xe8,0xb0,0x85,0x1f,0x24,0xb8,0x36,0x0a,
    0xd0,0xd6,0xe1,0x08,0x92,0x42,0xcf,0x73,0xa5,0x23,0x56,0xc1,0x64,0xf8,0x4e,0xb3,
    0x6c,0x45,0x98,0xc2,0x1d,0xc0,0xdb,0x80,0xd9,0x39,0xd7,0x06,0xa4,0x47,0xff,0xdd,
    0xe4,0x89,0xa6,0x00,0x39,0xc6,0xa6,0x11,0x24,0xba,0xf3,0xdd,0x60,0x76,0x8c,0xd5,
    0x88,0x82,0xea,0x20,0x00,0xfc,0x9d,0x33,0xc0,0x82,0xfc,0xe9,0x2c,0x73,0x40,0xf0,
    0x4c,0x73,0xe7,0x1d,0x2a,0xf8,0xf1,0x81,0x5e,0x89,0x98,0x74,0x24,0x04,0x82,0xe6,
    0x2d,0x4a,0x99,0x1f,0x26,0x9e,0x8e,0x6c,0xdc,0x80,0x15,0x92,0xc6,0xd0,0x32,0xb8,
    0x00,0x7a,0xc3,0xec,0xd6,0x9a,0x01,0x4d,0x1c,0xcc,0x03,0xb4,0x98,0x32,0xa8,0x90,
    0xb3,0x2d,0xec,0x94,0xf8,0x9c,0x0e,0xc0,0x47,0xfb,0xde,0xc0,0xa4,0x39,0xc5,0x4b,
    0xbd,0x52,0x6c,0x4b,0x70,0xb6,0x43,0x8d,0xd8,0x15,0x92,0xdc,0x61,0x5a,0x43,0xf5,
    0xba,0x07,0xc4,0xc5,0xa1,0x22,0xf3,0xcd,0x08,0xab,0xc0,0x31,0x84,0x26,0x1d,0x01,
    0x96,0x72,0x44,0x41,0x50,0x77,0xff,0xbd,0xf9,0x49,0x36,0x58,0xa8,0x93,0x0f,0xab,
    0xd3,0xe5,0x98,0x3c,0x57,0x52,0x02,0x27,0x70,0xc3,0xc4,0xe3,0x12,0xd5,0x8a,0xe9,
    0xc6,0xec,0x84,0x5e,0x83,0xed,0x77,0x20,0x89,0x28,0x5f,0xb9,0x76,0xd3,0xa2,0x54,
    0xdb,0x66,0xdf,0x71,0x99,0xba,0xd8,0xff,0xb4,0x1c,0x05,0xd9,0x81,0x0f,0x3c,0x40,
    0x6d,0xaa,0x4a,0xb8,0xc8,0xe0,0x57,0xf5,0xba,0xdc,0x4f,0x00,0x9e,0x7c,0xbf,0x76,
    0xf5,0x02,0xc0,0xe7,0x1e,0x20,0xba,0x55,0x50,0x21,0x48,0x5a,0xe9,0x24,0x37,0x4d,
    0xb4,0x6b,0x33,0x00,0x24,0xe0,0xbe,0x04,0xf7,0xbd,0xed,0x8f,0xd6,0x2b,0x19,0xc3,
    0xde,0x5b,0xf0,0x56,0xb0,0x2e,0xe6,0x8b,0x9c,0x68,0x23,0xd3,0xd3,0xf3,0xa5,0x6c,
    0x7f,0xda,0xd4,0xf6,0x59,0x94,0x00,0x28,0x2c,0xf9,0x9d,0x17,0xb4,0x05,0x55,0x02,
    0x3f,0xf7,0x3f,0x41,0x35,0xac,0x01,0x90,0xcb,0x40,0x3f,0x4d,0x40,0x4c,0x81,0x75,
    0x4d,0x11,0xbe,0x77,0x14,0x9f,0xb0,0x0e,0xbc,0x0f,0x44,0x15,0xff,0xa8,0x23,0x07,
    0x01,0x01,0xd7,0xdf,0x47,0x2d,0x80,0x2a,0x35,0x14,0x9d,0x8f,0x7f,0xe8,0x63,0x91,
    0x00,0x48,0x1a,0x97,0xcd,0xde,0xdb,0x7a,0x2b,0x73,0x6e,0xd1,0x1c,0x80,0xd7,0x1a,
    0xab,0x59,0x23,0xd4,0x8d,0x6d,0xff,0x03,0xc6,0xc0,0x4d,0x87,0x93,0x48,0x3c,0x81,
    0x28,0x79,0x73,0x29,0xae,0xa0,0x00,0x78,0x40,0xd3,0xd5,0x54,0x12,0x0a,0x6a,0xef,
    0xfb,0x55,0x20,0x68,0x0d,0x8d,0x41,0x39,0x57,0x41,0xff,0x52,0x8c,0x38,0x8a,0x3f,
    0xda,0x08,0xec,0x18,0x26,0x00,0x1b,0x5c,0xc7,0x70,0xdc,0xf6,0xab,0xde,0x80,0x16,
    0x18,0x89,0x38,0xab,0xa5,0xfc,0x3b,0x3d,0x68,0xd1,0x97,0x80,0x1e,0x1d,0xf0,0x07,
    0x45,0xa6,0x87,0x64,0x7c,0x36,0x83,0x86,0x80,0x49,0xa8,0xdf,0xee,0xe5,0xf4,0x7c,
    0x22,0x1a,0x4c,0x91,0xed,0xbe,0x03,0x90,0x42,0x22,0x58,0x0c,0xfe,0x40,0x23,0x5a,
    0xec,0xa0,0xb5,0xcb,0x26,0x49,0x58,0x01,0x8b,0x0a,0x66,0xf3,0x0d,0xbf,0x09,0x1c,
    0x22,0x97,0xfa,0xff,0xbe,0xca,0xc2,0xe8,0x2d,0x42,0xad,0x4b,0x7e,0xdf,0x61,0xe8,
    0xc9,0xa5,0x26,0x08,0x00,0x7b,0xdf,0xd5,0x73,0x58,0x04,0xba,0x00,0xdb,0x32,0x01,
    0x5b,0x14,0xcb,0x06,0xfa,0x0e,0xc8,0x00,0xe2,0xd5,0x30,0xd2,0xe0,0x0a,0x95,0x83,
    0xc5,0x26,0x59,0x05,0x12,0x40,0xe2,0x70,0x6a,0x43,0x39,0xdb,0x57,0xa8,0xea,0x34,
    0x41,0x96,0x73,0xbe,0x6e,0x35,0xdb,0xe1,0xc6,0xa8,0x75,0x02,0xfc,0x69,0x09,0x80,
    0x63,0x48,0x0f,0xce,0x6c,0x65,0x3f,0x3f,0x2b,0x62,0x0d,0x17,0xba,0x91,0xfc,0x7f,
    0x17,0x1a,0x37,0xfe,0xfe,0xef,0xa8,0x93,0x0d,0x29,0x7f,0xcf,0xf2,0x10,0x0c,0x64,
    0xcc,0x05,0x59,0x7b,0x53,0x9b,0x9a,0x0e,0x48,0xf4,0xd4,0xd4,0xe5,0xb8,0x30,0x8c,
    0x06,0xdb,0xbc,0x51,0xbf,0xde,0x06,0xa5,0xe4,0x9c,0x0f,0x12,0xbc,0xf5,0x9f,0xc2,
    0x49,0xb7,0xe2,0x9f,0x9a,0x88,0x64,0x56,0xa0,0xe8,0xf6,0x8c,0x56,0x82,0x89,0x64,
    0x22,0x8b,0xc9,0x2b,0xfd,0xba,0x2d,0x1b,0x3a,0x01,0x9b,0x70,0xc6,0xd4,0x0c,0x5d,
    0xc9,0xa1,0xff,0x81,0x29,0x5f,0x61,0x05,0xdc,0xd7,0x1b,0xca,0x35,0xd4,0xcf,0x8d,
    0x55,0xf7,0x7f,0x83,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0xff,0xfe,0x38,0x57,0xc0,
    0x0b,0x91,0xc9,0x00,0x30,0xc6,0x99,0xd7,0xbd,0x88,0x80,0x0d,0x93,0x86,0xa4,0x23,
    0x9d,0x8f,0x57,0xbf,0xff,0xbe,0x15,0xe0,0xe6,0x46,0x3c,0x40,0xa4,0x10,0x5e,0xaf,
    0x7e,0x00,0x17,0x73,0x03,0xab,0x5d,0x8a,0x8c,0x45,0xff,0xfe,0x1c,0x21,0x5e,0x00,
    0x31,0x8e,0x2c,0x44,0xe5,0x00,0x50,0x53,0x6f,0x01,0x59,0x0e,0xc9,0x21,0x0f,0x84,
    0xd0,0x00,0xd6,0x6c,0x5c,0x74,0x12,0xc7,0x1b,0xb5,0xf5,0x33,0x3c,0x88,0xf4,0xbb,
    0x5d,0x5f,0xa0,0x75,0xf4,0x8c,0x80,0x07,0xbc,0x28,0xd4,0xed,0x8e,0x34,0xae,0xfc,
    0x11,0x84,0x90,0x65,0x51,0x22,0x9b,0xbf,0xf0,0x13,0x37,0x4f,0xcf,0x80,0x04,0xf2,
    0xb3,0x3c,0x81,0x21,0x4a,0x46,0xb6,0x91,0x94,0xc3,0x6d,0xce,0x8f,0x70,0xd7,0xe1,
    0x89,0x98,0x23,0x2b,0xcb,0x7f,0x03,0x7a,0x9b,0x0e,0x0a,0xb8,0xc5,0x3d,0x7c,0x1f,
    0xea,0xb5,0xc6,0x93,0x5f,0xfb,0xfd,0xfb,0x4b,0x7b,0x00,0x95,0xba,0x15,0xdc,0x32,
    0x2d,0x08,0xfc,0x83,0xe2,0x15,0x70,0xa3,0xf5,0xc2,0x6b,0x78,0xe0,0xb2,0xcb,0xfa,
    0xc3,0x21,0x80,0xfc,0x11,0xdc,0xf4,0x32,0xb1,0xa6,0xdf,0xf3,0x15,0x57,0x0d,0x7d,
    0x6f,0xf0,0x00,0x9d,0x2b,0x31,0xf6,0x36,0x72,0xb2,0x69,0x51,0xa2,0x69,0xfd,0xff,
    0xa3,0x4b,0x91,0x9a,0x63,0xe0,0x35,0x49,0x1b,0x9f,0x90,0x9a,0xc7,0xf9,0xfd,0xdb,
    0x7c,0x3f,0x00,0xb8,0x60,0x3b,0x2e,0xda,0xfa,0xef,0xa1,0x80,0xfd,0xc9,0x9b,0x42,
    0x6c,0xa5,0x56,0x45,0x87,0xf8,0x00,0x43,0xa5,0x9b,0xd0,0xb2,0xae,0xe2,0x9d,0x23,
    0xd5,0x78,0x1e,0x85,0x22,0xad,0x67,0xe7,0x00,0x63,0xf0,0x0c,0xf7,0xe8,0xc9,0xa8,
    0x4a,0xa5,0x28,0x22,0x0d,0xfe,0xca,0xae,0x01,0xf1,0xa7,0x48,0x7d,0xff,0xc1,0xf8,
    0x37,0x87,0x54,0x2d,0xbe,0x21,0x47,0x13,0xdc,0xe4,0xd0,0x3b,0xff,0x09,0x98,0x5a,
    0xc7,0xfd,0x9c,0xe8,0x68,0x22,0xae,0x15,0x9f,0xfb,0xe1,0x90,0x00,0x08,0xd8,0x83,
    0xf6,0x50,0xf7,0xdc,0x20,0xc3,0xff,0xde,0xb1,0xa5,0x4d,0xff,0xef,0xd7,0x65,0xe4,
    0xad,0xea,0xde,0x1d,0xac,0x88,0x3b,0x31,0x70,0xcc,0xbc,0x1f,0xf0,0x00,0x35,0x36,
    0x6d,0x80,0xce,0x14,0x51,0x43,0xf7,0xf0,0x00,0xbd,0x79,0xa0,0xa9,0x4a,0x21,0xbc,
    0x55,0x4b,0xc3,0xfc,0x02,0x2e,0x09,0xe4,0x43,0xe5,0x74,0xe2,0xa5,0x5f,0xff,0xc0,
    0x02,0x19,0x4b,0x33,0xd0,0xb2,0xae,0xce,0x00,0x13,0x4b,0x75,0x10,0x87,0xe1,0xaa,
    0xc5,0xc2,0xdf,0xd6,0x54,0xfe,0x13,0xd9,0x2d,0x8f,0x14,0x97,0x91,0x73,0x7f,0x80,
    0x0c,0x40,0x8c,0x92,0x8a,0xc7,0xa1,0x8d,0x7d,0xe1,0x41,0x3e,0x00,0x90,0x3a,0xdd,
    0x64,0x3c,0x9b,0x29,0x6c,0x02,0xf1,0x6e,0x1a,0xb4,0xeb,0xe0,0x96,0x6e,0x22,0x33,
    0x4b,0xb5,0xff,0xc0,0x38,0x42,0xbc,0x96,0x8f,0x9c,0x6c,0x48,0x00,0x53,0xf4,0x11,
    0x54,0x81,0xf0,0x8b,0xef,0x02,0x3d,0x92,0x1a,0xba,0xb3,0x18,0x7c,0xff,0xfc,0x8c,
    0x2a,0xad,0x3b,0x7f,0xf5,0xfc,0x10,0x70,0x19,0x02,0x63,0x87,0x63,0x17,0x7a,0xeb,
    0xae,0xba,0xeb,0xaf,0xf0,0x08,0x4b,0x84,0x23,0x20,0x03,0xb9,0x31,0x38,0x1c,0x96,
    0x58,0x0e,0xd5,0xea,0xa4,0xc6,0xa4,0x22,0x9c,0x8f,0xa7,0x80,0xae,0x5a,0x26,0x23,
    0xf2,0x05,0x72,0xee,0x9b,0xb3,0x30,0x9b,0x9c,0x9f,0xfe,0x80,0x09,0xa4,0x4c,0x1e,
    0xa5,0x03,0x6e,0xbd,0xdb,0xf6,0x61,0xf8,0xd0,0x69,0x5a,0xac,0xca,0xcd,0xfe,0xe6,
    0xb5,0xf7,0xdc,0x7f,0xc6,0x0d,0xf6,0x18,0x2d,0xe9,0x64,0x63,0xc4,0x0a,0x41,0x05,
    0xea,0xf0,0x70,0x17,0x66,0x04,0x3c,0xf1,0x01,0xb6,0xad,0xd1,0x1e,0x5c,0x43,0x94,
    0x18,0x8c,0x57,0x0c,0xd1,0x88,0x6c,0x79,0xe2,0x0d,0xda,0x07,0x0d,0x2e,0xcf,0x00,
    0xea,0xb1,0x41,0xd9,0x74,0xd7,0x36,0x63,0xaa,0x26,0xd3,0xbf,0x5a,0x9b,0x81,0xb1,
    0x0c,0x50,0x73,0x8d,0xda,0x00,0xa1,0xf9,0x19,0x89,0xaa,0x95,0xad,0x5a,0x0b,0x19,
    0x8e,0x58,0xbb,0xbe,0x01,0x91,0xc6,0xbd,0x1d,0x03,0x90,0x84,0x83,0x19,0xe0,0x04,
    0x64,0x0b,0x65,0x1e,0x8b,0x29,0x7a,0xc0,0x38,0x40,0x3c,0x03,0x79,0x84,0x5d,0x42,
    0xe6,0x58,0xf8,0x38,0x67,0x32,0xf6,0x40,0x26,0x4c,0x04,0xfd,0x5b,0xef,0xf0,0x63,
    0x84,0xc0,0x34,0x0d,0x52,0xb6,0x78,0x29,0xb6,0x81,0x21,0x0e,0x70,0x53,0x8d,0xda,
    0xe0,0x3f,0xed,0x49,0x02,0x00,0x40,0xa8,0x30,0x06,0xf9,0x10,0xa9,0x08,0x66,0x21,
    0xbb,0x5f,0x70,0x49,0x0d,0xf7,0xb1,0x9a,0xdc,0x38,0xca,0x2c,0xae,0xdd,0xe0,0xd7,
    0xa3,0xaa,0x6b,0xdf,0xef,0x80,0x01,0x35,0xe1,0xf2,0x8f,0x81,0xd5,0x5a,0x8f,0x70,
    0xcc,0x41,0x24,0xc7,0xee,0x33,0x1c,0xac,0x25,0xc6,0x24,0xc5,0x25,0x4b,0x6b,0x3e,
    0x00,0x35,0x14,0xb6,0x3c,0x03,0x97,0xde,0xef,0xfc,0x28,0x46,0x43,0xc8,0x6e,0x71,
    0x6a,0xb1,0xaa,0xa0,0x00,0x10,0x29,0xff,0xdd,0x80,0x5b,0x27,0x75,0x0d,0x9d,0xbf,
    0xdd,0x6a,0xa8,0xe4,0xc1,0xaa,0xff,0xb7,0xaa,0x4e,0x72,0x31,0x15,0x99,0xc1,0x6f,
    0xdc,0x10,0xb5,0xf2,0x0a,0x87,0x5a,0xbf,0xfe,0xc7,0xac,0x4c,0x91,0x41,0xb9,0xfe,
    0xef,0xb4,0x43,0x90,0x34,0xe4,0xa2,0xd0,0xdf,0xde,0x40,0x66,0xa8,0xc9,0x06,0x35,
    0xe0,0x03,0xdb,0x40,0x14,0xdc,0x2d,0x25,0x03,0xee,0xfc,0x53,0x80,0xd9,0x90,0xe5,
    0x88,0x56,0x1f,0x38,0x7d,0x3e,0x5a,0xca,0xa0,0xed,0x87,0x8c,0xcb,0xfb,0xc0,0x07,
    0xcc,0x75,0x13,0x08,0x58,0xb7,0x9b,0xed,0xbc,0x1a,0xc4,0xe6,0x9d,0x47,0xfe,0xb6,
    0xb9,0xb1,0x99,0x88,0x08,0x07,0x33,0xb8,0x11,0xb4,0xac,0xcc,0x31,0xa8,0xb7,0xe7,
    0xff,0xd4,0x20,0x61,0x6e,0x39,0xd1,0xd4,0xb6,0xff,0xde,0x86,0x34,0x5c,0x78,0x71,
    0xbf,0x76,0x51,0xbc,0x0d,0x88,0x84,0x01,0x02,0xcd,0xfb,0xb7,0x22,0x35,0x3d,0xb2,
    0xf0,0x30,0xaf,0xbf,0xd6,0x53,0x2c,0x1c,0x2c,0x60,0x1b,0x09,0x81,0x10,0xcb,0xc2,
    0x96,0x30,0x8f,0x4f,0xe1,0x6c,0x38,0xaa,0x28,0xce,0x25,0x34,0x5b,0x7e,0x19,0x63,
    0x78,0xbe,0x48,0xcd,0xa1,0xff,0xde,0xfc,0xdd,0x35,0xb2,0x69,0xb0,0x74,0x8d,0x26,
    0x62,0xf0,0x60,0x08,0x09,0x10,0xfb,0x1c,0x80,0x6e,0xcf,0xf9,0xa4,0x23,0x17,0x03,
    0xd2,0x77,0xfb,0x7d,0xad,0x1c,0x9c,0xe7,0xfb,0x08,0xbc,0x24,0xcf,0xcf,0xe2,0xe6,
    0x1e,0x43,0x26,0x08,0xa9,0x3d,0xff,0xf7,0xcc,0x76,0x40,0x00,0x20,0x1e,0xbc,0x11,
    0xbe,0xe8,0x00,0x8a,0x05,0x48,0x48,0x0b,0xba,0x5c,0x0e,0xed,0xf3,0xf5,0x7a,0x48,
    0x7f,0x77,0xfc,0x13,0xb5,0x1c,0x01,0x89,0x3b,0x4a,0xf9,0x0c,0xad,0xdd,0x6f,0xff,
    0xfd,0x12,0x70,0xbf,0x3a,0x84,0x38,0x9e,0x10,0x7e,0x3f,0x90,0x4c,0x23,0x81,0xa8,
    0xbf,0x77,0x80,0x7f,0x0c,0x01,0xaa,0x56,0x68,0x7d,0xeb,0x6b,0x3a,0xdf,0xfe,0x5f,
    0x0b,0xb7,0x05,0x20,0x7e,0x20,0x17,0x8a,0x2e,0x2e,0x51,0x58,0xd5,0x57,0xe9,0x4b,
    0x9b,0xc7,0xbd,0x77,0xab,0xad,0xde,0x5e,0x1f,0xbf,0xea,0x3d,0xf0,0x73,0xf9,0x19,
    0x32,0x0d,0xdf,0xdd,0x70,0xb7,0x93,0x5f,0xd5,0xf4,0x10,0xec,0xc2,0x63,0x89,0x1a,
    0xde,0x10,0x17,0xa6,0x60,0x99,0x87,0xfb,0xb7,0x8e,0xd8,0x17,0xb6,0x4f,0x33,0x82,
    0xce,0xee,0x79,0xc4,0xdb,0x62,0xac,0x6f,0xcd,0xe8,0x2e,0xff,0x44,0x96,0x52,0x87,
    0x4d,0xcc,0x23,0x36,0x90,0x7f,0xd6,0x6d,0x37,0x1f,0xbf,0xee,0x50,0x36,0x78,0xf0,
    0x6d,0xba,0x78,0x1c,0x7c,0x85,0xa5,0x81,0xc6,0x80,0xe0,0x70,0x01,0x67,0xcd,0x83,
    0x52,0x9f,0x00,0x27,0x90,0x8b,0x8d,0x41,0x4a,0xf0,0x62,0xde,0x76,0xe1,0xbf,0x5f,
    0xf0,0x2f,0x76,0x02,0x0d,0x0b,0x95,0xbc,0xb0,0xc8,0x60,0x02,0x10,0x8d,0x96,0x06,
    0x37,0x09,0xc5,0x85,0xe7,0x43,0x76,0xb3,0xd1,0x21,0x5c,0x53,0x2a,0x8f,0xff,0x8c,
    0x00,0x50,0x35,0x6a,0xdb,0x73,0x82,0x06,0x80,0x0d,0x22,0xe4,0x1e,0xdc,0x87,0x20,
    0x70,0x38,0x4e,0x00,0xd0,0x35,0xd1,0xd2,0x0c,0x00,0x00,0x3b,0x0d,0x04,0xb0,0x78,
    0xca,0x9e,0xbe,0x05,0xc7,0x25,0x09,0x39,0x45,0xc9,0x67,0x7e,0xe0,0x2f,0xa2,0x77,
    0xac,0x3a,0x67,0x48,0xfe,0xc7,0x46,0x38,0xfb,0xf9,0x34,0xb7,0xbf,0xb5,0x04,0x52,
    0xd3,0xad,0x3f,0xfd,0xeb,0xeb,0x05,0x52,0x94,0xbd,0xff,0xf8,0xb1,0xac,0x04,0xd4,
    0x0b,0x2d,0xde,0xfd,0x2c,0xcf,0x70,0x6c,0xa9,0x00,0x00,0x80,0x65,0x38,0x73,0x42,
    0x19,0xb6,0x17,0xec,0xa7,0xe9,0xff,0x7e,0x01,0xba,0x21,0x82,0x72,0x0a,0x07,0xbf,
    0xb1,0x48,0x83,0x4e,0x16,0xd0,0xb1,0x90,0xd4,0x76,0xb7,0x3a,0xf2,0x89,0x90,0x91,
    0x02,0xd6,0x4b,0xd7,0xbf,0xc3,0x18,0xff,0x5c,0xff,0xdd,0xfc,0x4f,0x15,0xe2,0xd4,
    0xd5,0xb1,0x55,0x0f,0xe3,0x9d,0x10,0x43,0x4e,0x92,0xdb,0x48,0xce,0xc2,0x0b,0x6c,
    0xe5,0x32,0xc4,0x67,0x5b,0xed,0xef,0xf9,0x12,0x24,0x7e,0xf9,0xbe,0xff,0xfc,0x4c,
    0x42,0x2f,0x5e,0xfc,0x8a,0x55,0xdf,0xf8,0x00,0xac,0x98,0xfb,0x13,0x39,0x59,0xc8,
    0x13,0x6f,0x91,0x46,0x0f,0x92,0x70,0x15,0xa2,0x02,0x8f,0x28,0x15,0xa4,0x1f,0xad,
    0xe0,0xa2,0xa3,0x49,0xf5,0xef,0xb9,0x00,0x9e,0x5f,0x88,0x03,0xc2,0xd7,0xfa,0xe8,
    0xd9,0xd1,0x98,0xdb,0xb3,0xff,0xf2,0xeb,0xae,0xba,0xeb,0xae,0xfb,0xc3,0x7d,0xfe,
    0xfd,0xfe,0xff,0x7f,0xbf,0xdf,0x7f,0xbe,0xfa,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
    0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
    0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
    0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xbc
};
static unsigned char MPEG4_NoCam_Japan_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xda,0x05,0x07,0xe4,0x00,0x00,0x00,0x01,
    0x68,0xce,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x11,0xff,0xff,0x87,0xa2,
    0x80,0x00,0x80,0x8f,0xbc,0x56,0xf7,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,
    0x7d,0xf7,0xdf,0x7d,0x62,0xb5,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xad,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0x5d,0x7f,0xfc,0x03,0xf0,0x41,0x00,0x1f,0x0c,0xb0,0x8f,0x46,0x2e,
    0x1d,0x5d,0xe4,0xc9,0x30,0x05,0xce,0x74,0xff,0xff,0xf6,0x82,0x1c,0x00,0x33,0x6d,
    0xbe,0x53,0x73,0x08,0x07,0xa1,0x99,0x41,0x58,0x1b,0xa6,0xff,0x80,0x36,0x10,0x85,
    0x66,0x08,0x8e,0xc7,0x9b,0x82,0x36,0x76,0xe5,0x10,0x44,0x77,0xef,0x00,0x8f,0x5f,
    0x6c,0x3d,0x47,0x4b,0x05,0x5b,0x27,0x0d,0x2b,0x5d,0xd8,0xf5,0x00,0x20,0x92,0xdf,
    0xff,0x5b,0xe0,0x86,0x08,0xfd,0xb7,0xe0,0x1a,0x82,0x88,0x8f,0xd2,0x9d,0x7f,0xff,
    0x82,0xc4,0xe1,0x5c,0x00,0x56,0x62,0x73,0xe1,0x14,0xf5,0xa8,0xdd,0xa9,0x84,0x09,
    0xc1,0x7c,0x8e,0x44,0xf0,0xcb,0xea,0xc3,0xbd,0xfa,0x01,0x98,0xcd,0x82,0x85,0x62,
    0x07,0xd2,0x20,0x00,0x00,0x40,0x2f,0x62,0x72,0xb1,0xa2,0x55,0x87,0xbf,0xd7,0xfd,
    0xcc,0xdc,0x4c,0x12,0x15,0xe8,0xd6,0x28,0x82,0xd3,0x5d,0x3b,0x70,0xff,0x59,0x7a,
    0xea,0xf6,0x01,0x02,0x7d,0xde,0xfb,0xda,0x8f,0x24,0x37,0x31,0xaa,0xef,0xf6,0xf0,
    0x0a,0x28,0xc8,0x02,0x1c,0x97,0x2f,0x98,0x20,0xa4,0x9b,0x49,0xc7,0xbf,0xff,0x9b,
    0x9c,0x6d,0xa9,0x44,0x7f,0x2a,0xfd,0x98,0x00,0x17,0x49,0x02,0x22,0x4f,0xd7,0xe7,
    0xdf,0xfc,0x44,0x20,0x30,0xaf,0xc0,0x00,0xfb,0xc5,0x01,0x24,0xd3,0xe4,0xe7,0xef,
    0xc0,0x28,0xb1,0xa9,0x82,0x16,0x92,0x63,0xe6,0x11,0x95,0xc1,0xc5,0x4c,0xd7,0x37,
    0xc1,0x7e,0xd0,0x45,0x72,0x07,0xe2,0x07,0xc0,0x67,0x23,0xc3,0xf0,0x23,0x36,0xeb,
    0x6f,0x7f,0xe6,0xc5,0x88,0x42,0xb0,0x00,0xad,0x7f,0x6c,0x80,0x2c,0x14,0x92,0x3f,
    0xe9,0x9a,0x7d,0x39,0xaf,0xfe,0xe9,0x2e,0x45,0x7a,0x01,0xd4,0xdf,0xfa,0xed,0x80,
    0x1c,0xa4,0xd4,0x15,0xeb,0x7f,0x3b,0xbc,0x00,0x70,0xd5,0x23,0x50,0xc5,0x96,0x63,
    0x75,0xe7,0x07,0xf8,0x00,0x2a,0x06,0x0a,0xb2,0x8c,0x67,0xea,0x35,0x90,0xe3,0x8d,
    0xda,0xff,0x84,0x5f,0x00,0x85,0x7c,0x05,0x1e,0x00,0x05,0x5c,0x03,0x5c,0xb0,0x03,
    0xac,0x1f,0x96,0x21,0xd5,0x28,0xb0,0x19,0x30,0xec,0xb7,0x08,0xf9,0x50,0x3f,0xff,
    0x1c,0x12,0x15,0x80,0x08,0x82,0xc8,0x15,0x39,0x20,0x15,0x22,0x2f,0xbc,0x0a,0xc2,
    0xc8,0x70,0x49,0xcd,0xde,0x43,0x2a,0x0f,0x02,0x0d,0x9f,0xc7,0x3e,0x30,0xf1,0x02,
    0x4c,0x77,0x53,0x3f,0x26,0xb5,0xdb,0xff,0x87,0x00,0x85,0x70,0x00,0x9a,0x34,0x35,
    0x37,0x3e,0x10,0xb9,0x23,0x03,0x80,0x8c,0x4b,0x25,0xa8,0xc5,0xce,0xcb,0xd8,0xe1,
    0x26,0xa0,0xe0,0xd9,0x41,0xd8,0x65,0x42,0xad,0xf1,0x30,0x00,0x10,0xa2,0xa5,0x86,
    0x84,0xdf,0xfc,0xfc,0x21,0x5e,0x11,0x9b,0xee,0xa3,0xff,0xff,0xf7,0xe0,0x04,0x41,
    0xcb,0xc0,0x00,0x40,0x04,0x59,0x03,0x3d,0xda,0x18,0x00,0x89,0x1a,0xfc,0x7f,0xf0,
    0x0d,0xf0,0xaf,0x0d,0x27,0xf0,0x11,0x89,0xfd,0xd8,0x26,0x71,0x27,0x82,0x1c,0x43,
    0x9e,0xf6,0x50,0x32,0x85,0x29,0xe6,0x1e,0x0c,0x65,0x12,0xd1,0x11,0x8b,0xae,0xba,
    0xeb,0xaf,0xf8,0xdb,0xd8,0xcb,0x0a,0x40,0x03,0x93,0x20,0x71,0xf9,0x45,0x91,0x9f,
    0x7b,0x40,0xfd,0x9b,0x11,0x15,0xdb,0xdf,0x78,0x78,0x0d,0x90,0x4e,0x96,0xde,0xeb,
    0x00,0x11,0x8d,0xb7,0xca,0xf7,0xff,0xf6,0xb8,0x52,0xc1,0xcb,0x43,0x86,0x9b,0xe7,
    0x80,0xeb,0x22,0xc2,0xf8,0xb8,0xf5,0xdf,0x4f,0xf4,0xaa,0x1f,0x57,0xe0,0x0c,0x0b,
    0xf7,0x0d,0xb7,0xba,0x24,0xfe,0x05,0xb4,0x19,0x25,0x6c,0xbe,0x9b,0x5d,0xa1,0x36,
    0x1f,0x17,0x67,0x80,0x15,0x4f,0x34,0x50,0x01,0xa8,0xc5,0x58,0x88,0x39,0x7e,0x83,
    0x78,0x24,0xfe,0xfb,0xc3,0x85,0x48,0x53,0x90,0x2a,0x4d,0x19,0x48,0x23,0x98,0xa3,
    0x4c,0x68,0xf6,0x19,0x91,0xd1,0xbc,0x88,0x7e,0x79,0xf6,0xbe,0x8d,0x93,0x49,0x17,
    0xd7,0xf8,0x2b,0x21,0x48,0x9d,0x8f,0xba,0x04,0x00,0x0e,0x76,0x45,0xe4,0x7f,0xc2,
    0x1a,0x57,0x80,0x84,0x1e,0xdb,0xe9,0x6d,0xa3,0x47,0xff,0xf3,0xf6,0x1e,0xb7,0xe3,
    0xb9,0xb7,0xc0,0x17,0xf3,0x70,0x5b,0x28,0x1f,0x09,0x95,0xea,0x3c,0xab,0x60,0x00,
    0x20,0x00,0x16,0x21,0xef,0xaf,0x40,0x0c,0xe6,0xa8,0x7f,0x3c,0xe0,0x00,0xbd,0x5a,
    0x44,0xc8,0x7c,0x2b,0xa7,0xfe,0xf6,0x2f,0xcd,0x70,0x14,0xa6,0x05,0x7f,0xdb,0x85,
    0x78,0x76,0x5d,0x30,0xcc,0x93,0xff,0xfc,0xdd,0x5a,0x03,0x03,0xf0,0x83,0xf9,0xce,
    0x90,0x9f,0xfb,0x87,0x05,0x2d,0xd6,0xd1,0xc8,0xfd,0xaf,0x05,0x71,0x73,0x19,0xce,
    0x20,0x5f,0xc9,0x1e,0xaf,0x02,0x07,0xfc,0x24,0xf8,0x6a,0x5d,0x8d,0x88,0xd5,0xff,
    0xe0,0x00,0xf9,0xd4,0x41,0x12,0xbb,0x0a,0x69,0xa1,0x9e,0xfc,0x1a,0x44,0xff,0xbf,
    0x00,0x03,0x94,0xcd,0x90,0xb2,0xba,0x1e,0x04,0x73,0x88,0x86,0x5a,0x8c,0xa2,0xf7,
    0x23,0xe2,0xa6,0x7e,0x23,0xf7,0x80,0x8f,0x7c,0x07,0xfb,0xfe,0xf7,0x8b,0xe0,0x89,
    0x29,0xce,0x6f,0xfd,0x5f,0x82,0x3b,0x4e,0x29,0x98,0xbd,0xb5,0x39,0x45,0x6b,0x66,
    0xd7,0xc9,0xd9,0x92,0x4a,0xeb,0xde,0x1e,0x42,0xcc,0x27,0x06,0xb3,0x76,0xb8,0x00,
    0x9a,0x2a,0x36,0x18,0x07,0xc2,0x08,0x7e,0xd6,0x9f,0x83,0xb6,0xd1,0xde,0x4d,0x61,
    0xcf,0xc1,0xd0,0xea,0xbe,0xf0,0x15,0x1b,0xf2,0x9d,0x78,0xef,0xe2,0x33,0xdb,0xd5,
    0xa9,0xe5,0x9b,0x46,0xf6,0xb7,0x5e,0x34,0x56,0x0a,0x89,0x23,0xf7,0xc1,0xc0,0x20,
    0x38,0x2e,0xff,0xd0,0x53,0xdd,0xc1,0x34,0xa7,0xff,0xef,0xdc,0xe4,0x95,0xd2,0xfa,
    0x04,0xc3,0x97,0x16,0xd7,0x85,0x4b,0x5e,0xd1,0x3e,0x70,0x1a,0x8b,0x2b,0xd2,0x5d,
    0xbc,0x63,0xd7,0xdb,0x54,0xc3,0xe4,0x7b,0x1a,0xbe,0x19,0x6c,0x50,0x95,0x05,0x65,
    0xfd,0x34,0x91,0xdb,0xc9,0xaa,0xbd,0x53,0x44,0x9b,0x39,0x20,0xc0,0xd3,0xbd,0x94,
    0xd3,0x15,0x52,0x56,0x10,0xfc,0xfb,0x9d,0xe9,0xa3,0x5d,0xa4,0xff,0xff,0xc7,0xc3,
    0x65,0xb0,0xff,0xf1,0xb7,0x96,0x34,0x92,0xf2,0x98,0x9b,0xac,0xff,0xa8,0x64,0x22,
    0x28,0x90,0x55,0x2d,0x63,0xee,0xb3,0x5d,0x8b,0x4c,0x42,0x01,0xa1,0xbf,0xab,0xe7,
    0x22,0x0c,0x87,0x35,0xf7,0x65,0x40,0x50,0xe4,0x4e,0x55,0xab,0xf5,0x1d,0xf7,0x61,
    0xff,0x7e,0x8a,0x95,0x31,0x56,0x55,0x5d,0xfd,0xb0,0x66,0x07,0x57,0xdf,0x6f,0xa7,
    0x22,0x80,0x28,0x67,0x28,0x14,0x7d,0x69,0x91,0x98,0x21,0x37,0x99,0x20,0x58,0xb7,
    0x60,0x8c,0x9a,0x73,0x8c,0x5f,0x10,0xb4,0xe4,0xf4,0xc3,0x83,0x21,0xed,0x67,0xfa,
    0x83,0x00,0xb2,0x88,0x88,0xbb,0x91,0x18,0x5e,0x42,0xcc,0x32,0x0c,0xd7,0x3e,0xbf,
    0xf7,0xb7,0x80,0x3c,0xb2,0xc5,0x10,0xd2,0x19,0xbf,0x51,0x0f,0xa0,0x96,0x87,0x4b,
    0x5e,0xae,0xd8,0x57,0x8f,0x8f,0x1d,0x43,0x92,0x75,0xff,0xaf,0x6c,0xf0,0x37,0xcb,
    0x48,0x10,0xf8,0x3a,0x5c,0xcd,0x96,0x34,0x74,0x43,0x76,0x81,0x18,0x29,0x98,0x00,
    0x14,0x38,0xda,0xa8,0x85,0xb9,0x47,0x01,0x34,0xc1,0xe4,0x84,0xb3,0x7d,0x76,0x2b,
    0x00,0x28,0x5a,0x4d,0xa7,0x01,0x46,0x5e,0x60,0x05,0x25,0x80,0x67,0x65,0x5f,0xd4,
    0xe8,0x5f,0x73,0x80,0x4e,0xb7,0x34,0x07,0xca,0xd0,0xd5,0x61,0x08,0x3b,0xf7,0xea,
    0x68,0xd3,0x62,0x69,0x5f,0xfd,0x34,0xa9,0x64,0x06,0x48,0x88,0xa7,0x05,0xbf,0xfd,
    0x22,0x87,0xc9,0x0c,0x16,0x31,0xf7,0xd9,0x50,0x14,0x20,0xc0,0x78,0x33,0x5e,0x84,
    0x13,0xfe,0x24,0x7d,0x61,0x2f,0xbb,0x7f,0x8d,0xe3,0x44,0xe0,0x99,0x4c,0xaf,0xf4,
    0xf6,0x8f,0x2e,0x60,0x1a,0xc3,0x09,0x49,0x53,0xec,0x4e,0xd9,0x9a,0x80,0xcd,0x88,
    0xbf,0x7e,0x46,0x20,0x1d,0x75,0x1c,0xf4,0x0a,0x83,0x09,0x75,0xe3,0xf8,0xa8,0x53,
    0x90,0x7f,0x2f,0xd9,0xc5,0x4f,0xfe,0xca,0xa4,0x3a,0xc5,0xec,0xce,0xb5,0xcd,0xd8,
    0xdf,0xc0,0x04,0x06,0x1f,0xae,0xb3,0xca,0x03,0x04,0x57,0x4c,0x7e,0xf9,0x8f,0x9d,
    0x90,0x2c,0x22,0x8d,0x3d,0xb7,0xe8,0x08,0x1b,0xca,0x24,0x10,0x7e,0xb1,0xc3,0xb6,
    0x28,0x68,0xa4,0x8d,0x2a,0xd7,0x57,0xd8,0x4c,0x88,0xe2,0xbb,0xe7,0x70,0x95,0x04,
    0xdb,0x6c,0x7b,0x08,0x4f,0xf5,0x67,0x59,0x84,0x82,0xfe,0xff,0xd6,0x90,0x3c,0x20,
    0x82,0xcc,0x8b,0x72,0x16,0xfd,0xcf,0x85,0x9d,0x58,0x90,0xc8,0xc9,0x3f,0xed,0x77,
    0x62,0x55,0x20,0xb3,0x79,0xc8,0xe8,0x00,0x23,0x26,0x48,0xb6,0xf1,0xa0,0x26,0x3b,
    0x7d,0xd0,0x7a,0x3c,0x01,0x04,0x4c,0x52,0xd3,0x98,0x74,0x29,0x18,0x46,0x63,0xa6,
    0x34,0xfb,0xb6,0xfe,0xf2,0xc7,0xb8,0x68,0xe2,0x48,0x47,0xca,0xd3,0x85,0x2c,0x00,
    0x62,0x17,0x81,0x46,0xb6,0x15,0xca,0x39,0xdd,0xf2,0xdf,0xc6,0x85,0x71,0x37,0xdf,
    0xa9,0xf6,0x5c,0xe9,0xaf,0x7f,0x69,0xec,0x5e,0x5d,0x61,0x05,0x4f,0x5f,0xff,0xaa,
    0x35,0xc9,0x2e,0xa3,0x37,0x00,0xbd,0xe5,0x21,0xd2,0x61,0x14,0xb2,0xdf,0xfe,0x5e,
    0xd8,0x55,0x51,0x9c,0x10,0xa3,0x81,0xf5,0xcb,0x4c,0x4a,0x61,0xb6,0xcb,0xff,0xf3,
    0xb4,0x9f,0x5b,0xd0,0x54,0xb4,0x47,0x99,0x9f,0x08,0xc4,0xea,0x63,0xc0,0x75,0xe5,
    0x7d,0xdb,0xff,0xff,0xc7,0x86,0x0b,0x8e,0x1e,0x92,0x9e,0x0a,0x3f,0xc5,0x7d,0x02,
    0x3f,0x7b,0x83,0x40,0x88,0x00,0x22,0x5b,0x96,0xc9,0x3c,0xe0,0x99,0x4e,0xb9,0x0e,
    0x36,0x11,0xc0,0xc3,0xe9,0x70,0x16,0xfe,0x20,0x06,0x9e,0x0a,0xb2,0x2c,0x9f,0x81,
    0x4e,0xb5,0xa0,0x52,0xce,0xac,0x8f,0x46,0xf7,0xd8,0xad,0x1c,0x80,0x3b,0x18,0x04,
    0x5a,0xd4,0x6b,0x00,0xcb,0x4e,0xa0,0x65,0x4b,0xe3,0x6c,0xd6,0xa4,0x31,0xa2,0x56,
    0x4f,0xfb,0xf0,0x00,0x6f,0x2a,0xb7,0x47,0xac,0x39,0x10,0x57,0xcd,0xc2,0x1c,0x49,
    0xed,0x8d,0x82,0xea,0x99,0xff,0x51,0xfd,0x70,0x04,0x7f,0x26,0x47,0xa1,0xa2,0xa7,
    0x06,0xf5,0x6e,0x77,0xcc,0x78,0xf0,0x54,0x8c,0x56,0xef,0xbd,0x87,0x4a,0x9a,0x5d,
    0x7f,0xf0,0xa0,0x07,0x80,0xc4,0x33,0x52,0x80,0x51,0xd1,0x80,0x9a,0xff,0xfa,0xab,
    0xfe,0xfc,0x03,0xb7,0xea,0xf6,0x8d,0x2b,0x7a,0x21,0x21,0xaa,0x38,0x2d,0x22,0xfe,
    0xba,0x7f,0x7c,0xe0,0x2a,0x23,0x9d,0x06,0x15,0xdb,0xbe,0xef,0x3f,0x06,0x0c,0xad,
    0xeb,0xbb,0x7f,0xfb,0xdc,0x89,0xa4,0x1e,0x6b,0xf7,0x08,0x26,0x50,0xc7,0xbe,0xcf,
    0xef,0xfa,0x36,0xc4,0xd1,0x35,0x51,0x5f,0x9a,0x41,0x3e,0xa1,0x24,0x2d,0xef,0xc0,
    0xc1,0xff,0xbd,0xbd,0x87,0x9d,0x10,0xd7,0x9f,0x00,0xd8,0x56,0x53,0x88,0xe1,0xf7,
    0x09,0x98,0xa5,0x45,0x2a,0x89,0xad,0x61,0x07,0x39,0x36,0x91,0xea,0xf7,0xae,0xba,
    0xeb,0xae,0xbb,0xef,0xf7,0xfb,0xef,0xf7,0xfe,0x1a,0x87,0xff,0x0f,0xc3,0x84,0xac,
    0x09,0xa0,0x83,0xbf,0xbc,0x0e,0x70,0x6a,0x55,0x73,0x76,0xbf,0xef,0xd5,0xff,0xf8,
    0x4a,0xf8,0xd5,0x3f,0x03,0xfc,0xbf,0xbc,0x6d,0x5f,0xbf,0x8f,0xa3,0xee,0xdf,0xfc,
    0x25,0xce,0xa9,0xcf,0x57,0xbf,0xff,0x96,0x45,0xcc,0x49,0xf2,0x79,0x7d,0xff,0xb8,
    0xd5,0x52,0xa9,0xff,0xf8,0x7f,0xa9,0x64,0x3f,0xfc,0x3d,0x15,0xec,0x2c,0x4e,0x1c,
    0xf7,0x16,0x03,0xf7,0xef,0xed,0xf7,0xf8,0xfc,0x23,0xbd,0x7f,0x47,0xff,0xbf,0xdf,
    0x0d,0x14,0xe3,0x22,0x7f,0x6b,0xe1,0xff,0xf5,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0xfe,0x18,0x7f,0x09,0xf8,0x02,0x26,0x1b,0x28,0xc5,0xb8,0xda,0x9a,0x38,0xc6,0xf0,
    0x02,0xf1,0xf7,0xff,0xf3,0x04,0xa2,0x34,0x67,0x80,0x18,0x9d,0x7c,0xef,0xf5,0xb0,
    0x00,0x5a,0xa2,0x5b,0x08,0xfc,0x2f,0x0b,0x2d,0xff,0x40,0x87,0xcf,0xb7,0xb4,0x47,
    0xe6,0xf0,0x36,0xa3,0x88,0x1e,0xd5,0x07,0xd7,0xf9,0xf7,0x81,0x6c,0x22,0xb9,0xdf,
    0x95,0x81,0x9a,0x2a,0xb8,0x0b,0xfb,0xf4,0x46,0x82,0x72,0x82,0x7e,0xff,0x80,0x4d,
    0x82,0x23,0x7f,0xc0,0x09,0x3a,0x00,0x39,0xd4,0x0a,0x06,0x0f,0xb1,0xc0,0x6e,0x11,
    0xb2,0xc7,0xe1,0x8d,0xb4,0x69,0x1d,0x4c,0x05,0x9c,0xc8,0x57,0x0f,0xfc,0xc9,0xf7,
    0xad,0xed,0x8b,0x18,0x48,0x29,0x4a,0xcd,0x42,0x60,0x9a,0x36,0x29,0xe0,0x14,0x76,
    0x2a,0x84,0x89,0x6f,0x28,0xfc,0xff,0x47,0xda,0x20,0x34,0x07,0x99,0xe3,0x38,0xb1,
    0x5a,0x88,0xe8,0x5f,0xf1,0x91,0x26,0x00,0x0c,0x17,0x9f,0x9d,0x98,0x08,0x07,0x61,
    0x68,0x0b,0x0e,0xc7,0xa7,0x0f,0xea,0x13,0x84,0x67,0x00,0x1a,0xf0,0x51,0xd5,0x80,
    0xb8,0x76,0x9f,0xf2,0x8a,0xd6,0xc7,0x1b,0x91,0x40,0x69,0x40,0xa9,0xa0,0xe0,0xc6,
    0x0a,0x13,0xaa,0x19,0x01,0x76,0xf9,0x11,0x98,0xf7,0xfb,0xe0,0x33,0xd2,0x50,0x89,
    0xf5,0x79,0x86,0x1d,0x80,0x9a,0x3b,0xf1,0xff,0x8a,0x8a,0xdf,0x17,0xc0,0x00,0xd9,
    0x0c,0x94,0x94,0x65,0xac,0x24,0xb1,0x83,0x38,0xfd,0x74,0xf7,0xfb,0xb6,0x32,0xd9,
    0x8b,0x94,0x85,0x66,0xff,0x4e,0x32,0x82,0x00,0x7b,0x4b,0xf3,0x1e,0x64,0x2a,0xd9,
    0x03,0x51,0x74,0xba,0xfc,0x94,0x88,0x20,0xdc,0x00,0x4f,0xf8,0x0b,0x8a,0xfc,0xef,
    0x18,0x7b,0xfe,0x0e,0x00,0x3e,0x76,0xc6,0x32,0x3c,0xf2,0x95,0xbd,0xff,0x6b,0x07,
    0xc2,0x7c,0x00,0x3f,0x68,0xc1,0x26,0xe6,0x70,0xe3,0x4b,0x10,0x25,0x6d,0x87,0x12,
    0x16,0x11,0x99,0xe0,0x31,0xbb,0xe8,0x0f,0xce,0xe8,0xff,0x07,0xc7,0x21,0xde,0xbe,
    0xa0,0x88,0x2e,0xce,0xfa,0xce,0x29,0xcd,0xf9,0x57,0xcb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xaf,0xe9,0x8b,0x57,0x52,0xe2,0xb0,0x06,0xdc,0x83,0x30,0xe8,
    0x77,0x6c,0x1a,0xbd,0x4f,0x69,0x88,0xff,0xb5,0xe0,0x02,0xf4,0xa8,0x17,0x0b,0xe7,
    0xa0,0x57,0x9f,0x81,0x28,0xe4,0x92,0x9a,0x80,0x2d,0xe2,0xff,0xae,0x67,0x7c,0x90,
    0xb1,0xfd,0xd8,0x23,0x81,0xb2,0x90,0x9c,0xc7,0xee,0x00,0x00,0x08,0xff,0xa4,0x00,
    0xc1,0xbe,0x7c,0x57,0xc0,0x85,0x9f,0x29,0xa7,0xce,0xbc,0x3b,0x88,0xc5,0x79,0x94,
    0x96,0x9e,0x37,0xdb,0xdf,0x29,0xef,0xff,0xfc,0x1e,0xb8,0x4d,0x2c,0x01,0x4c,0xbc,
    0x46,0x1f,0x75,0xaf,0xfd,0xff,0xbb,0xa1,0x16,0x6a,0xe1,0x8f,0x78,0xa1,0x79,0x00,
    0x81,0x54,0x1b,0x67,0xb9,0xe9,0xf2,0x61,0x75,0x08,0x85,0xcb,0x9f,0x8b,0xc2,0x5c,
    0x86,0x19,0x8c,0x01,0x7b,0x93,0x8e,0x82,0xcc,0xb8,0x88,0x01,0xe9,0x6e,0x6c,0x56,
    0x1f,0x05,0xb5,0xdf,0x07,0x71,0xb0,0x13,0xd1,0x9a,0x2a,0xf3,0x2b,0xc0,0x6e,0x76,
    0x8c,0x51,0xd5,0xf1,0x9f,0xdf,0x48,0xc1,0xbe,0x39,0x82,0x55,0xf7,0x2e,0x19,0x99,
    0xc7,0x81,0x41,0x33,0xf7,0xf8,0x00,0x30,0x0f,0xdb,0x94,0x6d,0xa2,0x14,0x48,0x7f,
    0x92,0x28,0x73,0x1e,0x14,0x86,0x0a,0x85,0xda,0xea,0x3c,0x27,0xdd,0x7f,0xe0,0x00,
    0xdb,0x51,0xbc,0x00,0xda,0x95,0x1a,0xf4,0xf4,0x05,0x2e,0x4e,0x55,0xff,0xb0,0xa6,
    0xe6,0xa6,0xe3,0xf2,0x85,0x07,0x29,0x49,0x44,0x5f,0x9f,0xdd,0xc8,0x62,0xc3,0xbe,
    0x04,0x1b,0xed,0x59,0x11,0x04,0xa1,0x7b,0xb5,0x37,0x03,0xc5,0xef,0x15,0x8e,0x6f,
    0x98,0x05,0x17,0xc9,0x4c,0xf4,0x9c,0x27,0x4e,0x92,0x15,0x0a,0xef,0xde,0xc1,0x10,
    0x2f,0x4d,0x87,0x41,0xcf,0x87,0x0a,0x55,0xf0,0x30,0x72,0x5e,0x3c,0xf8,0xd8,0x9f,
    0x3c,0xfe,0x01,0x55,0x73,0x5c,0x69,0x75,0x0f,0xb3,0x65,0x12,0x44,0x0f,0xea,0xb0,
    0xed,0x3d,0x5f,0xbf,0x12,0xdb,0x41,0x85,0xc9,0xc8,0x1d,0x82,0x7b,0x2f,0x56,0x2c,
    0x88,0x0a,0x26,0x0b,0xe0,0x00,0x06,0x1d,0xcd,0xaf,0x47,0xd7,0xc6,0x70,0x22,0x4c,
    0xc9,0x0c,0x20,0x1d,0x77,0x0d,0xcc,0x62,0x85,0x61,0xff,0xae,0x39,0xc3,0xf4,0x42,
    0xdc,0x7f,0xff,0x9b,0x06,0xac,0x2d,0x94,0x2c,0xca,0xa9,0x9b,0xc1,0x95,0xbb,0xbb,
    0x9f,0xff,0xff,0xff,0xf6,0xf3,0x3a,0xd8,0x44,0x65,0x48,0xbd,0xc8,0xa9,0x0f,0x8e,
    0x3c,0x3f,0x9d,0xbf,0xff,0x0f,0x41,0x79,0xc0,0xea,0x53,0xd1,0x98,0xfc,0xdf,0x2b,
    0x45,0x25,0x3b,0xdf,0x5e,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xbb,0xef,
    0xae,0xfa,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
    0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
    0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
    0xba,0xeb,0xae,0xba,0xf0,
};
static unsigned char MPEG4_OutOfRange_Japan_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xda,0x05,0x07,0xe4,0x00,0x00,0x00,0x01,
    0x68,0xce,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x11,0xff,0xff,0x87,0xa2,
    0x80,0x00,0x80,0x8f,0xbc,0x56,0xf7,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,
    0x7d,0xf7,0xdf,0x7d,0x62,0xb5,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xad,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0xff,0xfc,0x03,0x04,0x30,0x01,0xf0,0xcb,0x08,0xf4,0x62,0xe1,0xd5,
    0xde,0x4c,0x93,0x00,0x5c,0xe7,0x4f,0x5f,0xff,0xd8,0x41,0xb0,0xae,0x00,0x19,0xb6,
    0xdf,0x29,0xb9,0x84,0x03,0xd0,0xcc,0xa0,0xac,0x0d,0xd3,0x18,0x22,0x3b,0x1e,0x6e,
    0x08,0xd9,0xdb,0x94,0x41,0x11,0xdf,0xbf,0xff,0x08,0x7c,0x10,0x40,0x23,0xd7,0xdb,
    0x0f,0x51,0xd2,0xc1,0x56,0xc9,0xc3,0x4a,0xd7,0x76,0x3d,0x40,0x08,0x24,0xb7,0xfd,
    0x6f,0xef,0x0a,0xc1,0x1f,0xb6,0xfc,0x03,0x50,0x51,0x11,0xfa,0x53,0xaf,0xc0,0x02,
    0x79,0x2c,0xcf,0x20,0x91,0xdd,0x17,0xc2,0x14,0xe2,0xbe,0xb2,0x8e,0x7b,0xff,0x8f,
    0x50,0x85,0x78,0x4a,0x6b,0xc8,0x54,0x04,0xf2,0x3d,0x6e,0x06,0x32,0x93,0x80,0x42,
    0xd4,0x96,0xff,0xb6,0x0b,0x73,0xa4,0x0e,0x42,0x2b,0xae,0x9f,0xff,0x8b,0x70,0x08,
    0x56,0x00,0x29,0xa1,0xbe,0xe4,0x11,0xfe,0xcb,0xed,0xc8,0x84,0x64,0x60,0x49,0xd4,
    0x36,0x1f,0xff,0xf3,0xf0,0x00,0xe8,0xb2,0x0d,0x13,0x0b,0x9a,0xbd,0x9c,0x1e,0x00,
    0x51,0x4f,0x2d,0xff,0x85,0x26,0x6b,0x0a,0xc0,0x19,0xf7,0xd7,0xfd,0x6f,0x1a,0xd6,
    0xc8,0xc0,0xfb,0x61,0xc0,0x90,0x71,0x12,0x0f,0xc8,0x5e,0xdb,0xdf,0xe8,0x00,0x3a,
    0xea,0x78,0x54,0xb0,0x41,0xad,0x6f,0xfe,0xf9,0x43,0xc3,0xca,0x88,0x51,0xc5,0x6c,
    0x02,0xc9,0x66,0xc7,0x68,0x44,0x23,0x61,0x7f,0xbf,0xf8,0x8e,0x27,0x0a,0xe0,0x07,
    0xb0,0x86,0x27,0xc4,0xd9,0xa5,0xf3,0x5f,0x4d,0xd8,0xda,0x28,0xfd,0x44,0x6a,0x0c,
    0x2d,0x7a,0xf0,0xea,0xef,0x98,0x1e,0x9f,0x7d,0xd6,0x01,0x6c,0x90,0xef,0x9c,0xbc,
    0xc4,0xff,0xc4,0x93,0x3c,0x2b,0x00,0x31,0x2e,0x24,0x6d,0x2e,0xd0,0xe3,0xa4,0xf4,
    0xfc,0xd2,0xfb,0x44,0x64,0x0b,0x00,0xc4,0x95,0xdf,0x47,0xb8,0x10,0x08,0xa9,0x81,
    0x85,0x91,0xea,0xbc,0x0f,0x11,0x6d,0xdf,0xb3,0xf2,0xc2,0xa9,0xda,0x02,0xc3,0xa9,
    0x12,0x19,0xea,0xbe,0x11,0x50,0x2f,0xef,0xdf,0xf8,0x0f,0x66,0x85,0x60,0x4f,0xca,
    0xca,0x1b,0xfc,0x4a,0xbf,0x89,0x40,0x53,0xa4,0xa7,0x15,0x6b,0x31,0x38,0x38,0x01,
    0x1b,0x09,0xce,0x80,0xea,0x38,0x9f,0x00,0x1e,0x7b,0x7a,0x59,0xbb,0xfc,0xdc,0x80,
    0x36,0xae,0xc1,0xb8,0xbf,0x2b,0xee,0xff,0x84,0x70,0xa4,0x2b,0x1e,0x00,0x86,0x12,
    0x94,0xb6,0x40,0x04,0x01,0xb5,0xae,0x00,0xcf,0xbe,0xbf,0xeb,0x78,0x15,0x1a,0xed,
    0x7d,0xbe,0x01,0xa2,0x70,0x09,0xd7,0x0b,0x0d,0xdc,0xef,0xfe,0xbf,0x85,0x70,0x01,
    0x90,0x31,0x63,0x1e,0x04,0xf9,0x8a,0xd3,0xa3,0xf6,0xb0,0x7d,0xc1,0x08,0xbf,0xc1,
    0xf8,0x00,0x8c,0x2c,0x50,0x34,0x97,0x07,0xc8,0x8e,0xff,0x73,0xa6,0x3f,0xeb,0x44,
    0xaa,0xe1,0x58,0x2e,0x36,0x3c,0x47,0xa4,0x2a,0x5f,0x7b,0xc0,0xdd,0xce,0x23,0x62,
    0x78,0x67,0x6e,0xff,0x0d,0xda,0x1c,0x5d,0x87,0x3f,0xa8,0x00,0x18,0xf5,0x5b,0x0a,
    0x9d,0x8c,0x02,0xe8,0xaa,0x32,0xf3,0x24,0x9f,0x57,0x46,0x97,0x27,0x07,0xfd,0x2c,
    0x99,0xe0,0xc5,0x55,0x2a,0x33,0xdb,0xbf,0xe3,0x5d,0x54,0x21,0x58,0xf1,0x11,0x5a,
    0x5b,0xc7,0xb1,0x2a,0xc2,0x38,0x85,0x0c,0xcc,0xd0,0x8c,0x09,0x7d,0x01,0xbf,0x9e,
    0x00,0x27,0x62,0x69,0x91,0x83,0x24,0xba,0xbe,0x25,0x49,0x9f,0xff,0xac,0x4e,0x15,
    0xf8,0x00,0xac,0xc4,0xe7,0xc2,0x29,0xeb,0x51,0xbb,0x59,0x84,0x09,0xc1,0x7c,0x8e,
    0x44,0xf0,0xcb,0xea,0xc3,0xbd,0xfa,0x01,0x98,0xcd,0x82,0x85,0x62,0x07,0xd2,0x20,
    0x00,0x00,0x40,0x2f,0x62,0x72,0xb1,0xa2,0x55,0x87,0xbf,0xd7,0xfd,0xcc,0xc3,0xe0,
    0x83,0xa3,0x58,0xa2,0x0b,0x4d,0x74,0xed,0xc3,0xfd,0x65,0xeb,0xab,0xd8,0x04,0x09,
    0xf7,0x7b,0xef,0x68,0x77,0x88,0x45,0x54,0x22,0xe4,0xba,0xeb,0xe3,0x60,0x06,0x06,
    0x94,0xe2,0x17,0x00,0x0e,0x4c,0x81,0xc7,0xe5,0x16,0x46,0x7d,0xed,0x03,0xf6,0x6c,
    0x44,0x57,0x6f,0x7d,0xe1,0xe0,0x36,0x41,0x3a,0x5b,0x7b,0xae,0xe8,0x93,0xf8,0x16,
    0xd0,0x64,0x95,0xb2,0xfa,0x6d,0x76,0x84,0xd8,0x7c,0x5d,0x9e,0x00,0x23,0x1b,0x6f,
    0x95,0xef,0xff,0xe8,0xa7,0xa7,0x87,0x51,0x1f,0xfa,0x70,0x1d,0x64,0x58,0x5d,0x0b,
    0x8f,0x5d,0xf3,0xfb,0x2a,0x03,0xae,0xb0,0xe1,0x52,0x14,0xe4,0x0a,0xb3,0x47,0x52,
    0x08,0xe6,0x28,0xd6,0x34,0x7b,0x54,0x3e,0x1b,0x72,0x7b,0x80,0x15,0x4f,0x34,0x50,
    0x01,0xa8,0xc5,0x58,0x88,0x39,0x7e,0x83,0x78,0x24,0xfe,0xfb,0xd0,0x20,0x00,0x73,
    0xb2,0x2f,0x23,0xfe,0x10,0xd2,0xbc,0x04,0x20,0xe3,0x32,0x3a,0x37,0x91,0x0f,0xcf,
    0x3e,0xd7,0xd1,0xb2,0x69,0x22,0xfa,0xf8,0x00,0x1f,0xfe,0x04,0x6a,0xa0,0x53,0xc0,
    0xa7,0xfb,0xd0,0x00,0x5e,0xad,0x22,0x64,0x3e,0x15,0xd3,0xff,0x7a,0xd7,0x9a,0xe0,
    0x29,0x4c,0x0e,0x7b,0x6a,0xb2,0x11,0xce,0xc7,0x9f,0xbd,0xb7,0xd2,0xdb,0x46,0x8f,
    0xff,0xe7,0xec,0x3d,0x6f,0xc7,0x73,0x6f,0x80,0x2f,0xe6,0xe0,0xb6,0x50,0x3e,0x13,
    0x2b,0xd4,0x79,0x56,0xc0,0x00,0x40,0x00,0x2c,0x43,0xdf,0x5e,0x0e,0x0a,0x5b,0xad,
    0xa3,0x91,0xfb,0x5f,0xc2,0xbc,0x3b,0x2e,0x98,0x66,0x49,0xff,0xfe,0x6e,0xad,0x01,
    0x81,0xf8,0x41,0xfe,0x12,0x7c,0x35,0x2e,0xc6,0xc4,0x6a,0xff,0xd2,0x1f,0xf2,0x27,
    0xdc,0x15,0xc5,0xcc,0x67,0x38,0x81,0x7f,0x24,0x7a,0xbc,0x08,0x1f,0xf8,0x00,0x1c,
    0xa6,0x6c,0x85,0x95,0xd0,0xf7,0x00,0x07,0xce,0xa2,0x08,0x95,0xd8,0x53,0x4d,0x0c,
    0xf0,0x08,0xf7,0xc0,0x7f,0xbf,0xee,0x6a,0x08,0xd9,0x42,0xed,0x0b,0xbf,0x2f,0xc1,
    0x1d,0xa7,0x14,0xcc,0x5e,0xda,0x9c,0xa2,0xb5,0xb3,0x6b,0xe6,0x0d,0x27,0x65,0xf4,
    0x35,0x7b,0x82,0x39,0xc4,0x43,0x2d,0x46,0x51,0x7b,0x91,0xf1,0x53,0x3f,0x11,0xfb,
    0xf5,0x4b,0xd0,0x28,0x7b,0x21,0x56,0xd2,0xa8,0x24,0xd0,0x2c,0x9a,0xbe,0xb0,0x25,
    0x89,0xc0,0xd5,0xe3,0x98,0xcf,0xf1,0x6e,0x99,0xb1,0x34,0x57,0xce,0x4e,0xcc,0x92,
    0x57,0x5e,0xf0,0xe0,0x63,0x96,0x19,0x96,0x24,0x28,0x33,0x9d,0x61,0xfb,0x54,0x67,
    0x47,0xd6,0xa4,0xff,0x5b,0xc1,0x5f,0x4d,0xb6,0x42,0xa9,0x7d,0x7e,0x0a,0xf2,0x11,
    0x33,0x5f,0x40,0x5a,0x68,0x16,0x66,0x76,0x63,0xde,0x27,0xc6,0x06,0x09,0x68,0xd7,
    0x00,0x00,0x07,0x64,0xaf,0xcc,0x6b,0xd8,0x47,0xde,0xf0,0x53,0x73,0x59,0x43,0x3a,
    0x1b,0x81,0x95,0xae,0xde,0xf8,0x2f,0xbc,0x69,0xa2,0x9f,0x75,0x1a,0xd2,0x64,0x5c,
    0xa9,0x58,0x7e,0x5d,0x7e,0x4b,0x44,0xf1,0x23,0x94,0x7e,0x01,0xa8,0x19,0x34,0x1c,
    0xfc,0x1c,0xdf,0x60,0x1a,0xd2,0xc5,0x26,0xb0,0xa5,0x46,0x8e,0xb2,0x49,0x51,0xeb,
    0x3d,0xeb,0xc9,0x2d,0xde,0x0e,0x58,0xd4,0x3a,0x3c,0x21,0x7f,0x46,0x85,0xa1,0xad,
    0xb4,0xd4,0x33,0x50,0x84,0x02,0xc8,0x99,0x69,0x85,0x0b,0x3b,0x7c,0x3c,0x00,0x0a,
    0x3d,0x0b,0x2c,0xe2,0x63,0x54,0x2d,0x0e,0x07,0x9b,0xc0,0xc0,0x00,0x02,0x00,0x76,
    0xf9,0x16,0xbd,0x6f,0xc0,0xc5,0x0e,0x3d,0xb8,0xf1,0xfb,0x3f,0xf4,0x30,0xdb,0x6c,
    0x25,0xed,0xf0,0xc1,0xc0,0x00,0x88,0xa8,0x64,0xb0,0x01,0xb0,0x48,0xaa,0xe8,0x53,
    0x59,0x0c,0x81,0xb3,0x12,0x1f,0xfb,0x7e,0x26,0xf0,0xec,0xba,0x3e,0x67,0x7f,0xe3,
    0x13,0x20,0x72,0xd4,0xca,0x4d,0x86,0xe6,0x7c,0x35,0xa2,0x00,0x0c,0x7f,0x60,0x15,
    0x05,0xe0,0x25,0x66,0xbe,0x88,0x47,0x28,0x29,0x1c,0xa6,0xb3,0x66,0x25,0xff,0xf5,
    0xa9,0x01,0xec,0xce,0x41,0x79,0xe7,0xbf,0xaf,0xbd,0x88,0x8d,0x48,0xa7,0x2b,0x9b,
    0xff,0xe0,0x3a,0xd0,0x20,0xe7,0x11,0xeb,0x18,0xee,0xaf,0x7f,0x85,0x3c,0x8e,0x23,
    0x46,0x48,0x36,0x9f,0xa2,0x35,0x7b,0xd6,0x4d,0x96,0x33,0xdd,0x47,0x59,0xed,0x7f,
    0x33,0x6e,0x9c,0xaf,0xf9,0xf8,0x93,0xc8,0x3c,0xe2,0x5a,0x7b,0xcf,0x01,0x99,0xa9,
    0x9b,0x0b,0x58,0x00,0x85,0x3e,0x03,0x98,0x6b,0x48,0x13,0x22,0x64,0x4d,0x9b,0xb4,
    0x8e,0x70,0x22,0x14,0x4e,0x65,0xf5,0xd6,0x91,0xd7,0x67,0x98,0xea,0x47,0xff,0xb0,
    0x9a,0x02,0x97,0xb9,0x55,0x0c,0x56,0xfd,0xdc,0x48,0x5a,0x44,0x77,0x6a,0x2d,0xfb,
    0x4c,0xf8,0x46,0xcc,0x51,0x81,0x6a,0x77,0xb0,0x07,0x37,0x20,0x2d,0x75,0x33,0x4f,
    0xc8,0xd0,0xcb,0xb6,0xe9,0x53,0xf0,0xd8,0x04,0xfd,0xa9,0x58,0x7e,0x29,0x93,0x21,
    0x7f,0x01,0x5e,0xff,0x75,0x2a,0xa6,0xb5,0xd5,0x3d,0x31,0x08,0x6d,0xd3,0x87,0x3d,
    0xf5,0xe0,0xf6,0x65,0xc1,0x06,0x2b,0xea,0x05,0xdf,0xee,0xe9,0x90,0x39,0xb2,0x84,
    0xbb,0x4a,0x7b,0xee,0x3e,0xf8,0x85,0x29,0x5d,0xc4,0x8f,0xf5,0x12,0x63,0xd7,0xb7,
    0x02,0x2d,0xf7,0xbb,0x49,0x9b,0x72,0x09,0xa8,0xe3,0x7d,0x5f,0x6a,0x4d,0x1c,0x40,
    0xd4,0xbc,0xf5,0x80,0x89,0xae,0x5c,0x79,0x66,0xed,0xeb,0x0b,0x65,0x89,0x93,0xa9,
    0x39,0xdf,0x74,0x3c,0x66,0x02,0x70,0x2d,0x8a,0xa3,0x65,0xcc,0x52,0xc1,0x37,0x55,
    0x66,0x05,0xdb,0x96,0x0c,0x42,0xfc,0x62,0xfb,0xb5,0xcf,0x95,0x8d,0x8e,0x84,0x1f,
    0xb6,0xb6,0x25,0x58,0xa5,0x30,0x4f,0x62,0xd2,0xdb,0xe0,0xe5,0x11,0x83,0x75,0x17,
    0xff,0xe1,0x80,0xd8,0xcd,0xbd,0x12,0x36,0x9e,0x0f,0x2a,0x23,0x30,0x4b,0xd8,0x5f,
    0x5e,0x07,0x83,0x1b,0x7e,0xc0,0x3c,0x0c,0x07,0x56,0x48,0x84,0x8d,0x5a,0x0b,0xfd,
    0xfb,0x01,0x36,0xb4,0xcf,0x2c,0x21,0x60,0xf7,0xed,0x14,0x29,0xb4,0x8a,0x07,0x4e,
    0x51,0xf3,0x72,0x8a,0xef,0xab,0x8d,0x3c,0xfe,0xb8,0x14,0xb8,0x8c,0x1e,0x60,0xff,
    0x3b,0x32,0x16,0x55,0x08,0x2a,0xfd,0xfa,0xd1,0x0a,0x4b,0x48,0x08,0x36,0x52,0x8b,
    0x5f,0xbf,0x1b,0xb0,0x95,0xf9,0x5e,0xff,0xf8,0x73,0x0f,0xcc,0x22,0xcc,0xbf,0x6e,
    0x53,0x1d,0xc7,0x38,0x05,0x00,0x44,0x96,0xff,0xff,0xfa,0xb8,0x92,0x7c,0xc6,0x50,
    0xc7,0xe7,0xd2,0x92,0x1a,0x21,0x11,0x00,0x01,0x7a,0xfd,0xc6,0xf3,0x4c,0x0a,0xe0,
    0x8a,0xe2,0x1a,0x99,0x52,0x5b,0x63,0xab,0x89,0xc6,0x95,0x43,0xfe,0x7f,0xc3,0x8e,
    0x45,0x85,0xd5,0x23,0xf2,0x68,0x14,0x7a,0xef,0xb4,0x1b,0x01,0xa3,0x76,0x60,0xb5,
    0xa3,0xa9,0xe3,0x4b,0xf1,0xc6,0x01,0x3e,0xfb,0x90,0x00,0x06,0x81,0x56,0xcb,0x1f,
    0x00,0x01,0x00,0xfb,0xa5,0xbf,0x78,0x92,0x24,0x00,0x02,0x01,0xaf,0xcf,0xd3,0xd1,
    0xc4,0x03,0x14,0x86,0x61,0x3a,0x0c,0x0d,0xe9,0x94,0x23,0x47,0x39,0xb6,0xfb,0x80,
    0xc0,0x0b,0x5e,0xa0,0x0b,0x05,0x24,0x8c,0x02,0xe9,0x9d,0x06,0x13,0x2d,0x32,0x46,
    0xfc,0x03,0xd4,0x85,0x76,0xde,0x9c,0x2e,0x0c,0x02,0x2b,0x9e,0x99,0x3e,0x00,0x0c,
    0xf0,0xb2,0x16,0xfe,0x2f,0x62,0xbb,0x7c,0x1f,0x13,0x19,0xdb,0x0f,0x82,0xea,0x44,
    0x2a,0x85,0x61,0xbe,0xdf,0xca,0xf9,0xfe,0x30,0x8c,0x44,0xa6,0x78,0x07,0x40,0x1e,
    0x5a,0x1e,0x1d,0x42,0x3e,0x7e,0x08,0xf5,0xfb,0x7f,0x36,0x64,0xdf,0xb0,0xcc,0xff,
    0xbd,0xa9,0xc1,0x4f,0x65,0x05,0x49,0x08,0xae,0xc7,0x8e,0x58,0xcc,0x00,0x1d,0xa6,
    0x3e,0xc2,0x52,0xd6,0xa2,0xc0,0x56,0x3e,0xf1,0x69,0xd7,0xff,0x3d,0xa4,0x1d,0xb3,
    0xb5,0x02,0x75,0x98,0xa1,0x32,0x6c,0x31,0xc2,0xde,0xcb,0x84,0x48,0x37,0x0c,0x50,
    0x55,0x14,0x90,0x10,0xd9,0x98,0xae,0x64,0xc8,0xe5,0x80,0x78,0xa3,0xe5,0xa5,0x65,
    0x0f,0xec,0xff,0x9b,0x83,0xe0,0x00,0x20,0x22,0xb3,0xa0,0x77,0x47,0x8f,0x38,0xc5,
    0xb6,0x47,0x37,0x9d,0x23,0x09,0x36,0xd2,0x07,0xde,0x04,0xc2,0xba,0x54,0x0d,0x75,
    0x6e,0x85,0xfd,0xfd,0x2e,0x5a,0x27,0x96,0x23,0xd3,0x78,0x21,0x4a,0x11,0x6b,0x7e,
    0x62,0x9e,0x9f,0xe0,0xf5,0x26,0xe3,0xd3,0xb5,0xf0,0x00,0xda,0x6f,0x42,0x8a,0xa8,
    0x7e,0x2a,0x53,0xd8,0xe2,0x0c,0xe7,0xfd,0x71,0x65,0x49,0x66,0x0e,0xc4,0xc7,0xbe,
    0x30,0x28,0xf4,0x45,0x4c,0x32,0x84,0xa3,0x25,0xa0,0x06,0x01,0x26,0x6b,0x64,0x81,
    0x7a,0x71,0x9d,0x88,0x87,0x56,0x1f,0x7d,0x26,0x65,0x85,0x88,0x12,0x17,0xad,0xf8,
    0x24,0xd1,0x46,0x08,0xcc,0x08,0x5d,0xbb,0xe0,0xb4,0xca,0x19,0x0f,0x88,0x3c,0xfd,
    0xbd,0xea,0x20,0x15,0x11,0x13,0x0f,0x83,0x06,0x95,0x51,0x96,0x4d,0xb0,0x86,0xaf,
    0x89,0x37,0x36,0xf8,0xbe,0x82,0x89,0x3e,0x71,0x61,0x57,0x5f,0xee,0x02,0x99,0xab,
    0xef,0x5f,0xdf,0xe0,0xc1,0xb7,0x97,0x19,0x19,0x57,0xc1,0x52,0x71,0x00,0x99,0x82,
    0x92,0x27,0x9f,0xca,0x66,0x76,0x80,0x10,0x25,0xe6,0x90,0xb3,0x09,0xc1,0xac,0xdd,
    0xae,0x00,0x26,0x8a,0x8d,0x86,0x01,0xf0,0x82,0x1f,0xb5,0xa7,0xe0,0xed,0xb4,0x77,
    0x93,0x58,0x73,0xf4,0x30,0xea,0xbe,0xf0,0x15,0x1b,0xf2,0x9d,0x78,0xef,0xe2,0x33,
    0xdb,0xd5,0xa9,0xe5,0x9b,0x46,0xf6,0xb7,0x5e,0x34,0x56,0x0a,0x89,0x23,0xf7,0xc1,
    0xc0,0x20,0x38,0x2e,0xff,0xdb,0x5e,0xee,0x09,0xa5,0x3f,0xff,0x7e,0xe7,0x24,0xae,
    0x97,0xdd,0x21,0xcb,0x8b,0x6b,0xc2,0xa5,0xaf,0x68,0x9f,0x38,0x0d,0x45,0x95,0xe9,
    0x2e,0xde,0x31,0xeb,0xed,0xaa,0x61,0xf2,0x3d,0x8d,0x5f,0x0c,0xb6,0x28,0x4a,0x82,
    0xb2,0xfe,0x9a,0x48,0xed,0xe4,0xd5,0x5e,0xa9,0xd1,0x3d,0x0f,0xf8,0x4f,0x65,0x34,
    0xc5,0x54,0x95,0x84,0x3f,0x3e,0x0e,0x3e,0x1b,0x2d,0x87,0xff,0x8d,0xa1,0xd7,0xf4,
    0x56,0xe3,0x7e,0xa3,0xbe,0xec,0x3f,0xef,0xd0,0xd8,0xd6,0x6f,0xe8,0x0f,0xd7,0x5d,
    0x77,0xfb,0xfd,0xf7,0xdf,0x7f,0xfd,0x7f,0xfc,0x25,0xfe,0xfb,0xda,0xbb,0x19,0x6f,
    0xdf,0x1f,0xff,0x09,0x43,0xcf,0x97,0xeb,0xdf,0x4d,0xf4,0xab,0xeb,0x7b,0x92,0x68,
    0x44,0xc8,0x6e,0xd0,0x7f,0xf5,0x7f,0xfe,0x12,0xca,0x8a,0x42,0x48,0xd0,0xd8,0x3f,
    0xe7,0x10,0x2a,0xc1,0xa2,0x44,0x90,0xfb,0xf1,0xff,0x12,0x49,0x29,0x24,0x95,0x2f,
    0xff,0xef,0x68,0xbf,0x11,0xc8,0x75,0x30,0xff,0xff,0xff,0xd5,0xf3,0x7f,0xfe,0x12,
    0x86,0x70,0x61,0xd8,0x2e,0x3f,0xf7,0xb6,0x60,0xaa,0x55,0x5b,0xff,0xde,0x7f,0x83,
    0x9a,0x76,0xd2,0xe2,0xe0,0xa5,0x9a,0x47,0x46,0xbe,0xbf,0xff,0x7e,0xad,0xff,0xc2,
    0x5b,0x8a,0x54,0x48,0x49,0x2f,0xbf,0xf5,0x0e,0x1c,0x94,0xb0,0x53,0xfa,0x07,0xfe,
    0xbc,0xbf,0xf8,0x4b,0x81,0x3c,0xdc,0x90,0x54,0x6c,0xa6,0x47,0xfa,0xfb,0x61,0xfc,
    0xfc,0x5f,0xfa,0x8f,0xff,0xf0,0x97,0xc0,0x61,0x51,0x2a,0x24,0x8a,0x43,0xeb,0xdf,
    0x4d,0xf4,0xab,0xea,0x33,0x58,0xd6,0xb1,0x2b,0x57,0x07,0xf1,0x3c,0x5f,0xff,0x84,
    0xa0,0x03,0x0f,0x52,0xa9,0x6b,0x12,0xf0,0x78,0xfc,0xad,0x68,0x06,0x81,0xaf,0xab,
    0xab,0xff,0x26,0xeb,0xae,0xba,0xeb,0xaf,0xe3,0xa0,0x95,0x23,0x1d,0xf0,0x1e,0x00,
    0x02,0x01,0xf4,0x00,0x49,0x60,0x07,0x62,0x61,0xfc,0x66,0x39,0x49,0x7d,0x8c,0xde,
    0x80,0x00,0x40,0x36,0x80,0x08,0x3e,0x3f,0x30,0x29,0x91,0x98,0x5c,0x54,0x35,0x0a,
    0x37,0x68,0x01,0x7d,0x30,0x99,0x07,0xf6,0xd1,0x21,0x02,0xcb,0x40,0xed,0x66,0xa1,
    0x89,0xd0,0x05,0x66,0x41,0x54,0x1e,0x49,0xa6,0x5f,0xf9,0xc3,0x0c,0x2c,0xf1,0x65,
    0xff,0xdb,0xc2,0xc9,0x8b,0xa1,0x38,0x3b,0x15,0x07,0x50,0xd4,0x09,0xeb,0x89,0xa5,
    0x14,0xb9,0x48,0x42,0xc6,0x43,0x00,0x79,0x64,0xd5,0x68,0x01,0xb4,0x22,0x64,0xa3,
    0x0c,0x37,0x55,0xe7,0x98,0x28,0x37,0xef,0xf0,0x18,0x04,0xc0,0x00,0x47,0x10,0x3b,
    0x21,0x36,0xfe,0x1f,0x30,0xd9,0x46,0x2d,0xc6,0xd4,0xde,0x0f,0x8e,0x6c,0x3a,0x5d,
    0x24,0x27,0xc7,0x95,0x33,0xa7,0xac,0x4e,0x8f,0x00,0xbc,0x4a,0x3f,0xc1,0x8e,0x33,
    0x78,0x02,0x58,0xfb,0xff,0xff,0xe0,0x68,0x98,0xcf,0x00,0x8f,0x5f,0x6d,0x00,0x0b,
    0x54,0x4b,0x61,0x1f,0x85,0xe1,0x65,0xbf,0xeb,0xe0,0x87,0xcf,0xb7,0xb4,0x47,0xe6,
    0xee,0xab,0x9a,0xe6,0x93,0xff,0xfe,0x06,0xd4,0x71,0x03,0xda,0xa0,0xfa,0xff,0x3e,
    0x19,0x18,0x3c,0x3e,0x80,0x90,0x00,0xdf,0x09,0xbc,0x9c,0x3a,0x96,0xfb,0x0d,0x50,
    0x3b,0x40,0x20,0x19,0x27,0xbf,0x00,0x21,0x9f,0x2c,0x00,0x04,0x03,0xfd,0x00,0x09,
    0xff,0xbc,0xcb,0x2b,0xc9,0x4e,0x12,0x67,0x84,0x2d,0xbe,0xac,0xdc,0x48,0xd8,0x9f,
    0xec,0x89,0x91,0x9a,0x1c,0x66,0x56,0xbf,0xd4,0x71,0x8a,0x71,0x69,0x5d,0xe6,0x75,
    0x07,0xa4,0x61,0xb3,0x3a,0x1b,0x53,0x61,0x68,0x0a,0x1a,0x14,0x49,0x4c,0xb9,0x75,
    0x3e,0x26,0x00,0xe2,0x20,0x17,0xc0,0xba,0xc1,0x5a,0x51,0x58,0xb2,0xd6,0x11,0xfe,
    0x37,0x6b,0x60,0x7f,0x8b,0x03,0x11,0x9b,0xf1,0x0d,0x12,0xb0,0x92,0xdf,0xf4,0x04,
    0x19,0xad,0xa2,0x40,0x10,0x32,0x6f,0xd3,0xfe,0xbd,0x00,0x3a,0xca,0x23,0xf4,0x83,
    0x9b,0x7c,0x08,0xd8,0x44,0xd4,0xf2,0x35,0x8e,0x24,0x00,0x02,0x00,0x40,0x07,0xf4,
    0x37,0x4c,0x59,0xb1,0xdf,0x2d,0x77,0x81,0xfd,0x55,0x06,0x46,0x8c,0x04,0xa2,0x56,
    0xbb,0x05,0x5f,0x17,0x8c,0x4a,0xf8,0x36,0x6d,0x73,0xa9,0xfb,0x9a,0xee,0x00,0x31,
    0x11,0x56,0xbf,0x85,0x7d,0x66,0x0b,0xf7,0x23,0xf5,0xf0,0x29,0x9f,0xb2,0x02,0x21,
    0xc2,0x06,0x6c,0xc0,0x5b,0x8a,0x08,0x96,0x2a,0x85,0xc7,0x09,0x3e,0xbd,0xc6,0xfe,
    0xe7,0x0c,0x48,0xa2,0x7c,0x17,0xb4,0xef,0x87,0x59,0x39,0x80,0x96,0x50,0x49,0x5b,
    0xa9,0xdf,0x8c,0x10,0x8e,0x44,0xcb,0x9d,0xf8,0x82,0x61,0xe6,0x76,0xd5,0xce,0x9a,
    0x64,0x66,0x71,0xea,0xfb,0x23,0xa3,0x81,0x32,0xb0,0x0d,0x6f,0x3b,0x24,0xa3,0x34,
    0x58,0x00,0x71,0x30,0x93,0x3e,0xad,0x8d,0x3d,0xb7,0xff,0xfd,0xfc,0x3d,0x65,0x35,
    0x2d,0xf1,0x60,0x0c,0x0c,0x79,0x54,0xe0,0x75,0x1a,0x96,0xc1,0xc0,0x25,0x52,0x4b,
    0x03,0x85,0x7a,0x4b,0x57,0xc5,0xb1,0x60,0x4e,0x31,0xd4,0x98,0x03,0x22,0x78,0xf3,
    0x03,0x06,0x43,0x8d,0x48,0x24,0x2d,0xea,0x7f,0x00,0xc5,0xe0,0xeb,0x6c,0x88,0x04,
    0x2c,0x7f,0xfd,0xec,0x3f,0x28,0x06,0xb3,0x8e,0x61,0x0d,0x7b,0x76,0x8e,0xaf,0x3f,
    0x3b,0x12,0x5f,0x5d,0xbf,0x23,0x20,0x68,0x5d,0xf7,0xef,0x3c,0x2e,0xc6,0xd0,0xe2,
    0xf8,0x39,0x6d,0x4b,0x00,0xd1,0x9d,0xef,0xce,0x5e,0xc4,0x6b,0x35,0x13,0x09,0x34,
    0xcf,0xb3,0xa7,0xd3,0x8d,0x1d,0xfe,0xfe,0x12,0x60,0xb9,0x4d,0xc6,0xbb,0xe3,0x1b,
    0xb6,0x94,0x9c,0xcf,0x30,0x2e,0x31,0x0e,0xff,0x43,0xa0,0xdb,0x47,0x08,0x14,0x2f,
    0x78,0x78,0x2c,0x8b,0x2c,0x18,0x03,0xa9,0x84,0x12,0x5e,0x4a,0x7c,0x90,0x28,0x97,
    0xa7,0x50,0x10,0x08,0x46,0xf8,0x07,0x00,0x10,0x68,0x1a,0xb1,0xe0,0x02,0xf7,0xee,
    0xc8,0x23,0x18,0x65,0x3f,0xf5,0xd8,0xd5,0x24,0xda,0x7e,0x18,0xbd,0x71,0xf7,0xfe,
    0x81,0x72,0x35,0x86,0xa4,0x24,0x51,0x55,0xab,0x51,0xe7,0x08,0x2c,0x0a,0x4a,0xd3,
    0x5d,0xa6,0x64,0x66,0x08,0xc2,0x36,0x7d,0xfe,0x6e,0x3f,0x0f,0x7c,0x81,0x83,0x06,
    0xe9,0xe1,0x48,0x22,0x22,0x0f,0x57,0xbf,0xd6,0xef,0x77,0xd7,0x5d,0x75,0xd7,0x5d,
    0x7f,0xff,0xfc,0x29,0x80,0x0d,0x72,0x98,0xbf,0x85,0x67,0x3f,0x00,0x15,0xec,0xb4,
    0x71,0x1a,0x73,0xf1,0xd9,0x66,0x34,0xc7,0xdc,0xc4,0x0d,0x83,0x4b,0x03,0x6b,0x1d,
    0xe8,0x90,0xa4,0x7b,0xc0,0x02,0x63,0xf8,0x23,0x20,0xaf,0x94,0x9e,0x06,0x46,0x20,
    0x0f,0x27,0x03,0x27,0x3b,0x1a,0x50,0xc9,0x30,0xf3,0x3d,0xaf,0xca,0xef,0x41,0x25,
    0x6e,0x09,0x96,0x6e,0xd5,0x3d,0xa2,0x78,0x00,0x79,0x00,0x15,0xef,0x9f,0xe7,0xc0,
    0x5d,0x18,0x41,0x10,0xbd,0xe4,0xfa,0xa5,0xc6,0xde,0x01,0x60,0x98,0xfe,0xd6,0xc3,
    0xb2,0x3b,0x8c,0x0c,0x4a,0xf7,0x7f,0xbf,0xcc,0x46,0xab,0x2d,0x2b,0x07,0x3a,0xb2,
    0x4f,0xaf,0xff,0xc4,0x4f,0x41,0x16,0xd5,0x7b,0xaf,0x7d,0x73,0xc0,0x18,0xd0,0x72,
    0xe6,0x3b,0x06,0xb2,0xd1,0xf3,0x05,0x73,0xc7,0x01,0x13,0x21,0x5f,0xbf,0x3c,0xe7,
    0x5a,0xf3,0xf8,0x1b,0x72,0x06,0x61,0x50,0xee,0xdf,0xb9,0x7a,0x9f,0xa6,0x47,0xfd,
    0xa0,0x4a,0x39,0x24,0xa6,0xa0,0x0b,0x78,0xbf,0xee,0x9d,0x73,0x26,0x43,0xc8,0xa0,
    0x05,0x61,0xb6,0xdf,0x60,0xb1,0x99,0x9f,0xfe,0x41,0xf8,0x30,0x82,0x38,0x1b,0x2b,
    0x13,0x98,0xfd,0xdf,0xed,0x40,0x09,0xff,0x89,0x80,0x0b,0xd2,0xa0,0x5c,0x2f,0x9e,
    0x81,0x5e,0x7e,0xfa,0x53,0xbe,0x48,0x93,0xb7,0x6f,0x02,0x16,0x7c,0xa6,0x9f,0x3a,
    0xb8,0x58,0xd3,0xd1,0x37,0xa4,0xf3,0xfe,0x18,0x2d,0xd8,0x5f,0x1e,0x11,0xf1,0x87,
    0xf7,0xbf,0x6b,0xd8,0x59,0xc1,0xa0,0x65,0xde,0xc9,0xc3,0x68,0xf5,0x81,0x50,0xa3,
    0xd3,0x1d,0x55,0x64,0x88,0xfd,0xf1,0x98,0x84,0x5f,0x6b,0x75,0x01,0x53,0x61,0xf9,
    0x8c,0x3b,0x6f,0x2f,0x90,0x32,0x84,0xb9,0x66,0x2b,0xe8,0x2c,0x6c,0x59,0x56,0xb0,
    0x6e,0xf5,0x48,0xae,0x12,0x15,0x55,0xe0,0x59,0xdf,0xde,0x00,0x13,0xdc,0xa4,0x31,
    0x56,0x59,0xd1,0x1f,0xd0,0xd5,0x29,0x28,0x08,0x41,0xfa,0x14,0xea,0x42,0x6f,0xba,
    0xf7,0xb5,0xf1,0xa5,0xd1,0x86,0x6c,0x0e,0x07,0x4f,0x05,0xea,0x1f,0x72,0xec,0x32,
    0xcc,0xb0,0x34,0x35,0x3f,0x7b,0x11,0xe8,0xba,0xd8,0x01,0x21,0x6c,0x20,0x46,0xe8,
    0x2b,0x82,0xa6,0xed,0xab,0xff,0xfd,0x6e,0x46,0x84,0x85,0x42,0x18,0x15,0xe0,0xff,
    0x5c,0xee,0x1f,0xfe,0x80,0x92,0x91,0x71,0x55,0x14,0x81,0x67,0xbb,0xdf,0xbf,0xec,
    0xa3,0x36,0x63,0xec,0x19,0x45,0x1a,0xf6,0xc7,0x1c,0xcd,0x30,0x1f,0x60,0xa8,0xbd,
    0xff,0x89,0xa8,0x8c,0x87,0xbb,0xf7,0xd8,0xfe,0xa9,0xea,0x6f,0xfb,0x75,0x3c,0x8f,
    0x00,0x98,0x29,0x95,0xfe,0xb6,0x2b,0x05,0x6c,0x94,0x04,0x69,0x7f,0x39,0x7b,0x23,
    0x86,0x84,0x06,0x4c,0xe8,0x4d,0x29,0xb5,0xad,0xd5,0xfd,0x52,0x78,0xf8,0x12,0x80,
    0x4c,0xbd,0xeb,0xb4,0x93,0x10,0xf1,0xec,0x17,0x48,0x63,0xfe,0xdf,0x0c,0xf8,0xe1,
    0xc5,0xbf,0xf7,0x8c,0x10,0x67,0x3c,0xb5,0xd5,0xa0,0x7b,0xb9,0x89,0x1f,0xbe,0xfe,
    0xce,0xc7,0xbe,0x07,0x9b,0x2e,0xc6,0x90,0x47,0x76,0x22,0xa1,0x98,0x1d,0xff,0x85,
    0x18,0x91,0x63,0xa8,0xf1,0x5f,0x44,0x00,0x22,0xfb,0x09,0x67,0x60,0x01,0x85,0xe5,
    0xd3,0x68,0x36,0xfd,0x19,0x08,0xbf,0x4c,0x63,0xc0,0xfc,0x9d,0x58,0xd2,0x32,0xb1,
    0x50,0x5f,0x0d,0xca,0xcf,0x69,0x3f,0x85,0x53,0xd6,0x0d,0x13,0x15,0xc3,0xdb,0x07,
    0x7f,0xb7,0xfc,0x43,0xea,0x10,0xcb,0xb8,0x0c,0x8f,0x7d,0xf5,0xdf,0x06,0x1e,0x0d,
    0xd6,0xcf,0x40,0x02,0xe1,0xe0,0xed,0xf4,0x68,0x3c,0x46,0x56,0xf9,0x0e,0x64,0x49,
    0x28,0xf7,0xfe,0x06,0xad,0x93,0x58,0xca,0xe0,0x23,0xf9,0xb7,0x7e,0xd6,0x6f,0x7f,
    0x4e,0xfa,0xb6,0xcd,0x19,0x80,0xa0,0xc4,0xe4,0x81,0xd8,0xf9,0x10,0x04,0x94,0x4b,
    0x24,0x93,0xbe,0x83,0x7a,0xa5,0x58,0xe0,0xf7,0xe0,0x02,0x93,0x43,0x71,0x11,0x7e,
    0xf5,0x39,0x2d,0x7b,0x42,0xf9,0x47,0xfc,0x90,0x7f,0x83,0x1f,0xba,0xeb,0xff,0x7f,
    0xfc,0x8f,0xcd,0x83,0xf0,0x9c,0x00,0x9b,0x76,0x88,0x7d,0x07,0xdf,0xc6,0xcd,0x99,
    0x1f,0x02,0x53,0x04,0xe1,0x0c,0xc0,0x1a,0x84,0x17,0xe3,0x1d,0x8f,0xf3,0xdb,0x35,
    0x3c,0x12,0x32,0x82,0xb2,0x3f,0xef,0xe3,0xdb,0x6f,0x4c,0x0a,0xb7,0xff,0xbb,0xfd,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x77,0xdf,0x7d,0xf5,0xd7,0x5d,0x77,0xdf,0x7d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x78,
};
#else
//Another one is using. 2499
unsigned char MPEG4_Playback_black_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x1e,0xda,0x05,0x07,0xe4,0x00,0x00,0x00,0x01,
    0x68,0xce,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x0a,0x7f,0xff,0xe1,0xe8,
    0xa0,0x00,0x67,0xdf,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,
    0x7d,0xf5,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x7e,0xcf,
    0x8d,0x86,0x89,0x1d,0xe0,0x06,0x26,0xfe,0xe7,0x79,0xf8,0x02,0x47,0xab,0x3e,0xfb,
    0xd3,0x67,0xc3,0x6a,0x86,0x22,0xcf,0xc6,0x0c,0x67,0x6c,0xd2,0xcb,0x80,0xfd,0x7a,
    0x06,0xaf,0x85,0xaf,0xd6,0x9b,0xdf,0x5c,0x23,0x7b,0x23,0x0c,0xf7,0xf7,0x44,0xf7,
    0x88,0x86,0x8a,0xa8,0x31,0x1c,0xae,0xdc,0xa6,0x7a,0xbc,0xac,0x00,0x0a,0x59,0x0a,
    0x8b,0x44,0x20,0x52,0x6e,0xea,0xe6,0xba,0x8e,0xe0,0x29,0x80,0x86,0xfc,0x51,0x42,
    0x53,0x4f,0x68,0x15,0x15,0x3b,0xfa,0xfb,0xe8,0x02,0x8e,0x9a,0x34,0x6d,0x4c,0x08,
    0xe5,0x44,0x0e,0x5b,0x71,0xe5,0x4a,0x9d,0x12,0x78,0x43,0xa2,0x80,0x05,0xaa,0x8e,
    0x7e,0xdb,0x58,0x06,0x38,0xf9,0x63,0xe4,0xcc,0xcc,0xda,0x9a,0xb0,0xfd,0xad,0x3b,
    0xeb,0xd4,0x77,0x0f,0x58,0xa4,0x03,0xb2,0xc0,0xf4,0xb7,0xb1,0xc4,0x5c,0x02,0xfd,
    0x6c,0xd9,0x2e,0xbc,0x56,0x15,0x53,0x17,0xbf,0xc2,0x0e,0xbd,0x9a,0x5b,0xbc,0x10,
    0xae,0xe4,0x0e,0x98,0xdf,0xcb,0x06,0x54,0xee,0x92,0x6d,0xaf,0xf4,0x60,0x9f,0x19,
    0x72,0x4a,0x40,0x34,0x76,0xc5,0x69,0x71,0x65,0x04,0x7f,0x7d,0x61,0xc6,0xec,0x23,
    0xfb,0xc8,0x83,0x87,0xd5,0x75,0xa0,0x59,0x7a,0x0f,0x9d,0x61,0x36,0x63,0x8b,0x30,
    0xf5,0x7b,0xc6,0x78,0x10,0x7d,0x98,0x30,0x60,0x40,0xb0,0x3d,0xe0,0x0a,0x2d,0x11,
    0xb4,0xfc,0x0c,0xdb,0xea,0xff,0xf7,0x7b,0xfb,0x52,0xec,0xcf,0x7e,0xff,0xe1,0x10,
    0x7e,0x24,0x3e,0x87,0xeb,0x03,0xe9,0xce,0xe3,0xb3,0x7b,0x1d,0x95,0xa1,0x94,0xff,
    0x18,0x0f,0x61,0x8e,0x64,0x96,0xd3,0xc2,0xc9,0x92,0x65,0x57,0x5b,0x63,0x9b,0x6f,
    0xfa,0xa7,0x66,0x0e,0x24,0x71,0x7c,0xf8,0x20,0x54,0x9e,0x79,0x9b,0xc7,0xf1,0xaa,
    0x03,0x33,0x99,0x2c,0x01,0x11,0x06,0x8e,0x37,0x80,0x18,0x1e,0xaf,0x8e,0xc5,0x3b,
    0x1e,0x64,0x55,0x23,0x4d,0x91,0x0f,0x51,0xd5,0x8c,0x5e,0xb8,0xfb,0xff,0x7e,0x11,
    0x4f,0x89,0x98,0x66,0xde,0x05,0x66,0x2e,0xb3,0xeb,0xdf,0xb3,0x8d,0x1c,0xbf,0x9f,
    0xc7,0x0e,0x58,0x05,0xa0,0xb6,0xba,0x73,0xb4,0x75,0xcb,0xa8,0x96,0x8f,0x7f,0xd6,
    0x5a,0x0f,0x52,0x0e,0x79,0x05,0xf6,0x15,0x50,0x72,0xda,0x35,0xa2,0x24,0x8e,0xa6,
    0x9c,0xde,0x48,0xa1,0x13,0x6f,0x5a,0x84,0x18,0xdf,0x40,0xbe,0x06,0xd3,0xe9,0x7a,
    0xdd,0x7f,0xe6,0xb3,0xcd,0x01,0xad,0xda,0x00,0x19,0xb7,0xfc,0xaf,0x87,0xd9,0x78,
    0x27,0xb3,0x5a,0x26,0x38,0xdd,0xe3,0x07,0x44,0x67,0x3d,0xa5,0xf4,0x15,0xaa,0x85,
    0x81,0xd9,0x1a,0xdd,0x90,0x02,0xf5,0x79,0xf6,0x54,0x6a,0x72,0xe3,0x6f,0x1b,0x0c,
    0x07,0x21,0x53,0x00,0xdb,0xef,0x96,0xe5,0x1f,0xff,0x31,0x0b,0x4b,0xab,0xcb,0xc3,
    0x56,0xff,0x1e,0xe3,0xc5,0x72,0x3d,0x42,0xfc,0x62,0xa6,0x61,0xa4,0xff,0x99,0xb6,
    0x46,0x64,0xf9,0xb1,0x89,0xc7,0x1a,0x71,0x3f,0xde,0x83,0x0a,0xe2,0x2d,0xdf,0x3e,
    0xa6,0xe1,0xa4,0x93,0xfb,0x5f,0xe2,0x64,0x68,0x1a,0x1e,0x5c,0xde,0xf8,0x5e,0xc3,
    0xa8,0xb7,0x72,0x72,0xd7,0xfd,0x70,0x62,0xdc,0x42,0xc9,0xb9,0x97,0x1f,0x4f,0xd7,
    0x10,0xc1,0x4c,0x71,0x09,0xde,0x00,0x65,0x56,0xd1,0xa4,0xbb,0x41,0x08,0xf7,0xf2,
    0xcd,0xcf,0xb7,0xf9,0x49,0xc2,0x55,0xbf,0xf5,0xf3,0x9e,0x32,0x2e,0x90,0x0e,0xec,
    0xca,0xcd,0xee,0xd9,0x6c,0x68,0xf6,0x10,0xeb,0xb4,0x60,0x34,0x6a,0x4c,0x7f,0xa9,
    0xa3,0x3f,0xf2,0x0d,0xf7,0x11,0x4a,0xda,0x1e,0x21,0x09,0x09,0x81,0x83,0xef,0xe1,
    0x37,0xff,0x6a,0x26,0xa5,0x9e,0xdd,0x9e,0x91,0x2c,0x24,0x8f,0x6f,0xfb,0xb9,0xf1,
    0x42,0x24,0x88,0x15,0xf0,0x2b,0x34,0x7c,0x93,0x8f,0xdf,0x4e,0xf2,0x7f,0xb8,0x13,
    0x0c,0x40,0x74,0x45,0x23,0x14,0x76,0x25,0x4d,0x18,0x7d,0x44,0x29,0xdf,0x52,0xfe,
    0x00,0x00,0x04,0x6e,0x9d,0x40,0x51,0x0d,0xb5,0x8c,0x66,0x85,0x52,0xdf,0xc8,0x80,
    0x75,0x33,0x30,0x00,0x0a,0xf4,0x66,0xc0,0xca,0xe9,0x96,0xc5,0x59,0x72,0x77,0x75,
    0x70,0x7c,0x47,0x35,0x44,0x66,0xb8,0x01,0x9f,0x6d,0x1c,0x87,0xde,0x82,0x74,0x47,
    0x80,0x19,0xbd,0xc8,0x0e,0x9b,0xff,0x2c,0x33,0x36,0x5a,0x36,0xff,0xf0,0x61,0x18,
    0x90,0x7c,0x2b,0xee,0xbf,0xdf,0x50,0xc9,0x12,0xc9,0xb0,0xfb,0xdd,0x82,0x39,0x0a,
    0x13,0xc2,0x74,0x78,0x85,0xa3,0x70,0xf8,0x00,0xdd,0x07,0x00,0x7a,0xad,0xd0,0x5f,
    0xdb,0x1f,0xf9,0xf4,0xf1,0x98,0x49,0xbf,0xcf,0x98,0x1b,0x6f,0x34,0x2f,0x4e,0x01,
    0xd4,0x44,0xdc,0x18,0x46,0xe0,0x09,0x56,0x99,0x1a,0x47,0x53,0x7d,0x68,0xed,0x49,
    0x89,0xd7,0x6e,0x14,0xec,0x7e,0xa2,0x69,0xfc,0x13,0xd7,0x5d,0x01,0xd3,0x7f,0x45,
    0x79,0xa4,0xcd,0x3d,0xa6,0x10,0x07,0xfa,0x60,0x95,0x20,0x0d,0x73,0x36,0x36,0xbe,
    0x97,0x7d,0xe3,0x35,0x1a,0x77,0xa7,0x11,0x2e,0x7c,0x6f,0x7d,0x66,0x68,0x8d,0x73,
    0x0a,0xe2,0x9f,0x08,0x4b,0xb4,0xc3,0x3d,0x25,0xd8,0x8f,0x4e,0xe2,0x1b,0xd3,0x56,
    0x8e,0xf0,0x02,0x18,0xcb,0xc8,0xe5,0x7c,0x11,0x6b,0xa7,0xb8,0xdd,0xfd,0xbc,0x66,
    0x3d,0x27,0x83,0xbe,0x10,0x8d,0x58,0xca,0xcc,0x75,0xfb,0xe0,0xbf,0x82,0xaa,0x0e,
    0x5d,0x93,0xc1,0x2f,0x83,0x20,0xf5,0x7a,0xfd,0xe4,0xc8,0xff,0xdf,0x6c,0x35,0x36,
    0x85,0xb2,0x69,0xf9,0xcd,0x41,0xe2,0xd1,0xfd,0xbc,0xdc,0xdd,0x3f,0x2b,0x9f,0x49,
    0x50,0xf9,0xae,0x2c,0x91,0x1c,0x97,0x5d,0x75,0xd7,0x5d,0x75,0xdf,0xef,0xf7,0xef,
    0xdf,0xef,0xf7,0xfb,0xfc,0x7f,0xfd,0x03,0xff,0xff,0xfd,0xfe,0xff,0x7f,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
    0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
    0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
    0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
    0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xc0,
};
#if((UI_VERSION == UI_VERSION_RDI) || (UI_VERSION == UI_VERSION_RDI_2) || (UI_VERSION == UI_VERSION_RDI_3))
unsigned char MPEG4_Playback_black_Japan_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xf4,0x0a,0x0f,0xc8,0x00,0x00,0x00,0x01,
    0x68,0xce,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x02,0x13,0x14,0x00,0x04,
    0x37,0xef,0xbe,0xfb,0xef,0xbe,0xfb,0xef,0xbe,0xfb,0xef,0xbe,0xfb,0xef,0xbe,0xfa,
    0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
    0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
    0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,
    0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,
    0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,
    0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xba,0xeb,0xae,0xbf,0xb2,0x03,0x2c,
    0x24,0xae,0x63,0x78,0x00,0xac,0x12,0xe1,0x52,0xe2,0x9a,0x5b,0x8f,0x57,0xa0,0x08,
    0x32,0x9b,0x66,0x33,0xb8,0x0c,0x17,0x0b,0xe9,0xe7,0xc0,0x18,0x11,0xc1,0x93,0xf1,
    0x12,0x6e,0x3b,0x0d,0x24,0xc0,0xf0,0x21,0x56,0xa5,0xd3,0xbc,0x09,0xb2,0xed,0xb4,
    0xf7,0xf0,0x01,0x0c,0x2b,0x52,0x4b,0x61,0xb6,0x10,0xec,0xf8,0x49,0x31,0xb8,0x70,
    0x00,0xf5,0x82,0x1a,0xad,0x1e,0xde,0x92,0x7d,0xfd,0x00,0xf8,0xf1,0x0e,0xc3,0x01,
    0x3f,0x9e,0xe7,0xa7,0x9e,0x11,0xb0,0x42,0x30,0xf2,0x47,0xc9,0x1b,0xf5,0x17,0x65,
    0xd6,0x6e,0xe2,0x37,0x6f,0xf4,0xe2,0x23,0x3c,0x08,0xf9,0x19,0xd5,0x31,0x14,0x65,
    0xde,0x00,0x0c,0x99,0x0d,0x05,0x4a,0x2f,0xd4,0x70,0xdc,0xad,0xc1,0xa0,0x22,0xc9,
    0xa9,0xaa,0xc9,0x49,0x98,0x27,0xfd,0xea,0x24,0x00,0x5b,0x19,0x85,0x18,0x21,0x0c,
    0xdd,0xd3,0xc4,0x62,0xae,0xe6,0x8b,0x47,0x61,0x2a,0x64,0x1f,0x81,0x0a,0xce,0x6f,
    0x5c,0x4d,0x43,0xe0,0x82,0x40,0x01,0x7e,0xc1,0x6a,0x55,0x13,0x9b,0x04,0x5a,0x5b,
    0x0e,0xf0,0x4e,0x70,0xc6,0x54,0x67,0x8a,0x57,0x75,0x8b,0x32,0xf0,0x00,0xc5,0x41,
    0x4e,0xa9,0x77,0xb1,0x6f,0xaf,0xbe,0x00,0x00,0x0f,0xc3,0xf0,0x62,0x28,0x96,0xa7,
    0x10,0x9e,0x8e,0x85,0x8f,0xaf,0x1b,0x2c,0xde,0x24,0x21,0xab,0x09,0xdb,0x9e,0xf0,
    0x4c,0x12,0x6e,0x4c,0x61,0x04,0x32,0x0f,0x51,0xa5,0x72,0x1b,0x9c,0x6e,0x03,0x80,
    0x01,0x30,0x18,0x3d,0xe9,0x60,0x03,0xa6,0x02,0xa7,0x63,0x8a,0xce,0x40,0xbd,0xac,
    0xf8,0x10,0x3f,0x7a,0x31,0x2f,0x21,0x73,0x1d,0x0a,0x46,0x01,0x5b,0x00,0x57,0x25,
    0x08,0x69,0x3b,0x2b,0xe6,0x60,0xfc,0x28,0xf7,0xc3,0x0b,0x75,0xd0,0x5f,0xa0,0x3c,
    0xc0,0x00,0x26,0x03,0x07,0xb8,0x99,0xe4,0xd9,0x09,0x14,0xa5,0xec,0x66,0x29,0x53,
    0xd4,0x68,0x3d,0x8e,0xc2,0x18,0x84,0xf0,0xa4,0x98,0x01,0x1d,0x05,0xbd,0xc5,0x1a,
    0x2a,0x86,0x18,0x01,0x30,0x80,0x2f,0x33,0xf8,0x8c,0x25,0xf3,0x2b,0x19,0xfa,0x1f,
    0x02,0x0f,0xc2,0x20,0x77,0x80,0x1e,0x02,0x02,0x4a,0x06,0xe1,0xdc,0xbc,0x1b,0x6a,
    0xc0,0x10,0xc7,0xd3,0x1a,0x9b,0x59,0x0d,0xde,0xda,0x0a,0x05,0x7e,0x18,0x00,0x58,
    0x04,0x3a,0x71,0x36,0x32,0x79,0xf4,0xc9,0xa6,0x7b,0xdf,0xc1,0x88,0x00,0x02,0x05,
    0xc0,0x0e,0xa7,0x00,0x17,0x22,0x0c,0x83,0xd1,0x6e,0x29,0xae,0x37,0x68,0xc0,0x00,
    0x26,0x03,0x07,0xbe,0x99,0xe0,0x03,0x66,0xc9,0xa1,0xb7,0x42,0xa3,0x3a,0x72,0xc0,
    0x25,0xc8,0x5d,0xee,0x00,0x2c,0x02,0xe1,0xf1,0x34,0x86,0x3e,0x5a,0xe3,0xfd,0xfd,
    0x5f,0xa4,0x44,0x42,0x4c,0x89,0xb6,0xd3,0xff,0xef,0x80,0xe0,0x00,0x4c,0x06,0x0f,
    0x7a,0x58,0x00,0x7d,0x23,0x1a,0xe2,0x13,0x39,0xdc,0x84,0x7d,0x40,0x04,0x01,0x30,
    0x7a,0x6f,0x01,0x73,0xc0,0xe1,0x80,0x02,0x69,0x98,0x97,0x14,0x9d,0x8e,0xc4,0x2b,
    0x00,0x0b,0x00,0x22,0x9f,0x3e,0xec,0xdf,0xf3,0xff,0xff,0xf1,0x00,0x00,0x78,0x06,
    0x1c,0x04,0x3c,0xa4,0x45,0x48,0x59,0x34,0xdb,0xff,0xf8,0x74,0xd5,0xd1,0xe0,0x57,
    0x05,0x2d,0xc3,0x00,0x16,0x98,0x03,0xb8,0x42,0x9e,0x86,0xa5,0xc7,0xab,0xd8,0x02,
    0xd0,0xce,0x98,0x4e,0xe1,0xcc,0xe1,0x46,0xb6,0x24,0x0a,0xc1,0x2e,0x1d,0x2e,0x29,
    0xa5,0xb0,0xf5,0x78,0x05,0x6c,0x01,0x5c,0x94,0x21,0xa4,0xec,0xaf,0x99,0xbc,0x1e,
    0x14,0xbc,0xe8,0x67,0x08,0x65,0x08,0x42,0xa4,0x3c,0x00,0x18,0xac,0x5d,0xcd,0x96,
    0x55,0x56,0xda,0x50,0x2f,0xf0,0xc5,0x47,0x87,0x5a,0x73,0x75,0xdb,0xde,0xd9,0xe5,
    0x80,0x01,0x92,0x21,0x26,0x21,0x33,0x19,0x88,0x46,0xf5,0x22,0x12,0x62,0x13,0x31,
    0x98,0x84,0x47,0x00,0x21,0xc4,0x57,0x09,0xee,0xc0,0x6f,0x85,0x3e,0x35,0x00,0x15,
    0xcb,0x02,0x98,0x4e,0xcb,0x3d,0x5a,0xf3,0x13,0x1a,0xaf,0x21,0x88,0x89,0x60,0xe6,
    0x2b,0xa2,0x18,0x4e,0xb4,0xde,0xc4,0xf0,0x06,0x19,0xd4,0x87,0xa5,0xee,0x37,0x68,
    0x04,0x36,0x42,0x4e,0x52,0xf6,0x33,0x14,0xad,0xe9,0xa2,0x1a,0x72,0x14,0x53,0x95,
    0xe9,0x1a,0xa6,0x03,0x12,0x4b,0x17,0x2c,0xfa,0xae,0x2c,0x9f,0x5e,0x63,0x00,0x00,
    0x90,0x0a,0x18,0xfc,0xb0,0x00,0xe4,0x65,0xa5,0x11,0x4b,0x9a,0xcb,0x4c,0xf6,0x70,
    0xc5,0xb9,0xc0,0x07,0x62,0x7e,0xc8,0xff,0x07,0xbd,0xde,0x30,0xb4,0x73,0x90,0x9f,
    0xb2,0x3a,0x95,0xbc,0x0c,0x85,0x46,0x42,0xee,0xcb,0x5d,0x15,0xbd,0xcc,0xc4,0xa0,
    0x1d,0x28,0xbc,0x59,0xe3,0x32,0x0a,0xfb,0x9b,0x26,0x86,0xdd,0x0a,0x8c,0xe8,0x1f,
    0x8c,0x17,0x88,0x50,0x0f,0xfa,0xd1,0x17,0xcf,0x7e,0x6f,0xc6,0x1f,0xce,0x72,0x97,
    0x66,0x47,0xc4,0x6e,0x48,0x2a,0x52,0x1d,0x59,0x4e,0x23,0x3f,0xaf,0x73,0x31,0x2e,
    0x29,0x3b,0x1d,0x88,0x5d,0x1b,0xc2,0xe3,0x8c,0x05,0x96,0xf6,0x36,0x00,0xa6,0x10,
    0xb7,0xa5,0xe8,0x61,0xea,0xf0,0x22,0x41,0xa6,0x1d,0x0e,0x2d,0xa5,0x38,0xf5,0x7b,
    0xcc,0x0f,0xc5,0x15,0x94,0x8a,0x43,0x87,0x35,0x6c,0x79,0xb6,0x63,0x5e,0x52,0x88,
    0x72,0xfd,0x23,0x16,0xf0,0x1c,0x00,0x09,0x80,0xc1,0xef,0x4b,0x71,0x24,0x45,0x48,
    0x59,0x12,0x4d,0xff,0xff,0xc0,0x83,0x52,0x38,0x41,0x7c,0x7a,0x77,0x4a,0xd3,0xcd,
    0xf8,0xd8,0xc3,0xfb,0x12,0x9b,0xbe,0x14,0xe6,0x62,0xf7,0xb3,0x1a,0xf2,0x94,0x43,
    0x97,0xbe,0x31,0x42,0xc3,0x50,0xc3,0x97,0x30,0x80,0x02,0xbe,0x8a,0x7b,0x44,0x77,
    0xd5,0x00,0x07,0xd8,0xeb,0x18,0x24,0x5c,0xb9,0x86,0x10,0xab,0xef,0x78,0x26,0x09,
    0x37,0x26,0x30,0x82,0x19,0x05,0x90,0xa1,0xae,0xe2,0x3e,0xe0,0x03,0x86,0x52,0x23,
    0x21,0x3e,0x2b,0xf7,0x5c,0xde,0xd2,0x30,0xe9,0xf1,0xb1,0x78,0x43,0x69,0xd6,0x00,
    0x63,0xea,0x19,0x65,0xbe,0x29,0x0e,0x3d,0x5e,0xf0,0x0a,0x98,0x69,0x1e,0xdd,0x77,
    0x1e,0x93,0x82,0xb0,0xd6,0x81,0x8c,0xc4,0xbd,0x39,0x55,0x4a,0x6b,0x59,0xff,0xa0,
    0x0e,0x9e,0x09,0xc2,0xc5,0x49,0x8c,0x24,0x96,0x78,0x10,0xaf,0x34,0xf4,0x69,0xce,
    0xb1,0x7a,0x92,0x31,0x72,0xcf,0x04,0x61,0xac,0x61,0x4b,0x6a,0xf8,0x3f,0xff,0xef,
    0x40,0x11,0x40,0x57,0xb8,0x3b,0x29,0xf9,0xf7,0x1f,0xf7,0xef,0x80,0xf7,0x18,0xb3,
    0x9a,0x8d,0x78,0x84,0x9f,0x7b,0xb0,0x62,0x00,0x47,0x41,0x6f,0x71,0x46,0x8a,0xa4,
    0x00,0x00,0x80,0x30,0x0e,0x5a,0x64,0x30,0x05,0x30,0x8c,0xff,0x72,0x91,0xd5,0x89,
    0xdc,0x38,0x87,0xe0,0x65,0x0c,0xaf,0xe6,0x88,0xc6,0xb8,0x84,0xce,0x77,0x21,0x1c,
    0x3f,0x12,0x0c,0xcf,0x7e,0x21,0x5d,0x58,0xb9,0x8c,0x00,0x02,0x60,0x30,0x7b,0xc9,
    0x90,0x01,0x72,0x0d,0x30,0xe8,0x71,0x6d,0x29,0xc7,0xab,0xc0,0xe0,0x00,0x48,0x06,
    0x0e,0x7a,0x5b,0xde,0x66,0x35,0x19,0x29,0xbf,0x59,0xc3,0x32,0xb1,0x79,0x32,0x02,
    0x66,0xc9,0xa1,0xb7,0x42,0xa3,0x3e,0x00,0x2a,0xc6,0xcc,0x6e,0xbc,0x86,0x32,0x27,
    0x81,0xc3,0xf3,0x6c,0xc6,0xa2,0x25,0x37,0xab,0x38,0x65,0xd4,0xfa,0x92,0x24,0x84,
    0xd9,0x08,0x8c,0xdb,0xbe,0xaa,0x45,0xd2,0xaf,0x7f,0xf9,0x22,0x22,0xa4,0x20,0x0e,
    0x26,0x50,0x92,0xcf,0x18,0x00,0x04,0x80,0x60,0xe7,0xa5,0x80,0x70,0x00,0x26,0x03,
    0x07,0xbd,0x2c,0x00,0x4c,0x65,0x99,0x8a,0x7a,0x72,0x1d,0x89,0x01,0x20,0x20,0x86,
    0x56,0xf8,0x36,0x1c,0x8c,0x0d,0xf2,0x3f,0x1c,0x00,0x02,0x43,0x24,0xb7,0xbd,0x00,
    0xf4,0x1d,0x5a,0xf1,0xb3,0x1b,0xaf,0x21,0x8c,0x89,0x60,0x70,0xfa,0x08,0xc2,0x8a,
    0x66,0x34,0xd3,0x11,0x8d,0x49,0x57,0xe0,0x60,0x42,0x2c,0xc8,0x77,0x53,0x90,0xce,
    0x4b,0xd4,0x88,0xa9,0x0b,0x26,0x93,0x4c,0x52,0x1e,0xd5,0xfb,0x86,0x00,0x2f,0x41,
    0x2e,0x15,0x2e,0x29,0xa5,0xb0,0xf5,0x78,0x01,0xd9,0x98,0xd4,0x64,0xa6,0xfd,0x67,
    0x0c,0xca,0x96,0x00,0x03,0x20,0xc8,0x29,0x29,0x73,0x46,0xa6,0x7b,0xcf,0xbe,0x3c,
    0x00,0x09,0x00,0xc1,0xcf,0x4b,0x61,0x80,0x26,0x00,0x84,0x1b,0x38,0xd5,0x66,0x90,
    0xe4,0xb0,0x4f,0x81,0xfe,0xf7,0x82,0x60,0x93,0x72,0x63,0x08,0x21,0x80,0xf0,0xeb,
    0xae,0xba,0xeb,0xae,0xba,0xef,0xbe,0xff,0x7d,0xf7,0x86,0xf0,0xdf,0xbe,0xf0,0xdf,
    0x7d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5e,
};
unsigned char MPEG4_Playback_black_German_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xDA,0x05,0x07,0xE4,0x00,0x00,0x00,0x01,
    0x68,0xCE,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x11,0xFF,0xFF,0x87,0xA2,
    0x80,0x00,0x80,0x8F,0xBC,0x56,0xF7,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,
    0x7D,0xF7,0xDF,0x7D,0x62,0xB5,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAD,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xFF,0xC3,0xF8,0x42,0x98,0x00,0x33,0x48,0xD3,0x13,0x9C,0x22,0x37,0xCF,0x22,0x1C,
    0x00,0x1B,0x26,0x6D,0x09,0xA2,0x95,0x59,0x16,0x1F,0xBF,0x8F,0x0C,0x2E,0x60,0x00,
    0x1F,0x02,0xB9,0x72,0xC0,0x11,0x2C,0x0C,0x75,0xDF,0x2F,0x94,0xEE,0xF9,0xE0,0xE0,
    0x00,0x7C,0x0A,0xE1,0x12,0xDA,0x54,0xE0,0xC7,0xFB,0x82,0x7E,0xA7,0xFD,0x00,0x38,
    0xFC,0x52,0xBB,0xEC,0x99,0x73,0x20,0x62,0x00,0x00,0x80,0x80,0x00,0x46,0x00,0x00,
    0xC0,0x36,0x02,0xDD,0x97,0xEA,0x62,0x9E,0xB7,0xBB,0xC6,0x00,0x01,0xE0,0x2B,0xD7,
    0x2D,0x46,0xA0,0x21,0x97,0x7E,0xBF,0x53,0xBB,0xE7,0xFE,0x1E,0x13,0xB0,0xCB,0x5B,
    0x96,0x6D,0x4D,0xEE,0x4C,0xDA,0x13,0x65,0x2A,0xB3,0x2F,0x87,0xC3,0x9E,0x3B,0x84,
    0x2F,0xF8,0x00,0x38,0xD8,0x7A,0x22,0xBD,0x77,0x93,0x94,0x59,0x1F,0xF7,0x8C,0x83,
    0xA6,0xA2,0x42,0x38,0x8A,0x50,0x59,0xFF,0xFE,0xA0,0x34,0x33,0x1C,0xDF,0xE0,0x38,
    0x9D,0xEA,0x45,0x1F,0x9F,0x83,0xF0,0x66,0xC1,0x37,0xEB,0x9E,0xAD,0x9D,0xE7,0xE4,
    0x3E,0x00,0x13,0x58,0xD1,0x31,0xC2,0x12,0x9D,0x9C,0xFF,0xEF,0x36,0x22,0xA4,0xDD,
    0xD9,0x32,0xB7,0x50,0x70,0xFF,0x9E,0x81,0x7F,0x7C,0x0D,0x26,0x30,0x8A,0x8A,0x71,
    0x6B,0xA2,0x94,0xFF,0xF7,0x80,0x70,0x06,0xE0,0x5A,0xB2,0xF9,0x4D,0x53,0x83,0x1E,
    0xEF,0x00,0x03,0x76,0xCD,0xB1,0xB9,0x82,0x27,0x7C,0xE2,0x03,0xE2,0x1B,0x49,0xE5,
    0xC0,0x03,0x75,0xDD,0x2B,0xDE,0xB0,0x58,0x2D,0x59,0xDF,0x78,0x81,0xD7,0xBA,0x1E,
    0x6C,0x45,0x49,0xBB,0xA2,0x65,0x6E,0xBA,0x30,0xF0,0x8F,0x2B,0x91,0x84,0x71,0x31,
    0x9E,0xFF,0x07,0xFE,0x2F,0xD8,0x53,0x03,0x40,0x44,0x21,0x4A,0x5A,0x40,0x23,0xD9,
    0x4E,0xE4,0x89,0xB8,0x88,0xE2,0xE7,0x07,0xFF,0xCE,0x08,0x17,0xF7,0xFC,0x87,0xAA,
    0x91,0xDB,0x01,0x89,0xBD,0xA3,0xF7,0x19,0x1F,0x81,0x3A,0xDC,0x53,0x14,0x59,0xCF,
    0xFF,0x6D,0x81,0xE4,0x1D,0x35,0x12,0x11,0xC4,0x52,0x82,0xCF,0xFF,0xF5,0x07,0x80,
    0x01,0x63,0x00,0xFE,0xB5,0x3C,0x31,0x07,0x57,0x93,0x19,0x12,0xEC,0xEE,0x9D,0x5B,
    0x3F,0x83,0x24,0x1A,0xF6,0x38,0x97,0x3F,0xBE,0xF2,0x43,0x0F,0x80,0x7A,0xA3,0x06,
    0x44,0x45,0xCA,0xDF,0x9B,0xFE,0xF0,0x13,0x67,0x40,0xFD,0xD7,0x7A,0x82,0x6F,0xF4,
    0x30,0xFA,0x85,0x48,0x5D,0x32,0x6E,0xF0,0x00,0x66,0xD1,0x26,0x37,0xE8,0x44,0x77,
    0x40,0x14,0x4C,0x13,0x51,0x13,0x13,0x56,0xCA,0x62,0xFF,0xE0,0xE4,0x02,0x35,0x94,
    0xFF,0x48,0x9B,0x68,0x71,0x73,0x80,0x50,0x06,0xE6,0xBE,0xAF,0x34,0xF1,0x13,0xFF,
    0xF0,0x12,0xCA,0x43,0x6C,0xFD,0x15,0x22,0xFB,0xF5,0x9A,0x06,0x63,0x9C,0xC6,0x39,
    0xAE,0xFD,0xF7,0xF0,0x26,0xA1,0x6F,0x32,0x96,0xBB,0x44,0x6B,0x37,0x5D,0xE9,0xA3,
    0xA6,0xAF,0xFE,0xF8,0x7F,0x20,0x08,0xF4,0x5B,0xB9,0x02,0x6F,0xA1,0xC5,0xCE,0xE0,
    0x01,0x19,0xA7,0x90,0xFD,0x27,0x45,0xFF,0xFD,0xE1,0xF3,0x3F,0x47,0xC0,0x43,0x70,
    0xE0,0x0E,0x80,0x65,0x09,0x16,0xBE,0x76,0xD6,0x78,0xB7,0x31,0x90,0x74,0xD4,0x48,
    0x47,0x11,0x4A,0x0A,0x3F,0xFF,0xD5,0x00,0x04,0x13,0xBF,0x4E,0xDB,0x32,0xC5,0xFD,
    0x00,0xD0,0xCC,0x73,0x7F,0x80,0xE2,0x77,0xA9,0x14,0x7E,0x7E,0xE0,0x4C,0x35,0xE5,
    0xF8,0xB9,0xD6,0x08,0x49,0x34,0x3F,0xEF,0x06,0x48,0x35,0xEC,0x73,0xDC,0x4A,0x3E,
    0xF2,0x78,0x07,0xAA,0x30,0x64,0x44,0x5C,0xAD,0xF9,0xBF,0xE0,0xC3,0xF3,0x62,0x2A,
    0x4D,0xDD,0x93,0x2B,0x75,0xD0,0x5B,0x85,0x25,0x4A,0x5A,0xD6,0xC5,0xD5,0xFB,0xFF,
    0x0F,0xF9,0x07,0x17,0xE8,0xD0,0xBF,0x90,0xBD,0x52,0x33,0xFC,0x9D,0x7B,0x25,0xA8,
    0x7B,0x1D,0x8C,0x2A,0xDC,0xA3,0xD5,0xEC,0x21,0x1B,0x0D,0xF4,0xE2,0xE1,0xC5,0x31,
    0xFF,0xEE,0xBC,0xD8,0xCA,0xB3,0x67,0x75,0xC8,0xD9,0x3F,0x00,0x2C,0x09,0x27,0xF7,
    0x1E,0x70,0x7E,0x0F,0x81,0x60,0x20,0x25,0x09,0xE8,0x2E,0x7D,0x86,0x2D,0x7C,0x79,
    0x69,0x22,0xE4,0x83,0xFF,0x9F,0xE8,0x7F,0x10,0x86,0x39,0x8E,0x76,0x3E,0xFE,0xFF,
    0xFF,0xF5,0xDE,0x9A,0x3A,0x6A,0xFF,0xEF,0xD0,0xD8,0x3E,0x3C,0x26,0xF6,0x21,0xFF,
    0xDE,0x5F,0xFE,0xBF,0x7C,0x18,0x37,0xC0,0x07,0x90,0x08,0x89,0x78,0x1F,0x9E,0x4D,
    0x91,0xEB,0x05,0x60,0x90,0x04,0xC6,0xC4,0x1F,0xD6,0xCD,0x31,0xFF,0xDF,0xF0,0x40,
    0x08,0x69,0x9F,0xFE,0x10,0x8A,0xDE,0x10,0x37,0x6E,0x04,0x0B,0x80,0xBD,0x4A,0x72,
    0x8D,0x5F,0xA8,0xF5,0x7B,0x81,0x6E,0x14,0x95,0x29,0x6B,0x5B,0x17,0x56,0xBF,0x70,
    0x04,0x6C,0xF3,0x4F,0xE2,0x71,0x50,0xBF,0xE0,0xC3,0xF5,0x34,0x69,0x0D,0xBA,0x91,
    0x59,0xD7,0x42,0x06,0x52,0xA3,0x27,0x2D,0x39,0xDF,0x77,0xFE,0x0F,0xFF,0xAF,0xDC,
    0x21,0x7C,0x10,0x2E,0x02,0xF5,0x29,0xCA,0x35,0x7E,0xA3,0xD5,0xE0,0x06,0x40,0x22,
    0x25,0xE0,0x7E,0x79,0x36,0x47,0xAC,0xAF,0x44,0x80,0x26,0x36,0x84,0x1F,0xD6,0xCD,
    0x33,0xF7,0xF8,0x12,0x13,0x19,0x0E,0x3D,0xA8,0x85,0xE1,0x47,0x02,0xBB,0x58,0x40,
    0x66,0x2A,0x3A,0xED,0x74,0xE5,0x1B,0xFF,0xB7,0xC0,0xB7,0x0A,0x4A,0x94,0xB5,0xAD,
    0x8B,0xAB,0x5F,0xBC,0x3E,0x00,0x8D,0x9E,0x69,0xFC,0x4E,0x2A,0x17,0xFD,0xEA,0x68,
    0xD2,0x1B,0x7E,0x45,0x65,0x50,0xC3,0xF0,0x0C,0x50,0x78,0x86,0xF0,0x00,0x66,0x91,
    0xA6,0x27,0x38,0x44,0x6F,0x9E,0x40,0x78,0x27,0x71,0xC3,0x37,0xF6,0x0D,0xA9,0xB4,
    0x0D,0x8E,0x86,0x1A,0xE3,0x55,0x85,0x61,0x1D,0x83,0x80,0x8D,0x23,0x4C,0x4E,0x70,
    0x88,0xDF,0x3C,0x8F,0x58,0x2C,0x16,0xAC,0xEF,0xBC,0x40,0xEB,0xDD,0x2D,0x15,0xA0,
    0x36,0x56,0x60,0x06,0x5F,0xB3,0xBF,0x7F,0xDA,0xC7,0x80,0xCA,0xF5,0x34,0x4C,0xFE,
    0x7A,0xBF,0xFF,0xDA,0xC7,0xB9,0x90,0xE2,0xA9,0x8B,0x3D,0x5E,0x90,0x08,0xF6,0x53,
    0xB9,0x22,0x6E,0x22,0x38,0xB9,0xDF,0xFF,0xCB,0x85,0x20,0x17,0x00,0x17,0xB0,0x29,
    0x8C,0x3A,0xFD,0x7C,0xA3,0xD5,0xEF,0xB0,0x8C,0x24,0x75,0x22,0x94,0xEA,0x51,0xBB,
    0x5F,0x00,0x04,0x90,0x88,0x97,0xF6,0x07,0x26,0xF7,0xD4,0x40,0x00,0x3A,0x20,0x21,
    0xB1,0x34,0x79,0x2F,0x5A,0x19,0x8A,0xFF,0x79,0x8F,0xC5,0x2B,0xBE,0x89,0x97,0x32,
    0x59,0x03,0x15,0x52,0xAB,0x67,0x2E,0xBC,0xF7,0xF5,0xFF,0xFC,0x0B,0x0F,0x0F,0x47,
    0x36,0xF9,0x30,0x87,0xBD,0xFD,0x92,0x06,0x63,0x1C,0xE6,0x31,0xF6,0xFD,0xF7,0xFF,
    0xEA,0x3C,0x53,0xD2,0x17,0xF3,0x1F,0x8A,0x57,0x7D,0x93,0x2E,0x64,0x0F,0xD6,0x91,
    0xA6,0x27,0xC0,0x06,0x46,0xFF,0x02,0x3D,0x60,0xB0,0x5A,0xB3,0xBE,0xF1,0x03,0xAF,
    0x74,0xA0,0x00,0xF2,0x01,0x90,0x2C,0xDA,0xFB,0x2F,0x7C,0xA2,0x3F,0xE0,0xD4,0x02,
    0x02,0xD8,0x9E,0x68,0x0B,0x9E,0x68,0xAD,0x01,0xB2,0xB3,0x00,0x32,0xFD,0x9D,0xFB,
    0xFE,0x40,0x23,0xD9,0x4E,0xE4,0x89,0xB8,0x88,0xE2,0xE7,0x7F,0xF8,0x04,0x26,0x0B,
    0x0F,0x08,0xBD,0x98,0x7F,0xF7,0x97,0xEE,0x0C,0x22,0x11,0x66,0xC0,0x43,0x7E,0x00,
    0x6C,0xE0,0x6C,0x8A,0xB7,0xED,0x69,0x2B,0x19,0xFB,0xD6,0xD1,0x26,0x37,0xE8,0x44,
    0x77,0x4D,0x0B,0x40,0x16,0x7A,0xDA,0x49,0x0F,0xA9,0x9F,0xEF,0x50,0x2E,0x02,0xF5,
    0x29,0xCA,0x35,0x7E,0xFA,0xEE,0xFC,0x87,0xE8,0x54,0x7F,0xD5,0x11,0x64,0xD7,0x60,
    0x64,0x00,0x02,0x04,0x1E,0x99,0x00,0x1E,0x40,0x22,0x25,0xE0,0x7E,0x79,0x36,0x47,
    0xAF,0x75,0x22,0x44,0x93,0xE4,0x10,0x62,0xDF,0xED,0x08,0x19,0x4A,0x8C,0x9C,0xBF,
    0xEE,0xF9,0xBF,0xF7,0xFF,0xB9,0x33,0x68,0x4D,0x94,0xAA,0xCC,0xBC,0x0B,0x70,0xA4,
    0xA9,0x4B,0x5A,0xD8,0xBA,0xB0,0x27,0xC1,0x87,0xD7,0x98,0xBB,0x6F,0xEF,0xE8,0x90,
    0x04,0xC6,0xD0,0x83,0xFA,0xD9,0xA6,0x7E,0xFF,0x03,0x80,0x37,0x02,0xD5,0x97,0xCA,
    0x6A,0x9C,0x18,0xF7,0x78,0x00,0x1B,0xB6,0x6D,0x8D,0xCC,0x11,0x3B,0xE7,0x10,0x1F,
    0x10,0xDA,0x4F,0x2E,0x00,0x1B,0xAE,0xE9,0x9E,0xF5,0x82,0xC1,0x6A,0xCE,0xFB,0xC4,
    0x0E,0xBD,0xD0,0xE0,0x08,0xD9,0xE6,0x9F,0xC4,0xE2,0xA1,0x7F,0xD8,0x18,0xB8,0xAC,
    0x69,0x51,0x0C,0x24,0x8C,0x7F,0xFF,0xD8,0x3F,0xF1,0x7E,0xC2,0x98,0x1A,0x02,0x21,
    0x0A,0x52,0xD2,0x01,0x1E,0xCA,0x77,0x24,0x4D,0xC4,0x47,0x17,0x38,0x3F,0xE2,0x38,
    0xC1,0x00,0x02,0x3B,0xFE,0x43,0xD5,0x48,0xED,0x80,0xC4,0xDE,0xD1,0xFB,0x24,0x44,
    0x20,0xDE,0x21,0x2F,0xE8,0x47,0x56,0x60,0x48,0x6C,0x74,0x30,0xD6,0xB2,0x15,0x85,
    0x1F,0x9D,0x80,0x51,0xB0,0xF4,0x45,0x7A,0xEF,0x27,0x28,0xB2,0x3F,0xEF,0x26,0x32,
    0x25,0xD9,0xDD,0x3A,0xB6,0x7E,0x5B,0xD3,0x89,0x89,0xEA,0x15,0x30,0x7E,0xE6,0xC9,
    0xA1,0xB7,0x42,0xA3,0x3A,0x78,0x0D,0xBB,0x20,0x6E,0xFB,0xAB,0x49,0x37,0x85,0x78,
    0x33,0x60,0x9B,0xF5,0xCF,0x10,0xEC,0x6B,0x6E,0x56,0xC3,0x33,0xD3,0x0A,0x5B,0xEA,
    0xD6,0x51,0xFF,0xFF,0x70,0xF9,0xF1,0x47,0xC1,0xCB,0xBC,0x00,0x12,0x42,0x22,0x5F,
    0xD8,0x1C,0x9B,0xDF,0x51,0x18,0xC8,0x3A,0x6A,0x24,0x23,0x88,0xA5,0x05,0x9F,0xFF,
    0xEA,0xB0,0x33,0x1C,0xDF,0xE8,0x73,0x14,0xC7,0xEB,0xA0,0xE0,0x69,0x31,0x84,0x54,
    0x53,0x8B,0x5D,0x14,0xA7,0xFF,0xBC,0x01,0x38,0x3E,0x16,0xEC,0xFF,0xAC,0x48,0xEB,
    0xD8,0x5B,0x80,0x04,0xD6,0x34,0x4C,0x70,0x84,0xA6,0xE7,0x3F,0xFB,0x4D,0x03,0x43,
    0x86,0xEF,0x56,0x28,0x97,0xE3,0xFF,0xC0,0xE1,0xF8,0x13,0x50,0xB7,0x99,0x4B,0x5D,
    0xA2,0x35,0x97,0xC1,0x9F,0x11,0x05,0x2B,0x9D,0x58,0x51,0x3C,0x4F,0xFF,0xC1,0x87,
    0xD3,0xED,0xFE,0x13,0xFC,0x66,0x79,0xB6,0x61,0x09,0x77,0x2C,0x56,0x0E,0x44,0x7D,
    0xCA,0xE5,0x8F,0x07,0xC7,0xEE,0x7F,0xEB,0xAE,0xBB,0xEF,0xAE,0xBA,0xEB,0xBE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xBE,0xFA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,
    0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,
    0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,
    0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,
    0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xC0,
};
unsigned char MPEG4_Playback_black_French_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x1e,0xda,0x05,0x07,0xe4,0x00,0x00,0x00,0x01,
    0x68,0xce,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x0a,0x7f,0xff,0xe1,0xe8,
    0xa0,0x00,0x67,0xdf,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,0x7d,0xf7,0xdf,
    0x7d,0xf5,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x7f,0xff,
    0x4a,0x86,0x15,0xc0,0x70,0x98,0x65,0x26,0x40,0x06,0x4c,0x83,0xdd,0xf6,0x36,0x47,
    0xc8,0x01,0x4b,0x8d,0x00,0x4c,0xac,0x13,0x57,0x80,0x9c,0xbc,0x4c,0xfa,0x7c,0xf2,
    0xdf,0xff,0xdd,0x34,0xd6,0xb5,0xef,0xf0,0xdb,0x1f,0xfa,0x90,0x3f,0x85,0x60,0x46,
    0xb6,0x97,0xd7,0xbb,0xac,0x48,0xd3,0xab,0xf8,0xff,0xfd,0xd7,0x5c,0xbf,0x98,0x56,
    0xb3,0xdf,0xe7,0x51,0x79,0x53,0x24,0x84,0xe8,0x9f,0x09,0xa0,0x66,0x2b,0x17,0x48,
    0x01,0xe6,0x9a,0xb4,0x21,0xd7,0x95,0x0d,0xdb,0x70,0xb8,0x39,0x79,0xab,0xe9,0xfe,
    0x38,0x93,0x1a,0x23,0xa1,0xb5,0x37,0xfc,0x56,0x81,0xe1,0x58,0x1b,0x52,0x86,0xfb,
    0x14,0xb2,0x3f,0xff,0xff,0x00,0x82,0x52,0xa6,0xf2,0x5a,0x8e,0x7f,0xfb,0xfd,0x0c,
    0x09,0x1e,0x8a,0x44,0xe5,0x77,0x92,0x37,0xfb,0xde,0x00,0x16,0x39,0x49,0x53,0x29,
    0x3d,0x73,0x82,0x3f,0xbc,0x05,0x5c,0x1c,0xbc,0xd5,0xf4,0xff,0x3f,0xfd,0x46,0x18,
    0x56,0x02,0xcd,0x7e,0xb8,0x11,0x65,0x52,0x7f,0xf5,0x99,0xa2,0x19,0x1a,0xd5,0x29,
    0x8f,0xdf,0xee,0x0c,0x0c,0xcb,0x3c,0x16,0xba,0x89,0x27,0x7e,0xfc,0x03,0x8f,0x32,
    0x48,0xb2,0xc6,0xf1,0x84,0x46,0x8d,0x5d,0xb3,0x27,0xff,0xff,0x9e,0xfb,0x6d,0xca,
    0x6e,0x7f,0xa8,0xd9,0x0d,0x23,0xa2,0x58,0xff,0xdf,0xfb,0xff,0xe3,0xc2,0x15,0x89,
    0x00,0x4d,0xb9,0xcc,0x6e,0x04,0x00,0x4d,0x1a,0xc6,0x8d,0xad,0xaf,0xe7,0xff,0x18,
    0x13,0x8c,0xb0,0xd8,0x1c,0x4c,0x7d,0x42,0x7e,0xa0,0xea,0x90,0x3d,0x9f,0xf3,0x77,
    0x47,0x5e,0x02,0xcd,0x35,0x68,0x43,0xaf,0x2b,0xbb,0xeb,0xf6,0x9a,0x6b,0x00,0x2d,
    0x77,0x8a,0x26,0x62,0x4a,0xea,0x92,0xbf,0xf7,0xfe,0xff,0xff,0xe1,0x58,0x20,0xee,
    0x5a,0xc8,0x2e,0xdc,0x61,0xbf,0xfa,0x03,0xc1,0x5b,0x92,0xa4,0x0c,0xa1,0xc5,0xd0,
    0x1f,0x84,0xe5,0x11,0xd7,0xae,0x47,0xcb,0xc0,0x4a,0xd9,0xc5,0x30,0x12,0xd7,0x28,
    0x27,0xdc,0x00,0xf9,0x0e,0x6a,0xfd,0x21,0x27,0x79,0xd1,0xaf,0x93,0xf9,0xd7,0xdf,
    0xff,0xeb,0x0a,0xc1,0x05,0x3a,0xc6,0x51,0x36,0xe5,0x66,0xff,0xe8,0x3c,0x00,0x13,
    0xb1,0x93,0x3b,0xbf,0x4e,0x9c,0xd4,0x0c,0x00,0xb8,0x9b,0xd4,0x46,0x24,0x8e,0x83,
    0x7d,0x83,0x60,0xb2,0xde,0xbd,0x04,0x3f,0x9e,0x26,0x0c,0xa6,0x37,0x17,0x73,0x96,
    0x4a,0x9b,0x57,0xe9,0x8c,0xff,0xfd,0xbf,0xff,0x60,0x03,0x20,0x85,0x60,0x69,0xf2,
    0x79,0x25,0xf0,0xb9,0x9f,0xf0,0x78,0x26,0x1d,0x49,0x9c,0x09,0xb4,0x2d,0xea,0xc9,
    0x74,0x8d,0xff,0xf0,0x60,0x07,0xc8,0x99,0xba,0xa4,0x66,0x5f,0xfa,0x06,0x66,0xfb,
    0xae,0x7f,0xff,0xff,0xc0,0x14,0x79,0x44,0xd3,0x15,0xd6,0x85,0x97,0x24,0x2f,0xd1,
    0x55,0x07,0x57,0xfd,0x7f,0xc2,0xb0,0x16,0x8d,0x63,0x46,0xd6,0xd7,0xed,0xff,0xca,
    0x00,0x26,0xdc,0xe8,0x6e,0x04,0x0c,0x7e,0x00,0xbc,0x89,0x9b,0xaa,0x46,0x6f,0xff,
    0xff,0x30,0x36,0x23,0x46,0xae,0xd9,0x93,0xff,0xff,0xcc,0x17,0x33,0x12,0x57,0x54,
    0x95,0xff,0xbf,0xf6,0x8d,0x90,0xd2,0x3a,0x25,0x8f,0xfd,0xff,0xbf,0xf7,0x0c,0xfc,
    0x2b,0x02,0x47,0x29,0x2a,0x65,0x27,0xaa,0x70,0xcf,0xe0,0x27,0x22,0x66,0xea,0x91,
    0x99,0x7f,0xeb,0x85,0xc1,0xcb,0xcd,0x5f,0x4f,0x73,0x84,0x3e,0x91,0x3c,0x55,0x6b,
    0x16,0x7f,0xf0,0x29,0xd3,0x49,0xfa,0xb3,0x00,0xb4,0x6b,0x1a,0x36,0xb6,0xbf,0x27,
    0xff,0x39,0x21,0x75,0x45,0x54,0x1d,0x5a,0x79,0x0e,0x6a,0xfd,0x09,0x3b,0xff,0xef,
    0xff,0xae,0xd8,0x24,0x2b,0xc5,0xf2,0xd9,0x00,0x93,0x32,0x3f,0xef,0x80,0xd8,0x8d,
    0x1a,0xbb,0x66,0x4f,0xff,0xff,0x3d,0xcb,0xc9,0x6f,0x56,0xff,0x69,0x99,0xb1,0xae,
    0xf7,0xa7,0xdb,0xbc,0x3c,0x00,0x27,0x73,0x26,0x00,0x2c,0xb9,0x74,0x96,0xe8,0x5e,
    0x47,0xfc,0x0c,0x05,0x1e,0x8a,0x44,0xe5,0x77,0x92,0xe6,0xff,0x7f,0xe2,0x10,0xf0,
    0xac,0x0d,0xc8,0x99,0xba,0xa4,0x66,0xff,0xff,0xf3,0x04,0x12,0xf8,0xf6,0x99,0x20,
    0xb4,0x6e,0xda,0x89,0x98,0x92,0xba,0xa4,0xaf,0xfd,0xff,0xbd,0xdf,0xa7,0x27,0x35,
    0x00,0x9a,0xc7,0x72,0x7c,0x4b,0x5c,0x9f,0xfd,0x82,0x72,0x88,0xeb,0xd7,0x23,0xe5,
    0xed,0x4d,0xa0,0xac,0x3f,0x4b,0x3c,0xfb,0xfd,0x46,0x43,0xf1,0x2a,0x3c,0x47,0x6d,
    0x7f,0xfb,0x7c,0x10,0x40,0x91,0xdb,0x2a,0x74,0x9c,0xae,0x61,0x9f,0xc0,0x69,0xf2,
    0x79,0x25,0xf0,0xb8,0x8f,0xf8,0x58,0x4c,0xf8,0x26,0xd0,0xb7,0xab,0x25,0xd2,0xc6,
    0x5d,0x75,0xd7,0x5d,0x75,0xdf,0x7f,0xbf,0x0e,0x2f,0xff,0xc3,0xf0,0x98,0xaa,0xb2,
    0xf4,0xea,0xf9,0x78,0x3f,0xbf,0x7d,0xe1,0xbc,0x37,0xde,0x1b,0xfd,0xfe,0xfd,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,
    0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,
    0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,
    0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x5d,0x75,0xd7,0x80,
};
unsigned char MPEG4_Playback_black_Italy_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xDA,0x05,0x07,0xE4,0x00,0x00,0x00,0x01,
    0x68,0xCE,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x11,0xFF,0xFF,0x87,0xA2,
    0x80,0x00,0x80,0x8F,0xBC,0x56,0xF7,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,
    0x7D,0xF7,0xDF,0x7D,0x62,0xB5,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAD,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0xFE,0x1F,0x45,0xE1,0x48,0x00,0x26,0x86,0x54,0x9F,0x30,0x31,0x35,0xBE,0xB2,
    0x03,0x0E,0x00,0x16,0x23,0xB4,0x2B,0x79,0x97,0xED,0xFF,0xDC,0x06,0x91,0xFC,0x0C,
    0xA4,0x54,0x12,0x4E,0x4B,0xDF,0x7F,0xFF,0xFA,0x0B,0xE1,0x86,0xE0,0x00,0xDD,0xB3,
    0x6C,0x6E,0x60,0x89,0xDF,0x38,0x80,0xC3,0x00,0x0B,0x09,0x8C,0x87,0x1E,0xD4,0x42,
    0xF0,0xA3,0x81,0x5D,0xB0,0x17,0x33,0xCD,0xB3,0x08,0x4B,0xB9,0x62,0xB7,0x90,0xF5,
    0x52,0x3B,0x6E,0x9D,0x73,0xE0,0x20,0xA4,0x22,0x42,0x34,0x4C,0xF1,0xFF,0xFD,0xEA,
    0x68,0xD2,0x1B,0x7E,0x45,0x65,0x50,0xC3,0xF5,0x34,0x69,0x0D,0xBF,0x22,0xB2,0xAD,
    0xAC,0x7B,0x99,0xCC,0x2A,0x9E,0xA3,0xD5,0xE0,0xFF,0x90,0x79,0xC3,0xC2,0xF0,0x00,
    0x4D,0x0C,0xA9,0x3E,0x60,0x62,0x6B,0x7D,0x64,0x7A,0x61,0x21,0xD3,0x86,0x5D,0xE5,
    0x0E,0x84,0x0D,0x7B,0x9B,0x26,0x86,0xD5,0x0A,0x8C,0xE9,0x6A,0x1E,0xC7,0x63,0x0A,
    0xB7,0x28,0xF5,0x7B,0xFC,0xD8,0xCA,0xB3,0x67,0x75,0xC8,0xD9,0x34,0x05,0x86,0xAF,
    0xBF,0x5B,0x95,0x2A,0x1C,0x53,0xDF,0xD8,0x03,0x31,0x0C,0x4C,0xA2,0x34,0xFB,0xD1,
    0xEE,0xF7,0x93,0x19,0x12,0xEC,0xEE,0x9D,0x5B,0x2F,0x87,0xA1,0xFC,0x42,0x18,0xE6,
    0x39,0xD8,0xFB,0xFB,0xFF,0xF5,0x34,0x69,0x0D,0xBA,0x91,0x59,0x5F,0xC1,0xFD,0x32,
    0x06,0x6D,0x07,0xBE,0x00,0xE3,0x72,0x9C,0xAC,0x3B,0xF9,0x45,0xA9,0xCE,0x0C,0xE3,
    0x33,0xCD,0xB3,0x08,0x4B,0xB9,0x62,0x34,0x00,0x19,0xA4,0x69,0x89,0xCE,0x11,0x1B,
    0xE7,0x91,0xAB,0x50,0xE5,0x35,0x28,0x89,0x6A,0x3F,0xFA,0xD0,0x36,0x3A,0x18,0x6B,
    0x8D,0x56,0x15,0x84,0x76,0xC0,0xC5,0xC5,0x63,0x4A,0x88,0x61,0x24,0x63,0xFF,0xFE,
    0xDC,0xF5,0xB7,0x92,0x13,0x56,0x22,0x6F,0x0F,0x96,0xF4,0xE1,0x76,0x7A,0x85,0x4D,
    0x6B,0x1E,0x03,0x2B,0xD4,0xD1,0x33,0xF9,0xEA,0xFE,0x1F,0xC3,0xEB,0x88,0x5F,0x6B,
    0xF8,0x36,0x7C,0x99,0xF7,0x65,0xAB,0xBA,0x06,0x60,0x00,0x1C,0x07,0x79,0xC9,0x80,
    0x2C,0x00,0x0B,0x18,0x07,0xF5,0xA9,0xE1,0x88,0x3A,0xB0,0x24,0x4C,0x13,0x51,0x13,
    0x35,0x6C,0xA6,0x2F,0xFA,0x02,0x42,0x63,0x21,0xC7,0xB5,0x10,0xBC,0x28,0xE0,0x57,
    0x6F,0x26,0x32,0x25,0xD9,0xD5,0x3A,0xB6,0x5F,0x01,0x36,0x74,0x0F,0xDD,0x77,0xA8,
    0x26,0xFF,0x43,0x0F,0xC0,0x9A,0x85,0xBC,0xCA,0x5A,0xED,0x11,0xAC,0xDF,0x01,0x36,
    0x74,0x0F,0xDD,0x77,0x68,0x26,0xF4,0xA0,0xF9,0xEB,0x6F,0x24,0x26,0xA8,0x44,0xDC,
    0x47,0x15,0x16,0xEF,0xDF,0x0F,0x04,0xEE,0x38,0x66,0xFE,0xC1,0xB5,0x30,0x0B,0x0D,
    0x88,0x72,0x30,0xCF,0xF5,0x14,0xA7,0x3F,0xFF,0xFE,0xA0,0x00,0x17,0x02,0x7F,0x1E,
    0xB1,0xD6,0x00,0x04,0x8D,0x85,0x89,0x54,0xBA,0x7D,0x22,0x25,0xC8,0x7F,0xCA,0x02,
    0xE0,0xC2,0x16,0xD9,0x74,0xB4,0x41,0xF1,0x5C,0x57,0xA3,0x48,0xD2,0x67,0x3D,0xFE,
    0x0F,0xEC,0x06,0x35,0xF5,0xAB,0xEA,0x16,0xB3,0xCF,0xF5,0xB6,0x07,0x86,0x82,0x19,
    0xE8,0x4E,0xDF,0xC3,0x7B,0xFF,0xFF,0x21,0xF0,0xC1,0x9B,0xB8,0x00,0x21,0xFE,0x45,
    0x16,0xFF,0xEC,0x82,0xB7,0xFC,0x8F,0x21,0xEA,0xA4,0x76,0xDD,0x3A,0xE7,0x4D,0x23,
    0x41,0x2D,0x99,0x00,0x06,0x84,0x24,0x33,0xFD,0xEF,0x52,0x44,0x90,0x98,0xE0,0x32,
    0x33,0x8F,0x24,0x3A,0x80,0x40,0x5B,0x13,0xC6,0x00,0xB9,0xE0,0x07,0x85,0x81,0x60,
    0xFF,0xF3,0x84,0x07,0xE0,0xF8,0x70,0x27,0x61,0x96,0xB7,0x34,0xDA,0x9A,0xD0,0x4E,
    0x7C,0x6C,0x82,0xAE,0x98,0x7B,0xFA,0xFF,0xFE,0x13,0x01,0x08,0xF8,0x55,0xC2,0xAA,
    0x50,0xF1,0x3F,0x6A,0xA9,0x24,0x54,0x95,0x7F,0xDF,0x0F,0xFD,0x3D,0x1B,0x40,0xEF,
    0x80,0x38,0xDC,0xA7,0x2B,0x0E,0xFE,0x51,0x6A,0x73,0x83,0x38,0xCC,0xF3,0x6C,0xC2,
    0x12,0xEE,0x58,0xAD,0x98,0x00,0x07,0x80,0xAF,0x10,0x98,0x0E,0x00,0x07,0x80,0xAF,
    0x10,0x99,0xA3,0x0F,0x08,0xF2,0xB9,0x18,0x47,0x13,0x19,0xEF,0xF6,0xF9,0x3C,0x24,
    0x44,0xAC,0x64,0xDE,0xFF,0xC0,0x64,0x35,0x58,0x87,0x31,0xF2,0xC7,0xBF,0xE6,0x9B,
    0x04,0x86,0x2B,0xB8,0x62,0x57,0x0E,0xA7,0xFF,0xDF,0xFF,0xC7,0x80,0x44,0x37,0x00,
    0x17,0xB0,0x29,0x8C,0x3A,0xFD,0x7C,0xA3,0xD5,0xE0,0x04,0x4C,0xDD,0x3B,0xFE,0xEB,
    0x17,0x64,0xB0,0x8C,0x24,0x75,0x22,0x94,0xEA,0x51,0xBB,0x46,0x00,0x01,0xD0,0x77,
    0x1C,0x99,0x80,0x78,0xE7,0xE7,0x0C,0xA5,0xAE,0xCA,0x10,0xF9,0xE4,0x00,0x00,0x80,
    0x60,0xC1,0x88,0x00,0x2C,0x17,0x61,0xDF,0xE2,0x3D,0xF6,0x1D,0x72,0xC8,0x18,0xAA,
    0x95,0x5B,0x39,0x75,0xE7,0xBF,0xAF,0xF3,0x62,0x2A,0x4D,0xDD,0x13,0x2B,0x75,0xF0,
    0xEC,0x23,0x89,0x1D,0x69,0xA5,0xBA,0xDA,0x6E,0xD7,0x03,0xF8,0x26,0x79,0x5D,0xEA,
    0x26,0x49,0x79,0x1F,0xFF,0x78,0x7C,0x78,0x9D,0xBB,0xF7,0xC1,0x50,0xF9,0xD9,0xBE,
    0x30,0x8E,0x14,0x6F,0xFE,0xD8,0x0B,0xA0,0x11,0x42,0xC2,0x95,0xD9,0x44,0x1C,0x58,
    0x2B,0xFE,0xFC,0x33,0x1C,0x80,0x44,0x5D,0xD5,0x2B,0x94,0xA5,0xAF,0x19,0x07,0x4D,
    0x44,0x84,0x71,0x14,0xA0,0xB3,0xFF,0xFD,0x54,0x6A,0x02,0x19,0x77,0xEB,0xF5,0x3B,
    0xBE,0x7F,0x09,0x60,0x39,0x40,0x94,0xBB,0x71,0xFB,0x6E,0xFF,0x78,0x76,0x60,0x08,
    0x45,0xC2,0x8B,0x77,0xAE,0xBC,0xF7,0xF5,0xFC,0x00,0x26,0xB1,0xA2,0x63,0x84,0x25,
    0x7B,0x3D,0xFF,0xDE,0x1F,0xF1,0xF9,0xC3,0x78,0x00,0x37,0x6C,0xDB,0x1B,0x98,0x22,
    0x77,0xCE,0x23,0xFC,0x87,0xAA,0x91,0xDB,0x54,0xEB,0x95,0x03,0xFA,0xC1,0x60,0xB5,
    0x67,0x7D,0xE2,0x07,0x5E,0xE7,0x03,0x0F,0x49,0xE6,0x13,0x86,0x5E,0x5E,0x94,0x6E,
    0x5E,0xFE,0x00,0xCC,0x43,0x13,0x28,0x8D,0x3E,0xF4,0x7B,0xBD,0xFF,0xF7,0xE3,0x80,
    0x58,0x77,0x80,0x02,0x0D,0x9F,0x26,0x7D,0xD9,0x6A,0xEE,0x80,0x00,0x90,0xF5,0x52,
    0x3B,0x60,0x31,0x37,0xB4,0x78,0xEE,0x4A,0x41,0x12,0x11,0x80,0x21,0x35,0xED,0x57,
    0xFF,0x83,0xE0,0x19,0x8E,0x6F,0xF0,0x1C,0x4E,0xF5,0x22,0x8F,0xCF,0xC0,0x69,0x31,
    0x84,0x54,0x53,0x8B,0x5D,0x14,0xA7,0xFF,0xBC,0xF2,0x63,0x22,0x5D,0x9D,0xD3,0xAB,
    0x67,0xF2,0x63,0x22,0x5D,0x9D,0x77,0x56,0x8A,0x18,0x76,0x03,0x1A,0xFA,0xD5,0xF5,
    0x0B,0x5A,0x8F,0xF5,0xB6,0x02,0x21,0xEA,0x45,0x39,0xCF,0x56,0x3D,0xFF,0x01,0x72,
    0x03,0xBC,0xE3,0xAF,0x95,0xCF,0xAE,0xEC,0x3F,0xE3,0xB0,0x63,0xDF,0x02,0x41,0x61,
    0xAB,0xEF,0xD6,0xE5,0x4A,0x87,0x14,0xF7,0xF0,0x03,0x8D,0xCA,0x72,0xB0,0xEF,0xE5,
    0x16,0xA7,0x38,0x32,0x00,0x0C,0xD2,0x34,0xC4,0xE7,0x08,0x8D,0xF3,0xC8,0x70,0x13,
    0xB8,0xE1,0x9B,0xFB,0x06,0xD4,0xDA,0x06,0xC7,0x43,0x0D,0x71,0xAA,0xC2,0xB0,0x8E,
    0xDE,0xA6,0x8D,0x21,0xB7,0x52,0x2B,0x2A,0xE0,0x62,0xE2,0xB1,0xA5,0x44,0x30,0x92,
    0xB1,0xFF,0xFF,0x60,0xFD,0x40,0x5C,0x18,0x42,0xDB,0x2E,0x95,0xAC,0x78,0x0C,0xAF,
    0x53,0x44,0xCF,0xE7,0xAB,0xFF,0xFF,0xE0,0xC1,0xB2,0x77,0x0E,0x3C,0x00,0x0F,0x01,
    0x5E,0x21,0x30,0x1C,0x00,0x0F,0x01,0x5E,0x21,0x33,0x00,0x72,0x43,0x63,0xE1,0x54,
    0xE5,0xA8,0xDD,0xA0,0x41,0x83,0x2B,0xF9,0xFE,0xB5,0xB4,0xE5,0x79,0xF7,0x03,0x12,
    0x1D,0xA9,0xA6,0x4B,0xA3,0x78,0x5D,0x7F,0xF6,0x9B,0x04,0x86,0x3B,0xB8,0x62,0x57,
    0x8C,0xC7,0xFF,0xC1,0xFF,0x08,0xDC,0x33,0x34,0xE4,0x52,0xB1,0x76,0xD2,0x3C,0xA1,
    0x03,0x7E,0x5D,0x96,0xD2,0xFF,0xEE,0x0F,0xFC,0x71,0x74,0x6C,0x3D,0xC0,0x01,0x31,
    0xF8,0xA5,0x77,0xD9,0x32,0xE6,0x40,0xFD,0x69,0x1A,0x62,0x7C,0x00,0x64,0x6F,0xE0,
    0x2B,0x88,0x6C,0x43,0x91,0x86,0x7F,0xA8,0xA5,0x39,0xFF,0xFF,0xFF,0x21,0xEA,0xA4,
    0x76,0xC0,0x62,0x6F,0x68,0xFD,0xE0,0xD0,0xE3,0xA1,0x90,0x47,0x10,0x4B,0x3F,0x55,
    0xFF,0xED,0x15,0xA0,0x36,0x56,0x60,0x06,0x5F,0xB3,0xBF,0x7F,0xF0,0x87,0x47,0x97,
    0x15,0xAA,0xB7,0x24,0xB8,0xAF,0xFF,0xDE,0x1F,0x93,0x19,0x12,0xEC,0xEF,0xBA,0xB6,
    0x7F,0x26,0x32,0x25,0xD9,0xD7,0x75,0x68,0xA1,0x87,0xEB,0xE2,0xE1,0xF8,0x4F,0xF9,
    0x20,0x11,0x12,0xF0,0x3F,0x3C,0x9B,0x23,0xD6,0x0A,0xC1,0x20,0x09,0x8D,0x88,0x3F,
    0xAD,0x9A,0x63,0xFF,0xBF,0xF0,0x2D,0xC2,0x92,0xA5,0x2D,0x6B,0x62,0xEA,0xD7,0xEE,
    0x00,0x8D,0x9E,0x69,0xFC,0x4E,0x2A,0x17,0xFC,0x0E,0x1A,0xEB,0xAE,0xBB,0xEF,0xBE,
    0xBB,0xEF,0xBE,0xBA,0xEB,0xBE,0xFB,0xEF,0xBE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,
    0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,
    0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,
    0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,
    0xBA,0xEB,0xAE,0xBA,0xEB,0xC0,
};
unsigned char MPEG4_Playback_black_Netherland_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xDA,0x05,0x07,0xE4,0x00,0x00,0x00,0x01,
    0x68,0xCE,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x11,0xFF,0xFF,0x87,0xA2,
    0x80,0x00,0x80,0x8F,0xBC,0x56,0xF7,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,
    0x7D,0xF7,0xDF,0x7D,0x62,0xB5,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAD,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5F,0xC0,0x5C,0x07,0x80,0x3F,0x78,0x00,0x7E,0xC1,0x98,0xE6,0x30,0x65,0xAE,
    0xCB,0x11,0xDF,0xA0,0x0C,0x3D,0x54,0x8E,0xDA,0xA7,0x5C,0xFB,0xB0,0x00,0xF6,0xDE,
    0xC7,0xF4,0x43,0x9D,0xDF,0xBF,0x60,0xC0,0xC8,0x6C,0x7E,0x7E,0xE0,0x46,0x2E,0xDE,
    0xAD,0xED,0x93,0x04,0x73,0x18,0xE7,0x31,0xF7,0xFD,0xF7,0xFF,0x80,0xA5,0x4B,0xC4,
    0xCA,0x55,0x94,0xB8,0xD4,0xDD,0x0E,0x11,0x1D,0xF0,0x86,0x1B,0xFC,0x04,0x60,0xB0,
    0x5A,0xB3,0xBE,0xF1,0x03,0xAF,0x74,0xBC,0x87,0xAA,0x91,0xDB,0x01,0x89,0xBD,0xA3,
    0xF7,0xE0,0xD0,0xE3,0xA1,0x90,0x47,0x10,0x4B,0x3F,0x55,0xFF,0xE0,0xE4,0x02,0x3D,
    0x94,0xEE,0x48,0x9B,0x88,0x8E,0x2E,0x77,0x93,0x19,0x12,0xEC,0xEF,0xBA,0xB6,0x7F,
    0x0F,0xC9,0x8C,0x89,0x76,0x75,0xDD,0x5A,0x28,0x61,0xFD,0x77,0x11,0x70,0x82,0x06,
    0xF8,0x00,0x38,0x98,0x6B,0xCB,0xF1,0x73,0xAC,0x10,0x92,0x6F,0x7F,0xDA,0x24,0x01,
    0x31,0x34,0x20,0xFE,0xB6,0x69,0x9F,0xBF,0xF0,0x24,0x26,0x32,0x1C,0x7B,0x51,0x0B,
    0xC2,0x0C,0x05,0x76,0x0F,0x04,0xEE,0x38,0x66,0xFE,0xB1,0xB5,0x36,0x82,0xDC,0x29,
    0x2A,0x52,0xD6,0xB6,0x2E,0xAF,0xDF,0xFD,0x86,0x2D,0x7C,0x79,0x69,0x22,0xE4,0x83,
    0xFF,0x9F,0xFF,0xFA,0x9A,0x34,0x86,0xDF,0x91,0x5B,0xBE,0x8A,0xD0,0x1B,0x2B,0x30,
    0x03,0x2F,0xD9,0x9F,0xBF,0xC3,0xFF,0x1C,0xE3,0xDF,0x0B,0x80,0x03,0x34,0x8D,0x31,
    0x39,0xC2,0x23,0x7C,0xF2,0x03,0xD0,0x36,0x3A,0x18,0x6B,0x8D,0x56,0x15,0x84,0x76,
    0x00,0x74,0x03,0x28,0x48,0xB5,0xF3,0xB6,0xB3,0xC5,0xA3,0xEB,0x20,0xE9,0xA8,0x90,
    0x8E,0x22,0x94,0x20,0xA7,0xFB,0x01,0xA1,0x98,0xE6,0xFF,0x01,0xC4,0xEF,0x52,0x28,
    0xFC,0xFD,0x6B,0x1E,0x03,0x2B,0xD4,0xD1,0x33,0xF9,0xEA,0xFF,0xE0,0xCD,0x82,0x6F,
    0xD7,0x3D,0x5B,0x3B,0xCF,0x05,0xF8,0x7C,0x03,0xD5,0x18,0x32,0x2A,0x2E,0x52,0xFC,
    0xDF,0xF7,0x9B,0x11,0x52,0x6E,0xEC,0x99,0x5B,0xA8,0x61,0xFF,0x57,0x8C,0x1C,0x2D,
    0x7F,0xC0,0x01,0xC4,0xC3,0x5E,0x5F,0x8B,0x9D,0x60,0x84,0x93,0x7B,0xFE,0xF4,0x48,
    0x02,0x62,0x68,0x41,0xFD,0x6C,0xD3,0x3F,0x7F,0x81,0x21,0x31,0x90,0xE3,0xDA,0x88,
    0x5E,0x10,0x60,0x2B,0xB0,0x7A,0x0B,0x70,0xA4,0xA9,0x4B,0x5A,0xD8,0xBA,0xBF,0x7F,
    0xFF,0xB0,0xC5,0xAF,0x8F,0x2D,0x24,0x5C,0x90,0x7F,0xF3,0xFF,0x01,0x36,0x74,0x0F,
    0xDD,0x77,0x68,0x26,0xEC,0x8F,0xE7,0xAD,0xBC,0x90,0x9A,0xA1,0x13,0x74,0x1E,0x76,
    0x43,0x17,0xEF,0x80,0xB9,0x9E,0x6D,0x99,0x80,0x00,0x80,0x47,0xF4,0x70,0xAD,0x8C,
    0x03,0x60,0x2D,0xD9,0x7E,0xA6,0x29,0xEB,0x7B,0xBD,0x80,0xA3,0x61,0xE8,0x8A,0xF5,
    0xDE,0x4E,0x51,0x64,0x7F,0xD8,0xC8,0x3A,0x6A,0x24,0x23,0x88,0xA5,0x05,0x9F,0xFF,
    0xEA,0xB7,0x8B,0xF3,0x39,0xC4,0x53,0xD6,0x7A,0xBD,0xCC,0x00,0x7C,0xB7,0x38,0x4D,
    0x22,0x09,0xE9,0xCF,0x72,0xDE,0x9C,0x4C,0x4F,0x50,0xAD,0x83,0xF0,0x66,0xC1,0x37,
    0xEB,0x9E,0xAD,0x9D,0xE7,0x93,0xC0,0x02,0x6B,0x1A,0x26,0x38,0x42,0x53,0x73,0x9F,
    0xFC,0x18,0x7E,0xBA,0x84,0x42,0xE3,0xDF,0x03,0x43,0x31,0xCD,0xFE,0x03,0x89,0xDE,
    0xA4,0x51,0xF9,0xF8,0x0D,0x13,0x04,0xDD,0x1F,0x3A,0xE5,0xE8,0xA7,0x47,0xF7,0x60,
    0x2A,0x40,0x13,0x1B,0x42,0x0F,0xEB,0x66,0x99,0x1F,0xBC,0xC6,0x78,0x15,0x3A,0x7D,
    0x5E,0xD0,0xE8,0x5C,0xC7,0x9B,0x11,0x52,0x6E,0xEC,0x99,0x5B,0xAE,0x82,0xDC,0x29,
    0x2A,0x52,0xD6,0xB6,0x2E,0xAF,0xDF,0xF8,0x7F,0x61,0x8B,0x5F,0x1E,0x5A,0x48,0xB9,
    0x20,0xFF,0xE7,0xFE,0x80,0x03,0xD9,0x36,0x60,0x6A,0xC4,0x13,0xDD,0xBE,0x1F,0x1F,
    0x50,0x80,0x20,0x5E,0xE0,0x02,0xB0,0xBE,0x3B,0x98,0x45,0xBD,0x47,0xAB,0xDF,0x88,
    0xF6,0x3B,0x9C,0x7A,0x0C,0xEE,0xF4,0xFF,0xF7,0x80,0x22,0x48,0x92,0x13,0x64,0x22,
    0x33,0x27,0x81,0xB1,0xC5,0x54,0xDB,0x8A,0x5D,0x96,0x21,0xFF,0xEF,0x00,0x50,0x46,
    0x12,0x72,0xA6,0x68,0x53,0x3A,0xA4,0xF5,0xFF,0xCE,0x04,0xEC,0x32,0xD6,0xE5,0x9B,
    0x53,0x79,0x0B,0xD5,0x23,0x3F,0x89,0xD7,0xB2,0x78,0x78,0x0C,0x86,0xAB,0x10,0xE6,
    0x3E,0x58,0xF7,0xFC,0xB0,0x10,0xD5,0xF4,0xBF,0xB9,0x5A,0x94,0x7F,0xAD,0x80,0x91,
    0x1C,0xCC,0x76,0xFB,0xE2,0x98,0xE6,0xFF,0xD6,0x02,0x22,0x53,0x9C,0xEB,0x16,0x9E,
    0x37,0xFE,0x7A,0xF4,0x17,0xF8,0x5F,0xF2,0x40,0x22,0x25,0xE0,0x7E,0x79,0x36,0x47,
    0xAC,0x15,0x82,0x40,0x13,0x1B,0x10,0x7F,0x5B,0x34,0xC7,0xFF,0x7F,0x00,0x06,0xED,
    0x9B,0x63,0x73,0x04,0x4E,0xF9,0xC4,0x07,0xA0,0x4C,0x64,0x38,0xF7,0x3A,0xBC,0x2B,
    0x48,0xEC,0x02,0xE6,0x79,0xB6,0x66,0x00,0x02,0x01,0x0B,0xE8,0xE1,0x5B,0x81,0x6E,
    0x14,0x95,0x29,0x6B,0x5B,0x17,0x56,0xBF,0x70,0x04,0x6C,0xF3,0x4F,0xE2,0x71,0x50,
    0xBF,0xE0,0x70,0xF1,0xE2,0xE0,0x65,0x7A,0xD8,0x26,0x7D,0xD3,0xCD,0xA6,0xA3,0x0D,
    0x83,0x5B,0xEB,0x4A,0x49,0x37,0xBF,0xFF,0x5E,0x90,0xFB,0xFA,0x0C,0xE7,0x73,0xBF,
    0xFF,0x90,0xC6,0x37,0xFE,0x87,0x80,0x04,0x08,0x39,0x84,0xC0,0x00,0x48,0x7A,0xA9,
    0x1D,0xB7,0x4E,0xB9,0xD3,0x86,0x46,0x1B,0x45,0x1A,0x8C,0x26,0x71,0xB7,0xFF,0xE1,
    0x00,0x00,0x40,0x40,0x00,0x23,0x1E,0xB6,0x89,0x31,0xBF,0x42,0x23,0xBA,0x06,0x00,
    0x76,0x1E,0x11,0xE5,0x72,0x30,0x8C,0x26,0x33,0xDF,0xEF,0xB8,0x13,0xB0,0xCB,0x5B,
    0x96,0x6D,0x4D,0xE4,0xC6,0x44,0xBB,0x3A,0x05,0xBD,0xE0,0x87,0xFC,0x3E,0x41,0xC4,
    0xE1,0x9C,0x2E,0x18,0x00,0xA4,0x3D,0x8E,0xC6,0x15,0x6E,0x51,0xEA,0xF7,0x80,0x23,
    0x19,0xEB,0xE1,0xDF,0x48,0x5A,0x3B,0xBB,0xCD,0x8C,0xAB,0x36,0x77,0x5C,0x8D,0x93,
    0xFE,0x43,0xD5,0x48,0xED,0xBA,0x75,0xCE,0x9E,0xB0,0x58,0x2D,0x59,0xDF,0x78,0x81,
    0xD7,0xB9,0xAC,0x01,0x2F,0x0F,0x3B,0x17,0xAB,0x5A,0x0D,0x7F,0xFF,0xB3,0x43,0xF8,
    0x84,0x31,0xCC,0x73,0xB1,0xF7,0xF7,0xFF,0xD8,0x76,0xB1,0xEE,0x67,0x30,0xAA,0x6A,
    0x8F,0x57,0xB0,0x06,0x62,0x18,0x99,0x44,0x69,0xF7,0xA3,0xDD,0xEF,0xFD,0xC0,0x75,
    0xC4,0x2E,0x11,0xB8,0x00,0x20,0x8F,0x82,0xEF,0x5F,0x39,0x5B,0x1B,0xEF,0x23,0x06,
    0xDE,0xC7,0xF4,0x43,0x9C,0xAF,0xDF,0xB5,0x86,0x71,0x67,0xAD,0x76,0xA7,0x5A,0x8D,
    0xDA,0x50,0x00,0x0B,0x81,0x3F,0x8F,0x50,0xEB,0x0F,0x80,0x1C,0x6C,0x2C,0x4A,0xA5,
    0xD3,0xE9,0x11,0x2E,0x7F,0xDF,0x03,0x43,0x31,0xCD,0xFE,0x03,0x89,0xDE,0xA4,0x51,
    0xF9,0xFB,0xC9,0x8C,0x89,0x76,0x75,0xDD,0x5B,0x2D,0x00,0xC6,0xBE,0xB5,0x7D,0x42,
    0xD6,0xFF,0xAF,0xA8,0x7F,0x81,0xE1,0xA0,0x86,0x7A,0x13,0xB7,0xF0,0xDE,0xFF,0x60,
    0x31,0xAF,0xAD,0x5F,0x50,0xB5,0xA8,0xFF,0x5B,0x78,0x2E,0x40,0x77,0x9C,0x75,0xF2,
    0xB9,0xF5,0xDD,0xFE,0x11,0x7F,0x0E,0xF8,0x1A,0x4C,0x61,0x15,0x14,0xE2,0xD7,0x45,
    0x29,0xFF,0xEF,0x00,0x4E,0x0F,0x85,0xBB,0x3F,0xEB,0x12,0x3A,0xF6,0x16,0x00,0x06,
    0x69,0x1A,0x62,0x73,0x84,0x46,0xF9,0xE4,0x07,0xEF,0x6C,0xDB,0x1B,0xF0,0x03,0x27,
    0x7F,0xF3,0xCD,0x00,0xCA,0x12,0x2D,0x7C,0xED,0xAC,0xF1,0x68,0xF0,0x13,0x50,0xB7,
    0x99,0x4B,0x5D,0xA3,0x59,0x7F,0xFE,0xE0,0xCF,0x88,0x82,0x95,0xCE,0xAC,0x28,0x9E,
    0x27,0xFF,0xE0,0x70,0xF4,0x3F,0x4E,0x2D,0xAB,0xC4,0x4F,0x7A,0xFE,0xF7,0xBC,0x19,
    0xB0,0x4D,0xFA,0xE7,0xCE,0xCE,0xF0,0xC7,0xFB,0x0F,0x9B,0xE9,0x70,0x00,0xC3,0x7F,
    0x19,0x07,0x4D,0x44,0x84,0x71,0x14,0xA0,0xB3,0xFF,0xFD,0x40,0x48,0x4C,0x64,0x38,
    0xF6,0xA2,0x17,0x85,0x1C,0x08,0xED,0x80,0xB9,0x9E,0x6D,0x98,0x42,0x5D,0xCB,0x15,
    0x83,0xE0,0x1E,0xA8,0xC1,0x91,0x51,0x72,0x92,0x72,0xFF,0xDE,0xA6,0x8D,0x21,0xB7,
    0xE4,0x56,0x55,0x0C,0x3F,0x53,0x46,0x90,0xDB,0xF2,0x2B,0x2A,0x86,0x1D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xDF,0x78,0x6F,0xBE,0xFB,0xEF,0xBE,0xFB,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,
    0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,
    0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,
    0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,
    0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBC,
};
unsigned char MPEG4_Playback_black_Spanish_QVGA[] =
{
    0x00,0x00,0x00,0x01,0x67,0x42,0x00,0x28,0xDA,0x05,0x07,0xE4,0x00,0x00,0x00,0x01,
    0x68,0xCE,0x38,0x80,0x00,0x00,0x00,0x01,0x65,0x88,0x84,0x11,0xFF,0xFF,0x87,0xA2,
    0x80,0x00,0x80,0x8F,0xBC,0x56,0xF7,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,0x7D,0xF7,0xDF,
    0x7D,0xF7,0xDF,0x7D,0x62,0xB5,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,0xEB,0xAE,0xBA,
    0xEB,0xAE,0xBA,0xEB,0xAD,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0xE1,0x5E,0x83,0xBE,0x17,0x00,0x06,0x6D,0x12,0x63,0x7E,0x84,0x47,0x74,0x90,
    0x08,0xD6,0x53,0xFD,0x22,0x6D,0xA1,0xC5,0xCE,0x0F,0xC0,0x50,0x06,0xE6,0xBE,0xAF,
    0x34,0xF1,0x13,0xFF,0xF5,0x9B,0x02,0x98,0xC3,0xAF,0xD7,0xCA,0x3D,0x5E,0x0C,0x10,
    0x46,0x12,0x3A,0x91,0x4A,0x74,0x28,0xDD,0xA0,0x00,0xED,0xE9,0xA3,0xA6,0xAF,0xFE,
    0xF8,0x3C,0x04,0x7A,0x2D,0xDC,0x81,0x37,0xE0,0xE2,0xE7,0x7F,0x80,0xA0,0x09,0x8D,
    0x3C,0x4E,0x79,0xE2,0xA7,0xFF,0xEB,0x20,0x62,0xAA,0x55,0x6C,0xE5,0xD7,0x9E,0xFE,
    0xBC,0x1F,0xF8,0x1F,0xD0,0x2C,0x9D,0xFE,0x06,0x86,0x63,0x9B,0xFC,0x07,0x13,0xBC,
    0x48,0x83,0xF3,0xF0,0x0A,0x48,0xC2,0x62,0x6B,0x4B,0x78,0xBC,0x72,0xBA,0xFF,0x78,
    0x13,0x18,0x45,0x45,0x38,0xB5,0xD1,0x4A,0x7F,0xFB,0xC0,0x11,0xA4,0x69,0x89,0xCE,
    0x11,0x1B,0xE7,0x91,0xE6,0xC4,0x54,0x9B,0xBB,0x26,0x56,0xEB,0x81,0x61,0xE1,0xE8,
    0xE6,0xDE,0x26,0x10,0xF7,0xBF,0x0F,0xF0,0x11,0x0F,0x52,0x29,0xCE,0x7E,0xB1,0xEF,
    0xF9,0xCB,0x7A,0x71,0x31,0x3D,0x42,0xA6,0xF0,0xF0,0x0E,0x2A,0x38,0x0B,0xF7,0x00,
    0x06,0x69,0x1A,0x62,0x73,0x84,0x46,0xF9,0xE4,0x79,0x0F,0x55,0x23,0xB6,0xE9,0xD7,
    0x3A,0x68,0x1B,0x1D,0x0C,0x35,0xC6,0xAB,0x0A,0xC2,0x3B,0x18,0x00,0x08,0x30,0xD5,
    0x93,0x03,0x80,0xB0,0x00,0x2C,0x60,0x1F,0xD6,0xA7,0xAD,0x07,0x50,0x12,0x26,0x09,
    0xA8,0x89,0x9A,0xB6,0x53,0x17,0xFD,0x5A,0xC7,0x80,0xCA,0xF5,0x34,0x4C,0xFE,0x7A,
    0xBF,0xFB,0x93,0x36,0x84,0xD9,0x4A,0xAC,0x8B,0xE1,0xF8,0x09,0xB3,0xA0,0x7E,0xEB,
    0xBD,0x41,0x37,0xE0,0xBF,0x02,0x6A,0x16,0xF3,0x29,0x6B,0xB4,0x46,0xB3,0x43,0x0F,
    0xC7,0x11,0x8B,0x5B,0xDF,0x02,0x42,0x63,0x21,0xC7,0xB5,0x10,0xBC,0x28,0xE0,0x57,
    0x60,0xF0,0x4E,0xE3,0x86,0x6F,0xEC,0x1B,0x53,0x60,0x2C,0x36,0x21,0xC8,0xC3,0x3F,
    0xD4,0x52,0x9C,0xFF,0xFF,0xEA,0x00,0x01,0x70,0x27,0xF1,0xEB,0x1D,0x61,0xE0,0x26,
    0xCE,0x81,0xFB,0xAE,0xED,0x04,0xDE,0x94,0xA0,0x2E,0x0C,0x21,0x6D,0x97,0x4B,0x9E,
    0xB6,0xF2,0x42,0x6A,0x84,0x4C,0x1E,0x88,0x3E,0x2B,0x8A,0xF4,0x69,0x1A,0x4C,0xE7,
    0xBF,0xD6,0x03,0x1A,0xFA,0xD5,0xF5,0x0B,0x59,0xE7,0xFA,0xDB,0xFF,0xA8,0x6B,0x70,
    0xE4,0x1B,0xC0,0x01,0x04,0xCD,0xD3,0xBF,0xEE,0xB1,0x76,0x40,0x02,0x46,0xC2,0xC4,
    0xAA,0x5D,0x3E,0x91,0x12,0xE4,0x3F,0xEF,0x73,0x64,0xE1,0xB0,0x05,0x25,0x39,0x9C,
    0x33,0xC2,0xF8,0xAA,0x25,0xF7,0xD1,0x05,0xEF,0xF1,0x01,0xE8,0xC6,0x77,0x4D,0xDC,
    0x00,0x49,0x66,0xF1,0xD7,0xC2,0x40,0x80,0xB6,0x27,0x8C,0x01,0x73,0xCC,0x0F,0x0D,
    0x04,0x33,0xD0,0x9D,0xBF,0x86,0xF7,0xFF,0x36,0x22,0xA4,0xDD,0xD9,0x32,0xB5,0x7F,
    0x0F,0x81,0xB6,0x5C,0x35,0x95,0xA4,0xC9,0x2A,0xAD,0xB4,0xB0,0x08,0xC7,0xC3,0x5E,
    0x27,0x64,0x6D,0x3E,0xE0,0xFF,0xFA,0x2B,0x26,0xCB,0xDF,0x00,0xF0,0xB0,0x2C,0x1F,
    0xFE,0x70,0x80,0xFC,0x1F,0x00,0x0E,0x37,0x29,0xCA,0xC3,0xBF,0x94,0x5A,0x9C,0xE0,
    0xCF,0x8C,0xCF,0x36,0xCC,0x21,0x2E,0xE5,0x8A,0xDE,0xB4,0x8D,0x31,0x39,0xC2,0x23,
    0x74,0xF2,0x36,0x11,0x11,0x28,0xD1,0x08,0x21,0x3F,0xF3,0x46,0x1E,0x11,0xE5,0x72,
    0x30,0x8E,0x26,0x33,0xDF,0xEF,0xFE,0x7A,0xDB,0xC5,0x99,0xAA,0x11,0x37,0x2D,0xE9,
    0xC4,0xC4,0xF5,0x0A,0xD8,0x30,0xF8,0x8E,0x3A,0xEF,0xEF,0xFA,0xC1,0x60,0xB5,0x67,
    0x7D,0xE2,0x07,0x5E,0xE9,0x30,0x00,0x05,0x8C,0x03,0xFA,0xD4,0xF1,0xC6,0xE6,0x00,
    0x29,0x0F,0x63,0xB1,0x85,0x5B,0x94,0x7A,0xBC,0x02,0x91,0x8C,0x50,0x22,0x6E,0xAA,
    0xD5,0xEA,0x52,0xBF,0xFF,0xF9,0xB1,0x95,0x66,0xCE,0xEB,0x91,0xB2,0x48,0x04,0x7B,
    0x29,0xDC,0x91,0x37,0x11,0x1C,0x5C,0xEE,0x00,0x93,0x2B,0x01,0x71,0x1B,0x36,0xBB,
    0xD3,0xFF,0xFB,0xC3,0xE0,0x26,0xA1,0x6F,0x32,0x96,0xBB,0x46,0xB2,0xFF,0xFD,0xA1,
    0xFC,0x42,0x18,0xE6,0x39,0xD8,0xFB,0xFB,0xFF,0x0F,0xFD,0x3C,0x40,0x01,0x03,0xB8,
    0x20,0x10,0xF7,0xF4,0xAE,0xA9,0x5A,0xD4,0x7F,0xAD,0xBF,0xCC,0x67,0x81,0x53,0xE7,
    0xD5,0xED,0x0E,0x95,0xCD,0x71,0x99,0xE6,0xD9,0x84,0x25,0xDC,0xB1,0x1B,0x30,0x00,
    0x0F,0x01,0x5E,0x21,0x30,0x1C,0x00,0x0F,0x01,0x5E,0x21,0x33,0xD0,0x00,0x7B,0x26,
    0xCC,0x0D,0x58,0x82,0x7B,0xB7,0xD4,0xD1,0xA4,0x36,0xFC,0x8A,0xCA,0xA0,0xE1,0xE0,
    0x32,0x1A,0xAC,0x43,0x98,0xF9,0x63,0xDF,0xF3,0x4D,0x82,0x43,0x15,0xDC,0x31,0x2B,
    0x87,0x53,0xFF,0xEF,0xFF,0x5E,0x82,0xF8,0x87,0x7C,0x05,0x80,0x01,0x63,0x00,0xFE,
    0xB5,0x3C,0x31,0x07,0x50,0x12,0x26,0x09,0xA8,0x89,0x9A,0xB6,0x53,0x17,0xFD,0x60,
    0x0E,0x33,0xC0,0xA9,0xF3,0xEA,0xF6,0x87,0x4A,0xE6,0xB8,0xCC,0xF3,0x6C,0xCC,0x00,
    0x04,0x02,0x3F,0xA3,0x85,0x6F,0x01,0x36,0x74,0x0F,0xDD,0x77,0xA8,0x26,0xFF,0x7C,
    0x09,0xA8,0x5B,0xCC,0xA5,0xAE,0xD1,0x1A,0xCD,0x0C,0x3F,0x40,0x01,0xEC,0x9B,0x30,
    0x35,0x62,0x09,0xEE,0xD7,0x02,0x76,0x19,0x6B,0x72,0xCD,0xA9,0x83,0xFE,0x23,0xF6,
    0x0D,0x03,0x7F,0x18,0x06,0xC0,0x5B,0xB2,0xFD,0x4C,0x53,0xD6,0xF7,0x78,0x0D,0x36,
    0x38,0xAA,0x9B,0x71,0x4B,0xB2,0xD6,0xFF,0xF7,0x80,0x00,0x9A,0x19,0x52,0x7C,0xC0,
    0xC4,0xD6,0xFA,0xC8,0x0E,0xC0,0x8C,0x63,0x7D,0xA9,0x8C,0x43,0x1F,0xAE,0x80,0x52,
    0xC6,0x13,0x13,0x4F,0xE2,0xC9,0x2F,0x38,0x77,0xFF,0xEF,0x72,0x66,0xD0,0x9B,0x29,
    0x55,0x91,0x78,0x18,0x90,0xED,0x4D,0x32,0x5D,0x5B,0xC2,0x6F,0xFF,0x83,0x0F,0x4D,
    0x82,0x43,0x06,0xFF,0x5E,0x2C,0x97,0x63,0xFF,0xDA,0x16,0x1E,0x1E,0x8E,0x6D,0xF2,
    0x61,0x11,0xBE,0xFF,0xE3,0xE2,0xDE,0x70,0xBF,0x81,0x31,0x84,0x54,0x53,0x8B,0x5D,
    0x14,0xA7,0xFF,0xBC,0xF0,0x00,0x6E,0xD9,0xB6,0x37,0x30,0x44,0xEF,0x9C,0x40,0x7E,
    0x43,0xD5,0x48,0xED,0xAA,0x75,0xCA,0x9E,0xB0,0x58,0x2D,0x59,0xDF,0x78,0x81,0xD7,
    0xB9,0xCC,0x04,0x43,0xD4,0x8A,0x73,0x9F,0xAC,0x7B,0xFE,0x7F,0xF4,0x9E,0x61,0x38,
    0x65,0xE5,0xE9,0x46,0xE5,0xEC,0x01,0x98,0x86,0x26,0x51,0x1A,0x7D,0xE8,0xF7,0x7B,
    0xFF,0xF9,0xAF,0x01,0x7E,0xF8,0x60,0x01,0xE1,0x98,0xE6,0xFF,0x01,0xC4,0xEF,0x52,
    0x28,0xFC,0xFD,0x81,0x28,0x81,0x11,0x2D,0x0A,0xF7,0xAC,0xC2,0x44,0x7F,0xBC,0x02,
    0xA4,0x01,0x31,0x34,0x20,0xFE,0xB6,0x79,0x91,0xFB,0xC0,0x1D,0x88,0xA9,0x37,0x76,
    0x4C,0xAD,0xD6,0x1F,0x02,0xDC,0x29,0x2A,0x52,0xD6,0xB6,0x2E,0xAD,0x7E,0xE0,0x08,
    0xD9,0xE6,0x9F,0xC4,0xE2,0xA1,0x7F,0xC1,0x87,0xDD,0x3C,0x19,0x8A,0x9D,0xFD,0x02,
    0x63,0x21,0xC5,0xB5,0x10,0xBC,0x20,0xC0,0x47,0x60,0x17,0x33,0xCD,0xB3,0x30,0x00,
    0x10,0x08,0xFE,0x8E,0x15,0xBD,0x06,0x73,0xB9,0xDF,0xFF,0xC8,0x63,0x1B,0xFF,0x40,
    0x0E,0x37,0x29,0xCA,0xC3,0xBF,0x94,0x5A,0x9C,0xE0,0xCF,0x01,0x36,0x74,0x0F,0xDD,
    0x77,0x68,0x26,0xF4,0x8E,0x1D,0x30,0x37,0x46,0x70,0x06,0x57,0xB3,0xE3,0xF7,0x3D,
    0x6D,0xE4,0x84,0xD5,0x08,0x98,0x30,0xF4,0x61,0xE1,0x1E,0x57,0x23,0x08,0xC2,0x63,
    0x3D,0xFE,0xFF,0x1F,0xC7,0x60,0x0D,0xE0,0x00,0xCD,0x23,0x4C,0x4E,0x70,0x88,0xDF,
    0x3C,0x87,0x01,0x3B,0x8E,0x19,0xBF,0xB0,0x6D,0x4D,0xA0,0x6C,0x74,0x30,0xD7,0x1A,
    0xAC,0x2B,0x08,0xEC,0x1C,0x78,0x00,0x1E,0x02,0xBC,0x42,0x60,0x38,0x00,0x1E,0x02,
    0xBC,0x42,0x62,0x80,0xB8,0x30,0x85,0xB6,0x5D,0x2B,0x58,0xF0,0x19,0x5E,0xA6,0x89,
    0x9F,0xCF,0x57,0xFF,0xF8,0x18,0x90,0xED,0x4D,0x32,0x5D,0x1B,0xC2,0xEB,0xFF,0xB4,
    0xD8,0x24,0x31,0xDD,0xC3,0x12,0xBC,0x66,0x3F,0xFE,0x0F,0xFC,0x7A,0xA7,0x40,0x85,
    0xF0,0x02,0x4B,0x18,0x4C,0x4D,0x3F,0x8B,0x24,0xBC,0xE1,0xDF,0xFF,0xA8,0x08,0xC6,
    0x37,0xDB,0x98,0xC6,0x7F,0x5F,0xCE,0x00,0x09,0x0F,0x55,0x23,0xB6,0xE9,0xD7,0x3A,
    0x00,0x38,0xDC,0xA7,0x2B,0x0E,0xFE,0x51,0x6A,0x73,0x83,0x38,0xC7,0x4E,0xAA,0x2D,
    0x2C,0x75,0xE9,0x15,0xE9,0xDA,0x16,0x1E,0x1E,0x8E,0x6D,0xF2,0x61,0x11,0xBE,0xA0,
    0x10,0xD5,0xF4,0xBF,0xB9,0x5A,0x9F,0xF5,0xF5,0xFF,0xD1,0x87,0x84,0x79,0x5C,0x8C,
    0x23,0x89,0x8C,0xF7,0xFA,0xC3,0xF4,0xE2,0xDA,0xBA,0xD6,0xA7,0x1E,0xFE,0xBF,0xFF,
    0x88,0xE0,0x84,0xF8,0x40,0x2F,0xE6,0x2D,0x14,0xAC,0xDF,0xA6,0x5E,0xE9,0xE6,0x3F,
    0x14,0xAE,0xFB,0x26,0x5C,0xC9,0xC1,0x63,0x09,0x89,0xA7,0xF1,0x64,0x97,0x9C,0x4F,
    0xFF,0xEC,0x09,0x8C,0x22,0xA2,0x9C,0x5A,0xE8,0xA5,0x3F,0xFD,0xE0,0x70,0x24,0x26,
    0x32,0x1C,0x7B,0x51,0x0B,0xC2,0x0E,0x04,0x76,0x01,0x73,0x3C,0xDB,0x30,0x84,0xBB,
    0x96,0x2B,0x60,0x26,0x0A,0x4A,0x8D,0x5A,0xDC,0xBA,0xB9,0x79,0xBC,0x09,0xA8,0x5B,
    0xCC,0xA5,0xAE,0xD1,0x1A,0xCB,0xF0,0xFD,0x4D,0x1A,0x43,0x6F,0xC8,0xAC,0xAB,0xEA,
    0x68,0xD2,0x1B,0x7E,0x45,0x65,0x50,0xC3,0x5D,0x75,0xD7,0x7D,0x75,0xDE,0x1B,0xEB,
    0xBE,0xBB,0xEB,0xBE,0xBB,0xC3,0x7D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,
    0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,
    0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,0x5D,0x75,0xD7,
    0x5D,0x75,0xD7,0x5E,
};
#endif
#endif
u32 SERVTYPE_STREAM_SERVER;
int CurrentCH;
int	SpeakerAvIndex;
int fileplayback=0;
int gbSearchEvent=0;
SMsgAVIoctrlPlayRecord gRemote_playfile;
struct search_time search_dir_start,search_dir_end;
s8 P2PEnableplaybackStreaming;
u8 Fileplaying=0;   /*for RDI 2: local playback*/
u8 Remote_play=0;
//Multi-CH related
s8  P2PEnableStreaming[MAX_AV_CH];
u32 P2PVideoBufReadIdx[MAX_AV_CH];
u32 P2PVideoPresentTime[MAX_AV_CH];
u32 P2PAudioBufReadIdx[MAX_AV_CH];
u32 P2PAudioPresentTime[MAX_AV_CH];
u32 P2PChannelStart[MAX_AV_CH];
VIDEO_BUF_MNG *P2PVideoBuf[MAX_AV_CH];
IIS_BUF_MNG   *P2PAudioBuf[MAX_AV_CH];

OS_EVENT* P2PAudioCmpSemEvt[MAX_AV_CH];
OS_EVENT* P2PVideoCmpSemEvt[MAX_AV_CH];
OS_EVENT* P2PAudioPlaybackCmpSemEvt;
OS_EVENT* P2PVideoPlaybackCmpSemEvt;

u8 h264header_updata[MAX_CLIENT]= {0,0,0,0};

static AV_Client gClientInfo[MAX_CLIENT];
int P2PAVsource[MAX_CLIENT];
int P2PAV_CH[MAX_CLIENT];

//P2P server related
int gOnlineNum = 0;
int gFirstConnect=0;
int videoquality=2;
u8 * gUID;
int gFlagLoginOK = 0;
int gLoginFaileCnt = 0;
int gFlagSpeakerOK = 0;
int gSpeakerFailedCnt = 0;
int gSpeakerSID = -1;
int gPlaybackSID= 0;
char gP2PPassword[UI_P2P_PSW_MAX_LEN]="000000";
#if UI_LIGHT_SUPPORT
u8 AppLightStatus=0;
#endif
#if(UI_VERSION == UI_VERSION_MAYON)
u8 MAYONLightStatus=0;
u8 MAYONAlarmStatus=0;
u8 MAYONTXTypeStatus=0;
int gCurPlaybackSID= -1;
#endif



#if APP_KEEP_ALIVE
#define KEEP_ALIVE_TIMEOUT	60

int gFlagKeepAlive[MAX_CLIENT+1] = {0,0,0,0,0}; /* 0:Default not connected; 1:APP connected*/
RTC_DATE_TIME gKeepAliveTime0;
RTC_DATE_TIME gKeepAliveTime1;
RTC_DATE_TIME gKeepAliveTime2;
RTC_DATE_TIME gKeepAliveTime3;
RTC_DATE_TIME gKeepAliveTime4;

#endif


struct sockaddr_in gPushMsgSrvAddr;
#if(HW_BOARD_OPTION == MR8211_ZINWELL)
char APNserver[30]="210.242.195.143";//http://push.plugcam.mobi
//#elif (HW_BOARD_OPTION == MR8200_RX_TRANWO_D8593)
//  char APNserver[30]="54.225.104.92";
// char APNserver2[30]="0.0.0.0";     // Slave server.
#else
char APNserver[30]="119.81.84.106";//"p2pserver1.mars-semi.com.tw ,Master server :Soft layer
char APNserver2[30]="125.65.83.75";// Slave server.
#endif
int gPushDuration=1;
struct sockaddr_in gFWSrvAddr;
//RTC_DATE_TIME gPushMsgTime;
unsigned int gPushMsgTime;

INT32U 	 gSessionTaskStack[TASK_SESSION_STACK_SIZE];
INT32U 	 gLoginTaskStack[TASK_LOGIN_STACK_SIZE];
INT32U 	 gListenTaskStack[TASK_LISTEN_STACK_SIZE];
INT32U 	 gSpeakerTaskStack[TASK_SPEAKER_STACK_SIZE];
INT32U   gP2PPlayfileTaskStack[TASK_P2P_PLAYFILE_STACK_SIZE-1];
char 	 timezone_des[256]="Taiwan";
u8* codeAddr = (u8*)((DRAM_MEMORY_END + 4) - 0x800000);
u8 fw_version[30]= {0};
char FWMD5[32];
extern u8  uiVersion[32];
u8 Reminder_FW_Upgrade=0;
int P2P_AV_Source[MAX_AV_CH];
u8  LocalChannelSource; // ch0 source
u8 Remoteplayback_CH;
s32 idx; //Progress of the f/w dowoloading
u8 OnlineUpdateStatus;
unsigned long gP2PStatus;
int CurrPlaybackSID;
u32 P2PPauseTime,P2PStartPauseTime,P2PStopPauseTime;
#if(HOME_RF_SUPPORT)
u8 gAppPairFlag=0;  /* 0: None, 1: Pair Success, 2: Pair Fail */
u8 gAppTXPairFlag=0;  	/* 0: None, 1: Pair Success, 2: Pair Fail */
u32 gPairAvIndex;
u8 APPversion_IOS[16]  = "IOS_1.0.0.18";
u8 APPversion_AND[16] = "AND_1.0.0.32";
u8 APPSensorListStatus=0;
u8 APPSensorStatus=0;
u8 APPRoomListStatus=0;
u8 APPSceneListStatus=0;
#endif
#if RFIU_RX_WAKEUP_TX_SCHEME
u8 gAppWakeCamflag=0;
#endif
u8  Reset_P2P_Connection_flag = 0;
u8	Reset_P2P_Connection_Stop_flag = 0;
u8	gSearchFileListFlag = 0;	//0:None; 1:APP use; 2:RX use.

/*
 *********************************************************************************************************
 * Extern Variables
 *********************************************************************************************************
 */
extern u32 gPlaybackWidth;
extern u32 gPlaybackHeight;
 
extern u8 rfiuAudioZeroBuf[RFI_AUIDIO_SILENCE_SIZE];

extern u8 uiP2PID[];
extern VIDEO_BUF_MNG rfiuRxVideoBufMng[MAX_RFIU_UNIT][VIDEO_BUF_NUM];
extern u32 rfiuRxVideoBufMngWriteIdx[MAX_RFIU_UNIT];

extern IIS_BUF_MNG rfiuRxIIsSounBufMng[MAX_RFIU_UNIT][IIS_BUF_NUM];
extern u32 rfiuRxIIsSounBufMngWriteIdx[MAX_RFIU_UNIT];

extern u8 *rfiuAudioRetDMANextBuf[RFI_AUDIO_RET_BUF_NUM];
extern u32 rfiuAudioRetRec_idx;
extern DEF_RFIU_UNIT_CNTL gRfiuUnitCntl[MAX_RFIU_UNIT];

extern u32 guiRFTimerID;

extern u8 P2P_playback_go;
extern u8 P2P_check;

extern unsigned int P2PPlaybackVideoStop;
extern int net_link_status;

extern u8  uiVersionTime[9]; /*Firmware version for MARS internal using.*/
extern u8  uiLightTimer[MULTI_CHANNEL_MAX][4];
extern u8  uiLightInterval[MULTI_CHANNEL_MAX][7][6];
#if( (CHIP_OPTION == CHIP_A1025A) || (CHIP_OPTION == CHIP_A1021A) )
extern s8	BoxExtKey;
extern u8  uiMACAddr[];
extern u32 gSystemStorageReady;
extern u8 homeRFSensorName[17];
#endif
#if APP_KEEP_ALIVE
extern u8 APPConnectIcon;
#endif
extern u8 homeRFSensorName[17];

/*
 *********************************************************************************************************
 * Function prototype
 *********************************************************************************************************
 */
void Task_Listen(void *pdata);
void client_p2pdisconnected(int SID);
void SendVideoFrameData(int SID, u32 time, u32 flag, int size, char *buf);
static void UCT_to_Local_convert_playfile(SMsgAVIoctrlPlayRecord *p);
static void Local_to_UCT_convert(STimeDay *q);
static void UCT_to_Local_convert(SMsgAVIoctrlListEventReq *p);
static void SendRegister(void);
static char *GetRegMessageString(char *UID);
static char *GetPushMessageString(char *UID, u32 camidx, int eventType);
static void SendPushMessage(u32 camidx, int eventType);
static int GetFile();
static void Handle_IOCTRL_Cmd(int SID, int avIndex, char *buf);
extern void  uiSetP2PImageLevel(u8  CamId, u8 level);
extern u8 uiSetP2PPassword(u8 *password);
void renew_iotclModule(unsigned short port);
extern void ClearNetworkInfo();
extern u8 SetLwIP(u8 mode);
void UpdateAPPLightStatus(u8 Camid);
void Task_SessionHandler(void* pData);

//------------------------------------code--------------------------------------//

/*Return which channel was streaming by APP.*/
int StreamingCH_by_APP()
{
    int ViewCH;
    int ch;
    int SID;
    ViewCH=0;
    for (ch=0; ch<MAX_AV_CH; ch++)
    {

        if(P2PEnableStreaming[ch]>0)
            ViewCH=ViewCH|(1<<ch);
    }
    return ViewCH;
}
extern u8 renewIP;

/*Checking P2P information*/
void Check_P2P_info(unsigned int *p2p_info)
{
    //int p2p_info;
    IOTC_Get_Login_Info(p2p_info);
    *p2p_info=*p2p_info&0x07;
	if(renewIP == 1) //Sean: 20170915 add
	   *p2p_info=*p2p_info&0x01;
    DEBUG_P2P("P2P INFO: %x.\n",*p2p_info);
}

/*Load time zone description*/
void Load_timezone_des(char *des)
{
    strcpy(timezone_des,des);
}

/*Return net link status*/
int Get_network_status()
{
    return net_link_status;
}

/*Register APN Server*/
static char *GetRegMessageString(char *UID)
{
    static char msgBuf[2048];

#if(HW_BOARD_OPTION == MR8211_ZINWELL)
    sprintf(msgBuf, "GET /apns/apns.php?cmd=reg_server&uid=%s HTTP/1.1\r\n"
            "Host: %s\r\n"
            "Connection: keep-alive\r\n"
            "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML,like Gecko) Chrome/19.0.1084.52 Safari/536.5\r\n"
            "Accept: */*\r\n""Accept-Encoding: gzip,deflate,sdch\r\n"
            "Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\r\n"
            "Accept-Charset: Big5,utf-8;q=0.7,*;q=0.3\r\n""Pragma: no-cache\r\n"
            "Cache-Control: no-cache\r\n"
            "\r\n", UID,inet_ntoa(gPushMsgSrvAddr.sin_addr));
#else
    sprintf(msgBuf, "GET /tpns/apns.php?cmd=reg_server&uid=%s HTTP/1.1\r\n"
            "Host: %s\r\n"
            "Connection: keep-alive\r\n"
            "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML,like Gecko) Chrome/19.0.1084.52 Safari/536.5\r\n"
            "Accept: */*\r\n""Accept-Encoding: gzip,deflate,sdch\r\n"
            "Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\r\n"
            "Accept-Charset: Big5,utf-8;q=0.7,*;q=0.3\r\n""Pragma: no-cache\r\n"
            "Cache-Control: no-cache\r\n"
            "\r\n", UID,inet_ntoa(gPushMsgSrvAddr.sin_addr));
#endif
    return msgBuf;
}

static void SendRegister()
{
    int skt;
    int err;
    char    hostname_IP[50]="";
    char hostname[50];

    strcpy(hostname,TPNS_SERVER);
    err=DN2IP(hostname,hostname_IP);
    if(err!=0)
        DEBUG_P2P("Parse TPNS_SERVER fail...\n");
    else
    {
        DEBUG_P2P("Get TPNS_SERVER,IP = %s\n",hostname_IP);
        DEBUG_P2P("Register the TPNS servre.\n");
        gPushMsgSrvAddr.sin_addr.s_addr=inet_addr(hostname_IP);
        gPushMsgSrvAddr.sin_port = htons(PORT_TPNS);
        gPushMsgSrvAddr.sin_family = AF_INET;

        if ((skt = (int)socket(AF_INET, SOCK_STREAM, 0)) >=0)
        {
            if (connect(skt, (struct sockaddr *)&gPushMsgSrvAddr, sizeof(struct sockaddr_in)) == 0)
            {
                char *msg = GetRegMessageString(gUID);
                if(send(skt, msg, strlen(msg), 0)<0)
                {
                    DEBUG_P2P("Register Fail\n");
                    err=-1;
                }
                else
                {
                    DEBUG_P2P("Register OK\n");
                    err=0;
                }
            }
            else
            {
                DEBUG_P2P("TPNS1 Connnection fail.\n");
                err=-1;
            }
            close(skt);
        }
    }
    /*Register backup TPNS server.*/
    if(err!=0)
    {
        strcpy(hostname,TPNS_SERVER2);
        err=DN2IP(hostname,hostname_IP);
        if(err!=0)
            DEBUG_P2P("Parse TPNS_SERVER2 fail...\n");

        else
        {
            DEBUG_P2P("Get TPNS_SERVER2 IP = %s\n",hostname_IP);
            DEBUG_P2P("Register the TPNS2 servre.\n");
            gPushMsgSrvAddr.sin_addr.s_addr=inet_addr(hostname_IP);
            gPushMsgSrvAddr.sin_port = htons(PORT_TPNS);
            gPushMsgSrvAddr.sin_family = AF_INET;

            if ((skt = (int)socket(AF_INET, SOCK_STREAM, 0)) >=0)
            {
                if (connect(skt, (struct sockaddr *)&gPushMsgSrvAddr, sizeof(struct sockaddr_in)) == 0)
                {
                    char *msg = GetRegMessageString(gUID);
                    if(send(skt, msg, strlen(msg), 0)<0)
                        DEBUG_P2P("Register Fail\n");
                    else
                        DEBUG_P2P("Register OK\n");
                }
                else
                {
                    DEBUG_P2P("TPNS2 Connnection fail.\n");
                }
                close(skt);
            }
        }
    }
}

void SetPushMsgDelay(int delay)
{
    gPushDuration=delay;
}


/*****************************************
Input : Packet Data
Return: 0	ERROR
		2	Status: 200 OK
		3	Status: Object Moved
		4	Status: Access Denied
		5	Status: Internal Server Error
*****************************************/
u8 ParsingHTTPHeader(u8* packet, u16 packet_len)
{
	u8* body;

	//printf("\x1B[96m packet_len:%d, %s \x1B[0m\n",packet_len,packet);
	if(packet_len == 0)		//Null Data
		return 0;

	body=strstr(packet,"HTTP");

	if(body[9] == 	   '2') 		// 2xx OK
		return 2;
	else if(body[9] == '3')	// 3xx redirect
		return 3;
	else if(body[9] == '4')	// 4xx Error
		return 4;
	else if(body[9] == '5')	// 5xx Server Error
		return 5;
	else
		return 0;
}

#if AutoNTPupdate
s8 SendGetTimeZoneMessage(void)
{
	int skt,err,on=1;
	char *msg;
	u8	timezoneMsg[512];
	u8	TimeZone_ACK[256];
	u8* body;
	u8 	ack_ret,i,retry=0;
	RTC_TIME_ZONE TimeZone;
    char hex_num[3],temp_char[2];
    char hostname_IP[50]="";
    char hostname[50];
	struct sockaddr_in TimeZoneSrvAddr;

	#define TimeZonePort	80
	#define TimeZoneServer	"timezone.mars-cloud.com"
	#define TimeZoneServer2	"timezone2.mars-cloud.com"

Retry:
	if(!retry)
    	strcpy(hostname,TimeZoneServer);
    else
    	strcpy(hostname,TimeZoneServer2);
    err=DN2IP(hostname,hostname_IP);

	TimeZoneSrvAddr.sin_addr.s_addr=inet_addr(hostname_IP);
	TimeZoneSrvAddr.sin_port = htons(TimeZonePort);
	TimeZoneSrvAddr.sin_family = AF_INET;

    if ((skt = (int)socket(AF_INET, SOCK_STREAM, 0)) >= 0)
    {
        setsockopt(skt,SOL_SOCKET,SO_KEEPALIVE,&on,sizeof(on));/*Check the TCP connection whether alive.*/
        if (connect(skt, (struct sockaddr *)&TimeZoneSrvAddr, sizeof(struct sockaddr_in)) == 0)
        {
            DEBUG_P2P("Sending TimeZone MSG\n");

			sprintf(timezoneMsg,"GET /api/getGeoInfo HTTP/1.1\r\n"
								"Host: timezone.mars-cloud.com\r\n"
								"Connection: keep-alive\r\n"
								"Cache-Control: max-age=0\r\n"
								"Upgrade-Insecure-Requests: 1\r\n"
								"User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36\r\n"
								"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\r\n"
								"Accept-Encoding: gzip, deflate\r\n"
								"Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\r\n\r\n");



			//printf("\x1B[96m%s\x1B[0m\n",timezoneMsg);

            if(send(skt, timezoneMsg, strlen(timezoneMsg), 0)<0)
            {
                DEBUG_P2P("Send TimeZone MSG Fail.\n");
                if(!retry)
	            {
	            	DEBUG_P2P("Retry TimeZone MSG\n");
	            	retry = 1;
	            	close(skt);
	            	goto Retry;
	            }
                return 100;
            }
            else
            {
                DEBUG_P2P("Send TimeZone MSG Event Success.\n");
				memset(TimeZone_ACK, 0, sizeof(TimeZone_ACK));
	            recv(skt, TimeZone_ACK, sizeof(TimeZone_ACK), 0);  //200 OK

				ack_ret = ParsingHTTPHeader(TimeZone_ACK, strlen(TimeZone_ACK));
				if(ack_ret != 2)
				{
					DEBUG_P2P("%s\n",TimeZone_ACK);
				}
				else
				{
					memset(TimeZone_ACK, 0, sizeof(TimeZone_ACK));
					recv(skt, TimeZone_ACK, sizeof(TimeZone_ACK), 0);  //DATA

					//printf("\x1B[96m%s\x1B[0m\n",TimeZone_ACK);
					body=strstr(TimeZone_ACK,"time_offset");

					if(body[13] == '-')
					{
						TimeZone.operator= 1;
						if(body[14] == '1')
						{
							memset(hex_num,0,sizeof(hex_num)); /*Convert Second*/
							for(i=0;i<2;i++)
							{
								sprintf(temp_char,"%c",body[14+i]);
								strcat(hex_num,temp_char);
							}
							hex_num[3]='\0';

							//TimeZone = 0-strtoul(hex_num,NULL,10);
							TimeZone.hour = strtoul(hex_num,NULL,10);
						}
						else
						{
							sprintf(hex_num,"%c",body[14]);
							//TimeZone = 0-strtoul(hex_num,NULL,10);
							TimeZone.hour = strtoul(hex_num,NULL,10);
						}
					}
					else
					{
						if(body[13] == '1')
						{
							memset(hex_num,0,sizeof(hex_num)); /*Convert Second*/
							for(i=0;i<2;i++)
							{
								sprintf(temp_char,"%c",body[13+i]);
								strcat(hex_num,temp_char);
							}
							hex_num[3]='\0';

							//TimeZone = strtoul(hex_num,NULL,10);
							TimeZone.hour = strtoul(hex_num,NULL,10);
						}
						else
						{
							sprintf(hex_num,"%c",body[13]);
							//TimeZone = strtoul(hex_num,NULL,10);
							TimeZone.hour = strtoul(hex_num,NULL,10);
						}

					}
					TimeZone.min = 0;
					printf("\x1B[96mTimeZone = %d %d:%d\x1B[0m\n",TimeZone.operator,TimeZone.hour,TimeZone.min);
					//RTC_Set_TimeZone(&TimeZone);


				}
            }
        }
        else
        {
            DEBUG_P2P("Couldn't send TimeZone MSG\n");

            if(!retry)
            {
            	DEBUG_P2P("Retry TimeZone MSG\n");
            	retry = 1;
            	goto Retry;
            }
            return 100;
        }
        close(skt);
		if(TimeZone.operator)
			return (0-TimeZone.hour);
		else
			return TimeZone.hour;

    }
    else
    {
        DEBUG_P2P("Create socket fail.\n");
        if(!retry)
        {
			DEBUG_P2P("Retry TimeZone MSG\n");
        	retry = 1;
        	goto Retry;
        }
        return 100;
    }

}
#endif
/*Raising event to APN server*/
static char *GetPushMessageString(char *UID, u32 camidx, int eventType)
{

    /*Content of event*/
    char EventString[10][50]={"%20[Motion]",
    						 "%20[Low_Battery]",
    						 "%20[PIR_Trigger]",
    						 "%20[DOOR_OPEN]",
    						 "%20[Siren_Switch_ON]",
    						 "%20[SOS]",		//Door bell sos
    						 "%20[Hello]",		//Door bell
    						 "%20[LOST_LINK]",	//LOST LINK
    						 "%20[MAT]",		//Bed Blanket 
    						 "%20[MAT2]",		//Bathroom Blanket
    						};
    char EventTime[20];
    char str[50];
#if (UI_VERSION == UI_VERSION_MAYON)
    char channel[12];
#else
    char channel[55];
#endif
#if DOOR_BELL_SUPPORT
    char rdiDoor[20];
#endif
    char sensor_id[10];
    char sensor_name[19];
    static char msgBuf[2048];
    RTC_DATE_TIME   localTime;
    u32 LocalTimeInSec;
    char deviceUID[21];
    int i;
    DEBUG_P2P("%s: camidx-0x%X, eventType-0x%X\n",__func__, camidx, eventType);
    RTC_Get_Time(&localTime);
    LocalTimeInSec=RTC_Time_To_Second(&localTime)+946684800;
    //DEBUG_P2P("UNIX=%d\n",LocalTimeInSec);

    memset_hw(deviceUID,0,21);
    strncpy(deviceUID,UID,20);


#if HOME_RF_SUPPORT
    /*Send HA Sensor to APP directly.*/
//    if (camidx > 4)

    if ((eventType  & HOMERF_PUSHMSG_PREFIX) != 0) //HomeRF sensor
    {
        sprintf(EventTime,"%d/%02d/%02d-%02d:%02d",localTime.year+2000,localTime.month,localTime.day,localTime.hour,localTime.min);
        strcat(EventTime, "%20[");
        sysAppGetSensorName(camidx);
        memset(sensor_name, 0, sizeof(sensor_name));
        strncpy(sensor_name,homeRFSensorName,16);
        for(i=0; i<16; i++)
            if(sensor_name[i] == ' ')
                sensor_name[i] = '_';
        strcat(sensor_name, "]%20");

        sprintf(msgBuf, "GET /tpns/apns.php?cmd=raise_event&uid=%s&event_type=100&event_time=%lu&msg=%s%s%s HTTP/1.1\r\n"
                "Host: %s\r\n"
                "Connection: keep-alive\r\n"
                "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML,like Gecko) Chrome/19.0.1084.52 Safari/536.5\r\n"
                "Accept: */*\r\n"
                "Accept-Encoding: gzip,deflate,sdch\r\n"
                "Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\r\n"
                "Accept-Charset: Big5,utf-8;q=0.7,*;q=0.3\r\n"
                "Pragma: no-cache\r\n"
                "Cache-Control: no-cache\r\n"
                "\r\n", deviceUID,LocalTimeInSec,EventTime,sensor_name,deviceUID,inet_ntoa(gPushMsgSrvAddr.sin_addr));
    }
    else
#endif
    {
#if DOOR_BELL_SUPPORT
    if ((eventType  & RDI_PUSHMSG_PREFIX) != 0) //RDI door bell
    {
        /*Send string to APP directly.*/
        strcpy(str,EventString[eventType & (~RDI_PUSHMSG_PREFIX)]);
        sprintf(rdiDoor, "%20[%04X]%20", camidx); //Sensor ID
        strcat(str,rdiDoor);
        DEBUG_P2P("%s: rdiDoor-%s\n",__func__, rdiDoor);
        DEBUG_P2P("%s: str-%s\n",__func__, str);
    }
    else /*for Normal event send, don't append sensor ID*/
#endif
        /*Send string to APP directly.*/
        strcpy(str,EventString[eventType]);
        sprintf(EventTime,"%d/%02d/%02d-%02d:%02d",localTime.year+2000,localTime.month,localTime.day,localTime.hour,localTime.min);
        strcat(EventTime, "%20");
        DEBUG_P2P("%s: EventTime-%s\n",__func__, EventTime);
#if (UI_VERSION == UI_VERSION_MAYON)
		if(EVENT_LOWBATTERY == eventType)
		{
			i=0;
			sprintf(channel, "CH");
			do
			{
				if(camidx & 0x01)
				{
					sprintf(channel, "%s:%d", channel, i+1);
				}
			}while( (camidx = (camidx >> 1)) && (i++ < MAX_RFIU_UNIT));
		}
		else
		{
			sprintf(channel, "CH%d", camidx+1);
		}
#else
        sprintf(channel, "CH%d", camidx+1);
#endif
        strcat(channel, str);
        DEBUG_P2P("%s: channel-%s: len-%d\n",__func__, channel, strlen(channel));
        sprintf(msgBuf, "GET /tpns/apns.php?cmd=raise_event&uid=%s&event_type=100&event_time=%lu&msg=%s%s%s HTTP/1.1\r\n"
                "Host: %s\r\n"
                "Connection: keep-alive\r\n"
                "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML,like Gecko) Chrome/19.0.1084.52 Safari/536.5\r\n"
                "Accept: */*\r\n"
                "Accept-Encoding: gzip,deflate,sdch\r\n"
                "Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\r\n"
                "Accept-Charset: Big5,utf-8;q=0.7,*;q=0.3\r\n"
                "Pragma: no-cache\r\n"
                "Cache-Control: no-cache\r\n"
                "\r\n", deviceUID,LocalTimeInSec,EventTime,channel,deviceUID,inet_ntoa(gPushMsgSrvAddr.sin_addr));
    }
    DEBUG_P2P("%s: msgBuf done-size %d\n",__func__,strlen(msgBuf));
    return msgBuf;
}

static void SendPushMessage(u32 camidx, int eventType)
{
    int skt;
    char *msg;
    int ret;
    int on=1;

    if (gPushMsgSrvAddr.sin_addr.s_addr == 0)
    {
        DEBUG_P2P("No push message server\n");
        SendRegister();
        //return;
    }
    if ((skt = (int)socket(AF_INET, SOCK_STREAM, 0)) >= 0)
    {
        ret=setsockopt(skt,SOL_SOCKET,SO_KEEPALIVE,&on,sizeof(on));/*Check the TCP connection whether alive.*/
        if(ret < 0)
            DEBUG_P2P("%s: setsockopt fail\n",__func__);
        if (connect(skt, (struct sockaddr *)&gPushMsgSrvAddr, sizeof(struct sockaddr_in)) == 0)
        {
            DEBUG_P2P("Sending push MSG\n");
            msg = GetPushMessageString(gUID, camidx, eventType);
            DEBUG_P2P("%s: msg done-size %d\n",__func__,strlen(msg));
            if(send(skt, msg, strlen(msg), 0)<0)
            {
                DEBUG_P2P("Send MSG Fail.\n");
                ret=-1;
            }
            else
            {
                DEBUG_P2P("Send MSG Success.\n");
                ret=0;
            }
        }
        else
        {
            DEBUG_P2P("Couldn't send MSG\n");
            ret=-1;
        }
        close(skt);
        if(ret<0)	/*Register TPNS server again, when sending push notification fail.*/
            SendRegister();
        /*
                if(ret<0)//Send push msg to backup server, if send to maste server was fail.
                {
                    DEBUG_P2P("Resend msg to backup server.\n");
                    gPushMsgSrvAddr.sin_addr.s_addr=inet_addr(APNserver2);
                    if ((skt = (int)socket(AF_INET, SOCK_STREAM, 0)) >= 0)
        	        {
        	            ret=setsockopt(skt,SOL_SOCKET,SO_KEEPALIVE,&on,sizeof(on));//Check the TCP connection whether alive.
        		        if (connect(skt, (struct sockaddr *)&gPushMsgSrvAddr, sizeof(struct sockaddr_in)) == 0)
        		        {
        			        DEBUG_P2P("Sending push MSG\n");
        			        msg = GetPushMessageString(gUID, eventType);
        			        if(send(skt, msg, strlen(msg), 0)<0)
        			        {
        				        DEBUG_P2P("Send MSG Fail.\n");
                                ret=-1;
        		            }
        			else
        			        {
        				DEBUG_P2P("Send MSG Success.\n");
                                ret=0;
        		        	}
        		}
        		else
        		        {
        			DEBUG_P2P("Couldn't send MSG\n");
                             ret=-1;
        		    }
        		close(skt);
        	}
        	else
        		DEBUG_P2P("Create socket fail\n");
        }
        */
    }
    else
        DEBUG_P2P("Create socket fail.\n");
}
s32 P2PSendEvent(u32 camidx,u32 eventType)
{

    //char IOCtrlBuf[MAX_BUF_SIZE];
    char *buf;
    int size;
    SMsgAVIoctrlEvent *q;
    //RTC_DATE_TIME current_time;
    unsigned int current_time;
    //u16 difftime;
    u32 difftime;

    current_time=OSTimeGet();
    //RTC_Get_Time(&current_time);
    //difftime=(current_time.min-gPushMsgTime.min)*60;
    //if((difftime+((s8 ) current_time.sec-(s8 ) gPushMsgTime.sec))>=30)
    IOTC_Get_Login_Info(&gP2PStatus);
#if ((UI_VERSION == UI_VERSION_MAYON) ||\
            (HW_BOARD_OPTION == MR9200_RX_TRANWO_SH8710R))
//Skip time check on MWM903, Paul add for push msg always on, 2018.08.29
	if(gP2PStatus==7)
	{
        DEBUG_P2P("Ready send MSG.\n");
        SendPushMessage(camidx, eventType);
	}
#else
    if(((current_time-gPushMsgTime)>600)&&(gP2PStatus==7)) //30 sec
    {
        DEBUG_P2P("Ready send MSG.\n");
        SendPushMessage(camidx, eventType);

        /*Send message via TUTK ioctl command*/
#if 0
        DEBUG_P2P("send msg for android\n");
        buf=IOCtrlBuf;
        size = sizeof(SMsgAVIoctrlEvent);
        q = (SMsgAVIoctrlEvent*)buf;
        q->time=20131008080405; 		// UTC Time
        q->channel=1; 		// Camera Index
        q->event=AVIOCTRL_EVENT_MOTIONDECT; 		// Event Type

        if(avSendIOCtrl(0, IOTYPE_USER_IPCAM_EVENT_REPORT, (char *)q, size) == AV_ER_NoERROR)
        {
            DEBUG_P2P("IPCAM_EVENT_REPORT OK \n\n");
        }
        //
#endif
        //RTC_Get_Time(&gPushMsgTime);
        gPushMsgTime=OSTimeGet();
    }
#endif
	return 1;
}

/*Firmware Upgrade via internet.*/
s32 Upgrade_fw_net(u32 dummy, u32 dummy2)
{
    char fw_name[30];

    if(GetFile("MD5SUM")==0)
    {
        DEBUG_P2P("FWMD5=%s\n",FWMD5);
        strcpy(fw_name,fw_version);
        strcat(fw_name,".bin");
        if(GetFile(fw_name)<0)
            DEBUG_P2P("Get firmware fail!\n");
    }
    else
        DEBUG_P2P("Get MD5SUM fail!\n");
    return 1;
}

#if ISP_NEW_UPGRADE_FLOW_SUPPORT
void netSetFirmwareName(char *Version, u32 Length)
{
	memset(fw_version, 0x0, 30);
	if(Version == NULL)
		return;
	strncpy(fw_version, Version, Length);
}

char *netGetFirmwareName(void)
{
	return fw_version;
}

int netDoDownloadFile(char *pPath, u8 *BufAddr)
{
	char urlfile[100], buf2[50], buf3[2], hostname_IP[50]="", hostname[50];
	u32 Index, FileSizeLimit = (1 << (20 + 3)), TryBackupServer = 0;
	int skt, bytesRecv, i, result, on = 1;
	u8 *pCh;
	u8 digest[16], err, retry;
	MD5_CTX ctx;

	sysDeadLockMonitor_OFF(); /*Turn off watch dog.*/

Retry:
	if(TryBackupServer == 0)
	{
		strcpy(hostname, FW_SERVER);
		err = DN2IP(hostname,hostname_IP);
		if(err == 0)
			DEBUG_P2P("Get FW_SERVER,IP = %s\n",hostname_IP);
		else
		{
			DEBUG_P2P("Parse FW_SERVER fail...\n");
			if(TryBackupServer == 0)
			{
				DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
				TryBackupServer = 1;
				goto Retry;
			}
		}

		memset(urlfile, 0, 100);
		sprintf(urlfile, "%s%s/%s", FW_PATH, fw_version, pPath);

		DEBUG_P2P("Get %s\n",urlfile);
		OnlineUpdateStatus = FW_DOWNLOADING;
		gFWSrvAddr.sin_addr.s_addr = inet_addr(hostname_IP);
		gFWSrvAddr.sin_port = htons(PORT_FW);
		gFWSrvAddr.sin_family = AF_INET;
	}
	else //China Server
	{
		memset(urlfile, 0, 100);
		sprintf(urlfile, "%s%s/%s", FW_PATH, fw_version, pPath);

		DEBUG_P2P("Get %s\n",urlfile);
		OnlineUpdateStatus = FW_DOWNLOADING;
		gFWSrvAddr.sin_addr.s_addr = inet_addr("119.29.94.156");
		gFWSrvAddr.sin_port = htons(PORT_FW);
		gFWSrvAddr.sin_family = AF_INET;
	}

	if((skt = (int)socket(AF_INET, SOCK_STREAM, 0)) >= 0)
	{
		result = -1;
		retry = 0;
		setsockopt(skt, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on));/*Check the TCP connection whether alive.*/
		while(result < 0)
		{
			result = connect(skt, (struct sockaddr *)&gFWSrvAddr, sizeof(struct sockaddr_in));
			retry++;
			if(result < 0)
			{
				close(skt);
				(skt = (int)socket(AF_INET, SOCK_STREAM, 0));
			}
			if(retry > 10)
			{
				if(TryBackupServer == 0)
				{
					DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
					TryBackupServer = 1;
					close(skt);
					goto Retry;
				}
				OnlineUpdateStatus = FW_DOWNLOAD_FAIL;
				break;
			}
		}
		if(result == 0)
		{
			memset(BufAddr, 0, FileSizeLimit);
			sprintf(BufAddr, "GET %s HTTP/1.1\r\n"
					"Host: %s\r\n"
					"Connection: keep-alive\r\n"
					"User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML,like Gecko) Chrome/19.0.1084.52 Safari/536.5\r\n"
					"Accept: text/html, application/xhtm l+xml,applicatio n/xml;q=0.9,*/*; q=0.8\r\n"
					"Accept-Encoding: gzip,deflate,sdch\r\n"
					"Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\r\n"
					"Accept-Charset: Big5,utf-8;q=0.7,*;q=0.3\r\n"
					"Cache-Control: no-cache\r\n"
					"\r\n", urlfile, inet_ntoa(gFWSrvAddr.sin_addr));
			send(skt, BufAddr, strlen(BufAddr), 0);
			Index = 0;
			i=0;
			memset(BufAddr, 0, FileSizeLimit);

			while(1)
			{
				bytesRecv = recv(skt, BufAddr + Index, FileSizeLimit, 0);
				DEBUG_P2P("#");
				if(bytesRecv > 0)
				{
					Index += bytesRecv;
				}
				else if(bytesRecv == 0)
				{
					DEBUG_P2P("Receive file finish.\n");
					break;
				}
				else
				{
					DEBUG_P2P("Connection Closed.\n");
					OnlineUpdateStatus = FW_DOWNLOAD_FAIL;
					OSFlagPost(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_UPDATE_SEC, OS_FLAG_SET, &err);
					break;
				}
			}

			// 20160929 Sean Modify Parsing method.
			pCh = strstr(BufAddr,"HTTP");
			if(pCh[9] == '3') // 3xx redirect
			{
				DEBUG_P2P("HTTP 302 found, Search data.\n");
				pCh = strstr(BufAddr,"\r\n\r\n") + 4;
				pCh = strstr(pCh,"\r\n\r\n") + 4;
			}
			else if(pCh[9] == '4') // 4xx Error
			{
				DEBUG_P2P("HTTP 4xx found, Download Error.\n");
				return -1;
			}
			else
			{
				DEBUG_P2P("Normal Download.\n");
				pCh = strstr(BufAddr,"\r\n\r\n") + 4;
			}

			Index = Index - (pCh - BufAddr);
			//DEBUG_P2P("RECV LEN: %d\n",idx);
			if(strcmp(pPath, "MD5SUM"))
			{
				OSTimeDly(1);
				MD5Init(&ctx);
				MD5Update(&ctx, (unsigned char*)pCh, Index);
				MD5Final(digest,&ctx);
				for (i = 0; i < 16; i++)
				{
					sprintf(buf3,"%02x",digest[i]);
					buf2[2*i]=buf3[0];
					buf2[2*i+1]=buf3[1];
				}
				buf2[32]='\0';
				DEBUG_P2P("FW MD5:%s\n",buf2);

				if(!strncmp(FWMD5,buf2,32))
				{
					OnlineUpdateStatus = FW_DOWNLOAD_FINISH;
					memcpy(BufAddr, pCh, Index);
				}
				else
				{
					DEBUG_P2P("MD5 check error!!\n");
					if(TryBackupServer == 0)
					{
						DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
						TryBackupServer = 1;
						close(skt);
						goto Retry;
					}
					OnlineUpdateStatus = FW_DOWNLOAD_FAIL;
					OSFlagPost(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_UPDATE_SEC, OS_FLAG_SET, &err);
				}
			}
			else
			{
				strcpy(FWMD5, pCh);
				DEBUG_P2P("MD5SUM:%s\n",FWMD5);
			}
		}
		else
		{
			DEBUG_P2P("Connect fail!\n");
			if(TryBackupServer == 0)
			{
				DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
				TryBackupServer = 1;
				close(skt);
				goto Retry;
			}
			OnlineUpdateStatus = FW_DOWNLOAD_FAIL;
			OSFlagPost(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_UPDATE_SEC, OS_FLAG_SET, &err);
			close(skt);
			return -1;
		}
		close(skt);
		return 0;
	}
	else
	{
		DEBUG_P2P("Socket create error=%d\n",skt);
		if(TryBackupServer == 0)
		{
			DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
			TryBackupServer = 1;
			goto Retry;
		}
		OnlineUpdateStatus = FW_DOWNLOAD_FAIL;
		OSFlagPost(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_UPDATE_SEC, OS_FLAG_SET, &err);
		return -1;
	}
}

int netGetVersionFileInfo(u8 *pSrcBuf, u32 LenOfBuf, u32 *ReadSize)
{
	char urlfile[100], req_fw_version[1024], hostname_IP[50]="", hostname[50];
    int skt, bytesRecv, result, retry, on=1;
    u32 idx, TryBackupServer = 0;
    char *pCh;

	// Reset target buffer
	memset(pSrcBuf, 0, LenOfBuf);
	*ReadSize = 0;

Retry:
	if(renewIP == 1)
	{
		DEBUG_P2P("Renew IP, leave check_fw.\n");
		goto End;
	}

	if(TryBackupServer == 0)
	{
		strcpy(hostname,FW_SERVER);

	    if(DN2IP(hostname, hostname_IP) == 0)
	    {
	        DEBUG_P2P("Get FW_SERVER, IP = %s\n", hostname_IP);
	    }
	    else
	    {
	        DEBUG_P2P("Parse FW_SERVER fail...\n");
	        if(TryBackupServer == 0)
			{
				DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
				TryBackupServer = 1;
				goto Retry;
			}
	        goto End;
	    }
	    memset(urlfile, 0, 100);
	    sprintf(urlfile, "%sVersion.ini", "/TMPS/");
	    DEBUG_P2P("Get %s\n", urlfile);
	    gFWSrvAddr.sin_addr.s_addr = inet_addr("192.168.210.64");
	    gFWSrvAddr.sin_port = htons(PORT_FW);
	    gFWSrvAddr.sin_family = AF_INET;
	}
	else
	{
		memset(urlfile, 0, 100);
	    sprintf(urlfile, "%sVersion.ini", "/TMPS/");
	    DEBUG_P2P("Get %s\n", urlfile);
	    gFWSrvAddr.sin_addr.s_addr = inet_addr("192.168.210.64");
	    gFWSrvAddr.sin_port = htons(PORT_FW);
	    gFWSrvAddr.sin_family = AF_INET;
	}

	if((skt = (int)socket(AF_INET, SOCK_STREAM, 0)) >= 0)
    {
        result = -1;
        retry = 0;
        setsockopt(skt, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on));
        while(result < 0)
        {
            result = connect(skt, (struct sockaddr *)&gFWSrvAddr, sizeof(struct sockaddr_in));
            retry++;
            if(result < 0)
            {
                close(skt);
                (skt = (int)socket(AF_INET, SOCK_STREAM, 0));
            }
            if(retry > 10)
                break;
        }
        if(result == 0)
        {
            memset(req_fw_version, 0,1024);
            sprintf(req_fw_version, "GET %s HTTP/1.1\r\n"
                    "Host: %s\r\n"
                    "Connection: keep-alive\r\n"
                    "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML,like Gecko) Chrome/19.0.1084.52 Safari/536.5\r\n"
                    "Accept: text/html, application/xhtm l+xml,applicatio n/xml;q=0.9,*/*; q=0.8\r\n"
                    "Accept-Encoding: gzip,deflate,sdch\r\n"
                    "Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\r\n"
                    "Accept-Charset: Big5,utf-8;q=0.7,*;q=0.3\r\n"
                    "Cache-Control: no-cache\r\n"
                    "\r\n",urlfile,inet_ntoa(gFWSrvAddr.sin_addr));
            send(skt, req_fw_version, strlen(req_fw_version), 0);
            idx = 0;
            memset(req_fw_version, 0, 1024);
            while(1)
            {
                if(net_link_status == NET_LINK_OFF)
                {
                    DEBUG_P2P("NET_LINK_OFF.\n");
                    break;
                }
                bytesRecv = recv(skt, req_fw_version + idx, 1024, 0 );
                if(bytesRecv < 0)
                {
                    DEBUG_P2P("Connection Closed.\n");
                    break;
                }
                else if(bytesRecv == 0)
                {
                    DEBUG_P2P("Receive file finish.\n");
                    break;
                }
                else
                {
                    idx += bytesRecv;
                }
            }
            close(skt);

            if(idx > LenOfBuf)
            {
            	DEBUG_P2P("Receive buffer overflow.\n");
            	goto End;
            }

            pCh = strstr(req_fw_version, "[");
            if(pCh == NULL)
            	return 0;

            *ReadSize = (pCh - req_fw_version);
            memcpy(pSrcBuf, pCh, idx - *ReadSize);
            return 1;
        }
        else
        {
        	DEBUG_P2P("Connect fail!\n");
        	if(TryBackupServer == 0)
        	{
        		TryBackupServer = 1;
        		close(skt);
        		goto Retry;
        	}
        }
        close(skt);
    }
    else
    {
        DEBUG_P2P("Socket create error=%d\n",skt);
        if(TryBackupServer == 0)
    	{
    		TryBackupServer = 1;
    		goto Retry;
    	}
    }

End:
	return 0;
}
#endif

static void check_fw(char *version)
{
    char urlfile[100], req_fw_version[1024], hostname_IP[50]="", hostname[50];
    int skt, bytesRecv, result, retry, err, on=1, i=0;
    s32 idx;
    char *ver;
    u8 ver_len, fw_fail=0;

Retry:

	if(renewIP == 1)
	{
		DEBUG_P2P("Renew IP, leave check_fw.\n");
		goto End;
	}

	if(!fw_fail)
	{
	    strcpy(hostname,FW_SERVER);
	    err=DN2IP(hostname,hostname_IP);

	    if(err==0)
	        DEBUG_P2P("Get FW_SERVER,IP = %s\n",hostname_IP);
	    else
	    {
	        DEBUG_P2P("Parse FW_SERVER fail...\n");
	        if(!fw_fail)
			{
				DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
				fw_fail = 1;
				goto Retry;
			}
	        ver=0;
	        return;
	    }
	    memset(urlfile, 0, 100);
	    sprintf(urlfile, "%sVersion.ini",FW_PATH);
	    DEBUG_P2P("Get %s\n",urlfile);
	    //uiSetRfDisplayMode(4);// 4="UI_MENU_RF_ENTER_SETUP" Enter Menu mode to alloc 8MB memory for f/w upgrade.
	    //gFWSrvAddr.sin_addr.s_addr=inet_addr("119.81.84.106");
	    gFWSrvAddr.sin_addr.s_addr=inet_addr(hostname_IP);
	    gFWSrvAddr.sin_port = htons(PORT_FW);
	    gFWSrvAddr.sin_family = AF_INET;
	}
	else //China Server
	{
		/*
	    strcpy(hostname,FW_SERVER2);
	    err=DN2IP(hostname,hostname_IP);

	    if(err==0)
	        DEBUG_P2P("Get FW_SERVER,IP = %s\n",hostname_IP);
	    else
	    {
	        DEBUG_P2P("Parse FW_SERVER fail...\n");
	        ver=0;
	        return;
	    }
	    */
	    memset(urlfile, 0, 100);
	    sprintf(urlfile, "%sVersion.ini",FW_PATH);
	    DEBUG_P2P("Get %s\n",urlfile);
	    //gFWSrvAddr.sin_addr.s_addr=inet_addr(hostname_IP);
	    gFWSrvAddr.sin_addr.s_addr=inet_addr("119.29.94.156");
	    gFWSrvAddr.sin_port = htons(PORT_FW);
	    gFWSrvAddr.sin_family = AF_INET;

	}
    if ((skt = (int)socket(AF_INET, SOCK_STREAM, 0)) >=0)
    {
        result=-1;
        retry=0;
        setsockopt(skt,SOL_SOCKET,SO_KEEPALIVE,&on,sizeof(on));
        while(result<0)
        {
            result=connect(skt, (struct sockaddr *)&gFWSrvAddr, sizeof(struct sockaddr_in));
            retry++;
            if(result<0)
            {
                close(skt);
                (skt = (int)socket(AF_INET, SOCK_STREAM, 0));
            }
            if(retry>10)
                break;
        }
        if(result==0)
        {
            memset(req_fw_version, 0,1024);
            sprintf(req_fw_version, "GET %s HTTP/1.1\r\n"
                    "Host: %s\r\n"
                    "Connection: keep-alive\r\n"
                    "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML,like Gecko) Chrome/19.0.1084.52 Safari/536.5\r\n"
                    "Accept: text/html, application/xhtm l+xml,applicatio n/xml;q=0.9,*/*; q=0.8\r\n"
                    "Accept-Encoding: gzip,deflate,sdch\r\n"
                    "Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\r\n"
                    "Accept-Charset: Big5,utf-8;q=0.7,*;q=0.3\r\n"
                    "Cache-Control: no-cache\r\n"
                    "\r\n",urlfile,inet_ntoa(gFWSrvAddr.sin_addr));
            send(skt, req_fw_version,strlen(req_fw_version), 0);
            idx=0;
            memset(req_fw_version, 0,1024);
            while(1)
            {
                if(net_link_status==NET_LINK_OFF)
                {
                    DEBUG_P2P( "NET_LINK_OFF.\n");
                    ver=0;
                    break;
                }
                bytesRecv = recv(skt, req_fw_version+idx, 1024, 0 );
                if ( bytesRecv  < 0  )
                {
                    DEBUG_P2P( "Connection Closed.\n");
                    ver=0;
                    break;
                }
                else if(bytesRecv==0)
                {
                    DEBUG_P2P( "Receive file finish.\n");
                    break;
                }
                else
                {
                    idx+=bytesRecv;
                }
            }
            ver=strstr(req_fw_version,"\r\n\r\n")+4;
            if(strncmp(ver,"[VERSION=",9))
            {
                ver=0;
                strcpy(version,ver);
            }
            else
            {
                ver=strchr(ver,'=')+1;
                //aher test 2015/09/04
                //ver_len=strlen(uiVersion);
                for(i=0; i<40; i++)
                {
                    if(ver[i]==']')
                    {
                        break;
                    }
                }
                if(i>=40)
                {
                    ver_len=strlen(uiVersion);
                }
                else
                {
                    if(ver[i-1]==' ')
                    {
                        i--;
                    }
                    ver_len=i;
                }
                ver[ver_len]='\0';
                strcpy(fw_version,ver);
                ver[ver_len]='0';
                ver=strstr(req_fw_version,"\r\n\r\n")+4;
                ver=strstr(ver,"\r\n\r\n")+4;
                if(strncmp(ver,"[DATE=",6))
                {
                    ver=0;
                    strcpy(version,ver);
                }
                else
                {
                    ver=strchr(ver,'=')+1;
                    ver_len=strlen(uiVersionTime);
                    ver[ver_len]='\0';
                    strcpy(version,ver);
                }
            }
            //strcpy(version,ver);
        }
        else
        {
            ver=0;
            strcpy(version,ver);
            DEBUG_P2P("Connect fail!\n");
			if(!fw_fail)
			{
				fw_fail = 1;
				close(skt);
				goto Retry;
			}
        }
        close(skt);
    }
    else
    {
        ver=0;
        strcpy(version,ver);
        DEBUG_P2P("Socket create error=%d\n",skt);
        if(!fw_fail)
    	{
    		fw_fail = 1;
    		goto Retry;
    	}
    }
    End:
}
/*Check firmware version on the http server.*/
#if 1
u8 Check_fw_ver_net(u8 connected)
{
    char urlfile[100];
    int skt;
    int bytesRecv;
    s32 idx;
    char ver[1024];
    char ver2[1024];
    u8 ver_len;
    int result;
    int retry;

    if(net_link_status==NET_LINK_OFF)
    {
        //ver=0;
        Reminder_FW_Upgrade=0;
        return Reminder_FW_Upgrade;
    }
    if(connected)
    {
        do
        {
			if(renewIP)
				break;
            check_fw(ver);
            check_fw(ver2);
        }
        while((strcmp(ver,ver2))&&(net_link_status==NET_LINK_ON));

        if(ver==0)
        {
            DEBUG_P2P("FW server connection fail!\n");
            Reminder_FW_Upgrade=0;
        }
        //else if((strcmp(uiVersion,ver))&&(strcmp(uiVersion,ver2)))
        else if((atoi(uiVersionTime)<atoi(ver))&&(atoi(uiVersionTime)<atoi(ver2)))
        {
            DEBUG_P2P("New firmware %s has released.\n",fw_version);
            //strcpy(fw_version,fw_ver);
            //DEBUG_P2P("fw_version=%s\n",fw_version);
            /*Show Upgrade f/w tips.*/
#if ((UI_VERSION == UI_VERSION_RDI) ||(UI_VERSION == UI_VERSION_RDI_2) ||\
			(UI_VERSION == UI_VERSION_RDI_3) || (UI_FW_UPGRADE_ICON_ENABLE == 1))
            uiOsdDrawRemindDownload(UI_OSD_DRAW);
#endif
            Reminder_FW_Upgrade=1;

        }
        else
        {
            DEBUG_P2P("Current firmware is latest.\n");
            Reminder_FW_Upgrade=0;
        }
        return Reminder_FW_Upgrade;
    }
    else
    {
        return Reminder_FW_Upgrade;
    }
}
#endif

/*Fetch file from HTTP server*/
static int GetFile(char *downfile)
{
    char urlfile[100], buf2[50], buf3[2], hostname_IP[50]="", hostname[50];
    int skt, bytesRecv, i, result, ret, on=1, a;
    u8 digest[16], err, retry, fw_fail=0;
    MD5_CTX ctx;
    u8* body;

    sysDeadLockMonitor_OFF(); /*Turn off watch dog.*/

Retry:

	if(!fw_fail)
	{
	    strcpy(hostname,FW_SERVER);
	    err=DN2IP(hostname,hostname_IP);
	    if(err==0)
	        DEBUG_P2P("Get FW_SERVER,IP = %s\n",hostname_IP);
	    else
	    {
	        DEBUG_P2P("Parse FW_SERVER fail...\n");
	        if(!fw_fail)
			{
				DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
				fw_fail = 1;
				goto Retry;
			}
	    }

	//u8* codeAddr2 = (u8*)((DRAM_MEMORY_END + 4) - 0x800000+4*1024*1024);
	    memset(urlfile, 0, 100);
	    sprintf(urlfile, "%s%s/%s",FW_PATH,fw_version,downfile);

	    DEBUG_P2P("Get %s\n",urlfile);
	    OnlineUpdateStatus=FW_DOWNLOADING;
#if 0 /*Enter Menu screen.*/
#if (RFIU_SUPPORT)
	    uiSetRfDisplayMode(4);// 4="UI_MENU_RF_ENTER_SETUP" Enter Menu mode to alloc 8MB memory for f/w upgrade.
#endif
#endif
	    gFWSrvAddr.sin_addr.s_addr=inet_addr(hostname_IP);
	    gFWSrvAddr.sin_port = htons(PORT_FW);
	    gFWSrvAddr.sin_family = AF_INET;
	}
	else //China Server
	{
		/*
		strcpy(hostname,FW_SERVER2);
		err=DN2IP(hostname,hostname_IP);
		if(err==0)
			DEBUG_P2P("Get FW_SERVER,IP = %s\n",hostname_IP);
		else
			DEBUG_P2P("Parse FW_SERVER fail...\n");
		*/
		memset(urlfile, 0, 100);
		sprintf(urlfile, "%s%s/%s",FW_PATH,fw_version,downfile);

		DEBUG_P2P("Get %s\n",urlfile);
		OnlineUpdateStatus=FW_DOWNLOADING;
#if 0 /*Enter Menu screen.*/
#if (RFIU_SUPPORT)
		uiSetRfDisplayMode(4);// 4="UI_MENU_RF_ENTER_SETUP" Enter Menu mode to alloc 8MB memory for f/w upgrade.
#endif
#endif
		//gFWSrvAddr.sin_addr.s_addr=inet_addr(hostname_IP);
		gFWSrvAddr.sin_addr.s_addr=inet_addr("119.29.94.156");
		gFWSrvAddr.sin_port = htons(PORT_FW);
		gFWSrvAddr.sin_family = AF_INET;
	}
    if ((skt = (int)socket(AF_INET, SOCK_STREAM, 0)) >=0)
    {
        result=-1;
        retry=0;
        ret=setsockopt(skt,SOL_SOCKET,SO_KEEPALIVE,&on,sizeof(on));/*Check the TCP connection whether alive.*/

        while(result<0)
        {
            result=connect(skt, (struct sockaddr *)&gFWSrvAddr, sizeof(struct sockaddr_in));
            retry++;
            if(result<0)
            {

                close(skt);
                (skt = (int)socket(AF_INET, SOCK_STREAM, 0));
            }
            if(retry>10)
            {
            	if(!fw_fail)
            	{
					DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
            		fw_fail = 1;
            		close(skt);
            		goto Retry;
            	}
                OnlineUpdateStatus=FW_DOWNLOAD_FAIL;
                break;
            }
        }
        //if (connect(skt, (struct sockaddr *)&gFWSrvAddr, sizeof(struct sockaddr_in)) == 0)
        if(result==0)
        {

            memset(codeAddr, 0, 1024*1024*8);
            sprintf(codeAddr, "GET %s HTTP/1.1\r\n"
                    "Host: %s\r\n"
                    "Connection: keep-alive\r\n"
                    "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML,like Gecko) Chrome/19.0.1084.52 Safari/536.5\r\n"
                    "Accept: text/html, application/xhtm l+xml,applicatio n/xml;q=0.9,*/*; q=0.8\r\n"
                    "Accept-Encoding: gzip,deflate,sdch\r\n"
                    "Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\r\n"
                    "Accept-Charset: Big5,utf-8;q=0.7,*;q=0.3\r\n"
                    "Cache-Control: no-cache\r\n"
                    "\r\n",urlfile,inet_ntoa(gFWSrvAddr.sin_addr));
            send(skt, codeAddr,strlen(codeAddr), 0);
            idx=0;
            i=0;
            memset(codeAddr, 0, 1024*1024*8);

            while(1)
            {
                bytesRecv = recv(skt, codeAddr+idx, 1024*1024*8, 0 );
                DEBUG_P2P("#");
                if ( bytesRecv < 0 )
                {
                    DEBUG_P2P( "Connection Closed.\n");
                    OnlineUpdateStatus=FW_DOWNLOAD_FAIL;
                    OSFlagPost(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_UPDATE_SEC, OS_FLAG_SET, &err);

                    break;
                }
                else if(bytesRecv==0)
                {
                    DEBUG_P2P( "Receive file finish.\n");
                    break;
                }
                else
                {
                    idx+=bytesRecv;
                }
                /*Avoid dead lock.*/
#if 0
                if(i==1000)
                {
                    OSTimeDly(1);
                    i=0;
                }
                i++;
#endif
            }
			   //printf("req_fw_version_RESP=%s\n",req_fw_version);

			   /*Test Downlad.bin File
							if ((pFile = dcfOpen("\\Download.bin", "w")) == NULL)
							{
							  DEBUG_DCF("!!!Error: create Download error!!!\n");

							}
							printf(">\"<\n");
							dcfWrite(pFile, codeAddr, idx, &writesize);

							dcfClose(pFile, &tmp);
			   */

			// 20160929 Sean Modify Parsing method.
			   body=strstr(codeAddr,"HTTP");
			   if(body[9] == '3') // 3xx redirect
			   {
				   DEBUG_P2P("HTTP 302 found, Search data.\n");
				   body=strstr(codeAddr,"\r\n\r\n")+4;
				   body=strstr(body,"\r\n\r\n")+4;
			   }
			   else if(body[9] == '4') // 4xx Error
			   {
				   DEBUG_P2P("HTTP 4xx found, Download Error.\n");
				   return -1;
			   }
			   else
			   {
				   DEBUG_P2P("Normal Download.\n");
				   body=strstr(codeAddr,"\r\n\r\n")+4;
			   }


			   //if(idx > 1024) // Sean 20160725: Use for URL redirect solution.
			   //{
			   //  for(a=0;a<16;a++)
			   //  {
			   //	   if(body[a] != 0)
			   //	   {
			   //		   DEBUG_P2P("NEXT SEARCH!!\n");
			   //		   body=strstr(body,"\r\n\r\n")+4;
			   //		   break;
			   //	   }
			   //  }
			   //}
            //DEBUG_P2P("addr1=%d,addr2=%d,diff=%d\n",codeAddr,body,body-codeAddr);
            //DEBUG_P2P("idx=%d,body=%ld,codeAddr=%ld,diff=%d\n",idx,body,codeAddr,body-codeAddr);
            idx=idx-(body-codeAddr);
            //DEBUG_P2P("RECV LEN: %d\n",idx);
            if(strcmp(downfile,"MD5SUM"))
            {
                //sysDeadLockMonitor_OFF(); /*Turn off watch dog.*/
                OSTimeDly(1);
                MD5Init(&ctx);
                MD5Update(&ctx, (unsigned char*)body,idx);
                MD5Final(digest,&ctx);
                for (i = 0; i < 16; i++)
                {
                    sprintf(buf3,"%02x",digest[i]);
                    buf2[2*i]=buf3[0];
                    buf2[2*i+1]=buf3[1];
                }
                buf2[32]='\0';
                DEBUG_P2P("FW MD5:%s\n",buf2);

                if(!strncmp(FWMD5,buf2,32))
                {
                    OnlineUpdateStatus=FW_DOWNLOAD_FINISH;
                    memcpy(codeAddr,body,idx);
                    ispUpdateAllload_Net(idx);
                }
                else
                {
                    DEBUG_P2P("MD5 check error!!\n");
                    if(!fw_fail)
	            	{
						DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
	            		fw_fail = 1;
	            		close(skt);
	            		goto Retry;
	            	}
                    OnlineUpdateStatus=FW_DOWNLOAD_FAIL;
                    OSFlagPost(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_UPDATE_SEC, OS_FLAG_SET, &err);
                }
                //sysForceWDTtoReboot();
            }
            else
            {
                strcpy(FWMD5,body);
            }
        }
        else
        {
            DEBUG_P2P("Connect fail!\n");
            if(!fw_fail)
        	{
				DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
        		fw_fail = 1;
        		close(skt);
        		goto Retry;
        	}
            OnlineUpdateStatus=FW_DOWNLOAD_FAIL;
            OSFlagPost(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_UPDATE_SEC, OS_FLAG_SET, &err);
            close(skt);
            return -1;
        }
        close(skt);
        return 0;
    }
    else
    {
        DEBUG_P2P("Socket create error=%d\n",skt);
        if(!fw_fail)
    	{
			DEBUG_P2P("\x1B[96mRetry Backup Server.\x1B[0m\n");
    		fw_fail = 1;
    		goto Retry;
    	}
        OnlineUpdateStatus=FW_DOWNLOAD_FAIL;
        OSFlagPost(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_UPDATE_SEC, OS_FLAG_SET, &err);
        return -1;
    }
}

/*Return the progress of f/w downloading*/
u8 GetFWDownProgress(s32* fw_length)
{
    *fw_length=idx;
    return OnlineUpdateStatus;
}

int AuthCallBackFn(char *viewAcc,char *viewPwd)

{
    char PW[32];
    strcpy(PW,viewPwd);
    //DEBUG_P2P("APP_PW[%s]\n",PW);

    if(strcmp(viewAcc, "admin") == 0 && strcmp(viewPwd,gP2PPassword) == 0)
        return 1;
    return 0;
}

void UpdateHeader(int ch,int UseMpeg_Q)
{
    int Width,Height;
    if(ch < 4)
    {
        if(P2P_AV_Source[ch] == Local_record)
        {
            if(ch == 0)
            {
                Width  = VideoClipOption[LocalChannelSource].asfVopWidth;
                Height = VideoClipOption[LocalChannelSource].asfVopHeight;
            }
            else
            {
                Width  = VideoClipOption[ch + 1].asfVopWidth;
                Height = VideoClipOption[ch + 1].asfVopHeight;
            }
        }
        else
        {
            Width  = gRfiuUnitCntl[ch].TX_PicWidth;
            Height = gRfiuUnitCntl[ch].TX_PicHeight;
        }
    }
    else//Local playck
    {
        Width = gPlaybackWidth;
        Height= gPlaybackHeight;
        //DEBUG_P2P("Play File RES= %d x %d\n",Width,Height);
    }
    MPEG4_config[0x17] &= 0xF0;
    MPEG4_config[0x18] &= 0x00;
    MPEG4_config[0x19] &= 0x7F;
    MPEG4_config[0x19] &= 0xC0;
    MPEG4_config[0x1A] &= 0x01;

    MPEG4_config[0x17] |= (unsigned char)(Width >> 9);
    MPEG4_config[0x18] |= (unsigned char)(Width >> 1);
    MPEG4_config[0x19] |= (unsigned char)(Width << 7);
    MPEG4_config[0x19] |= (unsigned char)(Height >> 7);
    MPEG4_config[0x1A] |= (unsigned char)(Height << 1);

    if(UseMpeg_Q)
    {
        MPEG4_config[0x1b]=0x49;
        MPEG4_config[0x1c]=0x0f;
    }
    else
    {
        MPEG4_config[0x1b]=0x44;
        MPEG4_config[0x1c]=0x3f;
    }


}
void UpdateH264Header(int ch)
{
//    DEBUG_P2P("# %d %d\n",gRfiuUnitCntl[ch].TX_PicWidth,gRfiuUnitCntl[ch].TX_PicHeight);
    int Width,Height,quality;
    if(ch > 4)// Playback.
    {
        Width = gPlaybackWidth;
        Height = gPlaybackHeight;
        quality = 1;
    }
    else
    {
        Width = gRfiuUnitCntl[ch].TX_PicWidth;
        Height = gRfiuUnitCntl[ch].TX_PicHeight;
        quality = videoquality;
    }
#if( (SW_APPLICATION_OPTION == MR9300_RFDVR_RX1RX2) || (SW_APPLICATION_OPTION == MR9300_NETBOX_RX1RX2) )

    if((quality == 1))
    {
        if((Width == 640)&&(Height == 352))
        {
            H264_config[0x07] = 0x1E;
            H264_config[0x08] = 0xDA;
            H264_config[0x09] = 0x02;
            H264_config[0x0A] = 0x80;
            H264_config[0x0B] = 0xB6;
            H264_config[0x0C] = 0x40;
        }
        else if((Width == 1280)&&(Height == 720))
        {
            H264_config[0x07] = 0x1E;
            H264_config[0x08] = 0xDA;
            H264_config[0x09] = 0x01;
            H264_config[0x0A] = 0x40;
            H264_config[0x0B] = 0x16;
            H264_config[0x0C] = 0xE4;
        }
        else if((Width == 1920)&&(Height == 1072))
        {
            H264_config[0x07] = 0x28;
            H264_config[0x08] = 0xDA;
            H264_config[0x09] = 0x01;
            H264_config[0x0A] = 0xE0;
            H264_config[0x0B] = 0x08;
            H264_config[0x0C] = 0x79;
        }
        else if((Width == 1920)&&((Height == 1080)|| (Height == 1088)))
        {
            H264_config[0x07] = 0x28;
            H264_config[0x08] = 0xDA;
            H264_config[0x09] = 0x01;
            H264_config[0x0A] = 0xE0;
            H264_config[0x0B] = 0x08;
            H264_config[0x0C] = 0x9F;
            H264_config[0x0D] = 0x95;
        }
    }
    else
    {
        H264_config[0x07] = 0x1E;
        H264_config[0x08] = 0xDA;
        H264_config[0x09] = 0x02;
        H264_config[0x0A] = 0x80;
        H264_config[0x0B] = 0xB6;
        H264_config[0x0C] = 0x40;
    }
#else
    if((quality == 1) ||(quality == 2))
    {
        if((Width == 640)&&(Height == 352))
        {
            H264_config[0x07] = 0x1E;
            H264_config[0x08] = 0xDA;
            H264_config[0x09] = 0x02;
            H264_config[0x0A] = 0x80;
            H264_config[0x0B] = 0xB6;
            H264_config[0x0C] = 0x40;
        }
        else if((Width == 1280)&&(Height == 720))
        {
            H264_config[0x07] = 0x1E;
            H264_config[0x08] = 0xDA;
            H264_config[0x09] = 0x01;
            H264_config[0x0A] = 0x40;
            H264_config[0x0B] = 0x16;
            H264_config[0x0C] = 0xE4;
        }
        else if((Width == 1920)&&(Height == 1072))
        {
            H264_config[0x07] = 0x28;
            H264_config[0x08] = 0xDA;
            H264_config[0x09] = 0x01;
            H264_config[0x0A] = 0xE0;
            H264_config[0x0B] = 0x08;
            H264_config[0x0C] = 0x79;
        }
        else if((Width == 1920)&&((Height == 1080)|| (Height == 1088)))
        {
            H264_config[0x07] = 0x28;
            H264_config[0x08] = 0xDA;
            H264_config[0x09] = 0x01;
            H264_config[0x0A] = 0xE0;
            H264_config[0x0B] = 0x08;
            H264_config[0x0C] = 0x9F;
            H264_config[0x0D] = 0x95;
        }
    }
    else
    {
        H264_config[0x07] = 0x1E;
        H264_config[0x08] = 0xDA;
        H264_config[0x09] = 0x02;
        H264_config[0x0A] = 0x80;
        H264_config[0x0B] = 0xB6;
        H264_config[0x0C] = 0x40;
    }
#endif
}

void unregedit_client_from_video(int SID)
{
    gClientInfo[SID].bEnableVideo = 0;
}

void regedit_client_to_video(int SID)
{
    gClientInfo[SID].bEnableVideo = 1;
}

void regedit_client_to_audio(int SID)
{
    gClientInfo[SID].bEnableAudio = 1;
}

void unregedit_client_from_audio(int SID)
{
    gClientInfo[SID].bEnableAudio = 0;
}

void regedit_client_to_avsession(int SID, int avIndex)
{
    gClientInfo[SID].avChannel = avIndex;
}

void regedit_client_to_speaker(int SID, int avIndex)
{
    gClientInfo[SID].bEnableSpeaker = 1;
    gClientInfo[SID].speakerAvIndex = avIndex;
}

void unregedit_client_from_speaker(int SID)
{
    gClientInfo[SID].bEnableSpeaker = 0;
}

void unregedit_client_from_avsession(int SID)
{
    int i;

    for(i=0; i<MAX_AV_CH; i++)
    {
        DEBUG_P2P("avServStop called SID[%d] avIndex[%d]\n", SID, gClientInfo[SID].avIndex[i]);
        avServStop(gClientInfo[SID].avIndex[i]);
        gClientInfo[SID].avIndex[i] = -1;
    }
    if((gClientInfo[SID].playBackCh!=0)&&((search_dir_start.YMD>0)||(search_dir_start.HMS>0)))
    {
        DEBUG_P2P("avServStop called SID[%d] avChannel[%d]\n",SID,gClientInfo[SID].avChannel);
        avServStop(gClientInfo[SID].avChannel);
        search_dir_start.YMD=0;
        search_dir_start.HMS=0;
        search_dir_end.YMD=0;
        search_dir_end.HMS=0;
    }
    gClientInfo[SID].avChannel= -1;
    unregedit_client_from_video(SID);
    unregedit_client_from_audio(SID);
    //aher
    unregedit_client_from_speaker(SID);
}

void LoadP2PPassword(char *password)
{
    strcpy(gP2PPassword,password);
}



/*yAPP to 8200 by aher*/
void Kill_Task_Speaker(int SID)
{
    if(gClientInfo[SID].bEnableSpeaker)
    {
        unregedit_client_from_speaker(SID);
#if (REMOTE_TALK_BACK == 0)
        rfiu_AudioRetONOFF_APP(0,CurrentCH);
#endif
        gSpeakerSID=-1;
        OSTimeDly(4);
        avClientStop(SpeakerAvIndex);
        DEBUG_P2P("====Kill_Task_Speaker:%d====\n",CurrentCH);
        //OSTaskSuspend(SPEAKER_TASK_PRIORITY);
#if REMOTE_TALK_BACK
        iisPreviewI2OEnd();
#endif
        //OSTimeDly(3);
        OSTaskDel(SPEAKER_TASK_PRIORITY);
    }
}

#if REMOTE_TALK_BACK

/*
}yAPP to 8211 by Peter.
*/

u8  TalkBackBuffer[IIS_CHUNK_SIZE * 2];

void Task_Speaker(void *pdata)
{
    int             SID         = gSpeakerSID;
    int             ret         = 0;
    FRAMEINFO_t     frameInfo;
    unsigned int    pnFrameIdx;
    unsigned long   servType;
    AV_Client       *p          = &gClientInfo[SID];
    int             TotalSize   = 0;
    int             i           = 0;
    int             offset      = 0;

    pnFrameIdx      = 0;

    SpeakerAvIndex  = avClientStart(SID, NULL, NULL, 20, &servType, p->speakerCh); // password no need
    if(SpeakerAvIndex >= 0)
    {
        iisPreviewI2OBegin();
        while(1)
        {
            if (gClientInfo[SID].bEnableSpeaker < 1)
            {
                OSTimeDly(3);
                DEBUG_P2P("Closing Task.\n");
                continue;
            }
            gFlagSpeakerOK  = 1;

            if (avCheckAudioBuf(SpeakerAvIndex))
            {
                if(iisSounBufMngWriteIdx == (IIS_BUF_NUM - 1))
                    ret = avRecvAudioData(SpeakerAvIndex , TalkBackBuffer + TotalSize, IIS_CHUNK_SIZE, (char*)&frameInfo, 16, &pnFrameIdx);
                else
                    ret = avRecvAudioData(SpeakerAvIndex , iisSounBufMng[iisSounBufMngWriteIdx].buffer + TotalSize, IIS_CHUNK_SIZE, (char*)&frameInfo, 16, &pnFrameIdx);

                if (ret < 0)
                    DEBUG_P2P("Receiving audio fail. Ret=%d\n", ret);
                else
                {
                    TotalSize  += ret;
                    if(TotalSize >= IIS_CHUNK_SIZE)
                    {
                        TotalSize              -= IIS_CHUNK_SIZE;
                        if(iisSounBufMngWriteIdx == (IIS_BUF_NUM - 1))
                        {
                            memcpy(iisSounBufMng[iisSounBufMngWriteIdx].buffer + offset, TalkBackBuffer + offset, IIS_CHUNK_SIZE - offset);
                            memcpy(iisSounBufMng[0].buffer, TalkBackBuffer + IIS_CHUNK_SIZE, ret);
                        }
                        iisSounBufMngWriteIdx   = (iisSounBufMngWriteIdx + 1) % IIS_BUF_NUM;
                        //OSSemAccept(iisTrgSemEvt);
                        //OSSemPost(iisCmpSemEvt);
                        OSSemPost(iisPlaybackSemEvt);
                        OSSemPost(iisPlaybackSemEvt);
                        OSSemPost(iisPlaybackSemEvt);
                        OSSemPost(iisPlaybackSemEvt);
                        if(iisSounBufMngWriteIdx == (IIS_BUF_NUM - 1))
                            offset  = ret;
                    }
                }
            }
            else
            {
                OSTimeDly(1);
            }

        }
    }
}

#else

/*
}yAPP to 8200 by aher.
*/

void Task_Speaker(void *pdata)
{
    int SID = gSpeakerSID;
    int ret =0;
    FRAMEINFO_t frameInfo;
    unsigned int pnFrameIdx;
    unsigned long servType;
    AV_Client *p = &gClientInfo[SID];
    int TotalSize=0;
    int i=0;
    int CH;
    //==============================//
    pnFrameIdx=0;
    CH=(int)pdata;
    DEBUG_P2P("===Task_Speaker Create:%d===\n",CH);
    SpeakerAvIndex = avClientStart(SID, NULL, NULL, 20, &servType, p->speakerCh); // password no need
    DEBUG_P2P("SpeakerAvIndex=%d\n",SpeakerAvIndex);
    if(SpeakerAvIndex > 0)
    {
        while(1)
        {
            if (gClientInfo[SID].bEnableSpeaker<1)
            {
                OSTimeDly(3);
                DEBUG_P2P("Closing Speaker Task.\n");
                continue;
            }
            gFlagSpeakerOK = 1;
            if (avCheckAudioBuf(SpeakerAvIndex)>10)
            {
                for(i=0; i<5; i++)
                {
                    ret = avRecvAudioData(SpeakerAvIndex ,rfiuAudioRetDMANextBuf[0]+TotalSize, BUFF_FOR_AUDIO, (char*)&frameInfo, 16,&pnFrameIdx);
                    //memcpy(rfiuAudioRetDMANextBuf[0]+TotalSize,rfiuAudioZeroBuf,1024);
                    if (ret<0)
                        DEBUG_P2P("Receiving audio fail. Ret=%d\n",ret);
                    else
                    {
                        TotalSize+=ret;
                        if(TotalSize>=(1024*(rfiuAudioRetRec_idx+1)))
                        {
                            rfiuAudioRetRec_idx=(rfiuAudioRetRec_idx+1)%RFI_AUDIO_RET_BUF_NUM;
                            if(rfiuAudioRetRec_idx == 0)
                            {
                                TotalSize=0;
                            }
                        }
                        if((rfiuAudioRetRec_idx & 0x07)==0)
                        {
                            gRfiuUnitCntl[CH].TxPktMap[RFI_AUDIORETURN1_ADDR_OFFSET/RFI_GRP_INPKTUNIT + (rfiuAudioRetRec_idx>>3)].PktCount=64;
                            gRfiuUnitCntl[CH].TxPktMap[RFI_AUDIORETURN1_ADDR_OFFSET/RFI_GRP_INPKTUNIT + (rfiuAudioRetRec_idx>>3)].RetryCount=0;
                            gRfiuUnitCntl[CH].TxPktMap[RFI_AUDIORETURN1_ADDR_OFFSET/RFI_GRP_INPKTUNIT + (rfiuAudioRetRec_idx>>3)].WriteDiv=8;
                            gRfiuUnitCntl[CH].TxPktMap[RFI_AUDIORETURN1_ADDR_OFFSET/RFI_GRP_INPKTUNIT + (rfiuAudioRetRec_idx>>3)].ReadDiv =0;
                            gRfiuUnitCntl[CH].TxPktMap[RFI_AUDIORETURN1_ADDR_OFFSET/RFI_GRP_INPKTUNIT + (rfiuAudioRetRec_idx>>3)].PktMap0 =0xffffffff;
                            gRfiuUnitCntl[CH].TxPktMap[RFI_AUDIORETURN1_ADDR_OFFSET/RFI_GRP_INPKTUNIT + (rfiuAudioRetRec_idx>>3)].PktMap1 =0xffffffff;
                        }
                    }
                }
            }
            OSTimeDly(2);
        }
    }
    else
    {
        DEBUG_P2P("Task_Speaker avClientStart fail :%d\n ",SpeakerAvIndex);
        while(1)
        {
            OSTimeDly(3);
        }
    }

}

#endif

void Remoteplayback_busy(void)
{
    int SID,i;
    int ret;
    VIDEO_BUF_MNG *P2PVideoPlaybackBuf_busy;
    u32 P2PVideoPlaybackBufReadIdx_busy;
    u32 P2PVideoPlaybackPresentTime_busy;
    u32 P2PChannelPlaybackStart;
    SMsgAVIoctrlPlayRecordResp buf;
    SMsgAVIoctrlPlayRecordResp *q;

    SID=gPlaybackSID;
    gClientInfo[gPlaybackSID].avChannel=avServStart(SID, "admin", gP2PPassword, 10, SERVTYPE_STREAM_SERVER,gClientInfo[SID].playBackCh);
    if(gClientInfo[gPlaybackSID].avChannel < 0)
    {
        DEBUG_P2P("avindex-avServStart failed SID[%d] code[%d]!!!\n", SID,gClientInfo[gPlaybackSID].avChannel);
        //IOTC_Session_Close(SID);
    }
    DEBUG_P2P("gClientInfo[gPlaybackSID].avChannel=%d\n",gClientInfo[gPlaybackSID].avChannel);
    DEBUG_P2P("---> Remoteplayback_busy\n");

#if((UI_VERSION == UI_VERSION_RDI) || (UI_VERSION == UI_VERSION_RDI_2) || (UI_VERSION == UI_VERSION_RDI_3))
#if (((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 3))||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 5)) ||\
    (HW_BOARD_OPTION == MR9200_RX_RDI_M906) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 9))||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 12)))
    if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPEN)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_Japan_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_Japan_QVGA;
        }
    }
#elif(((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 6)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 8)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 10))||\
      ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 11)))
    if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_GERMAN)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_German_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_German_QVGA;
        }
    }
    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_SPANISH)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_Spanish_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_Spanish_QVGA;
        }
    }
#else
    if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_SPANISH)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_Spanish_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_Spanish_QVGA;
        }
    }
#endif
#if(((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 8)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 10)) ||\
    ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 11)))
    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_Italy)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_Italy_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_Italy_QVGA;
        }
    }
    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_DUTCH)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_Netherland_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_Netherland_QVGA;
        }
    }
#endif
    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_FRENCH)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_French_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_French_QVGA;
        }
    }
    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_ENGLISH)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;

        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_QVGA;
        }
    }

#elif(UI_VERSION == UI_VERSION_TRANWO)
    if (CurrLanguage == 1)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_Spanish_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_Spanish_QVGA;
        }
    }
#if(UI_OTHER_LANGUAGE ==1)
    else if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPANSE)
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_Japan_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_Japan_QVGA;
        }
    }
#endif
    else
    {
        P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
        P2PVideoPlaybackBufReadIdx_busy=0;
        for(i=0; i<1; i++)
        {
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_QVGA);
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
            P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_QVGA;
        }
    }

#else
    P2PVideoPlaybackBuf_busy = P2PBusyVideoBufMng;
    P2PVideoPlaybackBufReadIdx_busy=0;
    for(i=0; i<1; i++)
    {
        P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].flag=1;
        P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].time=46000;
        P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].size=sizeof(MPEG4_Playback_black_QVGA);
        P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].offset=0;
        P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy+i].buffer=MPEG4_Playback_black_QVGA;
    }
#endif

    gPlaybackWidth=320;
    gPlaybackHeight=240;
    for(i=0; i<20; i++)
    {
        //------ Streaming video payload------//
        if(gClientInfo[SID].bStopPlayBack == 1)
        {
            DEBUG_P2P("bStopPlayBack\n");
            break;
        }
        //DEBUG_P2P("video_value=%d\n",video_value);

        P2PVideoPlaybackPresentTime_busy = (P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy].time); //if use chunk time
        #if(VIDEO_CODEC_OPTION == H264_CODEC)
        UpdateH264Header(6); // n ch1~4.
        memcpy(p2pbusylocal_buffer, H264_config, 0x18);
        memcpy_hw(p2pbusylocal_buffer+0x18, P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy].buffer, P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy].size);
        SendVideoFrameData(SID, P2PVideoPlaybackPresentTime_busy, P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy].flag, 0x18+P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy].size, p2pbusylocal_buffer);
        #else
        UpdateHeader(6,USE_MPEG_QUANTIZATION);
        memcpy(exifPrimaryBitstream, MPEG4_config, 0x1d);
        memcpy_hw(exifPrimaryBitstream+0x1d, P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy].buffer, P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy].size);
        SendVideoFrameData(SID, P2PVideoPlaybackPresentTime_busy, P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy].flag, 0x1d+P2PVideoPlaybackBuf_busy[P2PVideoPlaybackBufReadIdx_busy].size, exifPrimaryBitstream);
        #endif
        //P2PVideoPlaybackBufReadIdx_busy++;
        OSTimeDly(1);
    }
    DEBUG_P2P("End of playback busy.\n");
    gClientInfo[SID].bStopPlayBack =1;
    OSTimeDly(1);
    avServStop(gClientInfo[SID].avChannel);
    OSTimeDly(1);

    gClientInfo[SID].playBackCh=0;
    /*
    q->command=AVIOCTRL_RECORD_PLAY_END;
    ret=avSendIOCtrl(gClientInfo[SID].avChannel, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp));

    //if(avSendIOCtrl(gClientInfo[gPlaybackSID].avChannel, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp)) == AV_ER_NoERROR)
    if(ret== AV_ER_NoERROR)
    {
        DEBUG_P2P("AVIOCTRL_RECORD_PLAY_END OK\n");
    }
    else
        DEBUG_P2P("AVIOCTRL_RECORD_PLAY_END FAIL\n");

    if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
            DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
    */

}
/*
Play file task.
*/
extern u8 p2p_30PS;
extern u8 Get_p2p_playback;
#if(VIDEO_CODEC_OPTION == H264_CODEC)
void Task_remote_file_playback(void *pdata)
{

    //int rec_avindex;
    int ret;
    int SID;
    u16 video_value =0;
    u16 video_value_max =0;
    u16 audio_value = 0;
    u16 audio_value_max = 0;

    u32 P2PVideoPlaybackBufReadIdx;
    u32 P2PVideoPlaybackPresentTime;
    u32 P2PAudioPlaybackBufReadIdx;
    u32 P2PAudioPlaybackPresentTime;
    u32 P2PChannelPlaybackStart;

    VIDEO_BUF_MNG *P2PVideoPlaybackBuf;
    IIS_BUF_MNG   *P2PAudioPlaybackBuf;
    int nResend;
    u32 tmp;
    SMsgAVIoctrlPlayRecordResp buf;
    SMsgAVIoctrlPlayRecordResp *q;

    q=&buf;
    SID=gPlaybackSID;
    CurrPlaybackSID=SID;
//DEBUG_P2P("gPlaybackSID=%d, gClientInfo[SID].playBackCh)=%d\n",SID,gClientInfo[SID].playBackCh);
    gClientInfo[CurrPlaybackSID].avChannel=avServStart(CurrPlaybackSID, "admin", gP2PPassword, 40, SERVTYPE_STREAM_SERVER,gClientInfo[CurrPlaybackSID].playBackCh);
    //gClientInfo[gPlaybackSID].avChannel = avServStart3(SID, AuthCallBackFn,10, SERVTYPE_STREAM_SERVER, gClientInfo[SID].playBackCh, &nResend);
    //avServSetResendSize(gClientInfo[gPlaybackSID].avChannel,64);
    if(gClientInfo[CurrPlaybackSID].avChannel < 0)
    {
        DEBUG_P2P("avindex-avServStart failed SID[%d] code[%d]!!!\n", SID,gClientInfo[CurrPlaybackSID].avChannel);
        //IOTC_Session_Close(SID);

		Fileplaying=0;
        Remote_play=0;
#if(UI_VERSION == UI_VERSION_MAYON)
		gCurPlaybackSID = -1;
#endif
		OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY);
//#if(HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) //Sean: 20171122 add.
		goto end;
//#endif
    }
    DEBUG_P2P("gClientInfo[CurrPlaybackSID:%d].avChannel=%d\n",CurrPlaybackSID, gClientInfo[CurrPlaybackSID].avChannel);
    Get_p2p_playback = 1;
    tmp=GetVideoDuration(dcfPlaybackCurFile->pDirEnt->d_name)/10;
    //InitsysbackLowEvt();
    Get_p2p_playback = 0;
    sysSetEvt(SYS_EVT_SET_P2P_PLAYBACK,0);
    P2PVideoPlaybackBufReadIdx = 0;
    P2PVideoPlaybackPresentTime = 0;
    P2PAudioPlaybackBufReadIdx = 0;
    P2PAudioPlaybackPresentTime = 0;
    P2PChannelPlaybackStart = 1;

    P2PVideoPlaybackBuf = P2PVideoBufMng;
    P2PAudioPlaybackBuf = P2PiisSounBufMng;

    P2PVideoPlaybackCmpSemEvt = OSSemCreate(0);
    P2PAudioPlaybackCmpSemEvt = OSSemCreate(0);

    gClientInfo[CurrPlaybackSID].VOLSend=0;
    //P2PEnableplaybackStreaming  += 1;

    while(P2P_playback_go != 1)
        OSTimeDly(1);
    while(1)
    {
        if(gClientInfo[CurrPlaybackSID].bStopPlayBack == 1)
        {
            DEBUG_P2P("bStopPlayBack\n");
            break;
        }
        if(gClientInfo[CurrPlaybackSID].bPausePlayBack)
        {
            OSTimeDly(1);
            continue;
        }
        /*
                if(gClientInfo[CurrPlaybackSID].playBackCh!=0)
                {
                    Handle_IOCTRL_Cmd(CurrPlaybackSID, gClientInfo[CurrPlaybackSID].avChannel, IOCtrlBuf);
                }
        */
        //------ Streaming video payload------//
        if((audio_value == 0) || (P2PAudioPlaybackPresentTime >= P2PVideoPlaybackPresentTime))
        {
            video_value = OSSemAccept(P2PVideoPlaybackCmpSemEvt);

            //DEBUG_P2P("video_value=%d\n",video_value);
            if (video_value > 0)
            {
                if(video_value_max < video_value)
                    video_value_max = video_value;
                P2PVideoPlaybackPresentTime = (P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].time); //if use chunk time
            }
            else
                OSTimeDly(2);

            if(video_value> 0)
            {
                if(P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag)
                {
                    UpdateH264Header(6); // n ch1~4.
                    memcpy(p2plocal_buffer, H264_config, 0x18);
                    memcpy_hw(p2plocal_buffer+0x18, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].buffer, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size);
                    SendVideoFrameData(SID, P2PVideoPlaybackPresentTime/1000, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag, 0x18+P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size, p2plocal_buffer);
                    //SendVideoFrameData(SID, P2PVideoPresentTime[0], P2PVideoBuf[0][P2PVideoBufReadIdx[0]].flag, 0x1d+P2PVideoBuf[0][P2PVideoBufReadIdx[0]].size, p2plocal_buffer);

                    //Always send the i-frame with VOL header.
                    gClientInfo[SID].VOLSend = 0;
                }
                else
                {
                    SendVideoFrameData(SID, P2PVideoPlaybackPresentTime/1000, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].buffer);
                }
                P2P_check=0;
                //aher test 20140316
                //DEBUG_P2P("TO=%lu,N=%lu\n",tmp,P2PVideoPlaybackPresentTime/1000);
                if(P2PVideoPlaybackPresentTime/1000>=tmp-200)
                {
                    //DEBUG_P2P("Send AVIOCTRL_RECORD_PLAY_END\n");
                    OSTimeDly(40);
                    q->command=AVIOCTRL_RECORD_PLAY_END;
                    ret=avSendIOCtrl(gClientInfo[SID].avChannel, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp));

                    //if(avSendIOCtrl(gClientInfo[gPlaybackSID].avChannel, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp)) == AV_ER_NoERROR)
                    if(ret== AV_ER_NoERROR)
                    {
                        DEBUG_P2P("AVIOCTRL_RECORD_PLAY_END OK\n");
                    }
                    else
                        DEBUG_P2P("AVIOCTRL_RECORD_PLAY_END FAIL\n");
                    if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
                        DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
                }
            }

            if (video_value > 0)
            {
                P2PVideoPlaybackBufReadIdx = (P2PVideoPlaybackBufReadIdx + 1) % (VIDEO_BUF_NUM-10);
            }
        }

    }
    OSTimeDly(2);
//#if(HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) //Sean: 20171122 add.
    end:
//#endif

}
#else
void Task_remote_file_playback(void *pdata)
{

	//int rec_avindex;
	int ret;
	int SID;
	u16 video_value =0;
	u16 video_value_max =0;
	u16 audio_value = 0;
	//u16 audio_value_max = 0;
	u8  err;
	u32 P2PVideoPlaybackBufReadIdx;
    u32 P2PVideoPlaybackPresentTime;
	//u32 P2PAudioPlaybackBufReadIdx;
	u32 P2PAudioPlaybackPresentTime;
	//u32 P2PChannelPlaybackStart;

	VIDEO_BUF_MNG *P2PVideoPlaybackBuf;
	//IIS_BUF_MNG   *P2PAudioPlaybackBuf;
	//int nResend;
    u32 tmp;
    u8 p2p_totaltime = 0;

    SMsgAVIoctrlPlayRecordResp buf;
    SMsgAVIoctrlPlayRecordResp *q;

	DEBUG_P2P("Create Task_remote_file_playback.\n");
    q=&buf;
	SID=gPlaybackSID;
    CurrPlaybackSID=SID;
//printf("gPlaybackSID=%d, gClientInfo[SID].playBackCh)=%d\n",SID,gClientInfo[SID].playBackCh);
	gClientInfo[CurrPlaybackSID].avChannel=avServStart(CurrPlaybackSID, "admin", gP2PPassword, 1, SERVTYPE_STREAM_SERVER,gClientInfo[CurrPlaybackSID].playBackCh);

	//gClientInfo[gPlaybackSID].avChannel = avServStart3(SID, AuthCallBackFn,10, SERVTYPE_STREAM_SERVER, gClientInfo[SID].playBackCh, &nResend);
	//avServSetResendSize(gClientInfo[gPlaybackSID].avChannel,64);
	if(gClientInfo[CurrPlaybackSID].avChannel < 0)
	{
		DEBUG_P2P("avindex-avServStart failed SID[%d] code[%d]!!!\n", SID,gClientInfo[CurrPlaybackSID].avChannel);
		//IOTC_Session_Close(SID);
		Fileplaying=0;
        Remote_play=0;
		OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY);
		#if(HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) //Sean: 20170608 add.
		goto end;
		#endif
	}
	DEBUG_P2P("gClientInfo[CurrPlaybackSID:%d].avChannel=%d\n",CurrPlaybackSID,gClientInfo[CurrPlaybackSID].avChannel);
    Get_p2p_playback = 1;
	tmp=GetVideoDuration(dcfPlaybackCurFile->pDirEnt->d_name)/10;
    //InitsysbackLowEvt();
    Get_p2p_playback = 0;
	sysSetEvt(SYS_EVT_SET_P2P_PLAYBACK,0);
	P2PVideoPlaybackBufReadIdx = 0;
    P2PVideoPlaybackPresentTime = 0;
	//P2PAudioPlaybackBufReadIdx = 0;
	P2PAudioPlaybackPresentTime = 0;
	//P2PChannelPlaybackStart = 1;

	P2PVideoPlaybackBuf = P2PVideoBufMng;
	//P2PAudioPlaybackBuf= P2PiisSounBufMng;

	P2PVideoPlaybackCmpSemEvt   = OSSemCreate(0);
	if(P2PVideoPlaybackCmpSemEvt == 0)
		printf("Create P2PVideoPlaybackCmpSemEvt fail.\n");
	else
	{
		printf("Create P2PVideoPlaybackCmpSemEvt ok.\n");
		OSSemSet(P2PVideoPlaybackCmpSemEvt, 0, &err);
		if(err!= OS_NO_ERR)
			printf("Set P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
	}
    P2PAudioPlaybackCmpSemEvt   = OSSemCreate(0);
	if(P2PAudioPlaybackCmpSemEvt == 0)
		printf("Create P2PAudioPlaybackCmpSemEvt fail.\n");
	else
	{
		printf("Create P2PAudioPlaybackCmpSemEvt ok.\n");
		OSSemSet(P2PAudioPlaybackCmpSemEvt, 0, &err);
		if(err!= OS_NO_ERR)
			printf("Set P2PAudioPlaybackCmpSemEvt fail = %d\n",err);

	}

	gClientInfo[CurrPlaybackSID].VOLSend=0;
	//P2PEnableplaybackStreaming  += 1;
	#if(HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) //Sean: 20170608 add.
    play_back_start = 1;
    #endif

	while(P2P_playback_go != 1)
		OSTimeDly(1);
	while(1)
	{
		if(gClientInfo[CurrPlaybackSID].bStopPlayBack == 1)
		{
			DEBUG_P2P("bStopPlayBack\n");
			break;
		}
		if(gClientInfo[CurrPlaybackSID].bPausePlayBack)
		{
			OSTimeDly(1);
			continue;
		}
/*
        if(gClientInfo[CurrPlaybackSID].playBackCh!=0)
        {
            Handle_IOCTRL_Cmd(CurrPlaybackSID, gClientInfo[CurrPlaybackSID].avChannel, IOCtrlBuf);
        }
*/
		//------ Streaming video payload------//
            if((audio_value == 0) || (P2PAudioPlaybackPresentTime >= P2PVideoPlaybackPresentTime))
    		{
    		    video_value = OSSemAccept(P2PVideoPlaybackCmpSemEvt);

				//printf("video_value=%d\n",video_value);
                if (video_value > 0)
                {
        		    if(video_value_max < video_value)
                        video_value_max = video_value;
                    if(( p2p_30PS == 1) &&( p2p_totaltime == 0))
                    {
                        p2p_totaltime = 1;
                        tmp=tmp*2;
                    }
                    P2PVideoPlaybackPresentTime = (P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].time); //if use chunk time
                }
				else
					OSTimeDly(2);

                if(video_value> 0)
                {
                   if(gClientInfo[SID].VOLSend==0 && P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag)
                   {
                    //UpdateHeader(ch,gRfiuUnitCntl[ch].TX_Status & RFIU_TX_STA_MPEG_Q);
					   UpdateHeader(6,USE_MPEG_QUANTIZATION);
                       memcpy(p2plocal_buffer, MPEG4_config, 0x1d);
                       memcpy_hw(p2plocal_buffer+0x1d, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].buffer, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size);
                       SendVideoFrameData(SID, P2PVideoPlaybackPresentTime/1000, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag, 0x1d+P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size, p2plocal_buffer);
						//SendVideoFrameData(SID, P2PVideoPresentTime[0], P2PVideoBuf[0][P2PVideoBufReadIdx[0]].flag, 0x1d+P2PVideoBuf[0][P2PVideoBufReadIdx[0]].size, p2plocal_buffer);

						//Always send the i-frame with VOL header.
                        gClientInfo[SID].VOLSend = 0;
                    }
                    else if(gClientInfo[SID].VOLSend==1)
                    {
                        SendVideoFrameData(SID, P2PVideoPlaybackPresentTime/1000, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].flag, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].size, P2PVideoPlaybackBuf[P2PVideoPlaybackBufReadIdx].buffer);
                    }
                    P2P_check=0;
                    //aher test 20140316
//printf("TO=%lu,N=%lu\n",tmp,P2PVideoPlaybackPresentTime/1000);
                    if(P2PVideoPlaybackPresentTime/1000>=tmp-200)
                    {
//printf("Send AVIOCTRL_RECORD_PLAY_END\n");
                        OSTimeDly(40);
                        q->command=AVIOCTRL_RECORD_PLAY_END;
                        ret=avSendIOCtrl(gClientInfo[SID].avChannel, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp));

                        //if(avSendIOCtrl(gClientInfo[gPlaybackSID].avChannel, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp)) == AV_ER_NoERROR)
                        if(ret== AV_ER_NoERROR)
					    {
						    DEBUG_P2P("AVIOCTRL_RECORD_PLAY_END OK\n");
					    }
                        else
                            DEBUG_P2P("AVIOCTRL_RECORD_PLAY_END FAIL\n");
                        //if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
                        //        DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
                        OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY);
                    }
                }

                if (video_value > 0)
                {
                    P2PVideoPlaybackBufReadIdx = (P2PVideoPlaybackBufReadIdx + 1) % (VIDEO_BUF_NUM-10);
                }
            }

	}
	OSTimeDly(2);
	#if(HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) //Sean: 20170608 add.
    end:
    #endif
}
#endif

/*
Return the recorded file list to APP or Search the matched file to play.
*/
int get_recorded_filelist(SMsgAVIoctrlListEventReq *p,int SID,int avIndex)
{
    unsigned int ioType;
    char IOCtrlBuf[MAX_BUF_SIZE];
    char *buf;
    int ret;

    int i=0;
    int get_play_file=0;

    SMsgAVIoctrlListEventResp*q=(SMsgAVIoctrlListEventResp*)p2pEventList;
#if (HW_BOARD_OPTION != A1018_FPGA_BOARD)
    /*Initalize SMsgAVIoctrlListEventResp*/

    u32	waitFlag;
    u8	err;

//Paul: 20180821 add func define for RDI use.
    #if((UI_VERSION == UI_VERSION_TRANWO) || (UNIC_PLAYBACK_LIST_SUPPORT == 1))
    if(gSearchFileListFlag != 0)
	{
		DEBUG_P2P("File List is Using... return.\n");
		return;
	}
	else
		gSearchFileListFlag = 1; // APP use.
	#endif

    q->total=0;
    q->index=0;
    q->endflag=0;
    q->count=0;
    if(sysGetStorageStatus(SYS_I_STORAGE_MAIN) == SYS_V_STORAGE_READY)
    {
        if(gbSearchEvent == 0)
        {
            UCT_to_Local_convert(p);

            search_dir_start.YMD=(((p->stStartTime.year-1980)& 0x7F) <<9) |((p->stStartTime.month & 0xF)<< 5) |((p->stStartTime.day) & 0x1F);
            search_dir_start.HMS=((p->stStartTime.hour& 0x1F )<<11) |((p->stStartTime.minute& 0x3F)<< 5) |((p->stStartTime.second/2) & 0x1F);
            search_dir_end.YMD=(((p->stEndTime.year-1980)& 0x7F) <<9) |((p->stEndTime.month & 0xF)<< 5) |((p->stEndTime.day) & 0x1F);
            search_dir_end.HMS=((p->stEndTime.hour& 0x1F )<<11) |((p->stEndTime.minute& 0x3F)<< 5) |((p->stEndTime.second/2) & 0x1F);
            DEBUG_P2P("Search recording file for camera:%d\n",p->channel);
            DEBUG_P2P("START DIR = %02d/%02d/%02d %02d:%02d:%02d\n",(search_dir_start.YMD >> 9)+1980,
                      (search_dir_start.YMD & 0x01E0)>>5,
                      (search_dir_start.YMD & 0x001F),
                      (search_dir_start.HMS>>11),
                      (search_dir_start.HMS & 0x07E0)>>5,
                      (search_dir_start.HMS& 0x001F)<<1);
            DEBUG_P2P("END DIR = %02d/%02d/%02d %02d:%02d:%02d\n",(search_dir_end.YMD >> 9)+1980,
                      (search_dir_end.YMD & 0x01E0)>>5,
                      (search_dir_end.YMD & 0x001F),
                      (search_dir_end.HMS>>11),
                      (search_dir_end.HMS & 0x07E0)>>5,
                      (search_dir_end.HMS& 0x001F)<<1);
        }
        else
        {
            UCT_to_Local_convert_playfile(&gRemote_playfile);
            search_dir_start.YMD=(((gRemote_playfile.stTimeDay.year-1980)& 0x7F) <<9) |((gRemote_playfile.stTimeDay.month & 0xF)<< 5) |((gRemote_playfile.stTimeDay.day) & 0x1F);
            search_dir_start.HMS=((gRemote_playfile.stTimeDay.hour& 0x1F )<<11) |((gRemote_playfile.stTimeDay.minute& 0x3F)<< 5) |((gRemote_playfile.stTimeDay.second/2) & 0x1F);
            search_dir_end.YMD=(((gRemote_playfile.stTimeDay.year-1980)& 0x7F) <<9) |((gRemote_playfile.stTimeDay.month & 0xF)<< 5) |((gRemote_playfile.stTimeDay.day) & 0x1F);
            search_dir_end.HMS=((gRemote_playfile.stTimeDay.hour& 0x1F )<<11) |((gRemote_playfile.stTimeDay.minute& 0x3F)<< 5) |((gRemote_playfile.stTimeDay.second/2) & 0x1F);
            DEBUG_P2P("Search FILE=%02d/%02d/%02d %02d:%02d:%02d,CH=%d\n\n",(search_dir_start.YMD >> 9)+1980,
                      (search_dir_start.YMD & 0x01E0)>>5,
                      (search_dir_start.YMD & 0x001F),
                      (search_dir_start.HMS>>11),
                      (search_dir_start.HMS & 0x07E0)>>5,
                      (search_dir_start.HMS & 0x001F)<<1,
                      Remoteplayback_CH);
        }
        dcfPlaybackCurDir = dcfGetVideoDirListHead();
        do
        {
            if(((dcfPlaybackCurDir->pDirEnt->fsFileCreateDate_YMD>=search_dir_start.YMD)&&(dcfPlaybackCurDir->pDirEnt->fsFileCreateDate_YMD<=search_dir_end.YMD))
                    &&(get_play_file==0))
            {
                if(dcfScanFileOnPlaybackDir()==0)
                {
                    DEBUG_P2P("Enter folder fail!\n");
                    dcfPlaybackCurDir=dcfPlaybackCurDir->next;
                }
                else
                {
                    dcfPlaybackCurFile=dcfGetPlaybackFileListHead();
                    do //Check the file time.
                    {
                        if(((((search_dir_start.YMD==search_dir_end.YMD)&&(search_dir_start.YMD==dcfPlaybackCurDir->pDirEnt->fsFileCreateDate_YMD))&&((search_dir_start.HMS<=dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS)&&(search_dir_end.HMS>=dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS)))
                                ||(((dcfPlaybackCurDir->pDirEnt->fsFileCreateDate_YMD==search_dir_start.YMD)&&(dcfPlaybackCurDir->pDirEnt->fsFileCreateDate_YMD<search_dir_end.YMD))&&(search_dir_start.HMS<=dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS))
                                ||(((dcfPlaybackCurDir->pDirEnt->fsFileCreateDate_YMD>search_dir_start.YMD)&&(dcfPlaybackCurDir->pDirEnt->fsFileCreateDate_YMD==search_dir_end.YMD))&&(search_dir_end.HMS>=dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS))
                                ||((dcfPlaybackCurDir->pDirEnt->fsFileCreateDate_YMD>search_dir_start.YMD)&&(dcfPlaybackCurDir->pDirEnt->fsFileCreateDate_YMD<search_dir_end.YMD))))
                        {

                            //DEBUG_P2P("current FILE : %s\n,IDX= %d,p->channel=%d\n",dcfPlaybackCurFile->pDirEnt->d_name,atoi(&(dcfPlaybackCurFile->pDirEnt->d_name[7])),p->channel);
                            //if((gbSearchEvent == 0)&&)
                            if((gbSearchEvent == 0))
                            {
                                if(((p->channel==(atoi(&(dcfPlaybackCurFile->pDirEnt->d_name[7]))-1))||(p->channel==255))&&(q->total<160))/*Only send 160 event once.*/
                                {
                                    //DEBUG_P2P("Match FILE : %s,Total=%d\n",dcfPlaybackCurFile->pDirEnt->d_name,q->total);
                                    q->channel=atoi(&(dcfPlaybackCurFile->pDirEnt->d_name[7]));
                                    //DEBUG_P2P("CH IDX=%d\n",q->channel);
                                    q->stEvent[q->count].CameraCH=q->channel;
                                    q->stEvent[q->count].stTime.year = (dcfPlaybackCurFile->pDirEnt->fsFileCreateDate_YMD >> 9)+1980;
                                    q->stEvent[q->count].stTime.month =(dcfPlaybackCurFile->pDirEnt->fsFileCreateDate_YMD & 0x01E0)>>5;
                                    q->stEvent[q->count].stTime.day = (dcfPlaybackCurFile->pDirEnt->fsFileCreateDate_YMD & 0x001F);
                                    //q->stEvent[nCnt].stTime.wday = 5;
                                    q->stEvent[q->count].stTime.hour = (dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS>>11);
                                    q->stEvent[q->count].stTime.minute =(dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS & 0x07E0)>>5;
                                    q->stEvent[q->count].stTime.second = (dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS & 0x001F)<<1;
                                    q->stEvent[q->count].event = AVIOCTRL_EVENT_ALL;
                                    //q->stEvent[nCnt].status = 0;

                                    Local_to_UCT_convert(&(q->stEvent[q->count].stTime));
                                    q->total++;
                                    q->count++;
                                }
                                if(q->count>=80)
                                {
                                    /*
                                    buf=IOCtrlBuf;
                                    ret = avRecvIOCtrl(avIndex, &ioType, (char *)buf, MAX_BUF_SIZE, 0);
                                    if(ioType==IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL)
                                    {
                                    	SMsgAVIoctrlPlayRecord *pp = (SMsgAVIoctrlPlayRecord *)buf;
                                    	SMsgAVIoctrlPlayRecordResp *qq=(SMsgAVIoctrlPlayRecordResp *)buf;
                                    if(pp->command==AVIOCTRL_RECORD_PLAY_START)
                                    {
                                    	DEBUG_P2P("IPCAM_RECORD_PLAYCONTROL-%d\n",pp->command);
                                    	//switch (pp->command)
                                    	//{
                                    		//case AVIOCTRL_RECORD_PLAY_START :
                                    		//{
                                    			DEBUG_P2P("AVIOCTRL_RECORD_PLAY_START\n");
                                    			gbSearchEvent=1;
                                    			regedit_client_to_video(SID);
                                    			gClientInfo[SID].bPausePlayBack = 0;
                                    			gClientInfo[SID].bStopPlayBack = 0;
                                    			gClientInfo[SID].playBackCh = IOTC_Session_Get_Free_Channel(SID);
                                    			qq->command=pp->command;
                                    			qq->result=gClientInfo[SID].playBackCh;
                                    			gPlaybackSID=SID;
                                    			gRemote_playfile=*pp;
                                    			get_recorded_filelist((SMsgAVIoctrlListEventReq *)pp,SID,avIndex);
                                    			DEBUG_P2P("PLAY FILE: %d/%d/%d %d:%d:%d\n",gRemote_playfile.stTimeDay.year,gRemote_playfile.stTimeDay.month,gRemote_playfile.stTimeDay.day,gRemote_playfile.stTimeDay.hour,gRemote_playfile.stTimeDay.minute,gRemote_playfile.stTimeDay.second);
                                    	Remoteplayback_CH=pp->channel;
                                    			if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)qq, sizeof(SMsgAVIoctrlPlayRecordResp)) == AV_ER_NoERROR)
                                    			{
                                    				DEBUG_P2P("IPCAM_RECORD_PLAYCONTROL_RESP OK \n\n");
                                    			}
                                    			P2PEnableplaybackStreaming++;
                                    DEBUG_P2P("P2PEnableplaybackStreaming222=%d\n",P2PEnableplaybackStreaming);

                                    			P2PPlaybackVideoStop=0;
                                                #if 1
                                                    DEBUG_P2P("Fileplaying= %d,Remote_play= %d  \n",Fileplaying,Remote_play);
                                                if(Fileplaying)
                                                    Remoteplayback_busy();
                                                else
                                                {
                                                    Fileplaying=1;
                                                    Remote_play=1;
#if(UI_VERSION == UI_VERSION_MAYON)
                                                    gCurPlaybackSID = -1;
#endif
                                                    OSTaskCreate(Task_remote_file_playback, (void *)0,P2P_PLAYFILE_TASK_STACK, P2P_PLAYFILE_TASK_PRIORITY);
                                                }
                                                #else
                                                    OSTaskCreate(Task_remote_file_playback, (void *)0,P2P_PLAYFILE_TASK_STACK, P2P_PLAYFILE_TASK_PRIORITY);
                                                #endif
                                    		//}
                                    		//break;
                                    	//}
                                    	q->endflag=1;
                                    	if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_LISTEVENT_RESP, (char *)q, sizeof(SMsgAVIoctrlListEventResp)+(sizeof(SAvEvent)*q->count)) == AV_ER_NoERROR)
                                    	{
                                    		DEBUG_P2P("Stop sending the file list.\n");
                                    			return 0;
                                    	}
                                    }
                                    }
                                    */
                                    if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_LISTEVENT_RESP, (char *)q, sizeof(SMsgAVIoctrlListEventResp)+(sizeof(SAvEvent)*q->count)) == AV_ER_NoERROR)
                                    {
                                        /*
                                        if(q->endflag)
                                        {
                                        	DEBUG_P2P("Stop sending the file list.\n");
                                        	return 0;
                                        }
                                        else
                                        */
                                        DEBUG_P2P("Send file list-%d\n",q->index);
                                    }
                                    q->index++;
                                    q->count=0;
                                }
                            }
                            else
                            {
                                //DEBUG_P2P("Checking FILE: %s\n",dcfPlaybackCurFile->pDirEnt->d_name);
                                if(Remoteplayback_CH==atoi(&(dcfPlaybackCurFile->pDirEnt->d_name[7])))
                                    if(((dcfPlaybackCurFile->pDirEnt->fsFileCreateDate_YMD >> 9)+1980)==gRemote_playfile.stTimeDay.year)
                                        if(((dcfPlaybackCurFile->pDirEnt->fsFileCreateDate_YMD & 0x01E0)>>5)==gRemote_playfile.stTimeDay.month)
                                            if(((dcfPlaybackCurFile->pDirEnt->fsFileCreateDate_YMD & 0x001F))==gRemote_playfile.stTimeDay.day)
                                                if(((dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS>>11))==gRemote_playfile.stTimeDay.hour)
                                                    if(((dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS & 0x07E0)>>5)==gRemote_playfile.stTimeDay.minute)
                                                        if(((dcfPlaybackCurFile->pDirEnt->fsFileCreateTime_HMS & 0x001F)<<1)==gRemote_playfile.stTimeDay.second)
                                                        {
                                                            DEBUG_P2P("CURRENT FILE: %s\n",dcfPlaybackCurFile->pDirEnt->d_name);
                                                            get_play_file=1;

															if(gSearchFileListFlag != 2)
                                                            	gSearchFileListFlag = 0;
                                                            return 0;
                                                        }
                            }
                        }

                        if(get_play_file==0)
                        {
                            dcfPlaybackCurFile=dcfPlaybackCurFile->next;
                        }
                    }
                    while((dcfPlaybackCurFile!=dcfGetPlaybackFileListHead())&&(get_play_file==0));
                    dcfPlaybackCurDir=dcfPlaybackCurDir->next;
                }
            }
            else
            {
                dcfPlaybackCurDir=dcfPlaybackCurDir->next;
            }
        }
        while((dcfPlaybackCurDir!=dcfGetVideoDirListHead())&&(get_play_file==0));
        q->endflag=1;
        if(gbSearchEvent==0)
        {
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_LISTEVENT_RESP, (char *)q, sizeof(SMsgAVIoctrlListEventResp)+(sizeof(SAvEvent)*q->count)) == AV_ER_NoERROR)
            {
                DEBUG_P2P("Match Event Numer : %d\n",q->total);
                DEBUG_P2P("Send file list-END\n");
                gbSearchEvent=1;
            }
            q->total=0;
            q->index=0;
            q->endflag=0;
            q->count=0;
            //
            //^Event listAPP,SMsgAVIoctrlListEventRespP^Eventsmemory address.
            //HbMemoryPoolip2pEventList,size1024 byteSMsgAVIoctrlListEventResp+80SAvEvent.
            gbSearchEvent=1;
        }
    }
    else
    {
        DEBUG_P2P("No SD Card.\n");
        q->endflag=1;
        if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_LISTEVENT_RESP, (char *)q, sizeof(SMsgAVIoctrlListEventResp)+(sizeof(SAvEvent)*q->count)) == AV_ER_NoERROR)
        {
            DEBUG_P2P("Match Event Numer : %d\n",q->total);
            DEBUG_P2P("Send file list-END\n");
            gbSearchEvent=1;
        }
    }
    if(gSearchFileListFlag != 2)
		gSearchFileListFlag = 0;
#endif
}

/*Convert UCT time to local time. When receive a ioctl command : IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL.*/
static void UCT_to_Local_convert_playfile(SMsgAVIoctrlPlayRecord *p)
{
    RTC_DATE_TIME convert_time;
    u32	convert_second;
    RTC_TIME_ZONE zone;

    convert_time.year=p->stTimeDay.year-2000;
    convert_time.month=p->stTimeDay.month;
    convert_time.day=p->stTimeDay.day;
    convert_time.hour=p->stTimeDay.hour;
    convert_time.min=p->stTimeDay.minute;
    convert_time.sec=p->stTimeDay.second;
    convert_second=RTC_Time_To_Second(&convert_time);

    if(RTC_Get_DST()==1)	//Is DST duration?	 return 1 means 1hour, 2 means 2hours.
    {
        convert_second=convert_second+3600;
    }
    else if(RTC_Get_DST()==2)
    {
        convert_second=convert_second+7200;
    }

    RTC_Get_TimeZone(&zone);
    if(!zone.operator)
        convert_second=convert_second+zone.hour*60*60+zone.min*60;
    else
        convert_second=convert_second-zone.hour*60*60-zone.min*60;
    RTC_Second_To_Time(convert_second, &convert_time);
    //DEBUG_P2P("CONVERT-2 %d-%d-%d  %d:%d:%d\n",convert_time.year,convert_time.month,convert_time.day,convert_time.hour,convert_time.min,convert_time.sec);
    p->stTimeDay.year=convert_time.year+2000;
    p->stTimeDay.month=convert_time.month;
    p->stTimeDay.day=convert_time.day;
    p->stTimeDay.hour=convert_time.hour;
    p->stTimeDay.minute=convert_time.min;
    p->stTimeDay.second=convert_time.sec;

}


/*Convert UCT time to local time. When receive a ioctl command : IOTYPE_USER_IPCAM_LISTEVENT_REQ.*/
static void UCT_to_Local_convert(SMsgAVIoctrlListEventReq *p)
{
    RTC_DATE_TIME convert_time;
    u32	convert_second;
    RTC_TIME_ZONE zone;

    /*search start time */
    convert_time.year=p->stStartTime.year-2000;
    convert_time.month=p->stStartTime.month;
    convert_time.day=p->stStartTime.day;
    convert_time.hour=p->stStartTime.hour;
    convert_time.min=p->stStartTime.minute;
    convert_time.sec=p->stStartTime.second;
    convert_second=RTC_Time_To_Second(&convert_time);

    if(RTC_Get_DST()==1)	//Is DST duration?	 return 1 means 1hour, 2 means 2hours.
    {
        convert_second=convert_second+3600;
    }
    else if(RTC_Get_DST()==2)
    {
        convert_second=convert_second+7200;
    }

    RTC_Get_TimeZone(&zone);
    if(!zone.operator)
        convert_second=convert_second+zone.hour*60*60+zone.min*60;
    else
        convert_second=convert_second-zone.hour*60*60-zone.min*60;
    RTC_Second_To_Time(convert_second, &convert_time);
    //DEBUG_P2P("CONVERT-2 %d-%d-%d  %d:%d:%d\n",convert_time.year,convert_time.month,convert_time.day,convert_time.hour,convert_time.min,convert_time.sec);
    p->stStartTime.year=convert_time.year+2000;
    p->stStartTime.month=convert_time.month;
    p->stStartTime.day=convert_time.day;
    p->stStartTime.hour=convert_time.hour;
    p->stStartTime.minute=convert_time.min;
    p->stStartTime.second=convert_time.sec;

    /*search end time */
    convert_time.year=p->stEndTime.year-2000;
    convert_time.month=p->stEndTime.month;
    convert_time.day=p->stEndTime.day;
    convert_time.hour=p->stEndTime.hour;
    convert_time.min=p->stEndTime.minute;
    convert_time.sec=p->stEndTime.second;
    convert_second=RTC_Time_To_Second(&convert_time);

    if(RTC_Get_DST()==1)	//Is DST duration?	 return 1 means 1hour, 2 means 2hours.
    {
        convert_second=convert_second+3600;
    }
    else if(RTC_Get_DST()==2)
    {
        convert_second=convert_second+7200;
    }

    RTC_Get_TimeZone(&zone);
    if(!zone.operator)
        convert_second=convert_second+zone.hour*60*60+zone.min*60;
    else
        convert_second=convert_second-zone.hour*60*60-zone.min*60;
    RTC_Second_To_Time(convert_second, &convert_time);
    p->stEndTime.year=convert_time.year+2000;
    p->stEndTime.month=convert_time.month;
    p->stEndTime.day=convert_time.day;
    p->stEndTime.hour=convert_time.hour;
    p->stEndTime.minute=convert_time.min;
    p->stEndTime.second=convert_time.sec;

}

/*Convert UCT time to local time. For response : IOTYPE_USER_IPCAM_LISTEVENT_RESP.*/
static void Local_to_UCT_convert(STimeDay *q)
{
    RTC_DATE_TIME convert_time;
    u32	convert_second;
    RTC_TIME_ZONE zone;

    convert_time.year=q->year-2000;
    convert_time.month=q->month;
    convert_time.day=q->day;
    convert_time.hour=q->hour;
    convert_time.min=q->minute;
    convert_time.sec=q->second;
    convert_second=RTC_Time_To_Second(&convert_time);

    if(RTC_Get_DST()==1)	//Is DST duration?	 return 1 means 1hour, 2 means 2hours.
    {
        convert_second=convert_second-3600;
    }
    else if(RTC_Get_DST()==2)
    {
        convert_second=convert_second-7200;
    }

    RTC_Get_TimeZone(&zone);
    if(!zone.operator)
        convert_second=convert_second-zone.hour*60*60+zone.min*60;
    else
        convert_second=convert_second+zone.hour*60*60-zone.min*60;
    RTC_Second_To_Time(convert_second, &convert_time);
    //DEBUG_P2P("CONVERT-2 %d-%d-%d  %d:%d:%d\n",convert_time.year,convert_time.month,convert_time.day,convert_time.hour,convert_time.min,convert_time.sec);
    q->year=convert_time.year+2000;
    q->month=convert_time.month;
    q->day=convert_time.day;
    q->hour=convert_time.hour;
    q->minute=convert_time.min;
    q->second=convert_time.sec;

}
void client_p2pconnected(int SID)
{
    int i;
    gClientInfo[SID].bP2PConnected = 1;
    gClientInfo[SID].bShowInfo = 1;
    gClientInfo[SID].VOLSend= 0;
    for(i=0; i<MAX_AV_CH; i++)
        gClientInfo[SID].avIndex[i]=-1;
    gOnlineNum++;
}

void client_p2pdisconnected(int SID)
{
    DEBUG_P2P("P2P Client was disconnected.\n");
    gClientInfo[SID].bP2PConnected = 0;
    //aher 20130801
    gClientInfo[SID].getsupportstream=0;
#if(UI_VERSION == UI_VERSION_MAYON)
	if(CurrPlaybackSID == SID)
	{
		CurrPlaybackSID = -1;
		Remote_play = 0;
		Fileplaying = 0;
	}
#endif
    gOnlineNum--;
    DEBUG_P2P("unregedit_client_from_avsession(SID)=%d\n",SID);
    unregedit_client_from_avsession(SID);
    unregedit_client_from_speaker(SID);
    DEBUG_P2P("IOTC_Session_Close(SID)=%d\n",SID);
    IOTC_Session_Close(SID);
}

extern u8 uiCaptureVideo(void);

void Init_P2P_Session(void)
{
    int i;

    for(i=0; i<MAX_AV_CH; i++)
    {
        P2PVideoCmpSemEvt[i]   = OSSemCreate(0);
        P2PAudioCmpSemEvt[i]   = OSSemCreate(0);
    }
}

void Start_P2P_Session(int ch, int source)
{

    /**************************************
    **** Streaming Audio/Video Payload ****
    **************************************/
    unsigned int    cpu_sr = 0;
    INT8U           err;
    u8              level;
    u8              LocalChannel;
    int             i;
    u8              isBatteryCam = 0;

    ch = ch % MAX_AV_CH;

    DEBUG_P2P("P2PEnableStreaming[%d]: %d\n",ch,(P2PEnableStreaming[ch]));

    P2P_AV_Source[ch]   = source;
    #if  RFIU_RX_WAKEUP_TX_SCHEME
    isBatteryCam = (gRfiuUnitCntl[ch].RFpara.BateryCam_support);
    #endif
    if(P2PEnableStreaming[ch] == 0)
    {
        DEBUG_P2P("CH %d, start streaming Audio/Video Payload\n",ch);
        if(source == Local_record)
        {
#if 0
            //uiCaptureVideo();
            uiKeyVideoCapture();
#else
            DEBUG_P2P("Set 720P frame rate 5 fps\n");
            MultiChannelMpeg4SetVideoFrameRate(MPEG4_VIDEO_FRAMERATE_10, &VideoClipOption[2]);
            if(ch == 0)
            {
                switch(videoquality)
                {
                    case 1: // HD
                        LocalChannelSource                  = 2;
                        VideoClipParameter[2].asfVopWidth   = 1280;
                        VideoClipParameter[2].asfVopHeight  = 720;
                        break;
                    case 2: // VGA
                        LocalChannelSource                  = 1;
                        VideoClipParameter[1].asfVopWidth   = 640;
                        VideoClipParameter[1].asfVopHeight  = 480;
                        break;
                    case 3: // QVGA
                    case 4:
                    case 5:
                        LocalChannelSource                  = 1;
                        VideoClipParameter[1].asfVopWidth   = 320;
                        VideoClipParameter[1].asfVopHeight  = 240;
                        break;
                }
                LocalChannel    = LocalChannelSource;
            }
            else
            {
                LocalChannel                                    = ch + 1;
                VideoClipParameter[LocalChannel].asfVopWidth    = 1280;
                VideoClipParameter[LocalChannel].asfVopHeight   = 720;
            }
#if 0
            if(OSFlagAccept(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_CARD1_RDY, OS_FLAG_WAIT_SET_ALL, &err))   // SD card ready
            {
                DEBUG_P2P("SD card ready\n");
                VideoClipParameter[ch + 1].sysCaptureVideoMode  = sysCaptureVideoMode;
            }
            else    // SD card not ready
            {
                DEBUG_P2P("SD card not ready\n");
                VideoClipParameter[ch + 1].sysCaptureVideoMode  = sysCaptureVideoMode | ASF_CAPTURE_EVENT_DUMMY_ENA;
            }
#else
            if (sysGetStorageStatus(SYS_I_STORAGE_MAIN) == SYS_V_STORAGE_NREADY)
            {
                DEBUG_P2P("Main storage not ready\n");
                VideoClipParameter[LocalChannel].sysCaptureVideoMode  = sysCaptureVideoMode | ASF_CAPTURE_EVENT_DUMMY_ENA;
            }
            else
            {
                DEBUG_P2P("Main storage ready\n");
                VideoClipParameter[LocalChannel].sysCaptureVideoMode  = sysCaptureVideoMode;
            }
#endif
            if(MultiChannelGetCaptureVideoStatus(LocalChannel) && ((VideoClipOption[LocalChannel].asfVopWidth != VideoClipParameter[LocalChannel].asfVopWidth) || (VideoClipOption[LocalChannel].asfVopHeight != VideoClipParameter[LocalChannel].asfVopHeight)))
                MultiChannelSysCaptureVideoStopOneCh(LocalChannel);
            MultiChannelSysCaptureVideoOneCh(LocalChannel);
#endif

#if (MULTI_CHANNEL_VIDEO_REC)
            OSFlagPend(gSysSubReadyFlagGrp, FLAGSYS_SUB_RDYSTAT_REC_CH0 << (LocalChannel), OS_FLAG_WAIT_CLR_ALL, OS_IPC_WAIT_FOREVER, &err);
            while((VideoClipOption[LocalChannel].MPEG4_Task_Go == 0) || (VideoClipOption[LocalChannel].IIS_Task_Go == 0))
                OSTimeDly(1);

            OS_ENTER_CRITICAL();
            P2PVideoBufReadIdx[ch]                  = VideoClipOption[LocalChannel].VideoBufMngReadIdx;
            P2PVideoPresentTime[ch]                 = 0;

            P2PAudioBufReadIdx[ch]                  = VideoClipOption[LocalChannel].iisSounBufMngReadIdx;
            P2PAudioPresentTime[ch]                 = 0;
            P2PChannelStart[ch]                     = 1;

            P2PVideoBuf[ch]                         = VideoClipOption[LocalChannel].VideoBufMng;
            P2PAudioBuf[ch]                         = VideoClipOption[LocalChannel].iisSounBufMng;
            VideoClipOption[LocalChannel].SetIVOP   = 1;
            OS_EXIT_CRITICAL();

            /*
            DEBUG_P2P("P2PVideoBufReadIdx[%d]  = %d\n",     ch, P2PVideoBufReadIdx[ch]);
            DEBUG_P2P("P2PVideoPresentTime[%d] = %d\n",     ch, P2PVideoPresentTime[ch]);
            DEBUG_P2P("P2PVideoCmpSemEvt[%d]   = %d\n",     ch, P2PVideoCmpSemEvt[ch]->OSEventCnt);
            DEBUG_P2P("P2PVideoBuf[%d]         = 0x%08x\n", ch, P2PVideoBuf[ch]);
            DEBUG_P2P("P2PAudioBufReadIdx[%d]  = %d\n",     ch, P2PAudioBufReadIdx[ch]);
            DEBUG_P2P("P2PAudioPresentTime[%d] = %d\n",     ch, P2PAudioPresentTime[ch]);
            DEBUG_P2P("P2PAudioCmpSemEvt[%d]   = %d\n",     ch, P2PAudioCmpSemEvt[ch]->OSEventCnt);
            DEBUG_P2P("P2PAudioBuf[%d]         = 0x%08x\n", ch, P2PAudioBuf[ch]);
            */
#else
            OS_ENTER_CRITICAL();
            P2PVideoBufReadIdx[ch]  = 0;
            P2PVideoPresentTime[ch] = 0;

            P2PAudioBufReadIdx[ch]  = 0;
            P2PAudioPresentTime[ch] = 0;
            P2PChannelStart[ch]     = 1;

            P2PVideoBuf[ch]         = VideoBufMng;
            P2PAudioBuf[ch]         = iisSounBufMng;
            OS_EXIT_CRITICAL();
#endif
        }
        else if(source == Local_playback)
        {

          //  uiFlowPlaybackMode(UI_KEY_PLAY);//In playback thumbnail, send KE to playfile
            OS_ENTER_CRITICAL();
            P2PVideoBufReadIdx[ch]  = 0;
            P2PVideoPresentTime[ch] = 0;

            P2PAudioBufReadIdx[ch]  = 0;
            P2PAudioPresentTime[ch] = 0;
            P2PChannelStart[ch]=1;

            P2PVideoBuf[ch] = VideoBufMng;
            P2PAudioBuf[ch] = iisSounBufMng;
            OS_EXIT_CRITICAL();
        }
        else if(source == RX_receive)
        {
            DEBUG_P2P("RX_receive\n");

            if( gFirstConnect == 0) //APPi, L]wresolutionHD, 
            {
                rfiuRX_P2pVideoQuality = 2;
            }

            if( (rfiuRX_CamOnOff_Sta >> ch) & 0x01)
            {
                OS_ENTER_CRITICAL();
                P2PVideoBufReadIdx[ch]  = rfiuRxVideoBufMngWriteIdx[ch];
                P2PAudioBufReadIdx[ch]  = rfiuRxIIsSounBufMngWriteIdx[ch];

                P2PVideoPresentTime[ch] = 100; //Lsk TODO: msut add av time difference
                P2PAudioPresentTime[ch] = 100;
                P2PChannelStart[ch]=1;

                P2PVideoBuf[ch] = rfiuRxVideoBufMng[ch];
                P2PAudioBuf[ch] = rfiuRxIIsSounBufMng[ch];
                OS_EXIT_CRITICAL();
#if(UI_VERSION == UI_VERSION_MAYON)
//Add by Paul for liveview speed up, ask TX generate iFrame. 2018/08/29
				rfiuRX_OpMode = rfiuRX_OpMode | RfIU_RX_OPMODE_FORCE_I;
	            rfiu_SetRXOpMode_1(ch);
    	        rfiuRX_OpMode = rfiuRX_OpMode & (~RfIU_RX_OPMODE_FORCE_I);
//				DEBUG_P2P("CH:%d,Pt=%lu,%d\n", ch,P2PVideoBufReadIdx[ch], rfiuRxVideoBufMngWriteIdx[ch]);
#endif
#if 1
                if((isBatteryCam == 0) && (gRfiu_Op_Sta[ch]==RFIU_RX_STA_LINK_BROKEN))
                {
                    DEBUG_P2P("===== %d-CH is Out of Range =====\n",ch);
                    DEBUG_P2P("Out of Range\n");
                    P2PVideoBufReadIdx[ch]  = (0-60) % VIDEO_BUF_NUM;
                  #if (((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 3))||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 5))||\
                       ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 9)) || (HW_BOARD_OPTION == MR9200_RX_RDI_M906)||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 12)))
                    if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPEN)
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Japan_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Japan_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                    else
                    {
                        for(i=0; i<60; i++)
                        {
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_QVGA);
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_QVGA;
                            OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                  #elif (((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 6))|| ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 8)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 10))||\
                         ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 11)))
                    if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_GERMAN)
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_German_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_German_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_FRENCH)
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_French_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_French_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_Italy)//MPEG4_OutOfRange_Italy_QVGA
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Italy_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Italy_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_DUTCH)//MPEG4_OutOfRange_Netherland_QVGA
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Netherland_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Netherland_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_SPANISH)//MPEG4_OutOfRange_Spanish_QVGA
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Spanish_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Spanish_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                    else
                    {
                        for(i=0; i<60; i++)
                        {
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_QVGA);
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_QVGA;
                            OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                  #else
                   #if (UI_VERSION == UI_VERSION_TRANWO)
                   #if (UI_OTHER_LANGUAGE == 1)
                    if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPANSE)
                    {
                        for(i=0; i<60; i++)
                        {
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Japan_QVGA);
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Japan_QVGA;
                            OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                    else
                   #endif
                    {
                        for(i=0; i<60; i++)
                        {
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_QVGA);
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_QVGA;
                            OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                   #else
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                  #endif
                  #endif
                    gRfiuUnitCntl[ch].TX_PicWidth=320;
                    gRfiuUnitCntl[ch].TX_PicHeight=240;
                    //OSSemSet(P2PVideoCmpSemEvt[ch], 3, &err);

                }
#endif
            }
            else
            {
                DEBUG_P2P("-->RF CH-%d is OFF, Client-%d\n",ch,P2PEnableStreaming[ch]);
                OS_ENTER_CRITICAL();
                P2PVideoBufReadIdx[ch]  = rfiuRxVideoBufMngWriteIdx[ch];
                P2PAudioBufReadIdx[ch]  = rfiuRxIIsSounBufMngWriteIdx[ch];

                P2PVideoPresentTime[ch] = 100; //Lsk TODO: msut add av time difference
                P2PAudioPresentTime[ch] = 100;
                P2PChannelStart[ch]=1;

                P2PVideoBuf[ch] = rfiuRxVideoBufMng[ch];
                P2PAudioBuf[ch] = rfiuRxIIsSounBufMng[ch];
                OS_EXIT_CRITICAL();
                //--Fill black bitstream--//
                /*
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].flag=1;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].time=100;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].size=sizeof(MPEG4_NoCam_QVGA);//451;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].offset=0;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].buffer=MPEG4_NoCam_QVGA;

                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].flag=1;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].time=100;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].size=sizeof(MPEG4_NoCam_QVGA);//451;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].offset=0;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].buffer=MPEG4_NoCam_QVGA;

                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].flag=1;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].time=100;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].size=sizeof(MPEG4_NoCam_QVGA);//451;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].offset=0;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].buffer=MPEG4_NoCam_QVGA;
                */
              #if (((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 3))||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 5))||\
                   ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 9)) || (HW_BOARD_OPTION == MR9200_RX_RDI_M906)||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 12)))
                if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPEN)
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Japan_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Japan_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
                else
                {
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
              #elif (((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 6)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 8)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 10))||\
                     ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 11)))
                if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_GERMAN)
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_German_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_German_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
                else if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_FRENCH)
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_French_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_French_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
                else if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_Italy)//MPEG4_NoCam_Italy_QVGA
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Italy_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Italy_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
                else if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_DUTCH)//MPEG4_NoCam_Netherland_QVGA
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Netherland_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Netherland_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
                else if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_SPANISH)//MPEG4_NoCam_Spanish_QVGA
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Spanish_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Spanish_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
                else
                {
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
              #else
               #if (UI_VERSION == UI_VERSION_TRANWO)
               #if (UI_OTHER_LANGUAGE == 1)
                if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPANSE)
                {
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Japan_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Japan_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
                else
                #endif
                {
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
               #else
                for(i=0; i<60; i++)
                {
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_QVGA);
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_QVGA;
                    OSSemPost(P2PVideoCmpSemEvt[ch]);
                }
              #endif
              #endif
                gRfiuUnitCntl[ch].TX_PicWidth=320;
                gRfiuUnitCntl[ch].TX_PicHeight=240;
            }
        }
        else if(source == RX_transcoder)
        {
        }
    }
    else
    {
        if(source == RX_receive)
        {
            if( (rfiuRX_CamOnOff_Sta >> ch) & 0x01)
            {
                if((isBatteryCam == 0) && (gRfiu_Op_Sta[ch]==RFIU_RX_STA_LINK_BROKEN))
                {
                    DEBUG_P2P("===== %d-CH is Out of Range =====\n",ch);
                    DEBUG_P2P("Out of Range\n");
                    //P2PVideoBufReadIdx[ch]  = (0-60) % VIDEO_BUF_NUM;
                  #if (((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 3))||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 5))||\
                       ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 9)) || (HW_BOARD_OPTION == MR9200_RX_RDI_M906)||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 12)))
                    if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPEN)
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Japan_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Japan_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                    else
                    {
                        for(i=0; i<60; i++)
                        {
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_QVGA);
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_QVGA;
                            OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                  #elif (((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 6)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 8)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 10))||\
                         ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 11)))
                    if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_GERMAN)
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_German_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_German_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_FRENCH)
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_French_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_French_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_Italy)//MPEG4_OutOfRange_Italy_QVGA
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Italy_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Italy_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_DUTCH)//MPEG4_OutOfRange_Netherland_QVGA
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Netherland_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Netherland_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                    else if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_SPANISH)//MPEG4_OutOfRange_Spanish_QVGA
                    {
                        for(i=0;i<60;i++)
                        {
        					rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                  	  	    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                     	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Spanish_QVGA);
                       		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Spanish_QVGA;
                        	OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                    else
                    {
                        for(i=0; i<60; i++)
                        {
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_QVGA);
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_QVGA;
                            OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                  #else
                   #if (UI_VERSION == UI_VERSION_TRANWO)
                   #if (UI_OTHER_LANGUAGE == 1)
                    if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPANSE)
                    {
                        for(i=0; i<60; i++)
                        {
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_Japan_QVGA);
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_Japan_QVGA;
                            OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                    else
                    #endif
                    {
                        for(i=0; i<60; i++)
                        {
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_QVGA);
                            rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_QVGA;
                            OSSemPost(P2PVideoCmpSemEvt[ch]);
                        }
                    }
                   #else
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_OutOfRange_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_OutOfRange_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                  #endif
                  #endif
                    gRfiuUnitCntl[ch].TX_PicWidth=320;
                    gRfiuUnitCntl[ch].TX_PicHeight=240;
                    //OSSemSet(P2PVideoCmpSemEvt[ch], 3, &err);

                }
            }
            else
            {
                DEBUG_P2P("-->RF CH-%d is OFF, Client-%d\n",ch,P2PEnableStreaming[ch]);
                OS_ENTER_CRITICAL();
                P2PVideoBufReadIdx[ch]  = rfiuRxVideoBufMngWriteIdx[ch];
                P2PAudioBufReadIdx[ch]  = rfiuRxIIsSounBufMngWriteIdx[ch];

                P2PVideoPresentTime[ch] = 100; //Lsk TODO: msut add av time difference
                P2PAudioPresentTime[ch] = 100;
                P2PChannelStart[ch]=1;

                P2PVideoBuf[ch] = rfiuRxVideoBufMng[ch];
                P2PAudioBuf[ch] = rfiuRxIIsSounBufMng[ch];
                OS_EXIT_CRITICAL();
                //--Fill black bitstream--//
                /*
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].flag=1;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].time=100;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].size=sizeof(MPEG4_NoCam_QVGA);//451;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].offset=0;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]].buffer=MPEG4_NoCam_QVGA;

                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].flag=1;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].time=100;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].size=sizeof(MPEG4_NoCam_QVGA);//451;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].offset=0;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+1].buffer=MPEG4_NoCam_QVGA;

                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].flag=1;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].time=100;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].size=sizeof(MPEG4_NoCam_QVGA);//451;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].offset=0;
                                rfiuRxVideoBufMng[ch][P2PVideoBufReadIdx[ch]+2].buffer=MPEG4_NoCam_QVGA;
                */
              #if (((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 3))||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 5))||\
                   ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 9)) || (HW_BOARD_OPTION == MR9200_RX_RDI_M906)||((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 12)))
                if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPEN)
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Japan_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Japan_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
                else
                {
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
              #elif (((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 6)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 8)) || ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 10))||\
                     ((HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) && (PROJ_OPT == 11)))
                if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_GERMAN)
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_German_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_German_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
                else if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_FRENCH)
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_French_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_French_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
                else if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_Italy)//MPEG4_NoCam_Italy_QVGA
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Italy_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Italy_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
                else if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_DUTCH)//MPEG4_NoCam_Netherland_QVGA
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Netherland_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Netherland_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
                else if(CurrLanguage == UI_MENU_SETTING_LANGUAGE_SPANISH)//MPEG4_NoCam_Spanish_QVGA
                {
                    for(i=0;i<60;i++)
                    {
                		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;
                 	   	rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Spanish_QVGA);//451;
                   		rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Spanish_QVGA;
                    	OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
                else
                {
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
              #else
               #if (UI_VERSION == UI_VERSION_TRANWO)
               #if (UI_OTHER_LANGUAGE == 1)
                if (CurrLanguage == UI_MENU_SETTING_LANGUAGE_JAPANSE)
                {
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_Japan_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_Japan_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
                else
                #endif
                {
                    for(i=0; i<60; i++)
                    {
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_QVGA);
                        rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_QVGA;
                        OSSemPost(P2PVideoCmpSemEvt[ch]);
                    }
                }
               #else
                for(i=0; i<60; i++)
                {
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].flag=1;
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].time=100;
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].size=0;//451;
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].offset=sizeof(MPEG4_NoCam_QVGA);
                    rfiuRxVideoBufMng[ch][(P2PVideoBufReadIdx[ch]+i) % VIDEO_BUF_NUM ].buffer=MPEG4_NoCam_QVGA;
                    OSSemPost(P2PVideoCmpSemEvt[ch]);
                }
              #endif
              #endif
                gRfiuUnitCntl[ch].TX_PicWidth=320;
                gRfiuUnitCntl[ch].TX_PicHeight=240;
            }
        }
    }

    P2PEnableStreaming[ch]  += 1;

}

void Stop_P2P_Session(int ch)
{
    u8 err;

    DEBUG_P2P("(SID, CH) = (%d, %d), Stop P2P Session \n\n", (ch/MAX_AV_CH), (ch%MAX_AV_CH));
    ch = ch % MAX_AV_CH;

    P2PEnableStreaming[ch]  -= 1;
    if(P2PEnableStreaming[ch] <= 0)
    {
        DEBUG_P2P("CH %d, stop streaming Audio/Video Payload\n",ch);
        OSSemSet(P2PVideoCmpSemEvt[ch], 0, &err);
        OSSemSet(P2PAudioCmpSemEvt[ch], 0, &err);
        P2PEnableStreaming[ch]=0;
    }
}
void Reset_P2P_Session(void)
{
    int i;
    u8 err;

    for(i=0; i<MAX_AV_CH; i++)
    {
        OSSemSet(P2PVideoCmpSemEvt[i], 0, &err);
        OSSemSet(P2PAudioCmpSemEvt[i], 0, &err);
    }
}

// ----------------------
// HUD Update APP Sensor ]m 20150929 Sean
// ----------------------
#if HOME_RF_SUPPORT

void UpdateAPPSensorListStatus(void)
{
    APPSensorListStatus = 1;
}

void UpdateAPPSensorStatus(u8 sID)
{
    APPSensorStatus = sID;
}

void UpdateAPPRoomListStatus(void)
{
    APPRoomListStatus = 1;
}

void UpdateAPPSceneListStatus(void)
{
    APPSceneListStatus = 1;
}

#endif

void Handle_IOCTRL_Cmd(int SID, int avIndex, char *buf)
{
#if( (CHIP_OPTION == CHIP_A1025A) || (CHIP_OPTION == CHIP_A1021A) )
	u8	j,k, LED_level;
#endif
    static unsigned int room_id_add =0;
    static unsigned int sensor_id_add =0;
    static unsigned int scene_id_add =0;
    unsigned int i,x;
    unsigned int ioType;
    int ret;
    int PTZ_CHN;
    int Light_CHN;
	u8 result;

#if(UI_VERSION == UI_VERSION_MAYON)
	if(MAYONTXTypeStatus != 0)
	{
        int size = sizeof(SMsgAVIoctrlGetCameraTypeResp);
        SMsgAVIoctrlGetCameraTypeResp q;

		q.channel 	= MAYONTXTypeStatus - 1;			// Add by Paul for APP check batterycam channel, 180508

		q.CameraType 	= gRfiuUnitCntl[MAYONTXTypeStatus - 1].RFpara.BateryCam_support;

		q.BatteryLevel = gRfiuUnitCntl[MAYONTXTypeStatus - 1].RFpara.TxBatteryLev;

		if(q.BatteryLevel > 3)
			q.BatteryLevel = 3;

		MAYONTXTypeStatus = 0;

		//Fixed issue of nly 1 client can get TX_TYPE_RESP when battery cam sleep , Paul add, 180613
		for(i=0; i<MAX_CLIENT; i++)
		{
			if(gClientInfo[i].bP2PConnected == 1)
			{
				if(avSendIOCtrl(gClientInfo[i].avChannel, IOTYPE_USER_IPCAM_GET_TX_TYPE_RESP, (char*)&q, size)== AV_ER_NoERROR)
				{
					DEBUG_P2P("IPCAM_GET_TX_TYPE_RESP[%d:%d] OK\n\n", i, gClientInfo[i].avChannel);
					gAppWakeCamflag &= ~(0x01 << q.channel);
				}
			}
		}
    }

	if (MAYONLightStatus != 0)
	{
		int size = sizeof(SMsgAVIoctrlGetCameraLightResp);
		SMsgAVIoctrlGetCameraLightResp q;

		q.switch_value = uiGetLightOnOffAPP(MAYONLightStatus - 1);
		q.value = uiGetLightStatusAPP(MAYONLightStatus - 1);

        MAYONLightStatus = 0;

		if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_TX_LIGHT_RESP, (char*)&q, size)== AV_ER_NoERROR)
		{
			DEBUG_P2P("IPCAM_GET_TX_LIGHT_RESP OK\n\n");
		}

	}

	if (MAYONAlarmStatus != 0)
	{
		int size = sizeof(SMsgAVIoctrlGetCameraAlarmResp);
		SMsgAVIoctrlGetCameraAlarmResp q;

		q.switch_value= uiGetAlarmOnOffAPP(MAYONAlarmStatus - 1);
		q.AlarmStatus = uiGetAlarmStatusAPP(MAYONAlarmStatus - 1);

        MAYONAlarmStatus = 0;

		if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_TX_ALARM_RESP, (char*)&q, size)== AV_ER_NoERROR)
		{
			DEBUG_P2P("IPCAM_GET_TX_ALARM_RESP OK\n\n");
		}

	}

#endif
#if (UI_LIGHT_SUPPORT)
// ----------------------
// HUD Update APP Light ]m 20151126 Sean
// ----------------------
    if (AppLightStatus != 0)
    {
        int size =  sizeof(SMsgAVIoctrlGetLightStatusResp);

        SMsgAVIoctrlGetLightStatusResp q;

        q.channel = AppLightStatus-1;

        if((iconflag[UI_MENU_SETIDX_CH1_LS_STATUS + AppLightStatus-1])<2)
            q.status = 0;
        else
            q.status = 1;

        AppLightStatus = 0;

        for(i=0; i<MAX_CLIENT; i++)
        {
            if((ret = Check_Session_Status(i)) < 0) //session disconnected
                continue;
            if(avSendIOCtrl(gClientInfo[i].avIndex[0], IOTYPE_RDI_GETLIGHTSTATUS_RESP, (char *)&q, size)== AV_ER_NoERROR)
                DEBUG_P2P("IOTYPE_RDI_GETLIGHTSTATUS_RESP_2 OK\n\n");
        }
    }
#endif

#if HOME_RF_SUPPORT
//////////////////////////////////////////
// ----------------------
// HUD Update APP Status ]m 20151230 Sean
// ----------------------
    if (APPSensorListStatus != 0)
    {
        int size =  sizeof(SMsgAVIoctrlGetSensorLstResp);
        int i, j, ret;

        SMsgAVIoctrlGetSensorLstResp q;

        sysAppGetSensorList(&q,0);
        APPSensorListStatus = 0;

        for(i=0; i<MAX_CLIENT; i++)
        {
            if((ret = Check_Session_Status(i)) < 0) //session disconnected
                continue;
            if(avSendIOCtrl(gClientInfo[i].avIndex[0], IOTYPE_USER_GETSENSORLST_RESP, (char*)&q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETSENSORLST_RESP2 OK\n\n");
            }
            if(q.nTotalCount > MAXSENSOR_NUM_ONCE)
                for(j = 0; j < (q.nTotalCount)/(MAXSENSOR_NUM_ONCE+1); i++)
                {
                    sysAppGetSensorList(&q,j+1);
                    if(avSendIOCtrl(gClientInfo[i].avIndex[0], IOTYPE_USER_GETSENSORLST_RESP, (char*)&q, size)== AV_ER_NoERROR)
                        DEBUG_P2P("GETSENSORLST_RESP2_%d OK\n\n",j+2);
                }
        }
    }

    if (APPSensorStatus != 0)
    {
        int size =  sizeof(SMsgAVIoctrlGetSensorResp);
        int i, ret;

        SMsgAVIoctrlGetSensorResp q;

        sysAppGetSensor(APPSensorStatus,&q);
        APPSensorStatus = 0;

        for(i=0; i<MAX_CLIENT; i++)
        {
            if((ret = Check_Session_Status(i)) < 0) //session disconnected
                continue;
            if(avSendIOCtrl(gClientInfo[i].avIndex[0], IOTYPE_USER_GETSENSOR_RESP, (char*)&q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETSENSOR_RESP2 OK\n\n");
            }
        }
    }

    if (APPRoomListStatus != 0)
    {
        int size =  sizeof(SMsgAVIoctrlGetRoomLstResp);
        int i, j, ret;

        SMsgAVIoctrlGetRoomLstResp q;

        sysAppGetRoomList(&q,0);
        APPRoomListStatus = 0;

        DEBUG_P2P("\nGET ROOM : %d, %d, %d \n",q.nCount,q.nStartIdx,q.nTotalCount);

        for(i=0; i<MAX_CLIENT; i++)
        {
            if((ret = Check_Session_Status(i)) < 0) //session disconnected
                continue;
            if(avSendIOCtrl(gClientInfo[i].avIndex[0], IOTYPE_USER_GETROOMLST_RESP, (char*)&q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETROOMLST_RESP2 OK\n\n");
            }
            if(q.nTotalCount > MAXROOM_NUM_ONCE)
                for(j = 0; j < (q.nTotalCount)/(MAXROOM_NUM_ONCE+1); j++)
                {
                    sysAppGetRoomList(&q,j+1);
                    if(avSendIOCtrl(gClientInfo[i].avIndex[0], IOTYPE_USER_GETROOMLST_RESP, (char*)&q, size)== AV_ER_NoERROR)
                        DEBUG_P2P("GETROOMLST_RESP2_%d OK\n\n",j+2);
                }
        }
    }

    if (APPSceneListStatus != 0)
    {
        int size =  sizeof(SMsgAVIoctrlGetSceneLstResp);
        int i, j, ret;

        SMsgAVIoctrlGetSceneLstResp q;

        sysAppGetSceneList(&q,0);
        APPSceneListStatus = 0;

        for(i=0; i<MAX_CLIENT; i++)
        {
            if((ret = Check_Session_Status(i)) < 0) //session disconnected
                continue;
            if(avSendIOCtrl(gClientInfo[i].avIndex[0], IOTYPE_USER_GETSCENCELST_RESP, (char*)&q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETSCENCELST_RESP2 OK\n\n");
            }
            if(q.nTotalCount > MAXSCENE_NUM_ONCE)
                for(j = 0; j < (q.nTotalCount)/(MAXSCENE_NUM_ONCE+1); j++)
                {
                    sysAppGetSceneList(&q,j+1);
                    if(avSendIOCtrl(gClientInfo[i].avIndex[0], IOTYPE_USER_GETSCENCELST_RESP, (char*)&q, size)== AV_ER_NoERROR)
                        DEBUG_P2P("GETSCENCELST_RESP2_%d OK\n\n",j+2);
                }
        }
    }
//////////////////////////////////////////
#endif

    ret = avRecvIOCtrl(avIndex, &ioType, (char *)buf, MAX_BUF_SIZE, 0);

    if(avIndex<0)
    {
        return;
    }

    if(ret < 0)
    {
        if(ret==(AV_ER_INVALID_SID||AV_ER_SESSION_CLOSE_BY_REMOTE||AV_ER_REMOTE_TIMEOUT_DISCONNECT))
        {
        	if(gOnlineNum == 1)
            	ClearP2PConnection();
        }
        if(ret != AV_ER_DATA_NOREADY)
            DEBUG_P2P("Handle IOCTL CMD fail ret[%d] avIndex[%d]\n", ret, avIndex);
        //unregedit_client_from_avsession(SID);
        return;

    }

    //DEBUG_GREEN("Get ioType %x\n", ioType);
    switch(ioType)
    {
#if (HW_BOARD_OPTION  == MR8202A_RX_TARNWO_D8530)
        /* ----------------------
           Creat WalMart 20180305 Sean
           Functional Hard Code 20181718 Hank
		   ---------------------- */
		case IOTYPE_WALMART_SETCAMERAPAIR_REQ:
		    P2PCmd_SetCamPair(avIndex, buf);
		    break;

		case IOTYPE_WALMART_GETCAMERASTASUS_REQ:
		    P2PCmd_GetCamLinkStatus(avIndex, buf);
		    break;

		case IOTYPE_WALMART_SETCAMERASTASUS_REQ:
		    P2PCmd_SetCamOnOff(avIndex, buf);
		    break;

		case IOTYPE_WALMART_GETCAMERABRIT_REQ:
		    P2PCmd_GetCamBrightness(avIndex, buf);
		    break;

		case IOTYPE_WALMART_SETCAMERABRIT_REQ:
		    P2PCmd_SetCamBrightness(avIndex, buf);
    		break;

		case IOTYPE_WALMART_GETCAMERAFREQ_REQ:
		    P2PCmd_GetCamFrequence(avIndex, buf);
		    break;

		case IOTYPE_WALMART_SETCAMERAFREQ_REQ:
		    P2PCmd_SetCamFrequence(avIndex, buf);
		    break;

		case IOTYPE_WALMART_GETRECORDMANUAL_REQ:
		    P2PCmd_GetCamRecStatus(avIndex, buf);
    		break;

		case IOTYPE_WALMART_GETLIVEVIEWDATARATE_REQ:
		    P2PCmd_GetLiveDataRate(buf);
    		break;

		case IOTYPE_WALMART_SETRECORDMANUAL_REQ:
		    P2PCmd_SetCamManualRec(avIndex, buf);
    		break;

		case IOTYPE_WALMART_GETRECORDMOTIONLEV_REQ:
    		P2PCmd_GetCamMotionSensitivity(avIndex, buf);
    		break;

		case IOTYPE_WALMART_SETRECORDMOTIONLEV_REQ:
    		P2PCmd_SetCamMotionSensitivity(avIndex, buf);
    		break;

		case IOTYPE_WALMART_GETRECORDSCHEDULE_REQ:
    		P2PCmd_GetCamRecScheduleTable(avIndex, buf);
    		break;

		case IOTYPE_WALMART_SETRECORDSCHEDULE_REQ:
		    P2PCmd_SetCamRecScheduleTable(avIndex, buf);
		    break;

		case IOTYPE_WALMART_GETRECORDDURATION_REQ:
    		P2PCmd_GetRecSection(avIndex, buf);
    		break;

		case IOTYPE_WALMART_SETRECORDDURATION_REQ:
			P2PCmd_SetRecSection(avIndex, buf);
		    break;

		case IOTYPE_WALMART_SETSDFORMAT_REQ:
    		P2PCmd_SetFormat(avIndex, buf);
    		break;

		case IOTYPE_WALMART_GETSDOVERWRITE_REQ:
    		P2PCmd_GetOverwiteStatus(avIndex, buf);
    		break;

		case IOTYPE_WALMART_SETSDOVERWRITE_REQ:
		    P2PCmd_SetOverwite(avIndex, buf);
    		break;

		case IOTYPE_WALMART_GETSYSTIME_REQ:
			P2PCmd_GetDateTime(avIndex, buf);
    		break;

		case IOTYPE_WALMART_SETSYSTIME_REQ:
			P2PCmd_SetDateTime(avIndex, buf);
	    	break;

		case IOTYPE_WALMART_SETDEFAULT_REQ:
    		P2PCmd_SetDefault(avIndex, buf);
    		break;

		case IOTYPE_WALMART_GETLANG_REQ:
			P2PCmd_GetLanguage(avIndex, buf);
		    break;

		case IOTYPE_WALMART_SETLANG_REQ:
			P2PCmd_SetLanguage(avIndex, buf);
		    break;

		case IOTYPE_WALMART_GETNETSTATUS_REQ:
			P2PCmd_GetNetworkInfo(avIndex, buf);
		    break;

		case IOTYPE_WALMART_SETNETSTATUS_REQ:
		    P2PCmd_SetNetworkInfo(avIndex, buf);
    		break;

		case IOTYPE_WALMART_GETLED_REQ:
			P2PCmd_GetLEDStatus(avIndex, buf);
		    break;

		case IOTYPE_WALMART_SETLED_REQ:
			P2PCmd_SetLEDStatus(avIndex, buf);
		    break;

		case IOTYPE_WALMART_GETPLAYBACKFPS_REQ:
    		P2PCmd_GetPlaybackFPS(avIndex, buf);
    		break;

#elif( (CHIP_OPTION == CHIP_A1025A))
		// ----------------------
		// ???WalMart 20180305 Sean
		// ----------------------

		case IOTYPE_WALMART_SETCAMERAPAIR_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraPairResp);
			SMsgAVIoctrlSetCameraPairReq *p = (SMsgAVIoctrlSetCameraPairReq *)buf;
			SMsgAVIoctrlSetCameraPairResp *q=(SMsgAVIoctrlSetCameraPairResp *)buf;
#if(HOME_RF_SUPPORT)
			gPairAvIndex = avIndex;
#endif
			DEBUG_P2P("IOTYPE_WALMART_SETCAMERAPAIR_REQ OK:%d\n\n",p->channel);

			BoxExtKey = p->channel;

			uiSentKeyToUi(UI_KEY_CAM_PAIR);

			//if(avSendIOCtrl(avIndex, IOTYPE_WALMART_SETCAMERAPAIR_RESP, (char*)q, size)== AV_ER_NoERROR)
			//{
			//	DEBUG_P2P("IOTYPE_WALMART_SETCAMERAPAIR_RESP OK\n\n");
			//}
		}
		break;

		case IOTYPE_WALMART_GETCAMERASTASUS_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraStatusResp);
			SMsgAVIoctrlGetCameraStatusReq *p = (SMsgAVIoctrlGetCameraStatusReq *)buf;
			SMsgAVIoctrlGetCameraStatusResp *q=(SMsgAVIoctrlGetCameraStatusResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETCAMERASTASUS_REQ %d %d OK\n\n",  p->channel, gRfiu_Op_Sta[p->channel]);


			if (gRfiu_Op_Sta[p->channel] == RFIU_RX_STA_LINK_OK)
				q->status = 1;
			else
				q->status = 0;
			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_GETCAMERASTASUS_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETCAMERASTASUS_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETCAMERASTASUS_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraStatusResp);
			SMsgAVIoctrlSetCameraStatusReq *p = (SMsgAVIoctrlSetCameraStatusReq *)buf;
			SMsgAVIoctrlSetCameraStatusResp *q=(SMsgAVIoctrlSetCameraStatusResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETCAMERASTASUS_REQ OK,%d\n\n",p->channel);

			BoxExtKey = p->channel;
			iconflag[UI_MENU_SETIDX_CH1_ON + p->channel] = p->status;

			uiSentKeyToUi(UI_KEY_CAM_ON);
			q->result = 0;

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_SETCAMERASTASUS_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETCAMERASTASUS_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETCAMERABRIT_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraBrightnessResp);
			SMsgAVIoctrlGetCameraBrightnessReq *p = (SMsgAVIoctrlGetCameraBrightnessReq *)buf;
			SMsgAVIoctrlGetCameraBrightnessResp *q=(SMsgAVIoctrlGetCameraBrightnessResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETCAMERABRIT_REQ OK:%d\n\n",p->channel);

			q->status = iconflag[UI_MENU_SETIDX_BRIGHTNESS_CH1 + p->channel];

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_GETCAMERABRIT_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETCAMERABRIT_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETCAMERABRIT_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraBrightnessResp);
			SMsgAVIoctrlSetCameraBrightnessReq *p = (SMsgAVIoctrlSetCameraBrightnessReq *)buf;
			SMsgAVIoctrlSetCameraBrightnessResp *q=(SMsgAVIoctrlSetCameraBrightnessResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETCAMERABRIT_REQ OK:%d\n\n",p->channel);

			BoxExtKey = p->channel;
			iconflag[UI_MENU_SETIDX_BRIGHTNESS_CH1 + p->channel] = p->status;

			uiSentKeyToUi(UI_KEY_CAM_BRIGHTNESS);
			q->result = 0;

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_SETCAMERABRIT_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETCAMERABRIT_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETCAMERAFREQ_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraFreqResp);
			SMsgAVIoctrlGetCameraFreqReq *p = (SMsgAVIoctrlGetCameraFreqReq *)buf;
			SMsgAVIoctrlGetCameraFreqResp *q=(SMsgAVIoctrlGetCameraFreqResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETCAMERAFREQ_REQ OK\n\n");

			q->status = 1;//iconflag[UI_MENU_SETIDX_50HZ_60HZ];			//Paul modify for debug only

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_GETCAMERAFREQ_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETCAMERAFREQ_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETCAMERAFREQ_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraFreqResp);
			SMsgAVIoctrlSetCameraFreqReq *p = (SMsgAVIoctrlSetCameraFreqReq *)buf;
			SMsgAVIoctrlSetCameraFreqResp *q=(SMsgAVIoctrlSetCameraFreqResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETCAMERAFREQ_REQ OK\n\n");

			BoxExtKey = 0;
			iconflag[UI_MENU_SETIDX_50HZ_60HZ] = p->status;

			uiSentKeyToUi(UI_KEY_CAM_FLICKER);

			q->result = 0;

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_SETCAMERAFREQ_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETCAMERAFREQ_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETRECORDMANUAL_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetManualRecordResp);
			SMsgAVIoctrlGetManualRecordReq *p = (SMsgAVIoctrlGetManualRecordReq *)buf;
			SMsgAVIoctrlGetManualRecordResp *q=(SMsgAVIoctrlGetManualRecordResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETRECORDMANUAL_REQ OK\n\n");

			if(MultiChannelGetCaptureVideoStatus(p->channel) == 1)
				q->status = 1;
			else
				q->status = 0;

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_GETRECORDMANUAL_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETRECORDMANUAL_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETLIVEVIEWDATARATE_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetLiveViewDataRateReq);
			SMsgAVIoctrlGetLiveViewDataRateReq *p = (SMsgAVIoctrlGetLiveViewDataRateReq *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETLIVEVIEWDATARATE_REQ OKl bitRate=%d, index=%d\n\n", p->bitRate, p->lastFrameIndex);

		}
		break;

		case IOTYPE_WALMART_SETRECORDMANUAL_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetManualRecordResp);
			SMsgAVIoctrlSetManualRecordReq *p = (SMsgAVIoctrlSetManualRecordReq *)buf;
			SMsgAVIoctrlSetManualRecordResp *q=(SMsgAVIoctrlSetManualRecordResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETRECORDMANUAL_REQ OK\n\n");

			BoxExtKey = p->channel;
			if(gSystemStorageReady == 1)
			{
				uiSentKeyToUi(UI_KEY_CAM_MANUAL_REC);
				q->result = 0;
			}
			else
				q->result = 1; //SD card Not ready.

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_SETRECORDMANUAL_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETRECORDMANUAL_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETRECORDMOTIONLEV_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraMotionLevelResp);
			SMsgAVIoctrlGetCameraMotionLevelReq *p = (SMsgAVIoctrlGetCameraMotionLevelReq *)buf;
			SMsgAVIoctrlGetCameraMotionLevelResp *q=(SMsgAVIoctrlGetCameraMotionLevelResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETRECORDMOTIONLEV_REQ OK\n\n");

			q->status =	iconflag[UI_MENU_SETIDX_MOTION_SENSITIVITY_CH1 + p->channel];


			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_GETRECORDMOTIONLEV_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETRECORDMOTIONLEV_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETRECORDMOTIONLEV_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraMotionLevelResp);
			SMsgAVIoctrlSetCameraMotionLevelReq *p = (SMsgAVIoctrlSetCameraMotionLevelReq *)buf;
			SMsgAVIoctrlSetCameraMotionLevelResp *q=(SMsgAVIoctrlSetCameraMotionLevelResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETRECORDMOTIONLEV_REQ OK\n\n");


			BoxExtKey = p->channel;

			iconflag[UI_MENU_SETIDX_MOTION_SENSITIVITY_CH1 + p->channel] = p->status;

			uiSentKeyToUi(UI_KEY_CAM_SENSITIVITY);

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_SETRECORDMOTIONLEV_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETRECORDMOTIONLEV_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETRECORDSCHEDULE_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraRecordScheduleResp);
			SMsgAVIoctrlGetCameraRecordScheduleReq *p = (SMsgAVIoctrlGetCameraRecordScheduleReq *)buf;
			SMsgAVIoctrlGetCameraRecordScheduleResp *q=(SMsgAVIoctrlGetCameraRecordScheduleResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETRECORDSCHEDULE_REQ OK,%d\n\n",p->channel);

			for(j=0;j<56;j++)
			{
				q->status[j] = uiScheduleTime[j/8][p->channel][3*(j%8)];
				//if(j%8 == 0)
				//	printf("\n");
				//printf("\x1B[96m%d \x1B[0m",q->status[j]);
			}

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_GETRECORDSCHEDULE_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETRECORDSCHEDULE_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETRECORDSCHEDULE_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraRecordScheduleResp);
			SMsgAVIoctrlSetCameraRecordScheduleReq *p = (SMsgAVIoctrlSetCameraRecordScheduleReq *)buf;
			SMsgAVIoctrlSetCameraRecordScheduleResp *q=(SMsgAVIoctrlSetCameraRecordScheduleResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETRECORDSCHEDULE_REQ OK,%d\n\n",p->channel);

			for(j=0;j<56;j++)
			{
				//if(j%8 == 0)
				//	printf("\n");
				for(k=0;k<3;k++)
				{
					uiScheduleTime[j/8][p->channel][k + 3*(j%8)] = p->status[j];
				}
				//printf("%d ",p->status[j]);
			}

			/*
			for(j=0;j<7;j++)
			{
					printf("\n");
				for(k=0;k<8;k++)
					printf("\x1B[96m%d \x1B[0m",uiScheduleTime[j][p->channel][k*3]);
			}
			*/
			BoxExtKey = p->channel;
			uiSentKeyToUi(UI_KEY_CAM_SCHEDULE);
			q->result = 0;

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_SETRECORDSCHEDULE_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETRECORDSCHEDULE_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETRECORDDURATION_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraRecordDurationResp);
			SMsgAVIoctrlGetCameraRecordDurationResp *q=(SMsgAVIoctrlGetCameraRecordDurationResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETRECORDDURATION_REQ OK\n\n");

			q->status = iconflag[UI_MENU_SETIDX_SECTION];

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_GETRECORDDURATION_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETRECORDDURATION_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETRECORDDURATION_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraRecordDurationResp);

			SMsgAVIoctrlSetCameraRecordDurationReq *p=(SMsgAVIoctrlSetCameraRecordDurationReq *)buf;
			SMsgAVIoctrlSetCameraRecordDurationResp *q=(SMsgAVIoctrlSetCameraRecordDurationResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETRECORDDURATION_REQ OK\n\n");

			BoxExtKey = 0;
			iconflag[UI_MENU_SETIDX_SECTION] = p->status;

			uiSentKeyToUi(UI_KEY_CAM_INTERVAL);

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_SETRECORDDURATION_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETRECORDDURATION_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETSDFORMAT_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraSDFormatResp);
			SMsgAVIoctrlSetCameraSDFormatResp *q=(SMsgAVIoctrlSetCameraSDFormatResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETSDFORMAT_REQ OK\n\n");

			BoxExtKey = 0;
	        iconflag[UI_MENU_SETIDX_FORMAT] = 0;

			uiSentKeyToUi(UI_KEY_SD_FORMAT);
			q->result = 0;

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_SETSDFORMAT_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETSDFORMAT_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETSDOVERWRITE_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraSDOverWriteResp);

			SMsgAVIoctrlGetCameraSDOverWriteResp *q=(SMsgAVIoctrlGetCameraSDOverWriteResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETSDOVERWRITE_REQ OK\n\n");

			q->status = iconflag[UI_MENU_SETIDX_OVERWRITE];



			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_GETSDOVERWRITE_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETSDOVERWRITE_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETSDOVERWRITE_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraSDOverWriteResp);

			SMsgAVIoctrlSetCameraSDOverWriteReq *p=(SMsgAVIoctrlSetCameraSDOverWriteReq *)buf;
			SMsgAVIoctrlSetCameraSDOverWriteResp *q=(SMsgAVIoctrlSetCameraSDOverWriteResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETSDOVERWRITE_REQ OK\n\n");

			BoxExtKey = 0;
			iconflag[UI_MENU_SETIDX_OVERWRITE] = p->status;

			uiSentKeyToUi(UI_KEY_SD_OVERWRITE);

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_SETSDOVERWRITE_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETSDOVERWRITE_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETSYSTIME_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraSystemTimeResp);

			SMsgAVIoctrlGetCameraSystemTimeResp *q=(SMsgAVIoctrlGetCameraSystemTimeResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETSYSTIME_REQ OK\n\n");

			RTC_Get_Time(&SetTime);

			q->time[0] = SetTime.year;
			q->time[1] = SetTime.month;
			q->time[2] = SetTime.day;
			q->time[3] = SetTime.hour;
			q->time[4] = SetTime.min;

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_GETSYSTIME_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETSYSTIME_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETSYSTIME_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraSystemTimeResp);

			SMsgAVIoctrlSetCameraSystemTimeReq *p=(SMsgAVIoctrlSetCameraSystemTimeReq *)buf;
			SMsgAVIoctrlSetCameraSystemTimeResp *q=(SMsgAVIoctrlSetCameraSystemTimeResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETSYSTIME_REQ OK\n\n");

			SetTime.year 	= p->time[0];
			SetTime.month 	= p->time[1];
			SetTime.day		= p->time[2];
			SetTime.hour	= p->time[3];
			SetTime.min		= p->time[4];
			SetTime.sec		= 0;
			BoxExtKey = 0;
			iconflag[UI_MENU_SETIDX_DATE_TIME] = 1;

			uiSentKeyToUi(UI_KEY_SYS_TIME);
			//RTC_Set_Time(&SetTime);
			q->result = 0;

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_SETSYSTIME_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETSYSTIME_RESP OK\n\n");
			}
		}
		break;


		case IOTYPE_WALMART_SETDEFAULT_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraSystemTimeResp);

			SMsgAVIoctrlSetCameraDefaultResp *q=(SMsgAVIoctrlSetCameraDefaultResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETDEFAULT_REQ OK\n\n");

			BoxExtKey = 0;
			iconflag[UI_MENU_SETIDX_DEFAULT] = 0;
			uiSentKeyToUi(UI_KEY_SYS_DEFAULT);
			q->result = 0;


			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_SETDEFAULT_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETDEFAULT_RESP OK\n\n");
			}
		}
		break;


		case IOTYPE_WALMART_GETLANG_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraLanguageResp);

			SMsgAVIoctrlGetCameraLanguageResp *q=(SMsgAVIoctrlGetCameraLanguageResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETLANG_REQ OK\n\n");

			q->status = iconflag[UI_MENU_SETIDX_LANGUAGE];

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_GETLANG_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETLANG_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETLANG_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraLanguageResp);

			SMsgAVIoctrlSetCameraLanguageReq *p=(SMsgAVIoctrlSetCameraLanguageReq *)buf;
			SMsgAVIoctrlSetCameraLanguageResp *q=(SMsgAVIoctrlSetCameraLanguageResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETLANG_REQ OK\n\n");

			BoxExtKey = 0;
			iconflag[UI_MENU_SETIDX_LANGUAGE] = p->status;

			uiSentKeyToUi(UI_KEY_SYS_LANGUAGE);

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_SETLANG_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETLANG_RESP OK\n\n");
			}
		}
		break;


		case IOTYPE_WALMART_GETNETSTATUS_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraNetStatusResp);
			struct NetworkInfo info;
			SMsgAVIoctrlGetCameraNetStatusResp *q=(SMsgAVIoctrlGetCameraNetStatusResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETNETSTATUS_REQ OK\n\n");

			GetNetworkInfo(&info);

			sprintf(q->ipAddress,"%d.%d.%d.%d",info.IPaddr[0],info.IPaddr[1],info.IPaddr[2],info.IPaddr[3]);
			sprintf(q->gateway,"%d.%d.%d.%d",info.Gateway[0],info.Gateway[1],info.Gateway[2],info.Gateway[3]);
			sprintf(q->mask,"%d.%d.%d.%d",info.Netmask[0],info.Netmask[1],info.Netmask[2],info.Netmask[3]);
			sprintf(q->MAC,"%d-%d-%d-%d-%d-%d",uiMACAddr[0],uiMACAddr[1],uiMACAddr[2],uiMACAddr[3],uiMACAddr[4],uiMACAddr[5]);
			sprintf(q->UID,"%s",gUID);

			DEBUG_P2P("IP=%s\n",q->ipAddress);
			DEBUG_P2P("Netmask=%s\n",q->mask);
			DEBUG_P2P("Gateway=%s\n",q->gateway);
			DEBUG_P2P("MAC=%s\n",q->MAC);
			DEBUG_P2P("UID=%s\n",q->UID);

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_GETNETSTATUS_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETNETSTATUS_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETNETSTATUS_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetCameraNetStatusResp);

			SMsgAVIoctrlSetCameraNetStatusReq *p=(SMsgAVIoctrlSetCameraNetStatusReq *)buf;
			SMsgAVIoctrlSetCameraNetStatusResp *q=(SMsgAVIoctrlSetCameraNetStatusResp *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETNETSTATUS_REQ OK\n\n");





			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_SETNETSTATUS_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETNETSTATUS_RESP OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETLED_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetLEDResq);

			SMsgAVIoctrlGetLEDResq *q=(SMsgAVIoctrlGetLEDResq *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETLED_REQ OK\n\n");

			gpioGetLevel(0, 31, &LED_level);

			q->status = LED_level;

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_GETLED_RESQ, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETLED_RESQ OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_SETLED_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlSetLEDResq);

			SMsgAVIoctrlSetLEDReq *p=(SMsgAVIoctrlSetLEDReq *)buf;
			SMsgAVIoctrlSetLEDResq *q=(SMsgAVIoctrlSetLEDResq *)buf;

			DEBUG_P2P("IOTYPE_WALMART_SETLED_REQ OK\n\n");

			q->result = !(gpioSetLevel(0, 31, p->status));

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_SETLED_RESQ, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_SETLED_RESQ OK\n\n");
			}
		}
		break;

		case IOTYPE_WALMART_GETPLAYBACKFPS_REQ:
		{
			SMsgAVIoctrlGetPlayBackFPSReq *p=(SMsgAVIoctrlGetPlayBackFPSReq *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETPLAYBACKFPS_REQ OK:%d\n\n",p->FPS);

//			app_report_fps = p->FPS;
		}
		break;
#endif
		case IOTYPE_WALMART_GETCAMERASTASUS_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetCameraStatusResp);
			SMsgAVIoctrlGetCameraStatusReq *p = (SMsgAVIoctrlGetCameraStatusReq *)buf;
			SMsgAVIoctrlGetCameraStatusResp *q=(SMsgAVIoctrlGetCameraStatusResp *)buf;

			
    u8 value[4]; 
    u8 i, result;
DEBUG_P2P("IOTYPE_WALMART_GETCAMERASTASUS_REQ %d %d OK\n\n",  p->channel, gRfiu_Op_Sta[p->channel]);
    for (i = 0;i < 4; i++)
    {
			if (gRfiu_Op_Sta[i] == RFIU_RX_STA_LINK_OK)
				value[i] = 1;
			else
				value[i] = 0;

    }

    q->channel1[0] = value[0];
    q->channel2[0] = value[1];
    q->channel3[0] = value[2];
    q->channel4[0] = value[3];
			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_GETCAMERASTASUS_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_WALMART_GETCAMERASTASUS_RESP OK\n\n");
			}
		}
		break;
//--------------------Home Automation testing--------------------------------------------------------------
#if (HOME_RF_SUPPORT == 1)
// HA cmdcmdBz

        case IOTYPE_HA_JASON_CMD_REQ:
        {
		char msg[1024];
		DEBUG_P2P("IOTYPE_HA_JASON_CMD_REQ OK\n");

		//DEBUG_GREEN("%s\n",buf);
		
            result = JSONCmdHandleEvent(buf, msg);

	     //20181204 PAIRLtask^RESP

		if(result == 0) //PAIR mode
		{
			gPairAvIndex = avIndex;
			break;
		}

		if(result == 1)
		{
			//DEBUG_YELLOW("strlen(buf)2:%d, %s\n",strlen(buf), buf);

	            if(avSendIOCtrl(avIndex, IOTYPE_HA_JASON_CMD_RESP, (char*)buf, strlen(buf))== AV_ER_NoERROR)
	                        DEBUG_P2P("IOTYPE_HA_JASON_CMD_RESP OK\n\n");
		}
		else
		{
			//DEBUG_BLUE("strlen(buf):%d, %s\n",strlen(msg), msg);

	            if(avSendIOCtrl(avIndex, IOTYPE_HA_JASON_CMD_RESP, (char*)&msg, strlen(msg))== AV_ER_NoERROR)
	                        DEBUG_P2P("IOTYPE_HA_JASON_CMD_RESP OK\n\n");
		}
		memset(buf, 0, 1024);
        }
        break;
		
#elif 0//(HOME_RF_SUPPORT)

            
        case IOTYPE_USER_GETSENSORLST_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetSensorLstResp);
            SMsgAVIoctrlGetSensorLstReq *p = (SMsgAVIoctrlGetSensorLstReq *)buf;
            SMsgAVIoctrlGetSensorLstResp *q=(SMsgAVIoctrlGetSensorLstResp *)buf;

#if sensor_test
            sysAppGetSensorList(q,0);
#else
            q->nCount=3;
            q->nStartIdx=0;
            q->nTotalCount=3;
            q->sSensors[0].bytePushAlarm=1;
            q->sSensors[0].byteBattery=100;
            q->sSensors[0].byteStatus= mrss_Normal;
            q->sSensors[0].byteType= mrst_Door;
            q->sSensors[0].nSensorID=11;
            q->sSensors[0].byteSirenAlarm=1;
            q->sSensors[0].data.door.nIsOpen=1;
            q->sSensors[0].byteIsHealthType=0;
            strcpy (q->sSensors[0].szName,"test_door");

            q->sSensors[1].bytePushAlarm=1;
            q->sSensors[1].byteBattery=100;
            q->sSensors[1].byteStatus= mrss_Normal;
            q->sSensors[1].byteType= mrst_PIR;
            q->sSensors[1].nSensorID=12;
            q->sSensors[1].byteIsHealthType=0;
            strcpy (q->sSensors[1].szName,"test_pir");

            q->sSensors[2].bytePushAlarm=1;
            q->sSensors[2].byteBattery=100;
            q->sSensors[2].byteStatus= mrss_Normal;
            q->sSensors[2].byteType= mrst_Temperature;
            q->sSensors[2].nSensorID=13;
            q->sSensors[2].byteSirenAlarm=1;
            q->sSensors[2].byteIsHealthType=0;
            q->sSensors[2].data.tp.nTemperature=0x1D05;
            q->sSensors[2].data.tp.nHigh=0x3200;
            q->sSensors[2].data.tp.nLow=0x0500;
            q->sSensors[2].data.tp.nAlarmSwitch = 0x3;
            strcpy (q->sSensors[2].szName,"test_temperature");
#endif
            DEBUG_P2P("GETSENSORLST_REQ OK \n");

            if(avSendIOCtrl(avIndex, IOTYPE_USER_GETSENSORLST_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETSENSORLST_RESP OK\n\n");
            }
            if(q->nTotalCount > MAXSENSOR_NUM_ONCE)
            {
                for(i = 0; i < (q->nTotalCount)/(MAXSENSOR_NUM_ONCE+1); i++)
                {
                    sysAppGetSensorList(q,i+1);
                    if(avSendIOCtrl(avIndex, IOTYPE_USER_GETSENSORLST_RESP, (char*)q, size)== AV_ER_NoERROR)
                        DEBUG_P2P("GETSENSORLST_RESP_%d OK\n\n",i+2);
                }
            }
        }
        break;

        case IOTYPE_USER_SETADDSENSOR_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetAddSensorResp);
            SMsgAVIoctrlSetAddSensorReq *p = (SMsgAVIoctrlSetAddSensorReq *)buf;
            SMsgAVIoctrlSetAddSensorResp *q=(SMsgAVIoctrlSetAddSensorResp *)buf;
            gPairAvIndex = avIndex;
            DEBUG_P2P("SETADDSENSOR_REQ OK \n");
#if sensor_test
            sysAppEnterPairMode();
#else
            q->result=0;
            q->sSensor.nSensorID=100+sensor_id_add;
            sensor_id_add++;
            q->sSensor.bytePushAlarm=1;
            q->sSensor.byteBattery=100;
            q->sSensor.byteStatus=1;
            q->sSensor.byteType=0;
            q->sSensor.data.door.nIsOpen=1;
            if(avSendIOCtrl(avIndex, IOTYPE_USER_SETADDSENSOR_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETADDSENSOR_RESP OK\n\n");
            }
#endif
        }
        break;

        case IOTYPE_USER_SETEDITSENSOR_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetEditSensorResp);
            SMsgAVIoctrlSetEditSensorReq *p = (SMsgAVIoctrlSetEditSensorReq *)buf;
            SMsgAVIoctrlSetEditSensorResp *q=(SMsgAVIoctrlSetEditSensorResp *)buf;

            DEBUG_P2P("SETEDITSENSOR_REQ OK \n");

#if sensor_test
            q->result = sysAppEditSensor(p);
#else
            q->result=0;
#endif

            DEBUG_P2P("\nEdit SENSOR: %d %d,%d,%d,%d,%x,%s\n",p->sSensor.byteSirenAlarm,p->sSensor.bytePushAlarm,p->sSensor.byteBattery,p->sSensor.byteStatus,p->sSensor.byteType,p->sSensor.nSensorID,p->sSensor.szName);
            if(avSendIOCtrl(avIndex, IOTYPE_USER_SETEDITSENSOR_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETEDITSENSOR_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_SETDELSENSOR_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetDelSensorResp);
            SMsgAVIoctrlSetDelSensorReq *p = (SMsgAVIoctrlSetDelSensorReq *)buf;
            SMsgAVIoctrlSetDelSensorResp *q=(SMsgAVIoctrlSetDelSensorResp *)buf;

            DEBUG_P2P("SETDELSENSOR_REQ OK \n");
#if sensor_test
            q->result = sysAppDeleteSensor(p);
            UpdateAPPSensorListStatus();
#else
            q->result=0;
#endif
            if(avSendIOCtrl(avIndex, IOTYPE_USER_SETDELSENSOR_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETDELSENSOR_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_GETROOMLST_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetRoomLstResp);
            SMsgAVIoctrlGetRoomLstReq *p = (SMsgAVIoctrlGetRoomLstReq *)buf;
            SMsgAVIoctrlGetRoomLstResp *q=(SMsgAVIoctrlGetRoomLstResp *)buf;

            DEBUG_P2P("GETROOMLST_REQ OK \n");

#if room_test
            sysAppGetRoomList(q,0);
            //if(q->nTotalCount == 0)
#else
            q->nCount=2;
            q->nStartIdx=0;
            q->nTotalCount=2;
            q->sRooms[0].nRoomID=33;
            q->sRooms[0].nSensorCount=3;
            strcpy(q->sRooms[0].szName,"Living room");
            q->sRooms[0].nSensors[0]=11;
            q->sRooms[0].nSensors[1]=12;
            q->sRooms[0].nSensors[2]=13;

            q->sRooms[1].nRoomID=34;
            q->sRooms[1].nSensorCount=2;
            strcpy(q->sRooms[1].szName,"Bed room");
            q->sRooms[1].nSensors[0]=12;
            q->sRooms[1].nSensors[1]=13;
#endif
            DEBUG_P2P("\nGET ROOM : %d, %d, %d \n",q->nCount,q->nStartIdx,q->nTotalCount);

            if(avSendIOCtrl(avIndex, IOTYPE_USER_GETROOMLST_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETROOMLST_RESP OK\n\n");
            }
            if(q->nTotalCount > MAXROOM_NUM_ONCE)
            {
                for(i = 0; i < (q->nTotalCount)/(MAXROOM_NUM_ONCE+1); i++)
                {
                    sysAppGetRoomList(q,i+1);
                    if(avSendIOCtrl(avIndex, IOTYPE_USER_GETROOMLST_RESP, (char*)q, size)== AV_ER_NoERROR)
                        DEBUG_P2P("GETROOMLST_RESP_%d OK\n\n",i+2);
                }
            }
        }
        break;

        case IOTYPE_USER_SETADDROOM_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetAddRoomResp);
            SMsgAVIoctrlSetAddRoomReq *p = (SMsgAVIoctrlSetAddRoomReq *)buf;
            SMsgAVIoctrlSetAddRoomResp *q=(SMsgAVIoctrlSetAddRoomResp *)buf;

            DEBUG_P2P("SETADDROOM_REQ OK \n");
            DEBUG_P2P("\nSET ADD ROOM : %d, %d, %d, %s\n",p->sRoom.nRoomID,p->sRoom.nSensorCount,p->sRoom.nSensors[0],p->sRoom.szName);

#if room_test
            q->sRoom.nRoomID = sysAppAddRoom(p);
            UpdateAPPRoomListStatus();
            if(q->sRoom.nRoomID == 0)
                q->sRoom.nRoomID = -1; //sW WLjRoomq
#else
            q->sRoom.nRoomID=100+room_id_add;
            room_id_add++;
#endif
            DEBUG_P2P("q->sRoom.nRoomID = 0x%x\n",q->sRoom.nRoomID);
            if(avSendIOCtrl(avIndex, IOTYPE_USER_SETADDROOM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETADDROOM_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_SETEDITROOM_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetEditRoomResp);
            SMsgAVIoctrlSetEditRoomReq *p = (SMsgAVIoctrlSetEditRoomReq *)buf;
            SMsgAVIoctrlSetEditRoomResp *q=(SMsgAVIoctrlSetEditRoomResp *)buf;

            DEBUG_P2P("SETEDITROOM_REQ OK \n");

#if room_test
            q->result = sysAppEditRoom(p);
            UpdateAPPRoomListStatus();
#else
            q->result=0;
#endif
            if(avSendIOCtrl(avIndex, IOTYPE_USER_SETEDITROOM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETEDITROOM_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_SETDELROOM_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetDelRoomResp);
            SMsgAVIoctrlSetDelRoomReq *p = (SMsgAVIoctrlSetDelRoomReq *)buf;
            SMsgAVIoctrlSetDelRoomResp *q=(SMsgAVIoctrlSetDelRoomResp *)buf;

            DEBUG_P2P("SETDELROOM_REQ OK \n");
#if room_test
            q->result = sysAppDeleteRoom(p);
            UpdateAPPRoomListStatus();
#else
            q->result=0;
#endif
            if(avSendIOCtrl(avIndex, IOTYPE_USER_SETDELROOM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETDELROOM_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_GETIPCAMSUPPORT_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetIPCamSupportResp);
            SMsgAVIoctrlGetIPCamSupportReq *p = (SMsgAVIoctrlGetIPCamSupportReq *)buf;
            SMsgAVIoctrlGetIPCamSupportResp *q=(SMsgAVIoctrlGetIPCamSupportResp *)buf;

            DEBUG_P2P("GETIPCAMSUPPORT_REQ OK \n");
            q->nIsSupport=1;
            if(avSendIOCtrl(avIndex, IOTYPE_USER_GETIPCAMSUPPORT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETIPCAMSUPPORT_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_GETSENSOR_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetSensorResp);
            SMsgAVIoctrlGetSensorReq *p = (SMsgAVIoctrlGetSensorReq *)buf;
            SMsgAVIoctrlGetSensorResp *q= (SMsgAVIoctrlGetSensorResp *)buf;

            DEBUG_P2P("GETSENSOR_REQ OK \n");
#if sensor_test
            sysAppGetSensor(p->nSensorID,q);
#else
            if(p->nSensorID == 11)
            {
                q->sSensor.nSensorID = p->nSensorID;
                q->sSensor.byteStatus= mrss_Normal;
                q->sSensor.byteType= mrst_Door;
                q->sSensor.data.door.nIsOpen=1;
                strcpy(q->sSensor.szName,"test_door");
                q->result=0;
            }
            else if(p->nSensorID == 12)
            {
                q->sSensor.nSensorID = p->nSensorID;
                q->sSensor.byteStatus= mrss_Normal;
                q->sSensor.byteType= mrst_PIR;
                strcpy(q->sSensor.szName,"test_pir");
                q->result=0;
            }
            else if(p->nSensorID == 13)
            {
                q->sSensor.nSensorID = p->nSensorID;
                q->sSensor.byteStatus= mrss_Normal;
                q->sSensor.byteType= mrst_Temperature;
                q->sSensor.data.tp.nTemperature=0x1D05;
                q->sSensor.data.tp.nHigh=0x3200;
                q->sSensor.data.tp.nLow=0x0500;
                q->sSensor.data.tp.nAlarmSwitch = 0x3;
                strcpy(q->sSensor.szName,"test_temperature");
                q->result=0;
            }
            else
                return;
            q->sSensor.bytePushAlarm=1;
            q->sSensor.byteBattery=100;
#endif
            if(avSendIOCtrl(avIndex, IOTYPE_USER_GETSENSOR_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETSENSOR_RESP OK\n\n");
            }
        }
        break;



        case IOTYPE_USER_GETSENSORLOG_REQ:
        {
            u8 idx;
            int size =  sizeof(SMsgAVIoctrlGetSensorLogResp);
            SMsgAVIoctrlGetSensorLogReq *p = (SMsgAVIoctrlGetSensorLogReq *)buf;
            SMsgAVIoctrlGetSensorLogResp *q= (SMsgAVIoctrlGetSensorLogResp *)buf;

            DEBUG_P2P("GETSENSORLOG_REQ OK \n");

            idx=sysGetUISensorListIdx(p->nSensorID);

#if CDVR_iHome_LOG_SUPPORT
            sysAppGetSensorLog(p->nSensorID,q,p->nStartIdx);
#endif

            if(avSendIOCtrl(avIndex, IOTYPE_USER_GETSENSORLOG_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETSENSORLOG_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_GETSCENCELST_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetSceneLstResp);
            SMsgAVIoctrlGetSceneLstReq *p = (SMsgAVIoctrlGetSceneLstReq *)buf;
            SMsgAVIoctrlGetSceneLstResp *q= (SMsgAVIoctrlGetSceneLstResp *)buf;

            sysAppGetSceneList(q,0);

            if(avSendIOCtrl(avIndex, IOTYPE_USER_GETSCENCELST_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETSCENCELST_RESP OK\n\n");
            }
            if(q->nTotalCount > MAXSCENE_NUM_ONCE)
            {
                for(i = 0; i < (q->nTotalCount)/(MAXSCENE_NUM_ONCE+1); i++)
                {
                    sysAppGetSceneList(q,i+1);
                    if(avSendIOCtrl(avIndex, IOTYPE_USER_GETSCENCELST_RESP, (char*)q, size)== AV_ER_NoERROR)
                        DEBUG_P2P("GETSCENCELST_RESP_%d OK\n\n",i+2);
                }
            }
        }
        break;

        case IOTYPE_USER_SETADDSCENEHEAD_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetAddSceneHeadResp);
            SMsgAVIoctrlSetAddSceneHeadReq *p = (SMsgAVIoctrlSetAddSceneHeadReq *)buf;
            SMsgAVIoctrlSetAddSceneHeadResp *q= (SMsgAVIoctrlSetAddSceneHeadResp *)buf;

            q->sScene.nSceneID = sysAppAddScene(p);
            UpdateAPPSceneListStatus();
            //if(p->sScene.nSceneID != -1)
            //    break;

            DEBUG_P2P("SETADDSCENEHEAD_REQ OK \n");

            if(avSendIOCtrl(avIndex, IOTYPE_USER_SETADDSCENEHEAD_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETADDSCENEHEAD_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_GETSCENE_REQ:
        {
            int GetSceneID;
            int size =  sizeof(SMsgAVIoctrlGetSceneResp);
            SMsgAVIoctrlGetSceneReq *p = (SMsgAVIoctrlGetSceneReq *)buf;
            SMsgAVIoctrlGetSceneResp *q= (SMsgAVIoctrlGetSceneResp *)buf;

            DEBUG_P2P("GETSCENE_REQ OK \n");

            GetSceneID = p->nSceneID;
            sysAppGetScene(GetSceneID,q,0);

            if(avSendIOCtrl(avIndex, IOTYPE_USER_GETSCENE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETSCENE_RESP OK\n\n");
            }
            if(q->nTotalCount > MAXSENSOR_NUM_ONCE)
            {
                for(i = 0; i < (q->nTotalCount)/MAXSENSOR_NUM_ONCE; i++)
                {
                    sysAppGetScene(GetSceneID,q,i+1);
                    if(avSendIOCtrl(avIndex, IOTYPE_USER_GETSCENE_RESP, (char*)q, size)== AV_ER_NoERROR)
                        DEBUG_P2P("GETSCENE_RESP_%d OK\n\n",i+2);
                }
            }
        }
        break;

        case IOTYPE_USER_SETEDITSCENEHEAD_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetEditSceneHeadResp);
            SMsgAVIoctrlSetEditSceneHeadReq *p = (SMsgAVIoctrlSetEditSceneHeadReq *)buf;
            SMsgAVIoctrlSetEditSceneHeadResp *q= (SMsgAVIoctrlSetEditSceneHeadResp *)buf;

            DEBUG_P2P("SETEDITSCENEHEAD_REQ OK \n");

            q->result = sysAppEditSceneName(p);
            UpdateAPPSceneListStatus();

            if(avSendIOCtrl(avIndex, IOTYPE_USER_SETEDITSCENEHEAD_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETEDITSCENEHEAD_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_SETEDITSCENE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetEditSceneResp);
            SMsgAVIoctrlSetEditSceneReq *p = (SMsgAVIoctrlSetEditSceneReq *)buf;
            SMsgAVIoctrlSetEditSceneResp *q= (SMsgAVIoctrlSetEditSceneResp *)buf;

            DEBUG_P2P("SETEDITSCENE_REQ OK \n");

            q->result = sysAppEditScene(p,0);
            UpdateAPPSceneListStatus();
            if(avSendIOCtrl(avIndex, IOTYPE_USER_SETEDITSCENE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETEDITSCENE_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_SETDELSCENE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetDelSceneResp);
            SMsgAVIoctrlSetDelSceneReq *p = (SMsgAVIoctrlSetDelSceneReq *)buf;
            SMsgAVIoctrlSetDelSceneResp *q= (SMsgAVIoctrlSetDelSceneResp *)buf;

            DEBUG_P2P("SETDELSCENE_REQ OK \n");

            q->result = sysAppDeleteScene(p);
            UpdateAPPSceneListStatus();

            if(avSendIOCtrl(avIndex, IOTYPE_USER_SETDELSCENE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETDELSCENE_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_PLAYSCENE_REQ:
        {
            int size = sizeof(SMsgAVIoctrlPlaySceneResp);
            SMsgAVIoctrlPlaySceneReq *p = (SMsgAVIoctrlPlaySceneReq *)buf;
            SMsgAVIoctrlPlaySceneResp *q= (SMsgAVIoctrlPlaySceneResp *)buf;

            DEBUG_P2P("PLAYSCENE_REQ OK \n");

            q->result = sysAppExecuteScene(p->nSceneID);

            if(avSendIOCtrl(avIndex, IOTYPE_USER_PLAYSCENE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("PLAYSCENE_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_IPCAM_VERIFYVERSION_REQ:
        {
            int size = sizeof(SMsgAVIoctrlVerifyVersionResp);
            SMsgAVIoctrlVerifyVersionReq *p = (SMsgAVIoctrlVerifyVersionReq *)buf;
            SMsgAVIoctrlVerifyVersionResp *q= (SMsgAVIoctrlVerifyVersionResp *)buf;

            DEBUG_P2P("IPCAM_VERIFYVERSION_REQ OK \n");

            if(p->version[0] == APPversion_IOS[0])
            {
                if(p->version[4] == APPversion_IOS[4])
                {
                    q->result = 0;
                }
                else if(p->version[4] < APPversion_IOS[4])
                {
                    q->result = 1;
                }
                else if(p->version[4] > APPversion_IOS[4])
                {
                    q->result = 2;
                }
            }
            if(p->version[0] == APPversion_AND[0])
            {
                if(p->version[4] == APPversion_AND[4])
                {
                    q->result = 0;
                }
                else if(p->version[4] < APPversion_AND[4])
                {
                    q->result = 1;
                }
                else if(p->version[4] > APPversion_AND[4])
                {
                    q->result = 2;
                }
            }

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_VERIFYVERSION_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_VERIFYVERSION_RESP OK\n\n");
            }
        }
        break;
#endif /*#if (HOME_RF_SUPPORT)*/
//--------------------

#if APP_KEEP_ALIVE
        /*===============================KEEP ALIVE==================================*/
        case IOTYPE_USER_IPCAM_KEEPALIVE_REQ:
        {
            DEBUG_P2P("IPCAM_KEEPALIVE_REQ:%d OK \n",SID);
            gFlagKeepAlive[SID] = 1;
            switch(SID)
            {
                case 0:
                    RTC_Get_Time(&gKeepAliveTime0);
                    break;
                case 1:
                    RTC_Get_Time(&gKeepAliveTime1);
                    break;
                case 2:
                    RTC_Get_Time(&gKeepAliveTime2);
                    break;
                case 3:
                    RTC_Get_Time(&gKeepAliveTime3);
                    break;
                case 4:
                	RTC_Get_Time(&gKeepAliveTime4);
                    break;
                default:
                    break;
            }
        }
        break;
            /*===============================KEEP ALIVE==================================*/
#endif
#if(UI_VERSION == UI_VERSION_MAYON)
#if  RFIU_RX_WAKEUP_TX_SCHEME
        case IOTYPE_USER_IPCAM_GET_TX_TYPE_REQ:
        {
            int size = sizeof(SMsgAVIoctrlGetCameraTypeResp);
            SMsgAVIoctrlGetCameraTypeReq *p = (SMsgAVIoctrlGetCameraTypeReq *)buf;
            SMsgAVIoctrlGetCameraTypeResp *q= (SMsgAVIoctrlGetCameraTypeResp *)buf;

            DEBUG_P2P("IPCAM_GET_TX_TYPE_REQ OK \n");

//			q->channel = p->channel;//In the same buf, dont need to set.		// Add by Paul for APP check batterycam channel, 180508

			q->CameraType 	= gRfiuUnitCntl[p->channel].RFpara.BateryCam_support;

			q->BatteryLevel = gRfiuUnitCntl[p->channel].RFpara.TxBatteryLev;

			if(q->BatteryLevel > 3)
				q->BatteryLevel = 3;

			if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_TX_TYPE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_GET_TX_TYPE_RESP OK\n\n");
            }

        }
        break;
#endif


        case IOTYPE_USER_IPCAM_CHECK_TX_ALARM_REQ:
        {
            int size = sizeof(SMsgAVIoctrlGetAlarmSupportResp);
            SMsgAVIoctrlGetAlarmSupportReq *p = (SMsgAVIoctrlGetAlarmSupportReq *)buf;
            SMsgAVIoctrlGetAlarmSupportResp *q= (SMsgAVIoctrlGetAlarmSupportResp *)buf;

            DEBUG_P2P("IPCAM_CHECK_TX_ALARM_REQ OK \n");

//			q->channel = p->channel;//In the same buf, dont need to set.

			q->alarmsupport	= uiGetSuptAlarmAPP(p->channel);

			if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_CHECK_TX_ALARM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_CHECK_TX_ALARM_RESP OK\n\n");
            }

        }
        break;

        case IOTYPE_USER_IPCAM_GET_TX_ALARM_REQ:
        {
            int size = sizeof(SMsgAVIoctrlGetCameraAlarmResp);
            SMsgAVIoctrlGetCameraAlarmReq *p = (SMsgAVIoctrlGetCameraAlarmReq *)buf;
            SMsgAVIoctrlGetCameraAlarmResp *q= (SMsgAVIoctrlGetCameraAlarmResp *)buf;

            DEBUG_P2P("IPCAM_GET_TX_ALARM_REQ OK \n");

            q->switch_value= uiGetAlarmOnOffAPP(p->channel);
			q->AlarmStatus = uiGetAlarmStatusAPP(p->channel);

			if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_TX_ALARM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_GET_TX_ALARM_RESP OK\n\n");
            }

        }
        break;


        case IOTYPE_USER_IPCAM_SET_TX_ALARM_REQ:
        {
            int size = sizeof(SMsgAVIoctrlSetCameraAlarmResp);
            SMsgAVIoctrlSetCameraAlarmReq *p = (SMsgAVIoctrlSetCameraAlarmReq *)buf;
            SMsgAVIoctrlSetCameraAlarmResp *q= (SMsgAVIoctrlSetCameraAlarmResp *)buf;

            DEBUG_P2P("IPCAM_SET_TX_ALARM_REQ OK \n");

			if(p->switch_value)	//ON
			{
				uiSetAlarmOnOffAPP(p->channel, 1);
				uiSetAlarmStatusAPP(p->channel, p->AlarmStatus);
			}
			else	//OFF
			{
				uiSetAlarmOnOffAPP(p->channel, 0);
			}

			q->result = 0;

			if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_SET_TX_ALARM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_SET_TX_ALARM_RESP OK\n\n");
            }

        }
        break;

        case IOTYPE_USER_IPCAM_CHECK_SUPPORT_PIR_REQ:
        {
            int size = sizeof(SMsgAVIoctrlCheckSupportPIRResp);
			SMsgAVIoctrlCheckSupportPIRReq *p= (SMsgAVIoctrlCheckSupportPIRReq *)buf;
            SMsgAVIoctrlCheckSupportPIRResp *q= (SMsgAVIoctrlCheckSupportPIRResp *)buf;

            DEBUG_P2P("IPCAM_CHECK_SUPPORT_PIR_REQ OK \n");

//			q->channel = p->channel;//In the same buf, dont need to set.

			q->PIRsupport = 1;	//Always ON.

			if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_CHECK_SUPPORT_PIR_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_CHECK_SUPPORT_PIR_RESP OK\n\n");
            }

        }
        break;

        case IOTYPE_USER_IPCAM_GET_PIR_VALUE_REQ:
        {
            int size = sizeof(SMsgAVIoctrlGetCameraPIRResp);
            SMsgAVIoctrlGetCameraPIRReq *p = (SMsgAVIoctrlGetCameraPIRReq *)buf;
            SMsgAVIoctrlGetCameraPIRResp *q= (SMsgAVIoctrlGetCameraPIRResp *)buf;

            DEBUG_P2P("IPCAM_GET_PIR_VALUE_REQ OK \n");

			q->value = uiGetMotionStatusAPP(p->channel);

			if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_PIR_VALUE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_GET_PIR_VALUE_RESP OK\n\n");
            }

        }
        break;


        case IOTYPE_USER_IPCAM_SET_PIR_VALUE_REQ:
        {
            int size = sizeof(SMsgAVIoctrlSetCameraPIRResp);
            SMsgAVIoctrlSetCameraPIRReq *p = (SMsgAVIoctrlSetCameraPIRReq *)buf;
            SMsgAVIoctrlSetCameraPIRResp *q= (SMsgAVIoctrlSetCameraPIRResp *)buf;

            DEBUG_P2P("IPCAM_SET_PIR_VALUE_REQ OK \n");

			uiSetMotionStatusAPP(p->channel, p->value);

			if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_SET_PIR_VALUE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_SET_PIR_VALUE_RESP OK\n\n");
            }

        }
        break;


		case IOTYPE_USER_IPCAM_CHECK_SUPPORT_LIGHT_REQ:
		{
			int size = sizeof(SMsgAVIoctrlCheckSupportLightResp);
			SMsgAVIoctrlCheckSupportLightReq *p = (SMsgAVIoctrlCheckSupportLightReq *)buf;
			SMsgAVIoctrlCheckSupportLightResp *q= (SMsgAVIoctrlCheckSupportLightResp *)buf;

			DEBUG_P2P("IPCAM_CHECK_SUPPORT_LIGHT_REQ OK \n");

//			q->channel = p->channel;//In the same buf, dont need to set.

			q->Lightsupport = uiGetSuptLightAPP(p->channel);

			if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_CHECK_SUPPORT_LIGHT_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IPCAM_CHECK_SUPPORT_LIGHT_RESP OK\n\n");
			}

		}
		break;

		case IOTYPE_USER_IPCAM_GET_TX_LIGHT_REQ:
		{
			int size = sizeof(SMsgAVIoctrlGetCameraLightResp);
			SMsgAVIoctrlGetCameraLightReq *p = (SMsgAVIoctrlGetCameraLightReq *)buf;
			SMsgAVIoctrlGetCameraLightResp *q= (SMsgAVIoctrlGetCameraLightResp *)buf;

			DEBUG_P2P("IPCAM_GET_TX_LIGHT_REQ OK \n");

			q->switch_value = uiGetLightOnOffAPP(p->channel);
			q->value = uiGetLightStatusAPP(p->channel);

			if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_TX_LIGHT_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IPCAM_GET_TX_LIGHT_RESP OK\n\n");
			}

		}
		break;


		case IOTYPE_USER_IPCAM_SET_TX_LIGHT_REQ:
		{
			int size = sizeof(SMsgAVIoctrlSetCameraLightResp);
			SMsgAVIoctrlSetCameraLightReq *p = (SMsgAVIoctrlSetCameraLightReq *)buf;
			SMsgAVIoctrlSetCameraLightResp *q= (SMsgAVIoctrlSetCameraLightResp *)buf;

			DEBUG_P2P("IPCAM_SET_TX_LIGHT_REQ OK \n");

			if(p->switch_value)	//ON
			{
				uiSetLightOnOffAPP(p->channel, 1);
				uiSetLightStatusAPP(p->channel, p->value);
			}
			else	//OFF
			{
				uiSetLightOnOffAPP(p->channel, 0);
			}
			q->result = 0;

			if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_SET_TX_LIGHT_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IPCAM_SET_TX_LIGHT_RESP OK\n\n");
			}

		}
		break;
		case IOTYPE_USER_IPCAM_GET_TX_ALL_INFO_REQ:
		{//This flow move to IOTYPE_USER_IPCAM_START execute, for liveview speed up.
		//Comment add by Paul at 181019
			int size = sizeof(SMsgAVIoctrlTxAllInfoResp);
			SMsgAVIoctrlGetTxAllInfoReq *p = (SMsgAVIoctrlGetTxAllInfoReq *)buf;
			SMsgAVIoctrlTxAllInfoResp *q= (SMsgAVIoctrlTxAllInfoResp *)buf;

			DEBUG_P2P("IOTYPE_USER_IPCAM_GET_TX_ALL_INFO_REQ OK \n");

//			q->channel 	= p->channel;		// Add by Paul for APP check batterycam channel, 180508
			q->CameraType 	= gRfiuUnitCntl[p->channel].RFpara.BateryCam_support;
			q->BatteryLevel = gRfiuUnitCntl[p->channel].RFpara.TxBatteryLev;
			if(q->BatteryLevel > 3)
				q->BatteryLevel = 3;
			q->alarmsupport	= uiGetSuptAlarmAPP(p->channel);
			q->Lightsupport = uiGetSuptLightAPP(p->channel);
			q->PIRsupport = 1;	//Always ON.

			if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_TX_ALL_INFO_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_USER_IPCAM_GET_TX_ALL_INFO_RESP OK\n\n");
			}
		}
		break;
#endif
        case IOTYPE_USER_IPCAM_START:
        {
            if(gClientInfo[SID].playBackCh==0)
            {
                u8 delay_count = 20;
                SMsgAVIoctrlAVStream *p = (SMsgAVIoctrlAVStream *)buf;
                #if(UI_VERSION == UI_VERSION_MAYON)
                //Add by Paul at 180829 for liveview speed up, copy from IOTYPE_USER_IPCAM_GET_TX_ALL_INFO_RESP
                int size = sizeof(SMsgAVIoctrlTxAllInfoResp);
                SMsgAVIoctrlTxAllInfoResp *q= (SMsgAVIoctrlTxAllInfoResp *)buf;
                #endif
                DEBUG_P2P("IPCAM_START[%d:%d]\n", SID, avIndex);
                regedit_client_to_avsession(SID, avIndex);
                regedit_client_to_video(SID);
                gClientInfo[SID].VOLSend=0;
                for(i=0; i<MAX_AV_CH; i++)
                {
                    if(gClientInfo[SID].avIndex[i] == gClientInfo[SID].avChannel)
                    {
                        CurrentCH=i;

                        #if(UI_VERSION == UI_VERSION_MAYON)
				//Add by Paul at 180829 for liveview speed up, copy from IOTYPE_USER_IPCAM_GET_TX_ALL_INFO_RESP
                // Add by Paul at 180828 for liveview speed up
                        q->CameraType 	= gRfiuUnitCntl[CurrentCH].RFpara.BateryCam_support;
                        q->BatteryLevel = gRfiuUnitCntl[CurrentCH].RFpara.TxBatteryLev;
                        if(q->BatteryLevel > 3)
                        	q->BatteryLevel = 3;
                        q->alarmsupport	= uiGetSuptAlarmAPP(CurrentCH);//Modify by Paul for wrong channel, 2018.10.12
                        q->Lightsupport = uiGetSuptLightAPP(CurrentCH);
                        q->PIRsupport = 1;//Always On
                        q->channel 	= CurrentCH;
                        if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_TX_ALL_INFO_RESP, (char*)q, size)== AV_ER_NoERROR)
                        {
                        	DEBUG_P2P("IOTYPE_USER_IPCAM_GET_TX_ALL_INFO_RESP OK\n\n");
                        }
                        #endif

        				#if RFIU_RX_WAKEUP_TX_SCHEME
						while((gAppWakeCamflag & ~(0x01 << CurrentCH)) && delay_count--)//wait 20 tick(20*50ms==1sec) to send TX sleep CMD
							OSTimeDly(1);//Set TxType sended bit for online SID
						if(delay_count <= 0)
							DEBUG_P2P("[BTC] Wait sleep timeout...0x%X\n", gAppWakeCamflag);

        				if ((rfiuRX_CamSleep_Sta & (0x01 << CurrentCH))
										&& (gRfiuUnitCntl[CurrentCH].RFpara.BateryCam_support) // Add by Paul when Battery cam changed to normal cam.
										&& (SysCamOnOffFlag & (0x01 << CurrentCH)))  // Add by Paul to filter disabled cam wakeup.
                        {
        					DEBUG_P2P("Wakeup TX Channel[%d]\n", CurrentCH);
        					gRfiuUnitCntl[CurrentCH].WakeUpTxEn=1;
        				    gAppWakeCamflag |= (0x01 << CurrentCH);

							sysSetBTCTimer(CurrentCH, sysGetBTCWakeTime());		//Add by Paul for clear state when app triggered, 180508
							sysSetBTCWakeStatus(CurrentCH,SYS_BTC_WAKEUP_APP,TRUE); //Paul add for UI, 180507

        				}
        				#endif
                        h264header_updata[SID]=0;
                        if(gFirstConnect==0)
                        {
                            struct st_SInfo Sinfo;

                            ret = IOTC_Session_Check(SID, &Sinfo);
                            //gFirstConnect=1;

                            for(i=0; i<MAX_AV_CH; i++)
                            {
#if LAN_VGA_30FPS
                                if(Sinfo.Mode!=2)	// The connection mode is not LAN.
                                {
                                    DEBUG_P2P("Set VGA to 10 FPS.\n");
                                    uiSetP2PImageLevel(i,2);// Set the video quality to level 2 when P2P client connected.
                                }
                                else
                                {
                                    DEBUG_P2P("Set VGA to 15 FPS.\n");
                                    uiSetP2PImageLevel(i,4);// Set the video quality to level 4 when P2P client connected.
                                }
#else
                                DEBUG_P2P("Set QHD .\n");
                                uiSetP2PImageLevel(i,2);// Set the video quality to level 2 when P2P client connected.
#endif
                            }
                            OSTimeDly(1);
                        }
                        else
                        {
                            uiSetP2PImageLevel(i,6);
                        }

#if(HW_BOARD_OPTION == MR8211_ZINWELL)
                        Start_P2P_Session(CurrentCH, Local_record);
#else
                        Start_P2P_Session(CurrentCH, RX_receive);
#endif

                        if( sysCameraMode == SYS_CAMERA_MODE_RF_RX_QUADSCR )
                        {
                        #if( (SW_APPLICATION_OPTION  ==  MR9300_RFDVR_RX1RX2) || (SW_APPLICATION_OPTION == MR9300_NETBOX_RX1RX2) )

                        #else
                          #if RFRX_HALF_MODE_SUPPORT
                            if(rfiuRX_CamOnOff_Num <= 2)
                            {
                                if(sysTVOutOnFlag)
                                    iduPlaybackMode(RF_RX_2DISP_WIDTH*2,RF_RX_2DISP_HEIGHT+RFRX_HALF_MODE_SHIFT_TV*2,RF_RX_2DISP_WIDTH*2);
                                else
                                    iduPlaybackMode(RF_RX_2DISP_WIDTH*2,RF_RX_2DISP_HEIGHT+RFRX_HALF_MODE_SHIFT*2,RF_RX_2DISP_WIDTH*2);
                            }
                            else
                          #endif
                                iduPlaybackMode(RF_RX_2DISP_WIDTH*2,RF_RX_2DISP_HEIGHT*2,RF_RX_2DISP_WIDTH*2);
                        #endif
                            if(sysTVOutOnFlag)
                            {
                                tvTVE_INTC = TV_INTC_BOTFDSTART_ENA;
                            }
                            else
                            {
                                IduIntCtrl |= IDU_FTCINT_ENA;
                            }
                            //printf("[PAUL]|\n");
                        }

                    }
                }
            }
        }
        break;
        case IOTYPE_USER_IPCAM_STOP:
        {
            if(gClientInfo[SID].playBackCh==0)
            {
                SMsgAVIoctrlAVStream *p = (SMsgAVIoctrlAVStream *)buf;

                DEBUG_P2P("IPCAM_STOP[%d:%d-P-Ch %d]\n", SID, avIndex, p->channel);


				#if RFIU_RX_WAKEUP_TX_SCHEME
				//Correct the sleep channel of stop from app, Add by Paul 2018.08.28
                sysSetBTCWakeStatus(p->channel,SYS_BTC_WAKEUP_APP,FALSE);
				if(gRfiuUnitCntl[p->channel].WakeUpTxEn == 1)
				   gRfiuUnitCntl[p->channel].WakeUpTxEn = 0;
				else
				   rfiuCamSleepCmd(p->channel);

				#endif

                if(gClientInfo[SID].bEnableSpeaker>0)
                    Kill_Task_Speaker(SID);
                if(gOnlineNum<=0)
                {
                    gOnlineNum=0;
                    gFirstConnect=0;
                }

                unregedit_client_from_video(SID);

                for(i=0; i<MAX_AV_CH; i++)
                {
                    if(gClientInfo[SID].avIndex[i] == gClientInfo[SID].avChannel)
                        Stop_P2P_Session(i);
                }
            }
        }
        break;
        case IOTYPE_USER_IPCAM_AUDIOSTART:
        {
            if(gClientInfo[SID].playBackCh==0)
            {
                SMsgAVIoctrlAVStream *p = (SMsgAVIoctrlAVStream *)buf;
                DEBUG_P2P("IPCAM_AUDIOSTART[%d:%d]\n", p->channel, avIndex);
                regedit_client_to_audio(SID);
                if(gClientInfo[SID].bEnableSpeaker>0)
                    Kill_Task_Speaker(SID);
            }
        }
        break;
        case IOTYPE_USER_IPCAM_AUDIOSTOP:
        {
            if(gClientInfo[SID].playBackCh==0)
            {
                SMsgAVIoctrlAVStream *p = (SMsgAVIoctrlAVStream *)buf;
                DEBUG_P2P("IPCAM_AUDIOSTOP[%d:%d]\n", p->channel, avIndex);
                unregedit_client_from_audio(SID);
            }
        }
        break;

        case IOTYPE_USER_IPCAM_GETSUPPORTSTREAM_REQ:
        {
            unsigned short i;
            int index;
            int size = sizeof(int) + (sizeof(SStreamDef)*MAX_AV_CH);
            int ret;
            int nResend;

            SMsgAVIoctrlGetSupportStreamResp *p = (SMsgAVIoctrlGetSupportStreamResp *)buf;
            DEBUG_P2P("IPCAM_GETSUPPORTSTREAM_REQ \n\n");

            //ahre 20130801
            if(gClientInfo[SID].getsupportstream==1)
                return;

            gClientInfo[SID].getsupportstream=1;
            p->number = MAX_AV_CH;

            for(i=0; i<MAX_AV_CH; i++)
            {
                p->streams[i].index = i;
                p->streams[i].channel = i;
            }
            DEBUG_P2P("set support Multi-CH\n\n\n");
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GETSUPPORTSTREAM_RESP, (char *)p, size) == AV_ER_NoERROR)
            {
                for(i=1; i<MAX_AV_CH; i++)
                {
                    DEBUG_P2P("enable CH%d\n",i);
#if(UI_VERSION == UI_VERSION_MAYON)//Modify for relay mode connection lose issue. Add by Paul 2018.08.28
                    ret=avServStart(SID, "admin", gP2PPassword, 20, SERVTYPE_STREAM_SERVER, i);
#else
                    ret=avServStart(SID, "admin", gP2PPassword, 10, SERVTYPE_STREAM_SERVER, i);
#endif
                    //ret = avServStart3(SID, AuthCallBackFn,10, SERVTYPE_STREAM_SERVER, i, &nResend);
                    if(ret < 0)
                    {
                        DEBUG_P2P("avServStart failed SID[%d] code[%d]!!!\n", SID, ret);
                        IOTC_Session_Close(SID);
                        return;
                    }
                    gClientInfo[SID].avIndex[i]=ret;
                    //avServSetResendSize(gClientInfo[SID].avIndex[i],64);
                    DEBUG_P2P("@@ avServStart OK SID[%d] idx[%d]\n", SID, gClientInfo[SID].avIndex[i]);
                }
                if(gRfiuUnitCntl[sysRFRxInMainCHsel].TX_PicWidth > RF_RX_2DISP_WIDTH*2) //eRFresolution
                {
                    rfiuRX_P2pVideoQuality = 1;
                }
                else
                {
                    rfiuRX_P2pVideoQuality = 2;
                }
            }
        }
        break;

        case IOTYPE_USER_IPCAM_GETPASSWORD_REQ:
        {
            SMsgAVIoctrlGetPasswdReq *p= (SMsgAVIoctrlGetPasswdReq *)buf;
            SMsgAVIoctrlGetPasswdResp *q= (SMsgAVIoctrlGetPasswdResp *)buf;
            int size=sizeof(SMsgAVIoctrlGetPasswdResp);

            DEBUG_P2P("IPCAM_GETPASSWORD_REQ\n");
            memcpy(q->passwd,UI_P2P_PSW,UI_P2P_PSW_MAX_LEN);
            DEBUG_P2P("Get PW:%s\n",UI_P2P_PSW);
            avSendIOCtrl(avIndex,IOTYPE_USER_IPCAM_GETPASSWORD_RESP, (char *) q, size);

        }
        break;
        case IOTYPE_USER_IPCAM_SETPASSWORD_REQ:
        {
            SMsgAVIoctrlSetPasswdReq *p= (SMsgAVIoctrlSetPasswdReq *)buf;
            SMsgAVIoctrlSetPasswdResp *q= (SMsgAVIoctrlSetPasswdResp *)buf;
            int size=sizeof(SMsgAVIoctrlSetPasswdResp);
            DEBUG_P2P("IPCAM_SETPASSWORD_REQ\n");
            strcpy(gP2PPassword,p->newpasswd);
            DEBUG_P2P("New password = %s\n",gP2PPassword);
            uiSetP2PPassword(gP2PPassword);

            q->result=0;
            avSendIOCtrl(avIndex,IOTYPE_USER_IPCAM_SETPASSWORD_RESP, (char *) q, size);

        }
        break;
#if 1
        case IOTYPE_USER_IPCAM_GET_VIDEOMODE_REQ: //v
        {
            int size = (sizeof(SStreamDef)*MAX_AV_CH);
            SMsgAVIoctrlGetVideoModeResp *p = (SMsgAVIoctrlGetVideoModeResp *)buf;

            DEBUG_P2P("IPIDEOMODE_REQ\n\n");
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_VIDEOMODE_RESP, (char *)p, size) == AV_ER_NoERROR)
            {
                DEBUG_P2P("orl video mode=%d \n\n",p->mode);
                DEBUG_P2P("IPCAM_GET_VIDEOMODE OK \n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_VIDEOMODE_REQ: //v
        {
            int size = sizeof(SMsgAVIoctrlSetStreamCtrlResp);
            //aher
            SMsgAVIoctrlSetVideoModeReq *p = (SMsgAVIoctrlSetVideoModeReq *)buf;
            SMsgAVIoctrlSetStreamCtrlResp *q = (SMsgAVIoctrlSetStreamCtrlResp *)buf;
            DEBUG_P2P(" video mode=%d \n\n",p->mode);
            DEBUG_P2P("IPCAM_SET_VIDEOMODE_REQ\n\n");
            q->result=0xEA;
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_SET_VIDEOMODE_RESP, (char *)q, size) == AV_ER_NoERROR)
            {
                DEBUG_P2P("video mode result=%d \n\n",q->result);
                DEBUG_P2P("IPCAM_SET_VIDEOMODE_RESP OK \n\n");
            }
        }
        break;
#endif
#if 1
        case IOTYPE_USER_IPCAM_GET_ENVIRONMENT_REQ: //?
        {
            int size = sizeof(SMsgAVIoctrlGetEnvironmentResp);
            unsigned char mode;
            SMsgAVIoctrlGetEnvironmentReq *p = (SMsgAVIoctrlGetEnvironmentReq *)buf;
            SMsgAVIoctrlGetEnvironmentResp *q = (SMsgAVIoctrlGetEnvironmentResp*)buf;

            DEBUG_P2P("IPCAM_GET_ENVIRONMENT_REQ\n\n");
            if(sysGetFrequency(p->channel,&mode)<0)
            {
                DEBUG_P2P("GET ENVIRONMENT Fail!! \n");
                q->mode=255;
            }
            else
            {
                DEBUG_P2P("GET ENVIRONMENT OK!! \n");
                q->mode=mode;
            }
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_ENVIRONMENT_RESP, (char *)p, size) == AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_GET_ENVIRONMENT_REQ OK \n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_ENVIRONMENT_REQ: //?
        {
            int size = sizeof(SMsgAVIoctrlSetEnvironmentResp);
            SMsgAVIoctrlSetEnvironmentReq *p = (SMsgAVIoctrlSetEnvironmentReq *)buf;
            SMsgAVIoctrlSetEnvironmentResp *q = (SMsgAVIoctrlSetEnvironmentResp*)buf;

            DEBUG_P2P("IPCAM_SET_ENVIRONMENT_REQ OK \n");

            if(sysSetFrequency(p->channel,p->mode)<0)
            {
                DEBUG_P2P("SET ENVIRONMENT Fail!! \n");
                q->result=-1;
            }
            else
            {
                DEBUG_P2P("SET ENVIRONMENT OK!! \n");
                q->result=0;
            }
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_SET_FREQUENCY_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_SET_ENVIRONMENT_RESP OK\n\n");
            }
        }
        break;
#endif
#if 1
        case IOTYPE_USER_IPCAM_GETSTREAMCTRL_REQ: //T~ get
        {
            int size = sizeof(int) + (sizeof(SStreamDef)*MAX_AV_CH);
            SMsgAVIoctrlGetStreamCtrlResq *p = (SMsgAVIoctrlGetStreamCtrlResq *)buf;
            DEBUG_P2P("IPCAM_GETSTREAMCTRL_REQ\n\n");
            p->quality=videoquality;
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GETSTREAMCTRL_RESP, (char *)p, size) == AV_ER_NoERROR)
            {
                DEBUG_P2P("orl STREAMCTRL level =%d \n\n",p->quality);
                DEBUG_P2P("IPCAM_GETSTREAMCTRL_REQ OK \n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SETSTREAMCTRL_REQ: //T~ set. Set the resoultion to 720P/VGA/QVGA
        {
#if ((HW_BOARD_OPTION == MR8202A_RX_TARNWO_D8530)||(HW_BOARD_OPTION == A1025A_EVB_axviwe))

				int size = sizeof(SMsgAVIoctrlSetStreamCtrlResp);
				int i;
				SMsgAVIoctrlSetStreamCtrlReq *p = (SMsgAVIoctrlSetStreamCtrlReq *)buf;
				SMsgAVIoctrlSetStreamCtrlResp *q = (SMsgAVIoctrlSetStreamCtrlResp *)buf;
				DEBUG_P2P("STREAMCTRL level =%d \n\n",p->quality);
				DEBUG_P2P("IOTYPE_IPCAM_SETSTREAMCTRL_REQ\n\n");

				q->result=0;
				for (i = 0; i < MAX_RFIU_UNIT; i++)
					iconflag[UI_MENU_SETIDX_RESOLUTION_CH1+i] = p->quality;
                uiSentKeyToUi(UI_KEY_CAM_RESOLUTION);

#else
            int size = sizeof(SMsgAVIoctrlSetStreamCtrlResp);
            int i;
            SMsgAVIoctrlSetStreamCtrlReq *p = (SMsgAVIoctrlSetStreamCtrlReq *)buf;
            SMsgAVIoctrlSetStreamCtrlResp *q = (SMsgAVIoctrlSetStreamCtrlResp *)buf;
            DEBUG_P2P("STREAMCTRL level =%d \n\n",p->quality);
            DEBUG_P2P("IPCAM_SETSTREAMCTRL_REQ\n\n");

            q->result=0;
            if (p->quality==1)
            {
                videoquality=1;
                gFirstConnect=1;
                DEBUG_P2P("Set TX resoultion to FHD");
                for (i = 0; i < MAX_RFIU_UNIT; i++)
                    uiSetP2PImageLevel(i,1);

            }
            else if (p->quality==2)
            {
                struct st_SInfo Sinfo;

                ret = IOTC_Session_Check(SID, &Sinfo);
                DEBUG_P2P("Set TX resoultion to VGA ");
                videoquality=2;
                gFirstConnect=1;
                for (i = 0; i < MAX_RFIU_UNIT; i++)
                {
#if LAN_VGA_30FPS
                    if(Sinfo.Mode!=2)
                    {
                        DEBUG_P2P("10 FPS.\n");
                        uiSetP2PImageLevel(i,2);
                    }
                    else
                    {
                        DEBUG_P2P("15 FPS.\n");
                        uiSetP2PImageLevel(i,4);
                    }
#else
                    DEBUG_P2P("10 FPS.\n");
                    uiSetP2PImageLevel(i,2);
#endif
                }
            }
            else if (p->quality==3)
            {
                DEBUG_P2P("Set TX resoultion to QVGA(H).\n");
                videoquality=3;
                gFirstConnect=1;
                for (i = 0; i < MAX_RFIU_UNIT; i++)
                    uiSetP2PImageLevel(i,3);
            }
            else if (p->quality==4)
            {
                DEBUG_P2P("Set TX resoultion to QVGA(M).\n");
                videoquality=4;
                gFirstConnect=1;
                for (i = 0; i < MAX_RFIU_UNIT; i++)
                    uiSetP2PImageLevel(i,4);
            }
            else if (p->quality==5)
            {
                DEBUG_P2P("Set TX resoultion to QVGA(L).\n");
                videoquality=5;
                gFirstConnect=1;
                for (i = 0; i < MAX_RFIU_UNIT; i++)
                    uiSetP2PImageLevel(i,5);

            }
            else
            {
                DEBUG_P2P("Set TX resoultion Fail.\n");
                q->result=0x01;
            }

            if( sysCameraMode == SYS_CAMERA_MODE_RF_RX_QUADSCR )
            {
                if(rfiuRX_OpMode & RFIU_RX_OPMODE_QUAD)
                {
                #if( (SW_APPLICATION_OPTION == MR9300_RFDVR_RX1RX2) || (SW_APPLICATION_OPTION == MR9200_MIXCAM_RX1RX2) || (SW_APPLICATION_OPTION == MR9300_NETBOX_RX1RX2) )
                    //Idu_ClearQuadBuf();
                #else
                    DEBUG_P2P("memset_hw_Word(p2p_1)\n");
                    Idu_ClearBuf(DISPLAY_BUF_NUM);
                #endif
                }

            #if( (SW_APPLICATION_OPTION == MR9300_RFDVR_RX1RX2) || (SW_APPLICATION_OPTION == MR9300_NETBOX_RX1RX2) )

            #else
              #if RFRX_HALF_MODE_SUPPORT
                if(rfiuRX_CamOnOff_Num <= 2)
                {
                    if(sysTVOutOnFlag)
                        iduPlaybackMode(RF_RX_2DISP_WIDTH*2,RF_RX_2DISP_HEIGHT+RFRX_HALF_MODE_SHIFT_TV*2,RF_RX_2DISP_WIDTH*2);
                    else
                        iduPlaybackMode(RF_RX_2DISP_WIDTH*2,RF_RX_2DISP_HEIGHT+RFRX_HALF_MODE_SHIFT*2,RF_RX_2DISP_WIDTH*2);
                }
                else
              #endif
                    iduPlaybackMode(RF_RX_2DISP_WIDTH*2,RF_RX_2DISP_HEIGHT*2,RF_RX_2DISP_WIDTH*2);
            #endif

                if(sysTVOutOnFlag)
                {
                    tvTVE_INTC = TV_INTC_BOTFDSTART_ENA;
                    iduTVOSDEnable(IDU_OSD_L0_WINDOW_0);
                }
                else
                {
                    IduIntCtrl |= IDU_FTCINT_ENA;
                }
            }
#endif
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_SETSTREAMCTRL_RESP, (char *)q, size) == AV_ER_NoERROR)
            {
                DEBUG_P2P("STREAMCTRL level result =%d \n\n",q->result);
                DEBUG_P2P("IPCAM_SETSTREAMCTRL_RESP OK \n\n");
                rfiuRX_P2pVideoQuality = (videoquality == 1) ? 1 : 2; //1:FHD, 2:HD/QHD
                DEBUG_P2P("update resolution 1:FHD, 2:HD/QHD rfiuRX_P2pVideoQuality %d\n", rfiuRX_P2pVideoQuality);
            }
        }
        break;
#endif

#if 0
        case IOTYPE_USER_IPCAM_LISTWIFIAP_REQ: // WIFI
        {

            int size = sizeof(int) + (sizeof(SStreamDef)*MAX_AV_CH);
            SMsgAVIoctrlListWifiApResp *p = (SMsgAVIoctrlListWifiApResp*)buf;

            DEBUG_P2P("IPCAM_LISTWIFIAP_REQ\n\n");
            DEBUG_P2P("WIFI.ssid=%d\n",p->stWifiAp->ssid);
            DEBUG_P2P("WIFI.mode=%d\n",p->stWifiAp->mode);
            DEBUG_P2P("WIFI.enctype=%d\n",p->stWifiAp->enctype);
            DEBUG_P2P("WIFI.signal=%d\n",p->stWifiAp->signal);
            DEBUG_P2P("WIFI.status=%d\n",p->stWifiAp->status);

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_LISTWIFIAP_RESP, (char *)p, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_LISTWIFIAP_RESP OK \n\n");
            }
        }
        break;
#endif

#if 1
        case IOTYPE_USER_IPCAM_GETMOTIONDETECT_REQ: // get
        {

            int size =sizeof(SMsgAVIoctrlGetMotionDetectResp);
            u8 cam;
            u8 isEnable;
            u8 sensitivity;
            SMsgAVIoctrlGetMotionDetectReq *p = (SMsgAVIoctrlGetMotionDetectReq *)buf;
            SMsgAVIoctrlGetMotionDetectResp *q = (SMsgAVIoctrlGetMotionDetectResp *)buf;


            DEBUG_P2P("IPCAM_GETMOTIONDETECT_REQ\n\n");
            sysGet_MotionEnable(p->channel,&isEnable, &sensitivity,&sensitivity);
            if(!isEnable)
                q->sensitivity=0;
            else
                q->sensitivity=sensitivity;
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GETMOTIONDETECT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GETMOTIONDETECT_RESP OK:channel:%d, sensitivity:%d\n\n",q->channel,q->sensitivity);
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SETMOTIONDETECT_REQ: // set
        {

            int size =sizeof(SMsgAVIoctrlSetMotionDetectResp);
            int sensitivity;
            int isEnable;
            SMsgAVIoctrlSetMotionDetectReq *p = (SMsgAVIoctrlSetMotionDetectReq *)buf;
            SMsgAVIoctrlSetMotionDetectResp *q = (SMsgAVIoctrlSetMotionDetectResp *)buf;

            DEBUG_P2P("IPCAM_SETMOTIONDETECT_REQ: channel:%d, sensitivity:%d\n\n",p->channel,p->sensitivity);
            if(p->sensitivity!=0)
                isEnable=1;
            else
                isEnable=0;
            if(!sysSet_MotionEnable(p->channel,isEnable, p->sensitivity,p->sensitivity))
            {
                DEBUG_P2P("USER_IPCAM_SET_SENSITIVITY Fail!! \n");
            }
            else
            {
                DEBUG_P2P("USER_IPCAM_SET_SENSITIVITY OK!! \n");
            }

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_SETMOTIONDETECT_RESP, (char *)q, size) == AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_SETMOTIONDETECT_RESP OK \n\n");
            }
        }
        break;
#endif

        case IOTYPE_USER_IPCAM_PTZ_COMMAND: // PTZ
        {
            int size = sizeof(int) + (sizeof(SStreamDef)*MAX_AV_CH);
            SMsgAVIoctrlPtzCmd *p = (SMsgAVIoctrlPtzCmd *)buf;

            DEBUG_P2P("IPCAM_PTZ_COMMAND\n\n");
            DEBUG_P2P("PTZ=%d\n",p->control);

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_PTZ_COMMAND, (char *)p, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_PTZ_COMMAND OK \n\n");
            }
        }
        break;

        case IOTYPE_USER_IPCAM_GETRECORD_REQ: //v get
        {
            int size =  sizeof(SMsgAVIoctrlGetRecordResq);
            unsigned int mode;
            SMsgAVIoctrlGetRecordReq *p = (SMsgAVIoctrlGetRecordReq *)buf;
            SMsgAVIoctrlGetRecordResq *q = (SMsgAVIoctrlGetRecordResq *)buf;

            DEBUG_P2P("IPCAM_GETRECORD_REQ \n\n");
            if(sysGetRecordMode(&mode)<0)
            {
                DEBUG_P2P("GETRECORD Fail!!\n");
                q->recordType=-1;
            }
            else
            {
                DEBUG_P2P("GETRECORD OK!!\n");
                q->recordType=mode;
            }
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GETRECORD_RESP, (char *)p, size) == AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_GETRECORD_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_IPCAM_SETRECORD_REQ: //v set
        {
            int size =  sizeof(SMsgAVIoctrlSetRecordResp);

            SMsgAVIoctrlSetRecordReq *p = (SMsgAVIoctrlSetRecordReq *)buf;
            SMsgAVIoctrlSetRecordResp *q = (SMsgAVIoctrlSetRecordResp *)buf;
            DEBUG_P2P("IPCAM_SETRECORD_REQ \n\n");
            DEBUG_P2P(" mode =%d \n\n",p->recordType);
            if(sysSetRecordMode(p->recordType)<0)
            {
                DEBUG_P2P("SETRECORD Fail!!\n");
                q->result=-1;
            }
            else
            {
                DEBUG_P2P("SETRECORD OK!!\n");
                q->result=1;
            }
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_SETRECORD_RESP, (char *)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_SETRECORD_RESP OK\n\n");
                DEBUG_P2P(" mode result =%d \n\n",p->recordType);
            }
        }
        break;

        case IOTYPE_USER_IPCAM_SPEAKERSTART:
        {
            DEBUG_P2P("IPCAM_SPEAKERSTART:%d\n",CurrentCH);
            if(gSpeakerSID <= 0)
            {
                SMsgAVIoctrlAVStream *p = (SMsgAVIoctrlAVStream *)buf;
                gClientInfo[SID].speakerCh = p->channel;
                gSpeakerSID = SID;
                regedit_client_to_speaker(SID, avIndex);
                rfiu_AudioRetONOFF_APP(1,CurrentCH);
                if(OSTaskCreate(Task_Speaker, (void *)CurrentCH, SPEAKER_TASK_STACK, SPEAKER_TASK_PRIORITY) != OS_NO_ERR)
                {
                    DEBUG_P2P("OSTaskCreate Task_Speaker failed!!!!!!!!!!!!!!!!!!!\n");
                    return;
                }
            }

        }
        break;

        case IOTYPE_USER_IPCAM_SPEAKERSTOP:
        {
            DEBUG_P2P("IPCAM_SPEAKERSTOP\n");
            if(gClientInfo[SID].bEnableSpeaker>0)
            {
                Kill_Task_Speaker(SID);
            }
            /*
            unregedit_client_from_speaker(SID);
            rfiu_AudioRetONOFF_APP(0,CurrentCH);
            avClientStop(SpeakerAvIndex);
            gSpeakerSID=-1;
            OSTaskDel(SPEAKER_TASK_PRIORITY);
            */
        }
        break;

        case IOTYPE_USER_IPCAM_GETAUDIOOUTFORMAT_REQ:
        {
            int size = sizeof(int) + sizeof(SMsgAVIoctrlGetAudioOutFormatResp);

            //SMsgAVIoctrlGetAudioOutFormatReq *p = (SMsgAVIoctrlGetAudioOutFormatReq *)buf;
            SMsgAVIoctrlGetAudioOutFormatResp *q = (SMsgAVIoctrlGetAudioOutFormatResp *)buf;

            //DEBUG_P2P("aher channel=%d\n",q->channel);
            DEBUG_P2P("IPCAM_GETAUDIOOUTFORMAT_REQ\n");
            q->format=0x8C;
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GETAUDIOOUTFORMAT_RESP, (char *)q, size) == AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_GETAUDIOOUTFORMAT_RESP OK \n\n");
            }
        }
        break;

        case IOTYPE_USER_IPCAM_RECEIVE_FIRST_IFRAME:
        {
            gClientInfo[SID].VOLSend = 1;
            DEBUG_P2P("IPCAM_RECEIVE_FIRST_IFRAME[%d:%d] OK \n", SID, avIndex);
        }
        break;

        case IOTYPE_USER_IPCAM_DEVINFO_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlDeviceInfoResp);
            //unsigned char model[16]="---";
            unsigned char vendor[16]="---";
            unsigned int version=0x01020304;
            FS_DISKFREE_T *diskInfo;
            u16 total_size=0;
            u16 usage_size=0;
            u16 remain_size=0;
            //SMsgAVIoctrlDeviceInfoReq *p = (SMsgAVIoctrlDeviceInfoReq *)buf;
            SMsgAVIoctrlDeviceInfoResp *q = (SMsgAVIoctrlDeviceInfoResp *)buf;
            //memset(q,0,size);
            DEBUG_P2P("IPCAM_DEVINFO_REQ OK \n");
            strcpy(q->model,Model_name);
            strcpy(q->vendor,vendor);
            q->version=version;
            //get the SD card information.
#if (HW_BOARD_OPTION == MR8211_ZINWELL)
            if((sysGetStorageStatus(SYS_I_STORAGE_MAIN) == SYS_V_STORAGE_READY)&&(got_disk_info!= 0)&&(MountMode == AVIOCTRL_SDCARD_MOUNT))
#else
            if((sysGetStorageStatus(SYS_I_STORAGE_MAIN) == SYS_V_STORAGE_READY)&&(got_disk_info!= 0))
#endif
            {
                diskInfo=&global_diskInfo;
                total_size=diskInfo->total_clusters*diskInfo->sectors_per_cluster/(1024*2);
                remain_size=diskInfo->avail_clusters*1000/diskInfo->total_clusters;
                usage_size=1000- remain_size;
            }
            else
            {
                total_size=0;
                usage_size=0;
                remain_size=0;
            }
            //DEBUG_P2P("total_size  : %d \n", total_size);
            //DEBUG_P2P("remain_size : %d \n", remain_size);
            //DEBUG_P2P("usage_size  : %d \n", usage_size);
            q->total=total_size;
            q->free=remain_size;
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_DEVINFO_RESP, (char *)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_DEVINFO_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_IPCAM_FORMATEXTSTORAGE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlFormatExtStorageResp);
            SMsgAVIoctrlFormatExtStorageReq *p = (SMsgAVIoctrlFormatExtStorageReq *)buf;
            SMsgAVIoctrlFormatExtStorageResp *q=(SMsgAVIoctrlFormatExtStorageResp *)buf;

            DEBUG_P2P("IPCAM_FORMATEXTSTORAGE_REQ OK \n");
            uiCaptureVideoStop();
#if MULTI_CHANNEL_VIDEO_REC
			while(MultiChannelCheckRecordChannel() != 0)
			{
				OSTimeDly(1);
			}
#endif

            sysSetEvt(SYS_EVT_PLAYBACK_FORMAT, 0);
            q->result=0;

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_FORMATEXTSTORAGE_RESP, (char *)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_FORMATEXTSTORAGE_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_IPCAM_LISTEVENT_REQ:
        {
            SMsgAVIoctrlListEventReq *p = (SMsgAVIoctrlListEventReq *)buf;
            DEBUG_P2P("IPCAM_LISTEVENT_REQ\n");
            gbSearchEvent=0;
            get_recorded_filelist(p,SID,avIndex);
            DEBUG_P2P("IPCAM_LISTEVENT_RESP OK \n\n");
        }
        break;

        case IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL:
        {
            SMsgAVIoctrlPlayRecord *p = (SMsgAVIoctrlPlayRecord *)buf;
            SMsgAVIoctrlPlayRecordResp *q=(SMsgAVIoctrlPlayRecordResp *)buf;
            u8 error;
            u32 *tmp;
            DEBUG_P2P("IPCAM_RECORD_PLAYCONTROL-%d\n",p->command);

            switch (p->command)
            {
                case AVIOCTRL_RECORD_PLAY_START :
                {
                    DEBUG_P2P("AVIOCTRL_RECORD_PLAY_START[%d]\n", SID);
                    #if (HW_BOARD_OPTION == MR9200_RX_TRANWO_D8796P)//Sean: 20171204 add.
                    // Check the file whether is exist or not. prevent app play the wrong file.
                    if(dcfItemExist(dcfPlaybackCurFile->pDirEnt->d_name, "rb") < 0)
                    {
                    	printf("\x1B[96mFileplaying: F:%d, R:%d\x1B[0m\n", Fileplaying, Remote_play);
                    	q->command=p->command;
						q->result = -1;
						if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp)) == AV_ER_NoERROR)
						{
							DEBUG_P2P("IOTYPE_IPCAM_RECORD_PLAYCONTROL_RESP OK \n\n");
						}
						break;
                    }
                    if(Fileplaying)
                    {
                        printf("\x1B[96mFileplaying\x1B[0m\n");
                        q->command=p->command;
                        q->result = -1;
                        if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp)) == AV_ER_NoERROR)
                        {
                            DEBUG_P2P("IOTYPE_IPCAM_RECORD_PLAYCONTROL_RESP OK \n\n");
                        }
                        break;
                    }
                    #endif
#if(UI_VERSION == UI_VERSION_MAYON)
					if((Fileplaying ==1) && (CurrPlaybackSID == SID)  &&  (Remote_play ==1))
					{
						DEBUG_P2P("Skip AVIOCTRL_RECORD_PLAY_START[%d], CurrPlaybackSID= %d\n", SID, CurrPlaybackSID);
						break;
					}
					else if(Remote_play ==0)
					{// That means RX playback.
						CurrPlaybackSID = -1;
					}
#endif
                    Remoteplayback_CH=p->channel;
                    gRemote_playfile=*p;
                    regedit_client_to_video(SID);
                    gClientInfo[SID].bPausePlayBack = 0;
                    gClientInfo[SID].bStopPlayBack = 0;
                    gClientInfo[SID].playBackCh = IOTC_Session_Get_Free_Channel(SID);
                    q->command=p->command;
                    q->result=gClientInfo[SID].playBackCh;
                    gPlaybackSID=SID;
                    P2PEnableplaybackStreaming++;
                    P2PPlaybackVideoStop=0;
                    DEBUG_P2P("Fileplaying= %d,Remote_play= %d \n",Fileplaying,Remote_play);


                    if(Fileplaying)
                    {
                        if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp)) == AV_ER_NoERROR)
                        {
                            DEBUG_P2P("IPCAM_RECORD_PLAYCONTROL_RESP OK \n\n");
                        }
                        Remoteplayback_busy();
                    }
                    else
                    {
                        get_recorded_filelist((SMsgAVIoctrlListEventReq *)p,SID,avIndex);
                        DEBUG_P2P("PLAY FILE: %d/%d/%d %d:%d:%d CH=%d.\n",gRemote_playfile.stTimeDay.year,gRemote_playfile.stTimeDay.month,gRemote_playfile.stTimeDay.day,gRemote_playfile.stTimeDay.hour,gRemote_playfile.stTimeDay.minute,gRemote_playfile.stTimeDay.second,gRemote_playfile.channel);
                        tmp=(u32 *)q->reserved;
                        *tmp=GetVideoDuration(dcfPlaybackCurFile->pDirEnt->d_name)*1000;
                        if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp)) == AV_ER_NoERROR)
                        {
                            DEBUG_P2P("IPCAM_RECORD_PLAYCONTROL_RESP OK \n\n");
                        }
                        Fileplaying=1;
                        Remote_play=1;
                        error=OSTaskCreate(Task_remote_file_playback, (void *)0,P2P_PLAYFILE_TASK_STACK, P2P_PLAYFILE_TASK_PRIORITY);
                        if(error!=OS_NO_ERR)
                            DEBUG_P2P("OSTaskCreate error : %d\n",error);
                    }
                }
                break;
                /*
                case AVIOCTRL_RECORD_PLAY_STOP:
                {
                	u8 err;
                	DEBUG_P2P("AVIOCTRL_RECORD_PLAY_STOP\n");
                	P2PPlaybackVideoStop=1;
                	unregedit_client_from_video(SID);
                	gClientInfo[SID].bStopPlayBack = 1;
                	gClientInfo[SID].bPausePlayBack = 0;
                	OSSemSet(P2PVideoPlaybackCmpSemEvt, 0, &err);
                	OSSemSet(P2PAudioPlaybackCmpSemEvt, 0, &err);
                    DEBUG_P2P("Fileplaying=%d ,Remote_play=%d \n",Fileplaying,Remote_play);
                    if((Fileplaying==1)&&(Remote_play==1))
                    {
                		OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY);
                        Fileplaying=0;
                        Remote_play=0;
#if(UI_VERSION == UI_VERSION_MAYON)
                        gCurPlaybackSID = -1;
#endif
                		P2PEnableplaybackStreaming=0;
                		gClientInfo[SID].playBackCh=-1;

                     }
                	avServStop(gClientInfo[SID].avChannel);
                }
                break;
                */
                case AVIOCTRL_RECORD_PLAY_STOP:
                {
                    u8 err;
                    u8 error;
                    DEBUG_P2P("AVIOCTRL_RECORD_PLAY_STOP[%d]\n", SID);

                    /*
                    P2PEnableplaybackStreaming--;
                    if(P2PEnableplaybackStreaming<0)
                    		P2PEnableplaybackStreaming=0;
                    */
                    DEBUG_P2P("P2PEnableplaybackStreaming333=%d\n",P2PEnableplaybackStreaming);

                    if(gClientInfo[SID].bStopPlayBack<=0)
                    {
                        P2P_check=0;
                        P2PPlaybackVideoStop=1;
#if (UI_VERSION == UI_VERSION_MAYON)
                        CurrPlaybackSID=-1;
#else
                        CurrPlaybackSID=SID;
#endif
                        unregedit_client_from_video(SID);
                        gClientInfo[SID].bStopPlayBack = 1;
                        gClientInfo[SID].bPausePlayBack = 0;
                        avServStop(gClientInfo[SID].avChannel);
                        gClientInfo[SID].playBackCh=0;
						OSSemSet(P2PVideoPlaybackCmpSemEvt, 0, &err);
						if(err!= OS_NO_ERR)
							printf("111Set P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
						OSSemSet(P2PAudioPlaybackCmpSemEvt, 0, &err);
						if(err!= OS_NO_ERR)
							printf("111Set P2PAudioPlaybackCmpSemEvt fail = %d\n", err);
						P2PVideoPlaybackCmpSemEvt = OSSemDel(P2PVideoPlaybackCmpSemEvt, OS_DEL_ALWAYS, &err);
						if(err!= OS_NO_ERR)
							printf("Del P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
						P2PAudioPlaybackCmpSemEvt = OSSemDel(P2PAudioPlaybackCmpSemEvt, OS_DEL_ALWAYS, &err);
						if(err!= OS_NO_ERR)
							printf("Del P2PAudioPlaybackCmpSemEvt fail = %d\n", err);

                        DEBUG_P2P("Fileplaying=%d ,Remote_play=%d \n",Fileplaying,Remote_play);
                        if((Fileplaying)&&(Remote_play==1))
                        {
                            DEBUG_P2P("DELETE P2P PLAYFILE TASK.\n");
                            if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
                                DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
                            OSFlagPend(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_PLAY_FINISH, OS_FLAG_WAIT_CLR_ALL|OS_FLAG_CONSUME, OS_IPC_WAIT_FOREVER, &err);
                            DEBUG_P2P("pend FLAGSYS_RDYSTAT_PLAY_FINISH.\n");
                            if(OS_NO_ERR !=  OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY))
                                DEBUG_P2P("OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");

                            //if(error!=OS_NO_ERR)
                            //DEBUG_P2P("OSTaskDel error : %d\n",error);
                            Fileplaying=0;
                            Remote_play=0;
                            P2PEnableplaybackStreaming=0;
                            //OSTimeDly(10);
                        }
                    }
                    else
                        avServStop(gClientInfo[SID].avChannel);
#if (UI_VERSION == UI_VERSION_MAYON)
					gClientInfo[SID].avChannel = -1; //Clear TX channel when avChannel was stoped, Paul add, 180613
#endif
                }
                break;

                case AVIOCTRL_RECORD_PLAY_PAUSE:
                {
                    DEBUG_P2P("AVIOCTRL_RECORD_PLAY_PAUSE\n");
                    q->command=p->command;
                    q->result=0;
                    if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp)) == AV_ER_NoERROR)
                    {
                        DEBUG_P2P("IPCAM_RECORD_PLAYCONTROL_RESP OK \n\n");
                    }
                    gClientInfo[SID].bPausePlayBack = !gClientInfo[SID].bPausePlayBack;

                    if(gClientInfo[SID].bPausePlayBack)
                        P2PStartPauseTime = OSTimeGet();
                    else
                    {
                        P2PStopPauseTime = OSTimeGet();
                        P2PPauseTime = P2PStopPauseTime-P2PStartPauseTime;
                    }
                }
                break;

               case AVIOCTRL_RECORD_PLAY_DELFILE:
                {
                    DEBUG_P2P("AVIOCTRL_RECORD_PLAY_DELFILE\n");

#if PLAYBACK_FILE_DEL_SUPPORT
	                Remoteplayback_CH=p->channel;
	                gRemote_playfile = *p;
	                
	                q->command=p->command;
	                q->result=0;

					get_recorded_filelist((SMsgAVIoctrlListEventReq *)p,SID,avIndex);
					if(dcfItemExist(dcfPlaybackCurFile->pDirEnt->d_name, "r") < 1)
					{
						q->result = -1;
						DEBUG_P2P("Item Exist chk failed.\n");
					}

					if(dcfPlaybackDel() < 1)
					{
						q->result = -1;
						DEBUG_P2P("Play back Del failed.\n");
					}
#else
                    q->command=p->command;
                    q->result=0;

#endif
                    if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP, (char *)q, sizeof(SMsgAVIoctrlPlayRecordResp)) == AV_ER_NoERROR)
                    {
                        DEBUG_P2P("IPCAM_RECORD_PLAYCONTROL_RESP OK \n\n");
                    }

                }
                break;

            }

        }
        break;
#if(HW_BOARD_OPTION != MR8211_ZINWELL)
        case IOTYPE_USER_IPCAM_GET_FLOWINFO_REQ:
        {
            SMsgAVIoctrlGetFlowInfoReq *p = (SMsgAVIoctrlGetFlowInfoReq *)buf;
            SMsgAVIoctrlGetFlowInfoResp *q = (SMsgAVIoctrlGetFlowInfoResp *)buf;
            DEBUG_P2P("IPCAM_GET_FLOWINFO_REQ OK \n");
        }
        break;
#endif
        case IOTYPE_USER_IPCAM_SET_TIMEZONE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlTimeZone);
            RTC_TIME_ZONE zone;
            SMsgAVIoctrlTimeZone *p = (SMsgAVIoctrlTimeZone *)buf;
            DEBUG_P2P("IPCAM_SET_TIMEZONE_REQ OK \n");
            p->nIsSupportTimeZone=1;
            p->cbSize=size;
            strcpy(timezone_des,p->szTimeZoneString);
            (p->nGMTDiff>0)?(zone.operator=0):(zone.operator=1);
            zone.hour=abs(p->nGMTDiff/60);
            zone.min=abs(p->nGMTDiff%60);
            DEBUG_P2P("Set TimeZone.hour:%d, min:%d\n",zone.hour,zone.min);
            RTC_Set_TimeZone(&zone);
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_SET_TIMEZONE_RESP, (char *)p, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_SET_TIMEZONE_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_GET_TIMEZONE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlTimeZone);
            RTC_TIME_ZONE zone;
            //char timezone_des[256]="Taiwan";

            SMsgAVIoctrlTimeZone *q = (SMsgAVIoctrlTimeZone *)buf;
            DEBUG_P2P("IPCAM_GET_TIMEZONE_REQ OK \n");
            RTC_Get_TimeZone(&zone);
            q->cbSize=size;
            zone.operator?(q->nGMTDiff=(0-zone.hour*60+zone.min)):(q->nGMTDiff=zone.hour*60+zone.min);
            DEBUG_P2P("Get TimeZone= %d minutes\n",q->nGMTDiff);
            q->nIsSupportTimeZone=1;
            strcpy(q->szTimeZoneString,timezone_des);
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_TIMEZONE_RESP, (char *)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_GET_TIMEZONE_RESP OK\n\n");
            }
        }
        break;
///////////////////////////////////////////////////////////

        case IOTYPE_USER_IPCAM_GET_SCHEDULESETTING_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetScheduleSettingResp);
            int cam,hour;
            u8 pdata;

            SMsgAVIoctrlGetScheduleSettingReq *p = (SMsgAVIoctrlGetScheduleSettingReq *)buf;
            SMsgAVIoctrlGetScheduleSettingResp *q = (SMsgAVIoctrlGetScheduleSettingResp *)buf;

            DEBUG_P2P("IPCAM_GET_SCHEDULESETTING_REQ OK \n");

            for(cam=0; cam<=3; cam++)
            {

                for(hour=0; hour<=23; hour++)
                {
                    sysGet_Schedule((u8)cam, (u8)p->dayOfWeek, (u8)hour, &pdata);
                    q->dayOfWeek=p->dayOfWeek;
                    q->rec[hour][cam]=pdata;
                    if(q->rec[hour][cam]==1)
                        DEBUG_P2P("day:%d, rec[%d][%d]=%d\n",q->dayOfWeek,hour,cam,pdata);
                }

            }
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_SCHEDULESETTING_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_GET_SCHEDULESETTING_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_USER_IPCAM_SET_SCHEDULESETTING_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlSetScheduleSettingResp);
            int cam,day,hour;
            SMsgAVIoctrlSetScheduleSettingReq *p = (SMsgAVIoctrlSetScheduleSettingReq *)buf;
            SMsgAVIoctrlSetScheduleSettingResp *q = (SMsgAVIoctrlSetScheduleSettingResp *)buf;

            DEBUG_P2P("IPCAM_SET_SCHEDULESETTING_REQ OK \n");

            for(cam=0; cam<=3; cam++)
            {
                for(day=0; day<=6; day++)
                {
                    for(hour=0; hour<=23; hour++)
                    {
                        if(p->channel[cam]==1 && p->week[day]==1 && p->hour[hour]==1)
                        {
                            if(!sysSet_Schedule((u8)cam, (u8)day, (u8)hour, (u8)p->isSet))
                                DEBUG_P2P("USER_IPCAM_SET_SCHEDULESETTING Fail!! \n");
                            else
                                DEBUG_P2P("USER_IPCAM_SET_SCHEDULESETTING OK!! CH:%d, Day:%d, Hour:%d, isSet:%d\n",(u8)cam, (u8)day, (u8)hour, (u8)p->isSet);
                        }
                    }
                }
            }

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_SET_SCHEDULESETTING_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_SET_SCHEDULESETTING_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_GET_OVERWRITING_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetOverWritingResp);
            u8 isOverWriting;
            SMsgAVIoctrlGetOverWritingReq *p = (SMsgAVIoctrlGetOverWritingReq *)buf;
            SMsgAVIoctrlGetOverWritingResp *q = (SMsgAVIoctrlGetOverWritingResp *)buf;

            DEBUG_P2P("IPCAM_GET_OVERWRITING_REQ OK \n");

            sysGet_Overwrite(&isOverWriting);
            if(isOverWriting==0)
                q->isOverWriting=1;
            else if(isOverWriting==1)
                q->isOverWriting=0;
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_OVERWRITING_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GET_OVERWRITING_RESP: channel:%d, isOverWriting:%d \n\n",q->channel,isOverWriting);
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_OVERWRITING_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlSetOverWritingResp);
            int tmp;
            SMsgAVIoctrlSetOverWritingReq *p = (SMsgAVIoctrlSetOverWritingReq *)buf;
            SMsgAVIoctrlSetOverWritingResp *q = (SMsgAVIoctrlSetOverWritingResp *)buf;

            DEBUG_P2P("IPCAM_SET_OVERWRITING_REQ OK: channel:%d, isOverWriting:%d \n",p->channel,p->isOverWriting);
            if(p->isOverWriting==0)
                tmp=1;
            else if(p->isOverWriting==1)
                tmp=0;
            if(!sysSet_Overwrite(tmp))
            {
                DEBUG_P2P("SET_OVERWRITING Fail!! \n");
            }
            else
            {
                DEBUG_P2P("SET_OVERWRITING OK!! \n");
            }

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_SET_OVERWRITING_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SET_OVERWRITING_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_RECORDINGDURATION_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlSetRecordingDurationResp);

            SMsgAVIoctrlSetRecordingDurationReq *p = (SMsgAVIoctrlSetRecordingDurationReq *)buf;
            SMsgAVIoctrlSetRecordingDurationResp *q = (SMsgAVIoctrlSetRecordingDurationResp *)buf;

            DEBUG_P2P("IPCAM_SET_RECORDINGDURATION_REQ OK: channel:%d, recordingDuration:%d \n",p->channel,p->recordingDuration);
            /*if(!sysSet_Seccion(p->recordingDuration))
            {
            	DEBUG_P2P("SET_RECORDINGDURATION Fail!! \n");
            }
            else
            {
            	DEBUG_P2P("SET_RECORDINGDURATION OK!! \n");
            }*/
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_SET_RECORDINGDURATION_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SET_RECORDINGDURATION_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_GET_RECORDINGDURATION_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetRecordingDurationResp);
            u32 recordingDuration;

            SMsgAVIoctrlGetRecordingDurationReq *p = (SMsgAVIoctrlGetRecordingDurationReq *)buf;
            SMsgAVIoctrlGetRecordingDurationResp *q = (SMsgAVIoctrlGetRecordingDurationResp *)buf;

            DEBUG_P2P("IPCAM_GET_RECORDINGDURATION_REQ OK \n");

            sysGet_Seccion(&recordingDuration);
            //q->recordingDuration=recordingDuration;
            q->recordingDuration=10;
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_RECORDINGDURATION_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GET_RECORDINGDURATION_RESP OK: channel:%d, recordingDuration:%d\n\n",q->channel,recordingDuration);
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_PAIRING_REQ:// 20151127 Sean
        {
            SMsgAVIoctrlSetPairingReq *p = (SMsgAVIoctrlSetPairingReq *)buf;

            DEBUG_P2P("IPCAM_SET_PAIRING_REQ OK: channel:%d, isParing:%d\n",p->channel,p->isParing);

            if(!sysSet_Pair((p->channel)-1))
            {
                DEBUG_P2P("USER_IPCAM_SET_PAIRING Fail!! \n");
            }
            else
            {
                DEBUG_P2P("USER_IPCAM_SET_PAIRING OK!! \n");
            }
        }
        break;
        /*case IOTYPE_USER_IPCAM_GET_PAIRING_REQ:
        {
        	DEBUG_P2P("IPCAM_GET_PAIRING_REQ OK \n");
        }
        break;*/
        case IOTYPE_USER_IPCAM_GET_RECORDINGSETUP_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetRecordingSetupResp);
            u8 isCameraOn;

            SMsgAVIoctrlGetRecordingSetupReq *p = (SMsgAVIoctrlGetRecordingSetupReq *)buf;
            SMsgAVIoctrlGetRecordingSetupResp *q = (SMsgAVIoctrlGetRecordingSetupResp *)buf;

            DEBUG_P2P("IPCAM_GET_RECORDINGSETUP_REQ OK \n");

            sysGet_RecMode(p->channel,&isCameraOn);
            q->isCameraOn=isCameraOn;

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_RECORDINGSETUP_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GET_RECORDINGSETUP_RESP OK: channel:%d, isCameraOn:%d\n\n",q->channel, isCameraOn);
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_RECORDINGSETUP_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlSetRecordingSetupResp);

            SMsgAVIoctrlSetRecordingSetupReq *p = (SMsgAVIoctrlSetRecordingSetupReq *)buf;
            SMsgAVIoctrlSetRecordingSetupResp *q = (SMsgAVIoctrlSetRecordingSetupResp *)buf;

            DEBUG_P2P("IPCAM_SET_RECORDINGSETUP_REQ OK. channel:%d, isCameraOn:%d\n",p->channel, p->isCameraOn);
            if(!sysSet_RecMode(p->channel, p->isCameraOn))
            {
                DEBUG_P2P("USER_IPCAM_SET_RECORDINGSETUP Fail!! \n");
            }
            else
            {
                DEBUG_P2P("USER_IPCAM_SET_RECORDINGSETUP OK!! \n");
            }

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_SET_RECORDINGSETUP_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SET_RECORDINGSETUP_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_BRIGHTNESS_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlSetBrightnessResp);

            SMsgAVIoctrlSetBrightnessReq *p = (SMsgAVIoctrlSetBrightnessReq *)buf;
            SMsgAVIoctrlSetBrightnessResp *q = (SMsgAVIoctrlSetBrightnessResp *)buf;

            DEBUG_P2P("IPCAM_SET_BRIGHTNESS_REQ OK. channel:%d, brightnessValue:%d\n",p->channel, p->brightnessValue);

            if(!sysSet_Brightness(p->channel, p->brightnessValue))
            {
                DEBUG_P2P("USER_IPCAM_SET_BRIGHTNESS Fail!! \n");
            }
            else
            {
                DEBUG_P2P("USER_IPCAM_SET_BRIGHTNESS OK!! \n");
            }

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_SET_BRIGHTNESS_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SET_BRIGHTNESS_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_GET_BRIGHTNESS_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetBrightnessResp);
            u8 brightnessValue;

            SMsgAVIoctrlGetBrightnessReq *p = (SMsgAVIoctrlGetBrightnessReq *)buf;
            SMsgAVIoctrlGetBrightnessResp *q = (SMsgAVIoctrlGetBrightnessResp *)buf;

            DEBUG_P2P("IPCAM_GET_BRIGHTNESS_REQ OK \n");

            sysGet_Brightness(p->channel, &brightnessValue);
            q->brightnessValue=brightnessValue;

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_BRIGHTNESS_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GET_BRIGHTNESS_RESP OK: channel:%d, brightnessValue:%d\n\n",q->channel,brightnessValue);
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_RESOLUTION_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlSetResolutionResp);

            SMsgAVIoctrlSetResolutionReq *p = (SMsgAVIoctrlSetResolutionReq *)buf;
            SMsgAVIoctrlSetResolutionResp *q = (SMsgAVIoctrlSetResolutionResp *)buf;

            DEBUG_P2P("IPCAM_SET_RESOLUTION_REQ OK. channel:%d, Resolution:%d\n",p->channel,p->resolution);
#if GATEWAY_BOX	/*some APP will send IOTYPE_USER_IPCAM_SET_RESOLUTION_REQ, even not Gateway box.*/
            if(!sysSet_Resoultion(p->channel,p->resolution ))
            {
                DEBUG_P2P("USER_IPCAM_SET_RESOLUTION Fail!! \n");
            }
            else
            {
                DEBUG_P2P("USER_IPCAM_SET_RESOLUTION OK!! \n");
            }

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_SET_PAIRING_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SET_BRIGHTNESS_RESP OK\n\n");
            }
#endif
        }
        break;
        case IOTYPE_USER_IPCAM_GET_RESOLUTION_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetResolutionResp);
            u8 resolution;

            SMsgAVIoctrlGetResolutionReq *p = (SMsgAVIoctrlGetResolutionReq *)buf;
            SMsgAVIoctrlGetResolutionResp *q = (SMsgAVIoctrlGetResolutionResp *)buf;

            DEBUG_P2P("IPCAM_GET_RESOLUTION_REQ OK \n");

            sysGet_Resoultion(p->channel, &resolution);
            q->resolution=resolution;

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_RESOLUTION_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GET_RESOLUTION_RESP OK: channel:%d, resolution:%d\n\n",q->channel,resolution);
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_DEVICEALARM_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlSetDeviceAlarmResp);

            SMsgAVIoctrlSetDeviceAlarmReq *p = (SMsgAVIoctrlSetDeviceAlarmReq *)buf;
            SMsgAVIoctrlSetDeviceAlarmResp *q = (SMsgAVIoctrlSetDeviceAlarmResp *)buf;

            DEBUG_P2P("IPCAM_SET_DEVICEALARM_REQ: channel:%d, isDeviceAlarm:%d\n",p->channel,p->isDeviceAlarm);

            if(!sysSet_AlarmEnable(p->isDeviceAlarm))
            {
                DEBUG_P2P("USER_IPCAM_SET_RESOLUTION Fail!! \n");
            }
            else
            {
                DEBUG_P2P("USER_IPCAM_SET_RESOLUTION OK!! \n");
            }

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_SET_DEVICEALARM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SET_DEVICEALARM_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_GET_DEVICEALARM_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetDeviceAlarmResp);
            u8 isDeviceAlarm;
            SMsgAVIoctrlGetDeviceAlarmReq *p = (SMsgAVIoctrlGetDeviceAlarmReq *)buf;
            SMsgAVIoctrlGetDeviceAlarmResp *q = (SMsgAVIoctrlGetDeviceAlarmResp *)buf;

            DEBUG_P2P("IPCAM_GET_DEVICEALARM_REQ OK \n");

            sysGet_AlarmEnable(&isDeviceAlarm);
            q->isDeviceAlarm=isDeviceAlarm;

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_DEVICEALARM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GET_DEVICEALARM_RESP OK: channel:%d, isDeviceAlarm:%d\n\n",q->channel,isDeviceAlarm);
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_VIDEOOUT_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlSetVideoOutResp);

            SMsgAVIoctrlSetVideoOutReq *p = (SMsgAVIoctrlSetVideoOutReq *)buf;
            SMsgAVIoctrlSetVideoOutResp *q = (SMsgAVIoctrlSetVideoOutResp *)buf;

            DEBUG_P2P("IPCAM_SET_VIDEOOUT_REQ OK: channel:%d, videoOut:%d\n",p->channel, p->videoOut);

            if(!sysSet_TVOut(p->videoOut))
            {
                DEBUG_P2P("USER_USER_IPCAM_SET_VIDEOOUT Fail!! \n");
            }
            else
            {
                DEBUG_P2P("USER_USER_IPCAM_SET_VIDEOOUT OK!! \n");
            }

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_SET_VIDEOOUT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SET_VIDEOOUT_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_GET_VIDEOOUT_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetVideoOutResp);
            u8 vedioOut;
            SMsgAVIoctrlGetVideoOutReq *p = (SMsgAVIoctrlGetVideoOutReq *)buf;
            SMsgAVIoctrlGetVideoOutResp *q = (SMsgAVIoctrlGetVideoOutResp *)buf;

            DEBUG_P2P("IPCAM_GET_VIDEOOUT_REQ OK \n");

            sysGet_TVOut(&vedioOut);
            q->videoOut=vedioOut;

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_VIDEOOUT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GET_VIDEOOUT_RESP OK: channel:%d, vedioOut:%d\n\n",q->channel,vedioOut);
            }
        }
        break;
        /*case IOTYPE_USER_IPCAM_SET_DEVICESHOW_REQ:
        {
        	DEBUG_P2P("IPCAM_SET_DEVICESHOW_REQ OK \n");
        }
        break;*/
        case IOTYPE_USER_IPCAM_GET_DEVICESHOW_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetDeviceShowResp);
            struct NetworkInfo info;
            SMsgAVIoctrlGetDeviceShowResp *q = (SMsgAVIoctrlGetDeviceShowResp *)buf;
            //memset(q,0,size);
            DEBUG_P2P("IPCAM_GET_DEVICESHOW_REQ OK \n");
            GetNetworkInfo(&info);
            sprintf(q->ipAddress,"%d.%d.%d.%d",info.IPaddr[0],info.IPaddr[1],info.IPaddr[2],info.IPaddr[3]);
            sprintf(q->getwayAddress,"%d.%d.%d.%d",info.Gateway[0],info.Gateway[1],info.Gateway[2],info.Gateway[3]);
            sprintf(q->netMask,"%d.%d.%d.%d",info.Netmask[0],info.Netmask[1],info.Netmask[2],info.Netmask[3]);
            DEBUG_P2P("IP=%s\n",q->ipAddress);
            DEBUG_P2P("Netmask=%s\n",q->netMask);
            DEBUG_P2P("Gateway=%s\n",q->getwayAddress);

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_DEVICESHOW_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IPCAM_GET_DEVICESHOW_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_SET_DEVICEBUZZER_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlSetDeviceBuzzerResp);

            SMsgAVIoctrlSetDeviceBuzzerReq *p = (SMsgAVIoctrlSetDeviceBuzzerReq *)buf;
            SMsgAVIoctrlSetDeviceBuzzerResp *q = (SMsgAVIoctrlSetDeviceBuzzerResp *)buf;

            DEBUG_P2P("IPCAM_SET_DEVICEBUZZER_REQ OK: channel:%d, isDeviceBuzzer:%d\n",p->channel,p->isDeviceBuzzer);

            if(!sysSet_AlarmVal(p->isDeviceBuzzer))
            {
                DEBUG_P2P("SET_DEVICEBUZZER Fail!! \n");
            }
            else
            {
                DEBUG_P2P("SET_DEVICEBUZZER OK!! \n");
            }

            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_SET_DEVICEBUZZER_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SET_DEVICEBUZZER_RESP OK\n\n");
            }
        }
        break;
        case IOTYPE_USER_IPCAM_GET_DEVICEBUZZER_REQ://
        {
            int size =  sizeof(SMsgAVIoctrlGetDeviceBuzzerResp);
            u8 isDeviceBuzzer;

            SMsgAVIoctrlGetDeviceBuzzerReq *p = (SMsgAVIoctrlGetDeviceBuzzerReq *)buf;
            SMsgAVIoctrlGetDeviceBuzzerResp *q = (SMsgAVIoctrlGetDeviceBuzzerResp *)buf;

            DEBUG_P2P("IPCAM_GET_DEVICEBUZZER_REQ OK \n");

            sysGet_AlarmVal(&isDeviceBuzzer);
            q->isDeviceBuzzer=isDeviceBuzzer;
            if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_DEVICEBUZZER_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("GET_DEVICEBUZZER_RESP OK: channel:%d, isDeviceBuzzer:%d\n\n",q->channel,isDeviceBuzzer);
            }
        }
        break;

// ----------------------
// HU Light ]m 20150917 Sean
// ----------------------
#if (UI_LIGHT_SUPPORT)

		case IOTYPE_RDI_GETLIGHTCHECK_REQ:
		{
			int size =	sizeof(SMsgAVIoctrlGetLightSupportResp);
			int i;
			SMsgAVIoctrlGetLightSupportReq	*p = (SMsgAVIoctrlGetLightSupportReq *)buf;
			SMsgAVIoctrlGetLightSupportResp *q = (SMsgAVIoctrlGetLightSupportResp*)buf;

			DEBUG_P2P("IOTYPE_RDI_GETLIGHTCHECK_REQ OK \n");

			if(p->channel == 255)
			{
				for(i=0;i<MAX_AV_CH;i++)
				{
					if(gRfiuUnitCntl[i].RFpara.TxCodeVersion[31] & UI_VERSION_BIT_LIGHT)
					{
						q->lightsupport = 1; //Support Light
						break;
					}
					else
						q->lightsupport = 0; //NOT Support Light
				}
			}
			else
			{
				if(gRfiuUnitCntl[p->channel].RFpara.TxCodeVersion[31] & UI_VERSION_BIT_LIGHT)
				{
					q->lightsupport = 1; //Support Light
				}
				else
					q->lightsupport = 0; //NOT Support Light
			}

			if(avSendIOCtrl(avIndex, IOTYPE_RDI_GETLIGHTCHECK_RESP, (char*)q, size)== AV_ER_NoERROR)
			{
				DEBUG_P2P("IOTYPE_RDI_GETLIGHTCHECK_RESP OK\n\n");
			}

		}
		break;

        case IOTYPE_RDI_GETLIGHTSTATUS_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetLightStatusResp);

            SMsgAVIoctrlGetLightStatusReq *p	 = (SMsgAVIoctrlGetLightStatusReq *)buf;
            SMsgAVIoctrlGetLightStatusResp *q  = (SMsgAVIoctrlGetLightStatusResp *)buf;

            DEBUG_P2P("IOTYPE_RDI_GETLIGHTSTATUS_REQ OK \n");

            Light_CHN =  p->channel;

            /*
            UI_LIGHT_OFF			=0
            UI_LIGHT_MANUAL_OFF	=1
            UI_LIGHT_TIMER_ON	=2
            UI_LIGHT_MANUAL_ON	=3
            UI_LIGHT_TRIGGER_ON	=4
            */
            if((iconflag[UI_MENU_SETIDX_CH1_LS_STATUS + Light_CHN])<2)
                q->status = 0;
            else
                q->status = 1;

            if(avSendIOCtrl(avIndex, IOTYPE_RDI_GETLIGHTSTATUS_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_RDI_GETLIGHTSTATUS_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_RDI_SETLIGHTSTATUS_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetLightStatusResp);

            SMsgAVIoctrlSetLightStatusReq *p	 = (SMsgAVIoctrlSetLightStatusReq *)buf;
            SMsgAVIoctrlSetLightStatusResp *q  = (SMsgAVIoctrlSetLightStatusResp *)buf;

            DEBUG_P2P("IOTYPE_RDI_SETLIGHTSTATUS_REQ OK \n");

            Light_CHN =  p->channel;

            if(p->status == 0)
            {
                if(iconflag[UI_MENU_SETIDX_CH1_LS_STATUS+Light_CHN] >1) //Set Light OFF
                    uiCheckLightManualSwitchStatus(Light_CHN);
              #if UI_LIGHT_SUPPORT
                else //If App Setting & 8200 Setting are different, 8200 send sync to APP
                    UpdateAPPLightStatus(Light_CHN);
              #endif
                uiFlowSetRfLightStatus(Light_CHN, 0, 2);    //Set LCD icon OFF

                if(iconflag[UI_MENU_SETIDX_CH1_LS_STATUS+Light_CHN] < 2)
                    q->result = 0;
                else
                    q->result = 1;
            }
            if(p->status == 1)
            {
                if(iconflag[UI_MENU_SETIDX_CH1_LS_STATUS+Light_CHN] < 2) //Set Light ON
                    uiCheckLightManualSwitchStatus(Light_CHN);
              #if UI_LIGHT_SUPPORT
                else //If App Setting & 8200 Setting are different, 8200 send sync to APP
                    UpdateAPPLightStatus(Light_CHN);
              #endif
                uiFlowSetRfLightStatus(Light_CHN, 3, 2);    //Set LCD icon ON

                if(iconflag[UI_MENU_SETIDX_CH1_LS_STATUS+Light_CHN] > 1)
                    q->result = 0;
                else
                    q->result = 1;
            }

            if(avSendIOCtrl(avIndex, IOTYPE_RDI_SETLIGHTSTATUS_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_RDI_SETLIGHTSTATUS_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_RDI_GETLIGHTCONFIG_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetLightConfigResp);

            SMsgAVIoctrlGetLightConfigReq *p	 = (SMsgAVIoctrlGetLightConfigReq *)buf;
            SMsgAVIoctrlGetLightConfigResp *q  = (SMsgAVIoctrlGetLightConfigResp *)buf;

            DEBUG_P2P("IOTYPE_RDI_GETLIGHTCONFIG_REQ OK \n");

            Light_CHN =  p->channel;
            q->st.repeat[6]=(iconflag[UI_MENU_SETIDX_CH1_LS_TIMER+ Light_CHN]&64)>0?1:0;
            q->st.repeat[5]=(iconflag[UI_MENU_SETIDX_CH1_LS_TIMER+ Light_CHN]&32)>0?1:0;
            q->st.repeat[4]=(iconflag[UI_MENU_SETIDX_CH1_LS_TIMER+ Light_CHN]&16)>0?1:0;
            q->st.repeat[3]=(iconflag[UI_MENU_SETIDX_CH1_LS_TIMER+ Light_CHN]&8)>0?1:0;
            q->st.repeat[2]=(iconflag[UI_MENU_SETIDX_CH1_LS_TIMER+ Light_CHN]&4)>0?1:0;
            q->st.repeat[1]=(iconflag[UI_MENU_SETIDX_CH1_LS_TIMER+ Light_CHN]&2)>0?1:0;
            q->st.repeat[0]=(iconflag[UI_MENU_SETIDX_CH1_LS_TIMER+ Light_CHN]&1)>0?1:0;
			#if (UI_LIGHT_TIME_MIN_FORMAT == UI_TIME_INTERVAL_01MIN)
            q->dimmer = iconflag[UI_MENU_SETIDX_CH1_LS_DIMMER  	+ Light_CHN];
            q->duration =iconflag[UI_MENU_SETIDX_CH1_LS_DURATION	+ Light_CHN];
			#endif
            q->st.lightonHour=		uiLightTimer[Light_CHN][0];
            q->st.lightonMinute=	uiLightTimer[Light_CHN][1];
            q->st.lightoffHour=	uiLightTimer[Light_CHN][2];
            q->st.lightoffMinute=	uiLightTimer[Light_CHN][3];

            if(avSendIOCtrl(avIndex, IOTYPE_RDI_GETLIGHTCONFIG_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_RDI_GETLIGHTCONFIG_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_RDI_SETLIGHTCONFIG_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetLightConfigResp);
            u8 Repeat;

            SMsgAVIoctrlSetLightConfigReq *p	 = (SMsgAVIoctrlSetLightConfigReq *)buf;
            SMsgAVIoctrlSetLightConfigResp *q  = (SMsgAVIoctrlSetLightConfigResp *)buf;

            DEBUG_P2P("IOTYPE_RDI_SETLIGHTCONFIG_REQ OK \n");

            Light_CHN =  p->channel;
            Repeat = (64*(p->st.repeat[6])+32*(p->st.repeat[5])+16*(p->st.repeat[4])+8*(p->st.repeat[3])+4*(p->st.repeat[2])+2*(p->st.repeat[1])+(p->st.repeat[0]));
            if(Repeat != (iconflag[UI_MENU_SETIDX_CH1_LS_TIMER + Light_CHN]))
                iconflag[UI_MENU_SETIDX_CH1_LS_TIMER + Light_CHN] = Repeat;
#if (UI_LIGHT_TIME_MIN_FORMAT == UI_TIME_INTERVAL_01MIN)
            if(p->dimmer != (iconflag[UI_MENU_SETIDX_CH1_LS_DIMMER + Light_CHN]))
            {
                uiSetRfLightDimmerRxToTx(p->dimmer, Light_CHN);
                iconflag[UI_MENU_SETIDX_CH1_LS_DIMMER + Light_CHN] = p->dimmer;
            }

            if(p->duration != (iconflag[UI_MENU_SETIDX_CH1_LS_DURATION + Light_CHN]))
            {
                uiSetRfLightDurationRxToTx(p->duration, Light_CHN);
                iconflag[UI_MENU_SETIDX_CH1_LS_DURATION + Light_CHN] = p->duration;
            }
#endif
            uiLightTimer[Light_CHN][0] = p->st.lightonHour;
            uiLightTimer[Light_CHN][1] = p->st.lightonMinute;
            uiLightTimer[Light_CHN][2] = p->st.lightoffHour;
            uiLightTimer[Light_CHN][3] = p->st.lightoffMinute;

#if (UI_LIGHT_TIME_MIN_FORMAT == UI_TIME_INTERVAL_01MIN)
            uiSetRfLightTimerRxToTx(p->st.lightonHour, p->st.lightonMinute, p->st.lightoffHour, p->st.lightoffMinute, Repeat, Light_CHN, 1);
#elif (UI_LIGHT_TIME_MIN_FORMAT == UI_TIME_INTERVAL_30MIN)
            uiSyncLightTimer2LightInterval(Light_CHN, 1);
            {
                int i,j;
                for(i=0; i<7; i++)
                {
                    if((p->st.repeat[i]) == 1)
                        for(j=0; j<6; j++)
                            uiSetRfLightTimerRxToTx(i, uiLightInterval[Light_CHN][i][j], uiLightInterval[Light_CHN][i][j], uiLightInterval[Light_CHN][i][j], uiLightInterval[Light_CHN][i][j], uiLightInterval[Light_CHN][i][j], uiLightInterval[Light_CHN][i][j], Light_CHN, 1);
                }
            }
#endif

            Save_UI_Setting();

            q->result = 0;

            if(avSendIOCtrl(avIndex, IOTYPE_RDI_SETLIGHTCONFIG_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_RDI_SETLIGHTCONFIG_RESP OK\n\n");
            }
        }
        break;
#endif

#if(UI_VERSION == UI_VERSION_MAYON)
		case IOTYPE_WALMART_GETPLAYBACKFPS_REQ: //Paul add for MWM903, copy from Walmart, 180518
		{
			SMsgAVIoctrlGetPlayBackFPSReq *p=(SMsgAVIoctrlGetPlayBackFPSReq *)buf;

			DEBUG_P2P("IOTYPE_WALMART_GETPLAYBACKFPS_REQ OK:%d\n\n",p->FPS);
		}
		break;
		case IOTYPE_WALMART_GETPUSHMSGSTATUS_REQ: //Paul add for MWM903, copy from Walmart, 180904
		{
			SMsgAVIoctrlGetPushMsgtStatusResp *q=(SMsgAVIoctrlGetPushMsgtStatusResp *)buf;
			int size =  sizeof(SMsgAVIoctrlGetPushMsgtStatusResp);

			q->status = 0;//Need to modify here.

			DEBUG_P2P("IOTYPE_WALMART_GETPUSHMSGSTATUS_REQ OK:%d\n\n",q->status);

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_GETPUSHMSGSTATUS_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_WALMART_GETPUSHMSGSTATUS_RESP OK\n\n");
            }
		}
		break;
		case IOTYPE_WALMART_SETPUSHMSGSTATUS_REQ: //Paul add for MWM903, copy from Walmart, 180518
		{
			SMsgAVIoctrlSetPushMsgstatusReq *p=(SMsgAVIoctrlSetPushMsgstatusReq *)buf;
			SMsgAVIoctrlSetPushMsgstatusResp *q = (SMsgAVIoctrlSetPushMsgstatusResp *)buf;
			int size =  sizeof(SMsgAVIoctrlSetPushMsgstatusResp);

			DEBUG_P2P("IOTYPE_WALMART_SETPUSHMSGSTATUS_REQ OK:%d\n\n",p->status);

			q->result = 0;//Need to modify here.

			if(avSendIOCtrl(avIndex, IOTYPE_WALMART_SETPUSHMSGSTATUS_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_USER_SETPUSHMSGSTATUS_RESP OK\n\n");
            }
		}
		break;
#endif

/////////////////////////////////////////////////////////////////

#if(HW_BOARD_OPTION == MR8211_ZINWELL)

        /*
        Used by Zinwell
        */
        case IOTYPE_ZW_PLUGCAM_GETCURRENTTEMP_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetCurrentTempResp);
            float tempture=0;
            SMsgAVIoctrlGetCurrentTempReq *p = (SMsgAVIoctrlGetCurrentTempReq *)buf;
            SMsgAVIoctrlGetCurrentTempResp *q=(SMsgAVIoctrlGetCurrentTempResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GETCURRENTTEMP_REQ OK \n");

            if(sysGet_CurrTemp(&tempture)<0)
            {
                DEBUG_P2P("GETCURRENTTEMP Fail!! \n");
                q->CurrentTemp=255;
            }
            else
                q->CurrentTemp=tempture;
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_GETCURRENTTEMP_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GETCURRENTTEMP_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_GETTEMPHIGHMARGIN_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetTempHighMarginResp);
            float temp;
            SMsgAVIoctrlGetTempHighMarginReq *p = (SMsgAVIoctrlGetTempHighMarginReq *)buf;
            SMsgAVIoctrlGetTempHighMarginResp *q=(SMsgAVIoctrlGetTempHighMarginResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GETTEMPHIGHMARGIN_REQ OK \n");
            if(sysGet_TempHighMargin(p->channel,&temp))
            {
                DEBUG_P2P("GET TEMP HIGH MARGIN Fail!! \n");
                q->CurrentTemp=-1;
            }
            else
            {
                DEBUG_P2P("GET TEMP HIGH MARGIN OK!! \n");
                q->CurrentTemp=temp;
            }

            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_GETTEMPHIGHMARGIN_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GETTEMPHIGHMARGIN_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SETTEMPHIGHMARGIN_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetTempHighMarginResp);

            SMsgAVIoctrlSetTempHighMarginReq *p = (SMsgAVIoctrlSetTempHighMarginReq *)buf;
            SMsgAVIoctrlSetTempHighMarginResp *q=(SMsgAVIoctrlSetTempHighMarginResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SETTEMPHIGHMARGIN_REQ OK \n");
            if(sysSet_TempHighMargin(p->channel,p->CurrentTemp))
            {
                DEBUG_P2P("SET TEMP HIGH MARGIN Fail!! \n");
            }
            else
            {
                DEBUG_P2P("SET TEMP HIGH MARGIN OK!! \n");
            }
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_SETTEMPHIGHMARGIN_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SETTEMPHIGHMARGIN_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_GETTEMPLOWMARGIN_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetTempLowMarginResp);
            float temp;
            SMsgAVIoctrlGetTempLowMarginReq *p = (SMsgAVIoctrlGetTempLowMarginReq *)buf;
            SMsgAVIoctrlGetTempLowMarginResp *q=(SMsgAVIoctrlGetTempLowMarginResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GETTEMPLOWMARGIN_REQ OK \n");
            if(sysGet_TempLowMargin(p->channel,&temp))
            {
                DEBUG_P2P("GET TEMP LOW MARGIN Fail!! \n");
                q->CurrentTemp=-1;
            }
            else
            {
                DEBUG_P2P("GET TEMP LOW MARGIN OK!! \n");
                q->CurrentTemp=temp;
            }
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_GETTEMPLOWMARGIN_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GETTEMPLOWMARGIN_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SETTEMPLOWMARGIN_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetTempLowMarginResp);

            SMsgAVIoctrlSetTempLowMarginReq *p = (SMsgAVIoctrlSetTempLowMarginReq *)buf;
            SMsgAVIoctrlSetTempLowMarginResp *q =(SMsgAVIoctrlSetTempLowMarginResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SETTEMPLOWMARGIN_REQ OK \n");
            if(sysSet_TempLowMargin(p->channel,p->CurrentTemp))
            {
                DEBUG_P2P("SET TEMP LOW MARGIN Fail!! \n");
            }
            else
            {
                DEBUG_P2P("SET TEMP LOW MARGIN OK!! \n");
            }
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_SETTEMPLOWMARGIN_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SETTEMPLOWMARGIN_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SETRESET_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetResetResp);

            SMsgAVIoctrlSetResetReq *p = (SMsgAVIoctrlSetResetReq *)buf;
            SMsgAVIoctrlSetResetResp *q = (SMsgAVIoctrlSetResetResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SETRESET_REQ OK \n");
            q->result=sysSet_ResetToDef();
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_SETRESET_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SETRESET_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SET_NIGHTMODE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetNightModeResp);

            SMsgAVIoctrlSetNightModeReq *p = (SMsgAVIoctrlSetNightModeReq *)buf;
            SMsgAVIoctrlSetNightModeResp *q = (SMsgAVIoctrlSetNightModeResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_NIGHTMODE_REQ OK \n");

            if(sysSetNightMode(p->mode)<0)
            {
                DEBUG_P2P("SET NIGHTMODE Fail!! \n");
                q->result=-1;
            }
            else
            {
                DEBUG_P2P("SET NIGHTMODE OK!! \n");
                q->result=0;
            }
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_SET_NIGHTMODE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_NIGHTMODE_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_GET_NIGHTMODE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetNightModeResp);
            unsigned char mode;
            SMsgAVIoctrlGetNightModeReq *p = (SMsgAVIoctrlGetNightModeReq *)buf;
            SMsgAVIoctrlGetNightModeResp *q = (SMsgAVIoctrlGetNightModeResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_NIGHTMODE_REQ OK \n");

            if(sysGetNightMode(&mode)<0)
            {
                DEBUG_P2P("GET NIGHTMODE Fail!! \n");
                q->mode=255;
            }
            else
            {
                DEBUG_P2P("GET NIGHTMODE OK!! \n");
                q->mode=mode;
            }
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_GET_NIGHTMODE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_NIGHTMODE_RESP OK\n\n");
            }
        }
        break;

        case  IOTYPE_ZW_PLUGCAM_GET_LIGHT_REQ :
        {
            int size =  sizeof(SMsgAVIoctrlGetLightResp);
            unsigned char CurrentValueR,CurrentValueG,CurrentValueB,CurrentValueL,status;
            SMsgAVIoctrlGetLightReq *p = (SMsgAVIoctrlGetLightReq *)buf;
            SMsgAVIoctrlGetLightResp *q = (SMsgAVIoctrlGetLightResp *)buf;

            DEBUG_P2P(" IOTYPE_ZW_PLUGCAM_GET_LIGHT_REQ  OK \n");

            if(sysGetLight(&CurrentValueR,&CurrentValueG,&CurrentValueB,&CurrentValueL,&status)<0)
            {
                DEBUG_P2P("GET LIGHT Fail!! \n");
                q->CurrentValueR=255;
                q->CurrentValueG=255;
                q->CurrentValueB=255;
                q->CurrentValueL=255;
                q->CurrentStatus=255;
            }
            else
            {
                DEBUG_P2P("GET LIGHT OK!! \n");
                q->CurrentStatus=status;
                q->CurrentValueR=CurrentValueR;
                q->CurrentValueG=CurrentValueG;
                q->CurrentValueB=CurrentValueB;
                q->CurrentValueL=CurrentValueL;
            }
            if(avSendIOCtrl(avIndex,  IOTYPE_ZW_PLUGCAM_GET_LIGHT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P(" IOTYPE_ZW_PLUGCAM_GET_LIGHT_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SET_LIGHT_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetLightResp);

            SMsgAVIoctrlSetLightReq *p = (SMsgAVIoctrlSetLightReq *)buf;
            SMsgAVIoctrlSetLightResp *q = (SMsgAVIoctrlSetLightResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_LIGHT_REQ OK \n");

            if(sysSetLight(p->CurrentValueR,p->CurrentValueG,p->CurrentValueB,p->CurrentValueL,p->CurrentStatus)<0)
            {
                DEBUG_P2P("SET LIGHT Fail!! \n");
                q->Status=2;
            }
            else
            {
                DEBUG_P2P("SET LIGHT OK!! \n");
                q->Status=1;
            }
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_SET_LIGHT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_LIGHT_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SET_FILERECYCLE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetRecycleResp);

            SMsgAVIoctrlSetRecycleReq *p = (SMsgAVIoctrlSetRecycleReq *)buf;
            SMsgAVIoctrlSetRecycleResp *q = (SMsgAVIoctrlSetRecycleResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_FILERECYCLE_REQ OK \n");

            if(sysSetFileRecycle(p->Status)<0)
            {
                DEBUG_P2P("SET FILE RECYCLE Fail!! \n");
                q->Status=4;
            }
            else
            {
                DEBUG_P2P("SET FILE RECYCLE OK!! \n");
                q->Status=3;
            }
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_SET_FILERECYCLE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_FILERECYCLE_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_GET_FILERECYCLE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetRecycleResp);
            unsigned char status;
            SMsgAVIoctrlGetRecycleReq *p = (SMsgAVIoctrlGetRecycleReq *)buf;
            SMsgAVIoctrlGetRecycleResp *q = (SMsgAVIoctrlGetRecycleResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_FILERECYCLE_REQ OK \n");

            if(sysGetFileRecycle(&status)<0)
            {
                DEBUG_P2P("SET FILE RECYCLE Fail!! \n");
                q->Status=255;
            }
            else
            {
                DEBUG_P2P("SET FILE RECYCLE OK!! \n");
                q->Status=status;
            }
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_GET_FILERECYCLE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_FILERECYCLE_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_GET_SDCARDMUM_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetMUMSDCardResp);
            unsigned char mode;
            SMsgAVIoctrlGetMUMSDCardReq *p = (SMsgAVIoctrlGetMUMSDCardReq *)buf;
            SMsgAVIoctrlGetMUMSDCardResp *q = (SMsgAVIoctrlGetMUMSDCardResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_SDCARDMUM_REQ OK \n");

            if(sysGetMountSD(&mode)<0)
            {
                DEBUG_P2P("GET SD MOUNT INFO Fail!! \n");
                q->mode=255;
            }
            else
            {
                DEBUG_P2P("GET SD MOUNT INFO OK!! \n");
                q->mode=mode;
            }
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_GET_SDCARDMUM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_SDCARDMUM_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SET_SDCARDMUM_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetMUMSDCardResp);

            SMsgAVIoctrlSetMUMSDCardReq *p = (SMsgAVIoctrlSetMUMSDCardReq *)buf;
            SMsgAVIoctrlSetMUMSDCardResp *q = (SMsgAVIoctrlSetMUMSDCardResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_SDCARDMUM_REQ OK \n");

            if(sysSetMountSD(p->mode)<0)
            {
                DEBUG_P2P("SET SD MOUNT INFO Fail!! \n");
                q->result=255;
            }
            else
            {
                DEBUG_P2P("SET SD MOUNT INFO OK!! \n");
                q->result=0;
            }
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_SET_SDCARDMUM_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_SDCARDMUM_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_GETFWVERSION_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetFWVersionResp);
            char version[16];

            SMsgAVIoctrlGetFWVersionReq *p = (SMsgAVIoctrlGetFWVersionReq *)buf;
            SMsgAVIoctrlGetFWVersionResp *q = (SMsgAVIoctrlGetFWVersionResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GETFWVERSION_REQ OK \n");

            if(sysGetFWver(version)<0)
            {
                DEBUG_P2P("GET FW VER Fail!! \n");
                //q->version=255;
            }
            else
            {
                DEBUG_P2P("GET FW VER OK!! \n");
                strcpy(q->version,version);
            }
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_GETFWVERSION_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GETFWVERSION_RESP OK\n\n");
            }
        }
        break;
        /*
        		case IOTYPE_ZW_PLUGCAM_GET_FWUPDATE_REQ:
        		{
        			int size =  sizeof(SMsgAVIoctrlGetFWVersionResp);
        			char version[16];

        			SMsgAVIoctrlGetFWVersionReq *p = (SMsgAVIoctrlGetFWVersionReq *)buf;
        			SMsgAVIoctrlGetFWVersionResp *q = (SMsgAVIoctrlGetFWVersionResp *)buf;

        			DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_FWUPDATE_REQ OK \n");
        			Check_fw_ver_net(Check_by_net);
        			strcpy(q->version,fw_version);
        			if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_GET_FWUPDATE_RESP, (char*)q, size)== AV_ER_NoERROR)
        			{
        				DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_FWUPDATE_RESP OK\n\n");
        			}
        		}
        		break;
        */
        case IOTYPE_ZW_PLUGCAM_SET_FWUPDATE_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlFirmwareUpdateResp);

            SMsgAVIoctrlFirmwareUpdateReq *p = (SMsgAVIoctrlFirmwareUpdateReq *)buf;
            SMsgAVIoctrlFirmwareUpdateResp *q = (SMsgAVIoctrlFirmwareUpdateResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_FWUPDATE_REQ OK \n");

            Check_fw_ver_net(Check_by_net);
            OSTimeDly(10);
            Upgrade_fw_net();
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_SET_FWUPDATE_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_FWUPDATE_RESP OK\n\n");
            }
        }
        break;

        /*
        case IOTYPE_USER_IPCAM_SET_MDREGION_REQ:
        {
        	int size =  sizeof(SMsgAVIoctrlSetMUMSDCardResp);

        	SMsgAVIoctrlSetMUMSDCardReq *p = (SMsgAVIoctrlSetMUMSDCardReq *)buf;
        	SMsgAVIoctrlSetMUMSDCardResp *q = (SMsgAVIoctrlSetMUMSDCardResp *)buf;

        	DEBUG_P2P("IPCAM_SET_MDREGION_REQ OK \n");

        	if(sysSetMountSD(p->mode)<0)
        	{
        		DEBUG_P2P("SET MDREGION Fail!! \n");
        		q->result=255;
        	}
        	else
        	{
        		DEBUG_P2P("SET MDREGION INFO OK!! \n");
        		q->result=0;
        	}
        	if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_SET_MDREGION_RESP, (char*)q, size)== AV_ER_NoERROR)
        	{
        		DEBUG_P2P("IPCAM_SET_MDREGION_RESP OK\n\n");
        	}
        }
        break;

        case IOTYPE_USER_IPCAM_GET_MDREGION_REQ:
        {
        	int size =  sizeof(SMsgAVIoctrlSetMUMSDCardResp);

        	SMsgAVIoctrlSetMUMSDCardReq *p = (SMsgAVIoctrlSetMUMSDCardReq *)buf;
        	SMsgAVIoctrlSetMUMSDCardResp *q = (SMsgAVIoctrlSetMUMSDCardResp *)buf;

        	DEBUG_P2P("IPCAM_GET_MDREGION_REQ OK \n");

        	if(sysSetMountSD(p->mode)<0)
        	{
        		DEBUG_P2P("SET MDREGION Fail!! \n");
        		q->result=255;
        	}
        	else
        	{
        		DEBUG_P2P("SET MDREGION INFO OK!! \n");
        		q->result=0;
        	}
        	if(avSendIOCtrl(avIndex, IOTYPE_USER_IPCAM_GET_MDREGION_RESP, (char*)q, size)== AV_ER_NoERROR)
        	{
        		DEBUG_P2P("IPCAM_GET_MDREGION_RESP OK\n\n");
        	}
        }
        break;
        */

        case IOTYPE_ZW_PLUGCAM_SET_FREQUENCY_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetFrequencyResp);

            SMsgAVIoctrlSetFrequencyReq *p = (SMsgAVIoctrlSetFrequencyReq *)buf;
            SMsgAVIoctrlSetFrequencyResp *q = (SMsgAVIoctrlSetFrequencyResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_FREQUENCY_REQ OK \n");

            if(sysSetFrequency(p->channel,p->mode)<0)
            {
                DEBUG_P2P("SET FREQUENCY Fail!! \n");
                q->result=-1;
            }
            else
            {
                DEBUG_P2P("SET FREQUENCY OK!! \n");
                q->result=0;
            }
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_SET_FREQUENCY_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_FREQUENCY_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_GET_FREQUENCY_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetFrequencyResp);
            unsigned char mode;
            SMsgAVIoctrlGetFrequencyReq *p = (SMsgAVIoctrlGetFrequencyReq *)buf;
            SMsgAVIoctrlGetFrequencyResp *q = (SMsgAVIoctrlGetFrequencyResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_FREQUENCY_REQ OK \n");

            if(sysGetFrequency(p->channel,&mode)<0)
            {
                DEBUG_P2P("GET FREQUENCY Fail!! \n");
                q->mode=255;
            }
            else
            {
                DEBUG_P2P("GET FREQUENCY OK!! \n");
                q->mode=mode;
            }
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_GET_FREQUENCY_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_FREQUENCY_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SET_REBOOT_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetRebootResp);

            SMsgAVIoctrlSetRebootReq *p = (SMsgAVIoctrlSetRebootReq *)buf;
            SMsgAVIoctrlSetRebootResp *q = (SMsgAVIoctrlSetRebootResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_REBOOT_REQ OK \n");
            q->result=sysSet_Reset();
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_SET_REBOOT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_REBOOT_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_GET_NOISEALERT_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetNoiseAlertResp);
            unsigned char Status;
            SMsgAVIoctrlGetNoiseAlertReq *p = (SMsgAVIoctrlGetNoiseAlertReq *)buf;
            SMsgAVIoctrlGetNoiseAlertResp *q=(SMsgAVIoctrlGetNoiseAlertResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_NOISEALERT_REQ OK \n");
            if(sysGet_NoiseAlert(p->channel,&Status))
            {
                DEBUG_P2P("GET NOISE ALERT Fail!! \n");
                q->Status=-1;
            }
            else
            {
                DEBUG_P2P("GET NOISE ALERT OK!! \n");
                q->Status=Status;
            }

            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_GET_NOISEALERT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_NOISEALERT_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SET_NOISEALERT_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetNoiseAlertResp);

            SMsgAVIoctrlSetNoiseAlertReq *p = (SMsgAVIoctrlSetNoiseAlertReq *)buf;
            SMsgAVIoctrlSetNoiseAlertResp *q=(SMsgAVIoctrlSetNoiseAlertResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_NOISEALERT_REQ OK \n");
            if(sysSet_NoiseAlert(p->channel,p->Status))
            {
                DEBUG_P2P("SET NOISE ALERT Fail!! \n");
                q->Status=-1;
            }
            else
            {
                DEBUG_P2P("SET NOISE ALERT OK!! \n");
                q->Status=0;
            }
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_SET_NOISEALERT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_NOISEALERT_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_GET_TEMPALERT_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlGetTempAlertResp);
            unsigned char Status;
            SMsgAVIoctrlGetTempAlertReq *p = (SMsgAVIoctrlGetTempAlertReq *)buf;
            SMsgAVIoctrlGetTempAlertResp *q=(SMsgAVIoctrlGetTempAlertResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_TEMPALERT_REQ OK \n");
            if(sysGet_TempAlert(p->channel,&Status))
            {
                DEBUG_P2P("GET TEMPERATURE ALERT Fail!! \n");
                q->Status=-1;
            }
            else
            {
                DEBUG_P2P("GET TEMPERATURE ALERT OK!! \n");
                q->Status=Status;
            }

            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_GET_TEMPALERT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_GET_TEMPALERT_RESP OK\n\n");
            }
        }
        break;

        case IOTYPE_ZW_PLUGCAM_SET_TEMPALERT_REQ:
        {
            int size =  sizeof(SMsgAVIoctrlSetTempAlertResp);

            SMsgAVIoctrlSetTempAlertReq *p = (SMsgAVIoctrlSetTempAlertReq *)buf;
            SMsgAVIoctrlSetTempAlertResp *q=(SMsgAVIoctrlSetTempAlertResp *)buf;

            DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_TEMPALERT_REQ OK \n");
            if(sysSet_TempAlert(p->channel,p->Status))
            {
                DEBUG_P2P("SET TEMPERATURE ALERT Fail!! \n");
                q->Status=-1;
            }
            else
            {
                DEBUG_P2P("SET TEMPERATURE ALERT OK!! \n");
                q->Status=0;
            }
            if(avSendIOCtrl(avIndex, IOTYPE_ZW_PLUGCAM_SET_TEMPALERT_RESP, (char*)q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_ZW_PLUGCAM_SET_TEMPALERT_RESP OK\n\n");
            }
        }
        break;

#endif /*Only for Zinwell MR8211*/

        default:
            DEBUG_P2P("non-handle type[%X]\n", ioType);
            break;
    }
}

// ----------------------
// HUD Update APP Light ]m 20150923 Sean
// ----------------------
#if UI_LIGHT_SUPPORT

void UpdateAPPLightStatus(u8 Camid)
{
    AppLightStatus = Camid+1;
}

#endif

#if(UI_VERSION == UI_VERSION_MAYON)

void UpdateMAYONLightStatus(u8 Camid)
{
    MAYONLightStatus = Camid+1;
}

void UpdateMAYONAlarmStatus(u8 Camid)
{
    MAYONAlarmStatus = Camid+1;
}

void UpdateMAYONTXStatus(u8 Camid)
{
	MAYONTXTypeStatus = Camid+1;
}


#endif


u8 AVServerStart(int SID)
{
    /**** avIndex ****
    SID 0 : 0, 1, 2, 3
    SID 1 : 4, 5, 6, 7
    SID 2 : 8, 9, A, B
    SID 3 : C, D, E, F
    *****************/
    int ret;
    int i=0;
    int nResend;
#if(UI_VERSION == UI_VERSION_MAYON)//Modify for relay mode connection lose issue. Add by Paul 2018.08.28
    ret=avServStart(SID, "admin", gP2PPassword,20, SERVTYPE_STREAM_SERVER, 0);
#else
    ret=avServStart(SID, "admin", gP2PPassword,10, SERVTYPE_STREAM_SERVER, 0);
#endif
    //ret = avServStart3(SID, AuthCallBackFn,10, SERVTYPE_STREAM_SERVER, 0, &nResend);
    if(ret < 0)
    {
        DEBUG_P2P("avServStart failed SID[%d] code[%d]!!!\n", SID, ret);
        IOTC_Session_Close(SID);
        return 1;
    }
    /*
    if(gClientInfo[SID].avIndex[0] < 0)
    {
    	DEBUG_P2P("avServStart failed SID[%d] code[%d]!!!\n", SID, gClientInfo[SID].avIndex[0]);
    	IOTC_Session_Close(SID);
    	return;
    }
    */
    else
    {
        gClientInfo[SID].avIndex[0]=ret;
        regedit_client_to_avsession(SID, gClientInfo[SID].avIndex[0]);
        //avServSetResendSize(gClientInfo[SID].avIndex[0],64);
        DEBUG_P2P("avServStart OK SID[%d] idx[%d] [%d]\n\n\n\n", SID, gClientInfo[SID].avIndex[0], gClientInfo[SID].bP2PConnected);
        for(i=0; i<MAX_AV_CH; i++)
            uiSetP2PImageLevel(i,7);
        return 0;
    }
}

int Check_Session_Status(int SID)
{
    struct st_SInfo Sinfo;
    int ret;
    int i;
    u8 err;
    u8 error;
    if(gClientInfo[SID].bP2PConnected == 0)
    {
        return -1;
    }

    ret = IOTC_Session_Check(SID, &Sinfo);

#if(UI_VERSION == UI_VERSION_MAYON)
//Modify for relay mode connection lose issue, IOTC_Session_Check only send 1 time,
//Send twice to double confirm session tatus. Add by Paul 2018.08.29
	if(ret == IOTC_ER_REMOTE_TIMEOUT_DISCONNECT)
	{
		DEBUG_P2P("[thread_ForSessionHandler] session timeout, resend...\n");
    	ret = IOTC_Session_Check(SID, &Sinfo);
	}
#endif
    if(ret == IOTC_ER_SESSION_CLOSE_BY_REMOTE)
    {
        DEBUG_P2P("[thread_ForSessionHandler] remote site close this session, SID[%d]\n", SID);
        if(gClientInfo[SID].bEnableSpeaker>0)
        {
            Kill_Task_Speaker(SID);
        }
    }
    else if(ret == IOTC_ER_REMOTE_TIMEOUT_DISCONNECT)
    {
        DEBUG_P2P("[thread_ForSessionHandler] disconnected due to remote site no response for a while SID[%d]\n", SID);
        if(gClientInfo[SID].bEnableSpeaker>0)
        {
            Kill_Task_Speaker(SID);
        }
    }
    else if(ret == IOTC_ER_INVALID_SID)
    {
        DEBUG_P2P("[thread_ForSessionHandler] Session cant be used anymore\n");
        if(gClientInfo[SID].bEnableSpeaker>0)
        {
            Kill_Task_Speaker(SID);
        }
    }

    if(ret < 0)
    {
        if(gClientInfo[SID].bEnableSpeaker>0)
        {
            Kill_Task_Speaker(SID);
        }
        DEBUG_P2P("Check Session : Session close ret[%d] SID[%d]\n", ret, SID);
        client_p2pdisconnected(SID);
        /*Close remote playback task.*/
        if(gClientInfo[SID].playBackCh!=0)
        {
            avServStop(gClientInfo[SID].avChannel);
            P2PPlaybackVideoStop=1;
            unregedit_client_from_video(SID);
            gClientInfo[SID].bStopPlayBack = 1;
            gClientInfo[SID].bPausePlayBack = 0;
            P2PEnableplaybackStreaming--;
            DEBUG_P2P("P2PEnableplaybackStreaming5555=%d\n",P2PEnableplaybackStreaming);
            P2PEnableplaybackStreaming=0;
            OSSemSet(P2PVideoPlaybackCmpSemEvt, 0, &err);
            if(err!= OS_NO_ERR)
                printf("222Set P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
            OSSemSet(P2PAudioPlaybackCmpSemEvt, 0, &err);
            if(err!= OS_NO_ERR)
                printf("222Set P2PAudioPlaybackCmpSemEvt fail = %d\n", err);
            P2PVideoPlaybackCmpSemEvt=OSSemDel(P2PVideoPlaybackCmpSemEvt, OS_DEL_ALWAYS, &err);
            if(err!= OS_NO_ERR)
                printf("222Del P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
            P2PAudioPlaybackCmpSemEvt=OSSemDel(P2PAudioPlaybackCmpSemEvt, OS_DEL_ALWAYS, &err);
            if(err!= OS_NO_ERR)
                printf("222Del P2PAudioPlaybackCmpSemEvt fail = %d\n", err);
            gClientInfo[SID].playBackCh=0;
            DEBUG_P2P("Fileplaying= %d ,Remote_play= %d \n",Fileplaying,Remote_play);
            DEBUG_P2P("DELETE P2P PLAYFILE TASK.\n");
            if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
                DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");

            OSFlagPend(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_PLAY_FINISH, OS_FLAG_WAIT_CLR_ALL|OS_FLAG_CONSUME, OS_IPC_WAIT_FOREVER, &err);
            DEBUG_P2P("pend FLAGSYS_RDYSTAT_PLAY_FINISH.\n");

            if(OS_NO_ERR !=  OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY))
                DEBUG_P2P("OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
            /*
            error=OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY);
            if(error!=OS_NO_ERR)
            	DEBUG_P2P("OSTaskDel error : %d\n",error);
            */
            Fileplaying=0;
            Remote_play=0;
#if(UI_VERSION == UI_VERSION_MAYON)
			CurrPlaybackSID = -1;
#endif
        }

        //for check device connect timeout by aher 2012/12/21
        if(gOnlineNum<=0)
        {
            if(gFirstConnect)
            {
                if(gClientInfo[SID].bEnableSpeaker>0)
                {
                    Kill_Task_Speaker(SID);
                }
                /*Close remote playback task.*/
                if((Fileplaying)&&(Remote_play==1))
                {
                    P2PPlaybackVideoStop=1;
                    unregedit_client_from_video(SID);
                    gClientInfo[SID].bStopPlayBack = 1;
                    gClientInfo[SID].bPausePlayBack = 0;
                    P2PEnableplaybackStreaming=0;
                    OSSemSet(P2PVideoPlaybackCmpSemEvt, 0, &err);
                    if(err!= OS_NO_ERR)
                        printf("333Set P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
                    OSSemSet(P2PAudioPlaybackCmpSemEvt, 0, &err);
                    if(err!= OS_NO_ERR)
                        printf("333Set P2PAudioPlaybackCmpSemEvt fail = %d\n", err);
                    P2PVideoPlaybackCmpSemEvt=OSSemDel(P2PVideoPlaybackCmpSemEvt, OS_DEL_ALWAYS, &err);
                    if(err!= OS_NO_ERR)
                        printf("333Del P2PVideoPlaybackCmpSemEvt fail = %d\n", err);
                    P2PAudioPlaybackCmpSemEvt=OSSemDel(P2PAudioPlaybackCmpSemEvt, OS_DEL_ALWAYS, &err);
                    if(err!= OS_NO_ERR)
                        printf("333Del P2PAudioPlaybackCmpSemEvt fail = %d\n", err);
                    DEBUG_P2P("Fileplaying= %d ,Remote_play= %d \n",Fileplaying,Remote_play);
                    DEBUG_P2P("DELETE P2P PLAYFILE TASK.\n");
                    if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
                        DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");

                    OSFlagPend(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_PLAY_FINISH, OS_FLAG_WAIT_CLR_ALL|OS_FLAG_CONSUME, OS_IPC_WAIT_FOREVER, &err);
                    DEBUG_P2P("pend FLAGSYS_RDYSTAT_PLAY_FINISH.\n");

                    if(OS_NO_ERR !=  OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY))
                        DEBUG_P2P("OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
                    /*
                    error=OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY);
                    if(error!=OS_NO_ERR)
                    		DEBUG_P2P("OSTaskDel error : %d\n",error);
                    */
                    Fileplaying=0;
                    Remote_play=0;
                    search_dir_start.YMD=0;
                    search_dir_start.HMS=0;
                    search_dir_end.YMD=0;
                    search_dir_end.HMS=0;
                }
                //gFirstConnect=0;
            }
            for (i = 0; i < MAX_AV_CH; i++)
                uiSetP2PImageLevel(i,0);
        }
    }

    if(gClientInfo[SID].bShowInfo)
    {
        char *mode[3] = {"P2P", "RLY", "LAN"};
        // print session information(not a must)
        DEBUG_P2P("Client Info IP[%s:%d] Mode[%s] VER[%X] NAT_Type[%d]\n", Sinfo.RemoteIP, Sinfo.RemotePort, mode[(int)Sinfo.Mode], Sinfo.IOTCVersion, Sinfo.NatType);
        gClientInfo[SID].bShowInfo = 0;
    }

    return ret;
}

#if APP_KEEP_ALIVE
int Clear_Session_Status(int SID) //20160509 Sean : Check APP is Alive or not.
{
    struct st_SInfo Sinfo;
    int ret;
    int i;
    u8 err;
    u8 error;

    if(gClientInfo[SID].bP2PConnected == 0)
    {
        return -1;
    }
    DEBUG_P2P("Check Session Alive Fail[%d], Clear Session Status.\n",SID);
	APPConnectIcon = 0;
    if(gClientInfo[SID].bEnableSpeaker>0)
    {
        Kill_Task_Speaker(SID);
    }
    client_p2pdisconnected(SID);
    /*Close remote playback task.*/
    if(gClientInfo[SID].playBackCh!=0)
    {
        avServStop(gClientInfo[SID].avChannel);
        P2PPlaybackVideoStop=1;
        unregedit_client_from_video(SID);
        gClientInfo[SID].bStopPlayBack = 1;
        gClientInfo[SID].bPausePlayBack = 0;
        P2PEnableplaybackStreaming--;
        DEBUG_P2P("P2PEnableplaybackStreaming5555=%d\n",P2PEnableplaybackStreaming);
        P2PEnableplaybackStreaming=0;
        OSSemSet(P2PVideoPlaybackCmpSemEvt, 0, &err);
        OSSemSet(P2PAudioPlaybackCmpSemEvt, 0, &err);
        gClientInfo[SID].playBackCh=0;
        DEBUG_P2P("Fileplaying= %d ,Remote_play= %d \n",Fileplaying,Remote_play);
        DEBUG_P2P("DELETE P2P PLAYFILE TASK.\n");
        if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
            DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");

        //OSFlagPend(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_PLAY_FINISH, OS_FLAG_WAIT_CLR_ALL|OS_FLAG_CONSUME, OS_IPC_WAIT_FOREVER, &err);
        //DEBUG_P2P("pend FLAGSYS_RDYSTAT_PLAY_FINISH.\n");

        if(OS_NO_ERR !=  OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY))
            DEBUG_P2P("OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
        /*
        error=OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY);
        if(error!=OS_NO_ERR)
        	DEBUG_P2P("OSTaskDel error : %d\n",error);
        */
        Fileplaying=0;
        Remote_play=0;
#if(UI_VERSION == UI_VERSION_MAYON)
		CurrPlaybackSID = -1;
#endif
    }

    //for check device connect timeout by aher 2012/12/21
    if(gOnlineNum<=0)
    {
        if(gFirstConnect)
        {
            if(gClientInfo[SID].bEnableSpeaker>0)
            {
                Kill_Task_Speaker(SID);
            }
            /*Close remote playback task.*/
            if((Fileplaying)&&(Remote_play==1))
            {
                P2PPlaybackVideoStop=1;
                unregedit_client_from_video(SID);
                gClientInfo[SID].bStopPlayBack = 1;
                gClientInfo[SID].bPausePlayBack = 0;
                P2PEnableplaybackStreaming=0;
                OSSemSet(P2PVideoPlaybackCmpSemEvt, 0, &err);
                OSSemSet(P2PAudioPlaybackCmpSemEvt, 0, &err);
                DEBUG_P2P("Fileplaying= %d ,Remote_play= %d \n",Fileplaying,Remote_play);
                DEBUG_P2P("DELETE P2P PLAYFILE TASK.\n");
                if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
                    DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");

                OSFlagPend(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_PLAY_FINISH, OS_FLAG_WAIT_CLR_ALL|OS_FLAG_CONSUME, OS_IPC_WAIT_FOREVER, &err);
                DEBUG_P2P("pend FLAGSYS_RDYSTAT_PLAY_FINISH.\n");

                if(OS_NO_ERR !=  OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY))
                    DEBUG_P2P("OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
                /*
                error=OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY);
                if(error!=OS_NO_ERR)
                		DEBUG_P2P("OSTaskDel error : %d\n",error);
                */
                Fileplaying=0;
                Remote_play=0;
#if(UI_VERSION == UI_VERSION_MAYON)
				CurrPlaybackSID = -1;
#endif
                search_dir_start.YMD=0;
                search_dir_start.HMS=0;
                search_dir_end.YMD=0;
                search_dir_end.HMS=0;
            }
            //gFirstConnect=0;
        }
        for (i = 0; i < MAX_AV_CH; i++)
            uiSetP2PImageLevel(i,0);
    }

    return 0;
}
#endif

void ClearP2PConnection()
{
    int i;
    u8 err;
    DEBUG_P2P("All device connection timeout.\n");
    if(gOnlineNum<=0)
    {
        /*Reset the counter of remote playback*/
        if(Fileplaying&&Remote_play)
        {
            //OSFlagPend(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_PLAY_START, OS_FLAG_WAIT_SET_ALL, OS_IPC_WAIT_FOREVER, &err);
            if(OS_NO_ERR !=  OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY))
                DEBUG_P2P("OSTaskSuspend(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");

            OSFlagPend(gSysReadyFlagGrp, FLAGSYS_RDYSTAT_PLAY_FINISH, OS_FLAG_WAIT_CLR_ALL|OS_FLAG_CONSUME, OS_IPC_WAIT_FOREVER, &err);
            DEBUG_P2P("pend FLAGSYS_RDYSTAT_PLAY_FINISH.\n");

            if(OS_NO_ERR !=  OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY))
                DEBUG_P2P("OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY) error!!\n");
            /*
            DEBUG_P2P("DELETE P2P PLAYFILE TASK.\n");
            error=OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY);
            if(error!=OS_NO_ERR)
            	DEBUG_P2P("OSTaskDel error : %d\n",error);
            */
            Fileplaying=0;
            Remote_play=0;
#if(UI_VERSION == UI_VERSION_MAYON)
			CurrPlaybackSID = -1;
#endif
        }
        gOnlineNum=0;
        gFirstConnect=0;
        videoquality=2;

        for (i = 0; i < MAX_AV_CH; i++)
        {
            P2PEnableStreaming[i]=0;
            if(gClientInfo[i].bEnableSpeaker>0)
                Kill_Task_Speaker(i);
        }
    }
#if RFIU_RX_WAKEUP_TX_SCHEME

	gAppWakeCamflag = 0;
	for (i = 0; i < MAX_AV_CH; i++)
		gRfiuUnitCntl[i].WakeUpTxEn = 0;

#endif

}
void SendAudioFrameData(int SID, u32 time, int size, char *buf)
{
    FRAMEINFO_t frameInfo;
    int ret;
    if(size == 0) return; //check with Lucian
    if(gClientInfo[SID].bEnableAudio == 0) return;
    memset(&frameInfo, 0, sizeof(FRAMEINFO_t));
    frameInfo.codec_id = MEDIA_CODEC_AUDIO_PCM;
    frameInfo.flags = (AUDIO_SAMPLE_16K << 2) | (AUDIO_DATABITS_8 << 1) | AUDIO_CHANNEL_MONO;
    frameInfo.timestamp = time;

    ret = avSendAudioData(gClientInfo[SID].avChannel, buf, size, &frameInfo, sizeof(FRAMEINFO_t));

    if(ret < 0)
    {
        DEBUG_P2P("avSendAudioData error [%d] SID[%d] avIndex[%d]\n", ret, SID, gClientInfo[SID].avChannel);
        unregedit_client_from_audio(SID);
    }
}

void SendVideoFrameData(int SID, u32 time, u32 flag, int size, char *buf)
{
    FRAMEINFO_t frameInfo;
    int ret;

    if(size == 0)
    {
        return; //check with Lucian
    }
    if(gClientInfo[SID].bEnableVideo == 0)
        return;

    memset(&frameInfo, 0, sizeof(FRAMEINFO_t));

    #if(VIDEO_CODEC_OPTION == MPEG4_CODEC)
	frameInfo.codec_id = MEDIA_CODEC_VIDEO_MPEG4;
    #elif(VIDEO_CODEC_OPTION == H264_CODEC)
    frameInfo.codec_id = MEDIA_CODEC_VIDEO_H264;
    #endif

    if(flag)
        frameInfo.flags = IPC_FRAME_FLAG_IFRAME;
    else
        frameInfo.flags = IPC_FRAME_FLAG_PBFRAME;

    frameInfo.onlineNum = gOnlineNum;
    frameInfo.timestamp = time;

#if P2P_DEBUG_ENA
//if(frameInfo.flags == IPC_FRAME_FLAG_IFRAME)
    gpioSetLevel(2,9,1);
#endif

    ret = avSendFrameData(gClientInfo[SID].avChannel, buf, size, &frameInfo, sizeof(FRAMEINFO_t));

#if P2P_DEBUG_ENA
//if(frameInfo.flags == IPC_FRAME_FLAG_IFRAME)
    gpioSetLevel(2,9,0);
#endif

    if(ret < 0)
    {
        DEBUG_P2P("avSendFrameData error [%d] SID[%d] avIndex[%d]\n", ret, SID, gClientInfo[SID].avChannel);
        unregedit_client_from_video(SID);
    }
}

#if(HW_BOARD_OPTION == MR9200_RX_TRANWO_D8796P) //20171208 add.
void Reset_P2P_Connection(void)
{
    u8 i;

    DEBUG_P2P("\x1B[96mReset_P2P_Connection.\x1B[0m\n");
    OSTaskDel(SESSION_TASK_PRIORITY);

    for(i=0;i<5;i++)
    {
        Clear_Session_Status(i);
        avServExit(i,0);
    }
    Reset_P2P_Session();

    OSTaskDel(P2P_PLAYFILE_TASK_PRIORITY);
    OSTimeDly(10);

	if(OSTaskCreate(Task_SessionHandler, (void *)0, SESSION_TASK_STACK, SESSION_TASK_PRIORITY) != OS_NO_ERR)
	{
		DEBUG_P2P("OSTaskCreate Task_SessionHandler failed[%d]!!!!!!!!!!!!!!!!\n", SESSION_TASK_PRIORITY);
	}

    gOnlineNum = 0;
}

#endif

#if (VIDEO_CODEC_OPTION == H264_CODEC) //Multi-CH, Multi-Client
void Task_SessionHandler(void* pData)
{
	extern u8 qetIP;
#if (HOME_RF_SUPPORT)
	extern char *Get_JSON_ADD_MessageString(SMsgAVIoctrlSetAddSensorResp *resp, char *JSON_buf);
#endif

    u16 video_value[MAX_AV_CH]= {0};
    u16 video_value_max[MAX_AV_CH]= {0};
    u16 audio_value[MAX_AV_CH]= {0};
    u16 audio_value_max[MAX_AV_CH]= {0};
    u32 TimeShift[MAX_AV_CH]= {0};
    unsigned int t1[MAX_AV_CH];
    unsigned int t2[MAX_AV_CH];
    RTC_DATE_TIME gP2PCheckTime;
    int i,ch;
    int ret;
    char IOCtrlBuf[MAX_BUF_SIZE];
    int SyncTime;
    unsigned int dt;
    RTC_DATE_TIME current_time;
    u8 gP2PCheckFail;
    int err;
    char    hostname_IP[50]="";
    char hostname[50];
    int DlyFlag,RunCount, DlyInterval = 10;
    u32 testime=0;
    int mostSemCntCh;
    u16 mostSemCnt;
#if (HOME_RF_SUPPORT)
    char JSON_buf[128];
#endif
    //---------------------------//
    gP2PStatus=0;// if
    timerCountRead(guiRFTimerID, &t1[0]);
    for(i=0; i<MAX_AV_CH; i++)
    {
        t1[i]=t1[0];
        TimeShift[i]=0;
    }
    RunCount=0;
    RTC_Get_Time(&gP2PCheckTime);
    IOTC_Get_Login_Info(&gP2PStatus);
    gP2PCheckFail=0;
    while(1)
    {

#if(HW_BOARD_OPTION == MR9200_RX_TRANWO_D8796P) //20171208 add.
    Reset_P2P_Connection_flag = 0;
#endif
#if(HOME_RF_SUPPORT)

#if 0
        if(gAppPairFlag != 0)
        {
            int size =  sizeof(SMsgAVIoctrlSetAddSensorResp);
            SMsgAVIoctrlSetAddSensorResp q;
            sysAppAddSensor(&q);
            if(avSendIOCtrl(gPairAvIndex, IOTYPE_USER_SETADDSENSOR_RESP, (char*)&q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETADDSENSOR_RESP OK\n\n");
            }
        }
#else
//20181206 Sean Add for test
        if(gAppPairFlag != 0)
        {
		int size =  sizeof(SMsgAVIoctrlSetAddSensorResp);
		SMsgAVIoctrlSetAddSensorResp q;
		sysAppAddSensor(&q);

		memset(IOCtrlBuf, 0, sizeof(IOCtrlBuf));
		Get_JSON_ADD_MessageString(&q, JSON_buf);
            if(avSendIOCtrl(gPairAvIndex, IOTYPE_HA_JASON_CMD_RESP, (char*)&JSON_buf, sizeof(JSON_buf))== AV_ER_NoERROR)
            {
                DEBUG_P2P("SETADDSENSOR_RESP OK\n\n");
            }
        }
#endif
#endif

#if APP_KEEP_ALIVE
			/*===============================KEEP ALIVE==================================*/
		if((APPConnectIcon != 0) || (gOnlineNum > 0))
		{
			for(i=0;i<MAX_CLIENT+1;i++)
			{
				if(!gFlagKeepAlive[i])
				{
					Clear_Session_Status(i);
				}
				else
				{
					RTC_Get_Time(&current_time);
					switch(i)
					{
						case 0:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime0))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[0] = 0;
							RTC_Get_Time(&gKeepAliveTime0);
						}
						break;
						case 1:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime1))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[1] = 0;
							RTC_Get_Time(&gKeepAliveTime1);
						}
						break;
						case 2:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime2))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[2] = 0;
							RTC_Get_Time(&gKeepAliveTime2);
						}
						break;
						case 3:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime3))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[3] = 0;
							RTC_Get_Time(&gKeepAliveTime3);
						}
						case 4:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime4))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[4] = 0;
							RTC_Get_Time(&gKeepAliveTime4);
						}
						break;
						default:
							break;
					}
					//printf("-%d-\n",gFlagKeepAlive);
				}
			}
		}
			/*===============================KEEP ALIVE==================================*/
#endif

        //if(gFlagLoginOK || gLoginFaileCnt < 10)
        if(gFlagLoginOK)
        {
            DEBUG_P2P("*****OSTaskDel(LOGIN_TASK_PRIORITY)*****\n");
            DEBUG_P2P("Login P2Pserve : %d.\n",gFlagLoginOK);
#if 1
            if(gFlagLoginOK)
                SendRegister();//Register the device to APN server
#endif
            OSTaskDel(LOGIN_TASK_PRIORITY);
            gFlagLoginOK = 0;
            gLoginFaileCnt =0;
        }

        DlyFlag=1;
        /*Try to reconnect the P2P server, when P2P info != 7.*/
        RTC_Get_Time(&current_time);
        if(net_link_status==NET_LINK_ON)
        {
            if(gOnlineNum==0)/*Don't check P2P server connection status, when APP is connecting.*/
            {
                if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gP2PCheckTime)))>30)
                {
                    IOTC_Get_Login_Info(&gP2PStatus);
                    RTC_Get_Time(&gP2PCheckTime);
                    if (gP2PStatus<7)
                    {
                        DEBUG_P2P("Retry p2p failed:%d.\n",gP2PCheckFail);
                        gP2PCheckFail++;
                    }
                    else
                        gP2PCheckFail=1;

                    if(gP2PCheckFail<15)    /* Re-open p2p socket, if Check p2p connection fail.*/
                    {
                        if ((gP2PCheckFail%3)==0)
                        {
							#if(HW_BOARD_OPTION == MR9200_RX_TRANWO_D8796P) //20171208 add.
							Reset_P2P_Connection_flag = 1;
							#endif

                            strcpy(hostname,TPNS_SERVER);
                            err=DN2IP(hostname,hostname_IP);
                            if(err!=0)
                                DEBUG_P2P("WAN is not ready...\n");
                            //else //20170216 Sean: this func cause APP can't connect, pbuf_alloc will fail.
                            //{
                            //    DEBUG_P2P("Renew ioctl module.\n");
                            //    renew_iotclModule(2123*gP2PCheckFail);
                            //}

							#if(HW_BOARD_OPTION == MR9200_RX_TRANWO_D8796P) //20171208 add.
							Reset_P2P_Connection_flag = 0;
							Reset_P2P_Connection_Stop_flag = 0;
							#endif
                        }
                    }
                    if(gP2PCheckFail==15) /*Re-new IP, if check p2p connection still fail after re-open socket.*/
                    {
                        ClearNetworkInfo();
                        #if(HW_BOARD_OPTION == MR9200_RX_TRANWO_D8796P) //20171208 add.
						Reset_P2P_Connection_Stop_flag = 1;
						#endif
						#if(HW_BOARD_OPTION == MR9200_RX_RDI_UDR777) //20180201 add.
                        if(qetIP == 0 || SetLwIP(1)==-1)
						#else
                        if(SetLwIP(1)==-1)
                        #endif
                        {
                            DEBUG_P2P("Couldn't get IP, rebooting...\n");
							sysForceWDTtoReboot();
                        }
                        strcpy(hostname,TPNS_SERVER);
                        err=DN2IP(hostname,hostname_IP);
                        if(err!=0)
                            DEBUG_P2P("WAN is not ready...\n");
                        //else //20170216 Sean
                        //{
                        //    renew_iotclModule(45367);
                        //}
						#if(HW_BOARD_OPTION == MR9200_RX_TRANWO_D8796P) //20171208 add.
						Reset_P2P_Connection_flag = 0;
					    Reset_P2P_Connection_Stop_flag = 0;
					    #endif
                    }
                    if(gP2PCheckFail==30) /*Reboot device, if check p2p connection still fail after re-new ip.*/
                    {
                        DEBUG_P2P("P2P connection couldn't recovery, rebooting...\n");
						sysForceWDTtoReboot();
                    }
                }
            }
        }

        for(ch=0; ch<MAX_AV_CH; ch++)
        {
            // ------Streaming audio payload------//
            if((video_value[ch] == 0) || (P2PAudioPresentTime[ch] <= P2PVideoPresentTime[ch]))
            {
                audio_value[ch] = OSSemAccept(P2PAudioCmpSemEvt[ch]);
                if (audio_value[ch] > 0)
                {
                    if(audio_value_max[ch] < audio_value[ch])
                        audio_value_max[ch] = audio_value[ch];
                    //DEBUG_P2P("PAIdx = %d iisIdx = %d\n", P2PAudioBufReadIdx[ch], VideoClipOption[ch + 1].iisSounBufMngWriteIdx);
                }

                for(i=0; i<MAX_CLIENT; i++)
                {
#if 1
                    if((ret = Check_Session_Status(i)) < 0) //session disconnected
                    {
                        continue;
                    }
                    //aher test 20140316
                    if(gClientInfo[i].playBackCh!=0)
                    {
                        Handle_IOCTRL_Cmd(i, gClientInfo[CurrPlaybackSID].avChannel, IOCtrlBuf);
                    }

                    Handle_IOCTRL_Cmd(i, gClientInfo[i].avIndex[ch], IOCtrlBuf);
#endif

                    if((gClientInfo[i].avIndex[ch] == gClientInfo[i].avChannel) && (gClientInfo[i].bEnableAudio > 0) && (audio_value[ch] > 0))
                    {
                        //TUTK API only support 1024byte
                        /*
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]   , 1024, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+64, 1024, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+1024);
                        */
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]   , 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+20, 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+320);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+40, 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+640);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+60, 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+960);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+80, 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+1280);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+100,320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+1600);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+108, 128, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+1920);

                    }
                }

                if (audio_value[ch] > 0)
                {
#if( (SW_APPLICATION_OPTION == MR8200_RFCAM_RX1RX2) || (SW_APPLICATION_OPTION == MR9300_RFDVR_RX1RX2) || (SW_APPLICATION_OPTION == MR9300_NETBOX_RX1RX2) || (SW_APPLICATION_OPTION == MR9200_HDMI_RX1RX2) || (SW_APPLICATION_OPTION == MR9200_MIXCAM_RX1RX2) || (SW_APPLICATION_OPTION == MR8200_RFCAM_RX1) )
                    timerCountRead(guiRFTimerID, &t2[ch]);
                    if(P2PChannelStart[ch])
                    {
                        t1[ch]=t2[ch];
                        P2PChannelStart[ch]=0;
                        TimeShift[ch]=0;
                    }
                    if(t1[ch] >= t2[ch])
                        dt=t1[ch]-t2[ch];
                    else
                        dt=(t1[ch]+TimerGetTimerCounter(TIMER_7))-t2[ch];

                    if(dt > 20000)
                    {
                        TimeShift[ch] = dt/10;
                        if(P2PChannelStart[ch])
                            TimeShift[ch]=0;
                        else
                        {
                            P2PAudioPresentTime[ch] += (TimeShift[ch]+2000);
                            P2PVideoPresentTime[ch] += (TimeShift[ch]+2000);
                            DEBUG_P2P("--->P2P Ch-%d Shift=%d ms\n",ch,TimeShift[ch]);
                        }
                    }
                    else
                        TimeShift[ch]=0;
                    t1[ch]=t2[ch];
#else
                    TimeShift[ch]=0;
#endif

                    P2PAudioPresentTime[ch] += (P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time);    //if use chunk time
                    P2PAudioBufReadIdx[ch]   = (P2PAudioBufReadIdx[ch] + 1) % IIS_BUF_NUM;
                    //DEBUG_P2P("A%d ",audio_value[ch]);
                }
            }

            //------ Streaming video payload------//
            if((audio_value[ch] == 0) || (P2PAudioPresentTime[ch] >= P2PVideoPresentTime[ch]))
            {
                video_value[ch] = OSSemAccept(P2PVideoCmpSemEvt[ch]);
                if (video_value[ch] > 0)
                {
                    //DEBUG_P2P("ch[%d]=%d\n", ch, P2PVideoCmpSemEvt[ch]->OSEventCnt);
                    if(video_value_max[ch] < video_value[ch])
                        video_value_max[ch] = video_value[ch];
                    P2PVideoPresentTime[ch] += (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].time); //if use chunk time
                }
                for(i=0; i<MAX_CLIENT; i++)
                {
                    if((ret = Check_Session_Status(i)) < 0)
                    {
                        continue;
                    }
                    //aher test 20140316
                    if(gClientInfo[i].playBackCh!=0)
                    {
                        Handle_IOCTRL_Cmd(i, gClientInfo[CurrPlaybackSID].avChannel, IOCtrlBuf);
                    }

                    Handle_IOCTRL_Cmd(i, gClientInfo[i].avIndex[ch], IOCtrlBuf);
#if( (SW_APPLICATION_OPTION == MR9300_RFDVR_RX1RX2) || (SW_APPLICATION_OPTION == MR9300_NETBOX_RX1RX2) )
                    //DEBUG_P2P("videoquality =%d\n",videoquality);
                    if(videoquality == 1)
                    {
                        if((gClientInfo[i].avIndex[ch] == gClientInfo[i].avChannel) && (gClientInfo[i].bEnableVideo) && (video_value[ch] > 0))
                        {
                            if((gClientInfo[i].VOLSend == 0||gClientInfo[i].VOLSend == 5 ) && P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag)
                            {
                                if(P2P_AV_Source[ch] == Local_record)
                                    UpdateHeader(ch, USE_MPEG_QUANTIZATION);
                                else
                                    UpdateH264Header(ch);

                                if (h264header_updata[i] == 0)
                                {
                                    h264header_updata[i]++;
                                    memcpy(p2plocal_buffer, H264_config, 0x18);
                                    memcpy_hw(p2plocal_buffer+0x18, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                }
                                else
                                {
                                    memcpy_hw(p2plocal_buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                    //DEBUG_P2P("I=%2x%2x%2x%2x%2x\n",*(p2plocal_buffer+0x1d),*(p2plocal_buffer+0x1d+1),
                                    //*(p2plocal_buffer+0x1d+2),*(p2plocal_buffer+0x1d+3),*(p2plocal_buffer+0x1d+4));
                                }

                                //DEBUG_P2P("It=%lu\n",P2PVideoPresentTime[ch]);
                                gClientInfo[i].VOLSend = 1; //[ ,tutk S^ 20121404
                                SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset+0x18, p2plocal_buffer);
                                //Wait P2P client send the Ioctl command "IOTYPE_USER_IPCAM_RECEIVE_FIRST_IFRAME"
                                //Send the VOL pre second.

                                if(gClientInfo[i].VOLSend == 5)
                                    gClientInfo[i].VOLSend = 1;
                            }
                            else if(gClientInfo[i].VOLSend >= 1)
                            {
                                //DEBUG_P2P("Pt=%lu\n",P2PVideoPresentTime[ch]);
                                SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer);
                                if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag)
                                {
                                    gClientInfo[i].VOLSend++;
                                }
                            }
                            //DEBUG_P2P("V%d ",video_value[ch]);
                        }
                    }
                    else
                    {
                        if((gClientInfo[i].avIndex[ch] == gClientInfo[i].avChannel) && (gClientInfo[i].bEnableVideo) && (video_value[ch] > 0))
                        {
                            if((gClientInfo[i].VOLSend==0||gClientInfo[i].VOLSend==5 )&& P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag)
                            {
                                if(P2P_AV_Source[ch] == Local_record)
                                    UpdateHeader(ch, USE_MPEG_QUANTIZATION);
                                else
                                    UpdateH264Header(ch);

                                if (h264header_updata[i]==0)
                                {
                                    h264header_updata[i]++;
                                    memcpy(p2plocal_buffer, H264_config, 0x18);
                                    if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size == 0)
                                        memcpy_hw(p2plocal_buffer+0x18, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                    else
                                        memcpy_hw(p2plocal_buffer+0x18, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset));
                                }
                                else
                                {
                                    if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size == 0)
                                        memcpy_hw(p2plocal_buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                    else
                                        memcpy_hw(p2plocal_buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset));
                                    //DEBUG_P2P("I=%2x%2x%2x%2x%2x\n",*(p2plocal_buffer+0x1d),*(p2plocal_buffer+0x1d+1),
                                    //*(p2plocal_buffer+0x1d+2),*(p2plocal_buffer+0x1d+3),*(p2plocal_buffer+0x1d+4));
                                }

                                //DEBUG_P2P("It=%lu\n",P2PVideoPresentTime[ch]);
                                gClientInfo[i].VOLSend = 1; //[ ,tutk S^ 20121404
                                if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size == 0)
                                    SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset+0x18, p2plocal_buffer);
                                else
                                    SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset)+0x18, p2plocal_buffer);

                                //Wait P2P client send the Ioctl command "IOTYPE_USER_IPCAM_RECEIVE_FIRST_IFRAME"
                                //Send the VOL pre second.

                                if(gClientInfo[i].VOLSend == 5)
                                    gClientInfo[i].VOLSend = 1;
                            }
                            else if(gClientInfo[i].VOLSend >= 1)
                            {
                                //DEBUG_P2P("Pt=%lu\n",P2PVideoPresentTime[ch]);
                                if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size == 0)
                                    SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag,  P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer);
                                else
                                    SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset), P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag)
                                {
                                    gClientInfo[i].VOLSend++;
                                }
                            }
                            //DEBUG_P2P("V%d ",video_value[ch]);
                        }
                    }
#else
                    //DEBUG_P2P("videoquality =%d\n",videoquality);
                    if((videoquality == 1) || (videoquality == 2))
                    {
                        if((gClientInfo[i].avIndex[ch] == gClientInfo[i].avChannel) && (gClientInfo[i].bEnableVideo) && (video_value[ch] > 0))
                        {
                            if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag)
                            {
#if(UI_VERSION == UI_VERSION_MAYON)
								if(gClientInfo[i].VOLSend==0)
									DEBUG_P2P("-iF-\n");
#endif
                                if(h264header_updata[i] <= 5)
                                {
                                    if(P2P_AV_Source[ch] == Local_record)
                                        UpdateHeader(ch, USE_MPEG_QUANTIZATION);
                                    else
                                        UpdateH264Header(ch);
                                    h264header_updata[i]++;
                                    memcpy(p2plocal_buffer, H264_config, 0x18);
                                    if((P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset+0x18) > (1920*1088*2))
                                        printf("#1 offset %d\n",P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                    memcpy_hw(p2plocal_buffer+0x18, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                    SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset+0x18, p2plocal_buffer);
                                }
                                else
                                {
                                    if((P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset) > (1920*1088*2))
                                        printf("#2 offset %d\n",P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                    memcpy_hw(p2plocal_buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                                    SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, p2plocal_buffer);
                                    //DEBUG_P2P("I=%2x%2x%2x%2x%2x\n",*(p2plocal_buffer+0x1d),*(p2plocal_buffer+0x1d+1),
                                    //*(p2plocal_buffer+0x1d+2),*(p2plocal_buffer+0x1d+3),*(p2plocal_buffer+0x1d+4));
                                }


                            }
                            else
                            {
                                //DEBUG_P2P("Pt=%lu,%d\n",P2PVideoBufReadIdx[ch], rfiuRxVideoBufMngWriteIdx[ch]);
                                SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer);
                            }
                            //DEBUG_P2P("V%d ",video_value[ch]);
                        }
                    }
                    else
                    {
                        if((gClientInfo[i].avIndex[ch] == gClientInfo[i].avChannel) && (gClientInfo[i].bEnableVideo) && (video_value[ch] > 0))
                        {
                            if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag)
                            {
                                if(h264header_updata[i] <= 5)
                                {
                                    if(P2P_AV_Source[ch] == Local_record)
                                        UpdateHeader(ch, USE_MPEG_QUANTIZATION);
                                    else
                                        UpdateH264Header(ch);
                                    h264header_updata[i]++;
                                    memcpy(p2plocal_buffer, H264_config, 0x18);
                                    if((P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset+0x18) > (1920*1088*2))
                                        printf("#1 size %d offset %d\n",P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size,P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
									/* Sean Edit 20160825 */
									if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size == 0)
									{
										memcpy_hw(p2plocal_buffer+0x18, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset));
										SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset)+0x18, p2plocal_buffer);
									}
									else
									{
										memcpy_hw(p2plocal_buffer+0x18, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset));
										SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset)+0x18, p2plocal_buffer);
									}
									/* Sean Edit End 20160825 */
                                }
                                else
                                {
                                    if((P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset) > (1920*1088*2))
                                        printf("#2 size %d offset %d\n",P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size,P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
									/* Sean Edit 20160825 */
									if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size == 0)
									{
										memcpy_hw(p2plocal_buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset));
										SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset), p2plocal_buffer);
									}
									else
									{
										memcpy_hw(p2plocal_buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset));
										SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset), p2plocal_buffer);
									}
									/* Sean Edit End 20160825 */

                                    //DEBUG_P2P("I=%2x%2x%2x%2x%2x\n",*(p2plocal_buffer+0x1d),*(p2plocal_buffer+0x1d+1),
                                    //*(p2plocal_buffer+0x1d+2),*(p2plocal_buffer+0x1d+3),*(p2plocal_buffer+0x1d+4));
                                }

                            }
                            else
                            {
                                //DEBUG_P2P("Pt=%lu\n",P2PVideoPresentTime[ch]);
                                SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size - P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset), P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer + P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].offset);
                            }
                            //DEBUG_P2P("V%d ",video_value[ch]);
                        }
                    }
#endif
                }

                if (video_value[ch] > 0)
                {
                    P2PVideoBufReadIdx[ch] = (P2PVideoBufReadIdx[ch] + 1) % VIDEO_BUF_NUM;
                }
            }

            ///------------------- Bitstream buffer control---------------------------------//
            /*
                 Lsk: HVideo bitstream buffer indexlI,Yj ASF_DROP_FRAME_THRESHOLD
                         htLC,drop frame.

            */
            if( (P2PVideoCmpSemEvt[ch]->OSEventCnt > 60) )
            {
                DEBUG_P2P("\nP2P-%d DROP Video frame Start:(%d,%d) \n",ch,P2PVideoPresentTime[ch],P2PAudioPresentTime[ch]);
                SyncTime=0;
                //------Video-----//
                do
                {
                    video_value[ch] = OSSemAccept(P2PVideoCmpSemEvt[ch]);
                    //DEBUG_P2P("%d ",video_value[ch]);
                    if (video_value[ch] > 0)
                    {
                        if(video_value_max[ch] < video_value[ch])
                            video_value_max[ch] = video_value[ch];

                        P2PVideoPresentTime[ch] += P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].time;
                        SyncTime += P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].time;
                        P2PVideoBufReadIdx[ch] = (P2PVideoBufReadIdx[ch] + 1) % VIDEO_BUF_NUM;
                    }
                    else
                    {
                        DEBUG_P2P("Video buffer empty!\n");
                        //break;
                        OSTimeDly(1);
                    }
                }
                while(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag != FLAG_I_VOP);

                //------Audio-----//
                DEBUG_P2P("P2P-%d DROP Audio frame Start:%d,SyncTime=%d \n",ch,P2PAudioCmpSemEvt[ch]->OSEventCnt,SyncTime);

                do
                {
                    audio_value[ch] = OSSemAccept(P2PAudioCmpSemEvt[ch]);
                    //DEBUG_P2P("%d ",audio_value[ch]);

                    if (audio_value[ch] > 0)
                    {
                        if(audio_value_max[ch] < audio_value[ch])
                            audio_value_max[ch] = audio_value[ch];

                        P2PAudioPresentTime[ch] += P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time;
                        SyncTime -= P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time;
                        P2PAudioBufReadIdx[ch] = (P2PAudioBufReadIdx[ch] + 1) % IIS_BUF_NUM;
                    }
                    else
                    {
                        DEBUG_P2P("Audio buffer empty!\n");
                        break;
                    }

                    if(SyncTime < 0)
                        break;
                }
                while( (P2PAudioPresentTime[ch] < P2PVideoPresentTime[ch]) );

                //P2PAudioPresentTime[ch] = P2PVideoPresentTime[ch];
                DEBUG_P2P("P2P-%d DROP frame End:(%d,%d)!!\n\n",ch,P2PVideoPresentTime[ch],P2PAudioPresentTime[ch]);
                sysDeadLockMonitor_Reset();
                DlyFlag=0;
                RunCount=0;
                //OSTimeDly(1);
            }

            if ( (video_value[ch] > 0) || (audio_value[ch] > 0) )
                DlyFlag=0;
        }


	/*adjust delay interval, Delay too much will cause P2P liveView lag, Delay too less will cause Record and System cannot get any CPU resource*/
	 mostSemCnt = 0;
	 mostSemCntCh = -1;

	if((DlyFlag == 0) && ((RunCount % DlyInterval) == 0))
	{
		/* get the Channel, which has the most sem cnt */
	        for(ch=0; ch<MAX_AV_CH; ch++)
	        {
		        if(MultiChannelGetCaptureVideoStatus(ch))
			{
				if(VideoClipOption[ch].VideoCmpSemEvt->OSEventCnt > mostSemCnt)
				{
					mostSemCnt = VideoClipOption[ch].VideoCmpSemEvt->OSEventCnt;
					mostSemCntCh = ch;
				}
		        }
	        }
		 if(mostSemCntCh >= 0) //recording channel exists
		 {
		      if(mostSemCnt > 60)
			    DlyInterval = 3;
		      else if(mostSemCnt > 40)
			    DlyInterval = 5;
			else if(mostSemCnt > 20)
			    DlyInterval = 7;
			else
			    DlyInterval = 10;
	         }
		  else  //no recording
	              DlyInterval = 10;
	 }

        if(DlyFlag)
        {
            RunCount=0;
            //DEBUG_P2P("&");
            OSTimeDly(1);

        }
        else
        {
            if( (RunCount % DlyInterval) == 0) //Lucian: release CPU power
            {
                //DEBUG_P2P("V=%d ",P2PVideoCmpSemEvt[ch]->OSEventCnt);
                //DEBUG_P2P("Rcnt=%d ",RunCount);
                if(RunCount>100)
                    sysDeadLockMonitor_Reset();
                OSTimeDly(1);
            }
        }

        RunCount ++;
    }
}
#else
void Task_SessionHandler(void* pData)
{
    u16 video_value[MAX_AV_CH]={0};
    u16 video_value_max[MAX_AV_CH]={0};
    u16 audio_value[MAX_AV_CH]={0};
    u16 audio_value_max[MAX_AV_CH]={0};
    u32 TimeShift[MAX_AV_CH]={0};
    unsigned int t1[MAX_AV_CH];
    unsigned int t2[MAX_AV_CH];
    RTC_DATE_TIME gP2PCheckTime;
    int i,ch;
    int ret;
    char IOCtrlBuf[MAX_BUF_SIZE];
    int SyncTime;
    unsigned int dt;
    RTC_DATE_TIME current_time;
    u8 gP2PCheckFail;
    int err;
    char    hostname_IP[50]="";
    char hostname[50];

    int DlyFlag,RunCount;
    //---------------------------//
    gP2PStatus=0;// if
    timerCountRead(guiRFTimerID, &t1[0]);
    for(i=0;i<MAX_AV_CH;i++)
    {
        t1[i]=t1[0];
        TimeShift[i]=0;
    }
    RunCount=0;
    RTC_Get_Time(&gP2PCheckTime);
    IOTC_Get_Login_Info(&gP2PStatus);
    gP2PCheckFail=0;
    while(1)
    {
    #if((HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M721) && (PROJ_OPT == 5)) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M706) && (PROJ_OPT == 8))) //Sean: 20170621 add. //20171208 add M732HT
    Reset_P2P_Connection_flag = 0;
    #endif
    #if(HOME_RF_SUPPORT)
        if(gAppPairFlag != 0)
        {
            int size =  sizeof(SMsgAVIoctrlSetAddSensorResp);
            SMsgAVIoctrlSetAddSensorResp q;
            sysAppAddSensor(&q);
            if(avSendIOCtrl(gPairAvIndex, IOTYPE_USER_SETADDSENSOR_RESP, (char*)&q, size)== AV_ER_NoERROR)
            {
                DEBUG_P2P("IOTYPE_SETADDSENSOR_RESP OK\n\n");
            }
        }
#endif
#if APP_KEEP_ALIVE
/*===============================KEEP ALIVE==================================*/
		if((APPConnectIcon != 0) || (gOnlineNum > 0))
		{
			for(i=0;i<MAX_CLIENT+1;i++)
			{
				if(!gFlagKeepAlive[i])
				{
					Clear_Session_Status(i);
				}
				else
				{
					RTC_Get_Time(&current_time);
					switch(i)
					{
						case 0:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime0))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[0] = 0;
							RTC_Get_Time(&gKeepAliveTime0);
						}
						break;
						case 1:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime1))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[1] = 0;
							RTC_Get_Time(&gKeepAliveTime1);
						}
						break;
						case 2:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime2))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[2] = 0;
							RTC_Get_Time(&gKeepAliveTime2);
						}
						break;
						case 3:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime3))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[3] = 0;
							RTC_Get_Time(&gKeepAliveTime3);
						}
						case 4:
						if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gKeepAliveTime4))) >= KEEP_ALIVE_TIMEOUT)
						{
							gFlagKeepAlive[4] = 0;
							RTC_Get_Time(&gKeepAliveTime4);
						}
						break;
						default:
							break;
					}
					//printf("-%d-\n",gFlagKeepAlive);
				}
			}
		}
/*===============================KEEP ALIVE==================================*/
#endif

        //if(gFlagLoginOK || gLoginFaileCnt < 10)
        if(gFlagLoginOK)
        {
            DEBUG_P2P("*****OSTaskDel(LOGIN_TASK_PRIORITY)*****\n");
            DEBUG_P2P("Login P2Pserve : %d.\n",gFlagLoginOK);
            if(gFlagLoginOK)
                SendRegister();//Register the device to APN server
            OSTaskDel(LOGIN_TASK_PRIORITY);
            gFlagLoginOK = 0;
            gLoginFaileCnt =0;
        }

        DlyFlag=1;
        /*Try to reconnect the P2P server, when P2P info != 7.*/
        RTC_Get_Time(&current_time);
        if(net_link_status==NET_LINK_ON)
        {
        	#if(HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) //Sean: 20170608 add.
        	//Check all the time.
        	#else
            if(gOnlineNum==0)/*Don't check P2P server connection status, when APP is connecting.*/
            #endif
            {
                if(((RTC_Time_To_Second(&current_time))-(RTC_Time_To_Second(&gP2PCheckTime)))>30)
                {
                    IOTC_Get_Login_Info(&gP2PStatus);
                    RTC_Get_Time(&gP2PCheckTime);
                    if (gP2PStatus<7)
                    {
                        DEBUG_P2P("Retry p2p failed.\n");
                        gP2PCheckFail++;
                    }
                    else
                        gP2PCheckFail=1;

                    if(gP2PCheckFail<15)    /* Re-open p2p socket, if Check p2p connection fail.*/
                    {
                        if ((gP2PCheckFail%3)==0)
                        {
							#if((HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M721) && (PROJ_OPT == 5)) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M706) && (PROJ_OPT == 8))) //Sean: 20170621 add. //20171208 add M732HT
							Reset_P2P_Connection_Stop_flag = 1;
							#endif

                            strcpy(hostname,TPNS_SERVER);
                            err=DN2IP(hostname,hostname_IP);
                            if(err!=0)
                                DEBUG_P2P("WAN is not ready...\n");
                            //else //20170216 Sean: this func cause APP can't connect, pbuf_alloc will fail.
                            //{
                            //#if(HW_BOARD_OPTION != MR8200_RX_TRANWO_SMH101_HA)
                            //    DEBUG_P2P("Renew ioctl module.\n");
                            //    renew_iotclModule(2123*gP2PCheckFail);
                            //#endif
                            //}
                            //Reset_P2P_Connection();

							#if((HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M721) && (PROJ_OPT == 5)) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M706) && (PROJ_OPT == 8))) //Sean: 20170621 add. //20171208 add M732HT
							Reset_P2P_Connection_flag = 0;
							Reset_P2P_Connection_Stop_flag = 0;
							#endif
                        }
                    }
                    if(gP2PCheckFail==15) /*Re-new IP, if check p2p connection still fail after re-open socket.*/
                    {
                        ClearNetworkInfo();
						#if((HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M721) && (PROJ_OPT == 5)) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M706) && (PROJ_OPT == 8))) //Sean: 20170621 add. //20171208 add M732HT
					    Reset_P2P_Connection_Stop_flag = 1;
					    #endif
                        if(SetLwIP(1)==-1)
                        {
                            DEBUG_P2P("Couldn't get IP, rebooting...\n");
							sysForceWDTtoReboot();
                        }

                        strcpy(hostname,TPNS_SERVER);
                        err=DN2IP(hostname,hostname_IP);
                        if(err!=0)
                            DEBUG_P2P("WAN is not ready...\n");
                        //else //20170216 Sean
                        //{
                        //	#if(HW_BOARD_OPTION != MR8200_RX_TRANWO_SMH101_HA)
                        //    renew_iotclModule(45367);
                        //    #endif
                        //}
						#if((HW_BOARD_OPTION == MR8200_RX_TRANWO_SMH101_HA) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M721) && (PROJ_OPT == 5)) || ((HW_BOARD_OPTION == MR8200_RX_RDI_M706) && (PROJ_OPT == 8))) //Sean: 20170621 add. //20171208 add M732HT
						Reset_P2P_Connection_flag = 0;
					    Reset_P2P_Connection_Stop_flag = 0;
					    #endif
                    }
                    if(gP2PCheckFail==30) /*Reboot device, if check p2p connection still fail after re-new ip.*/
                    {
                        DEBUG_P2P("P2P connection couldn't recovery, rebooting...\n");
						sysForceWDTtoReboot();
                    }
                }
            }
        }

        for(ch=0; ch<MAX_AV_CH; ch++)
        {
            // ------Streaming audio payload------//
            if((video_value[ch] == 0) || (P2PAudioPresentTime[ch] <= P2PVideoPresentTime[ch]))
            {
                audio_value[ch] = OSSemAccept(P2PAudioCmpSemEvt[ch]);
                if (audio_value[ch] > 0)
                {
                    if(audio_value_max[ch] < audio_value[ch])
                        audio_value_max[ch] = audio_value[ch];
                    //DEBUG_P2P("PAIdx = %d iisIdx = %d\n", P2PAudioBufReadIdx[ch], VideoClipOption[ch + 1].iisSounBufMngWriteIdx);
                }

                for(i=0;i<MAX_CLIENT;i++)
                {
#if 1
                    if((ret = Check_Session_Status(i)) < 0) //session disconnected
                    {
                        continue;
                    }
                    //aher test 20140316
                    if(gClientInfo[i].playBackCh!=0)
                    {
                        Handle_IOCTRL_Cmd(i, gClientInfo[CurrPlaybackSID].avChannel, IOCtrlBuf);
                    }

                    Handle_IOCTRL_Cmd(i, gClientInfo[i].avIndex[ch], IOCtrlBuf);
#endif

                    if((gClientInfo[i].avIndex[ch] == gClientInfo[i].avChannel) && (gClientInfo[i].bEnableAudio > 0) && (audio_value[ch] > 0))
                    {
                        //TUTK API only support 1024byte
                        /*
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]   , 1024, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+64, 1024, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+1024);
                        */
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]   , 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+20, 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+320);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+40, 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+640);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+60, 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+960);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+80, 320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+1280);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+100,320, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+1600);
                        SendAudioFrameData(i, P2PAudioPresentTime[ch]+108, 128, P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].buffer+1920);

                    }
                }

                if (audio_value[ch] > 0)
                {
#if( (SW_APPLICATION_OPTION == MR8200_RFCAM_RX1RX2) || (SW_APPLICATION_OPTION == MR8200_RFCAM_RX1) || (SW_APPLICATION_OPTION == MR8100_BABYMONITOR) || (SW_APPLICATION_OPTION == MR8100_DUALMODE_VBM) )

                    timerCountRead(guiRFTimerID, &t2[ch]);
                    if(P2PChannelStart[ch])
                    {
                        t1[ch]=t2[ch];
                        P2PChannelStart[ch]=0;
                        TimeShift[ch]=0;
                    }
                    if(t1[ch] >= t2[ch])
                        dt=t1[ch]-t2[ch];
                    else
                        dt=(t1[ch]+TimerGetTimerCounter(TIMER_7))-t2[ch];

                    if(dt > 20000)
                    {
                        TimeShift[ch] = dt/10;
                        if(P2PChannelStart[ch])
                            TimeShift[ch]=0;
                        else
                        {
                            P2PAudioPresentTime[ch] += (TimeShift[ch]+2000);
                            P2PVideoPresentTime[ch] += (TimeShift[ch]+2000);
                            DEBUG_P2P("--->P2P Ch-%d Shift=%d ms\n",ch,TimeShift[ch]);
                        }
                    }
                    else
                        TimeShift[ch]=0;
                    t1[ch]=t2[ch];
#else
                    TimeShift[ch]=0;
#endif

                    P2PAudioPresentTime[ch] += (P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time);    //if use chunk time
                    P2PAudioBufReadIdx[ch]   = (P2PAudioBufReadIdx[ch] + 1) % IIS_BUF_NUM;
                    //DEBUG_P2P("A%d ",audio_value[ch]);
                }
            }

            //------ Streaming video payload------//
            if((audio_value[ch] == 0) || (P2PAudioPresentTime[ch] >= P2PVideoPresentTime[ch]))
            {
                video_value[ch] = OSSemAccept(P2PVideoCmpSemEvt[ch]);
                if (video_value[ch] > 0)
                {
                    //DEBUG_P2P("P2PVideoCmpSemEvt[%d]=%d\n", ch, P2PVideoCmpSemEvt[ch]->OSEventCnt);
                    if(video_value_max[ch] < video_value[ch])
                        video_value_max[ch] = video_value[ch];
                    P2PVideoPresentTime[ch] += (P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].time); //if use chunk time
                }
                for(i=0;i<MAX_CLIENT;i++)
                {
                    if((ret = Check_Session_Status(i)) < 0)
                    {
                        continue;
                    }
                    //aher test 20140316
                    if(gClientInfo[i].playBackCh!=0)
                    {
                        Handle_IOCTRL_Cmd(i, gClientInfo[CurrPlaybackSID].avChannel, IOCtrlBuf);
                    }

                    Handle_IOCTRL_Cmd(i, gClientInfo[i].avIndex[ch], IOCtrlBuf);
                    if((gClientInfo[i].avIndex[ch] == gClientInfo[i].avChannel) && (gClientInfo[i].bEnableVideo) && (video_value[ch] > 0))
                    {
                        if((gClientInfo[i].VOLSend==0||gClientInfo[i].VOLSend==5 )&& P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag)
                        {
                            if(P2P_AV_Source[ch] == Local_record)
                                UpdateHeader(ch, USE_MPEG_QUANTIZATION);
                            else
                            {
                                if(gFirstConnect==0)//APP@su,NVOL]VGA
                                {//Paul modify for D8530
#if (HW_BOARD_OPTION == MR8202A_RX_TARNWO_D8530)
                                    gPlaybackWidth=1280;
                                    gPlaybackHeight=720;
#else
                                    gPlaybackWidth=640;
                                    gPlaybackHeight=480;
#endif
                                    gFirstConnect=1;
                                    UpdateHeader(6,USE_MPEG_QUANTIZATION);
                                }
                                else
                                    UpdateHeader(ch,gRfiuUnitCntl[ch].TX_Status & RFIU_TX_STA_MPEG_Q);
                            }

                            memcpy(p2plocal_buffer, MPEG4_config, 0x1d);
                            memcpy_hw(p2plocal_buffer+0x1d, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size);
                            SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, 0x1d+P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size, p2plocal_buffer);
                            //Wait P2P client send the Ioctl command "IOTYPE_USER_IPCAM_RECEIVE_FIRST_IFRAME"
                            //Send the VOL pre second.
                            if(gClientInfo[i].VOLSend==5)
                                gClientInfo[i].VOLSend = 1;
                        }
                        else if(gClientInfo[i].VOLSend>=1)
                        {
                            SendVideoFrameData(i, P2PVideoPresentTime[ch], P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].size, P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].buffer);
                            if(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag)
                            {
                                gClientInfo[i].VOLSend++;
                            }
                        }
                        //DEBUG_P2P("V%d ",video_value[ch]);
                    }


                }

                if (video_value[ch] > 0)
                {
                P2PVideoBufReadIdx[ch] = (P2PVideoBufReadIdx[ch] + 1) % VIDEO_BUF_NUM;
                }
            }

            ///------------------- Bitstream buffer control---------------------------------//
            /*
            Lsk: ?Video bitstream buffer ??index??F????E,L?? ASF_DROP_FRAME_THRESHOLD
            ????????,?drop frame.

            */
            if( (P2PVideoCmpSemEvt[ch]->OSEventCnt > 60) )
            {
                DEBUG_P2P("\nP2P-%d DROP Video frame Start:(%d,%d) \n",ch,P2PVideoPresentTime[ch],P2PAudioPresentTime[ch]);
                SyncTime=0;
                //------Video-----//
                do
                {
                    video_value[ch] = OSSemAccept(P2PVideoCmpSemEvt[ch]);
                    //DEBUG_P2P("%d ",video_value[ch]);
                    if (video_value[ch] > 0)
                    {
                        if(video_value_max[ch] < video_value[ch])
                            video_value_max[ch] = video_value[ch];

                        P2PVideoPresentTime[ch] += P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].time;
                        SyncTime += P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].time;
                        P2PVideoBufReadIdx[ch] = (P2PVideoBufReadIdx[ch] + 1) % VIDEO_BUF_NUM;
                    }
                    else
                    {
                        DEBUG_P2P("Video buffer empty!\n");
                        //break;
                        OSTimeDly(1);
                    }
                } while(P2PVideoBuf[ch][P2PVideoBufReadIdx[ch]].flag != FLAG_I_VOP);

                //------Audio-----//
                DEBUG_P2P("P2P-%d DROP Audio frame Start:%d,SyncTime=%d \n",ch,P2PAudioCmpSemEvt[ch]->OSEventCnt,SyncTime);

                do
                {
                    audio_value[ch] = OSSemAccept(P2PAudioCmpSemEvt[ch]);
                    //DEBUG_P2P("%d ",audio_value[ch]);

                    if (audio_value[ch] > 0)
                    {
                        if(audio_value_max[ch] < audio_value[ch])
                            audio_value_max[ch] = audio_value[ch];

                        P2PAudioPresentTime[ch] += P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time;
                        SyncTime -= P2PAudioBuf[ch][P2PAudioBufReadIdx[ch]].time;
                        P2PAudioBufReadIdx[ch] = (P2PAudioBufReadIdx[ch] + 1) % IIS_BUF_NUM;
                    }
                    else
                    {
                        DEBUG_P2P("Audio buffer empty!\n");
                        break;
                    }

                    if(SyncTime < 0)
                        break;
                }while( (P2PAudioPresentTime[ch] < P2PVideoPresentTime[ch]) );

                //P2PAudioPresentTime[ch] = P2PVideoPresentTime[ch];
                DEBUG_P2P("P2P-%d DROP frame End:(%d,%d)!!\n\n",ch,P2PVideoPresentTime[ch],P2PAudioPresentTime[ch]);
                sysDeadLockMonitor_Reset();
                DlyFlag=0;
                RunCount=0;
                //OSTimeDly(1);
            }

            if ( (video_value[ch] > 0) || (audio_value[ch] > 0) )
                DlyFlag=0;
        }

        if(DlyFlag)
        {
            RunCount=0;
            //DEBUG_P2P("&");
            OSTimeDly(1);

        }
        else
        {
            if( (RunCount & 0x03) == 0) //Lucian: release CPU power
            {
                //DEBUG_P2P("A=%d ",P2PAudioCmpSemEvt[0]->OSEventCnt);
                //DEBUG_P2P("Rcnt=%d ",RunCount);
                if(RunCount>100)
                    sysDeadLockMonitor_Reset();
                OSTimeDly(1);
            }
        }

        RunCount ++;
    }
}

#endif


extern u8 my_ipaddr[];

void Task_Login(void *UID) //  when succeed deleted by other task
{
    INT8U err;
    int ret = -1;

    DEBUG_P2P("### Task_Login start wait get IP.......\n");
    OSFlagPend(gpiNetStatusFlagGrp, FLAGGPI_LWIP_IP_READY, OS_FLAG_WAIT_SET_ANY, OS_IPC_WAIT_FOREVER, &err);
    DEBUG_P2P("### Task_Login start running[%s].......\n", gUID);
    DEBUG_P2P("### MyIp %u.%u.%u.%u\n", my_ipaddr[0], my_ipaddr[1], my_ipaddr[2], my_ipaddr[3]);

    while(1)
    {
        ret = IOTC_Device_Login((char *)gUID, NULL, NULL);
        DEBUG_P2P("@@@ IOTC_Device_Login() ret = %d\n", ret);

        if(ret == IOTC_ER_NoERROR)
        {
            gFlagLoginOK = 1;
            OSTimeDly(65000);  // switch to other task
            DEBUG_P2P("OSTimeDly break\n");
        }
        else
        {
            gLoginFaileCnt++;
            OSTimeDly(200);
        }
    }
}

void Task_Listen(void *pdata)
{
    int SID;
    INT8U err;
    int i;
    int ret;
    DEBUG_P2P("Task_Listen start wait get IP.......\n");
    OSFlagPend(gpiNetStatusFlagGrp, FLAGGPI_LWIP_IP_READY, OS_FLAG_WAIT_SET_ANY, OS_IPC_WAIT_FOREVER, &err);

    while(1)
    {

		// Accept connection only when IOTC_Listen() calling
		DEBUG_P2P("+++IOTC_Listen calling.....\n");

		SID = IOTC_Listen(0);
		if((SID == 5) || (gOnlineNum >= MAX_CLIENT))
        {
        	printf("Can't be Connected!\n");
        	OSTimeDly(200);
        	continue;
        }

        DEBUG_P2P("+++IOTC_Listen ret[%d].....\n", SID);

#if APP_KEEP_ALIVE
        /*==============================KEEP ALIVE==================================*/
        switch(SID)
        {
            case 0:
                RTC_Get_Time(&gKeepAliveTime0);
                break;
            case 1:
                RTC_Get_Time(&gKeepAliveTime1);
                break;
            case 2:
                RTC_Get_Time(&gKeepAliveTime2);
                break;
            case 3:
                RTC_Get_Time(&gKeepAliveTime3);
                break;
            case 4:
				RTC_Get_Time(&gKeepAliveTime4);
            default:
                break;
        }
        gFlagKeepAlive[SID] = 1;
        /*===============================KEEP ALIVE==================================*/
#endif

        if(SID > -1)
        {
            //aher test for encryption
            // cause 9200 network crash problem
            ret=IOTC_Set_Partial_Encryption(SID,1);
            DEBUG_P2P("Set partial encryption = %d\n",ret);
            DEBUG_P2P("IOTC_Listen ret SID[%d]\n", SID);

            client_p2pconnected(SID);
            AVServerStart(SID);

        }
        else if(SID == IOTC_ER_EXCEED_MAX_SESSION)
        {
            DEBUG_P2P("Listen fail : IOTC_ER_EXCEED_MAX_SESSION.\n");
            //for (i=0;i<MAX_CLIENT;i++)
            //client_p2pdisconnected(i);
            OSTimeDly(200);
        }

    }
}


void init_AVInfo()
{
    int i,j;
    for(i=0; i<MAX_CLIENT; i++)
        memset(&gClientInfo[i], 0, sizeof(AV_Client));
}

void renew_iotclModule(unsigned short port)
{

    int err;
    err=ReopenP2PSocket(port);
    DEBUG_P2P("ReopenP2PSocket:%d\n",err);
}

void ResetALL()
{
	int ret = -1;
	u8 	i;

	printf("\x1B[96m Reset TUTK. \x1B[0m\n");
	IOTC_DeInitialize();
	OSTaskDel(LISTEN_TASK_PRIORITY);
	OSTaskDel(LOGIN_TASK_PRIORITY);
    OSTaskDel(SESSION_TASK_PRIORITY);
	renewIP = 1;

	OSTimeDly(40);

	IOTC_Set_Max_Session_Number(MAX_CLIENT);
	// use which Master base on location, port 0 means to get a random port
	ret = IOTC_Initialize2(0);
	DEBUG_P2P("### IOTC_Initialize2() ret = %d\n", ret);
	if(ret != IOTC_ER_NoERROR)
	{
		DEBUG_P2P("### IOTC_Initialize2 failed process exit...!!\n");
		return;
	}
	ret = avInitialize(MAX_CLIENT * MAX_AV_CH);/*(MAX_CLIENT * MAX_AV_CH)*/
	DEBUG_P2P("avInitialize ret[%d]\n", ret);

	Reset_P2P_Session();

	gOnlineNum = 0;
	gFirstConnect=0;
	videoquality=2;
	for (i = 0; i < MAX_AV_CH; i++)
	{
		P2PEnableStreaming[i]=0;
		if(gClientInfo[i].bEnableSpeaker>0)
			Kill_Task_Speaker(i);
	}
	gFlagLoginOK = 0;
	if(OSTaskCreate(Task_Listen, (void *)0, LISTEN_TASK_STACK, LISTEN_TASK_PRIORITY) != OS_NO_ERR)
	{
		DEBUG_P2P("OSTaskCreate Task_Listen failed[%d]!\n", LISTEN_TASK_PRIORITY);
		return;
	}

	if(OSTaskCreate(Task_Login, (void *)0, LOGIN_TASK_STACK, LOGIN_TASK_PRIORITY) != OS_NO_ERR)
	{
		DEBUG_P2P("OSTaskCreate Task_Login failed!\n");
		return;
	}
    if(OSTaskCreate(Task_SessionHandler, (void *)0, SESSION_TASK_STACK, SESSION_TASK_PRIORITY) != OS_NO_ERR)
    {
        DEBUG_P2P("OSTaskCreate Task_SessionHandler failed[%d]!!!!!!!!!!!!!!!!\n", SESSION_TASK_PRIORITY);
        return;
    }

}

void tutkSampleInit()
{
    int ret = -1;
    unsigned long pnVersion;
    u8 err;

    /*Set the device function*/
    /*bit 18 Disable/Enable Gatewaybox*/
    /*bit 19 Disable/Enable TimeZone shfit on APP side.*/

#if REMOTE_FILE_PLAYBACK
    SERVTYPE_STREAM_SERVER=38880;	//5920//5984//6112 	// Disable WiFi setting,Format SDCard function,Record setting function. 			aher 2013/06/04
#else
    SERVTYPE_STREAM_SERVER=38904;//6136; 	// Disable WiFi setting,Format SDCard function,Record setting,File playback function.
#endif

#if GATEWAY_BOX
    SERVTYPE_STREAM_SERVER=SERVTYPE_STREAM_SERVER&0x7eff;
#endif

#if NIC_TIMEZONE_DISABLE
    SERVTYPE_STREAM_SERVER=SERVTYPE_STREAM_SERVER|0x20000;
#endif

#if(HW_BOARD_OPTION == MR8211_ZINWELL)
    SERVTYPE_STREAM_SERVER=0;
#endif
#if ((HW_BOARD_OPTION == MR8200_RX_TRANWO_D8593) || (HW_BOARD_OPTION == MR8200_RX_TRANWO_BOX))
    SERVTYPE_STREAM_SERVER=SERVTYPE_STREAM_SERVER|0x02;
#endif

    init_AVInfo();

    DEBUG_P2P("tutkSampleInit entry...\n");
    IOTC_Get_Version(&pnVersion);
    DEBUG_P2P("AVAPIver=%x,IOTCver=%x\n",avGetAVApiVer(),pnVersion);
    gUID = uiP2PID;
//	strcpy(gUID,"DLUA8X5WKVVCUN6GY14J");
    DEBUG_P2P("gUID = %s\n",gUID);

    //RTC_Get_Time(&gPushMsgTime);
    gPushMsgTime=0;

    Init_P2P_Session();
    IOTC_Set_Max_Session_Number(MAX_CLIENT+2);
    // use which Master base on location, port 0 means to get a random port
    //ret = IOTC_Initialize2(0);
    ret = IOTC_Initialize2(0);
    DEBUG_P2P("### IOTC_Initialize2() ret = %d\n", ret);
    if(ret != IOTC_ER_NoERROR)
    {
        DEBUG_P2P("### IOTC_Initialize2 failed process exit...!!\n");
        return;
    }
    // alloc MAX_CLIENT_NUMBER*2 for every session av data/speaker/
    ret = avInitialize((MAX_CLIENT * MAX_AV_CH)+1);/*(MAX_CLIENT * MAX_AV_CH)+ File playback*/
    DEBUG_P2P("avInitialize ret[%d]\n", ret);

#if 1
    if(OSTaskCreate(Task_Login, (void *)0, LOGIN_TASK_STACK, LOGIN_TASK_PRIORITY) != OS_NO_ERR)
    {
        DEBUG_P2P("OSTaskCreate Task_Login failed!!!!!!!!!!!!!!!!!!!\n");
        return;
    }
#endif

    if(OSTaskCreate(Task_SessionHandler, (void *)0, SESSION_TASK_STACK, SESSION_TASK_PRIORITY) != OS_NO_ERR)
    {
        DEBUG_P2P("OSTaskCreate Task_SessionHandler failed[%d]!!!!!!!!!!!!!!!!\n", SESSION_TASK_PRIORITY);
        return;
    }

    if(OSTaskCreate(Task_Listen, (void *)0, LISTEN_TASK_STACK, LISTEN_TASK_PRIORITY) != OS_NO_ERR)
    {
        DEBUG_P2P("OSTaskCreate Task_Listen failed[%d]!!!!!!!!!!!!!!!!!!!\n", LISTEN_TASK_PRIORITY);
        return;
    }
    //RTC_Get_Time(&gPushMsgTime);
    gPushMsgTime=0;

    DEBUG_P2P("2 tutkSampleInit OK!!!!!\n");

}
#else

   #include "arch/cc.h"


  #if (LWIP_PLATFORM_BYTESWAP == 0) && (BYTE_ORDER == LITTLE_ENDIAN) && ICOMMWIFI_SUPPORT

    u16_t
    htons(u16_t n)
    {
      return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
    }

    u16_t
    ntohs(u16_t n)
    {
      return htons(n);
    }

    u32_t
    htonl(u32_t n)
    {
      return ((n & 0xff) << 24) |
        ((n & 0xff00) << 8) |
        ((n & 0xff0000) >> 8) |
        ((n & 0xff000000) >> 24);
    }

    u32_t
    ntohl(u32_t n)
    {
      return htonl(n);
    }

  #endif /* (LWIP_PLATFORM_BYTESWAP == 0) && (BYTE_ORDER == LITTLE_ENDIAN) */

#endif

#if (HOME_RF_SUPPORT)
//Add for New Home Automation
int hacmd_func_sensor_pair(JS_CONVERT *jsInfo)
{
    int i=0, j=0, maxArguNm=4;//MaxArgu
    u32 matched = 0;
    jsmntok_t *tmp_tok = jsInfo->js_tok;
    const char *strSubCmd[] = {
                "test1",//Mapping to real JS sub CMD of Curr HA CMD
                "test2",
                "test3",
                "test4"
            };

//        ((jsInfo->js_tok+i)->end < (jsInfo->js_tok+jsInfo->curr_jstok)->end) && i < jsInfo->max_jstok;
    for(i= jsInfo->curr_jstok+1;
        ((tmp_tok+i)->end < (tmp_tok+jsInfo->curr_jstok)->end) && i < jsInfo->max_jstok;
        i++)
    {
        for(j=0; j < maxArguNm; j++ )
        {
            if(((matched & FOUNDED_KEY(j)) == 0) &&//Bypass key if got it.
                (jsoneq(jsInfo->buf, tmp_tok+i, strSubCmd[j]) == 0)) //Must be equal, double confirm
            { //Get key
                switch(j)
                { //Translate value to argument
                    case 0:
                    {
                    //Argument translate, should mapping with strSubCmd
//                        sprintf(num_temp, "%.*s", t[i+1].end-t[i+1].start, cmdStr + t[i+1].start);
//                        sUID = strtol(num_temp, NULL, 10);
                        i++;//Got value, going to next key
                        matched |= FOUNDED_KEY(j);
                    }
                    break;
                }
            }
        }
    }

    //Fill return JS string here
    //Use the same buffer to APP
    //jsInfo->buf
    //Notice, if here have second JSCMD in one IOCMD, it passable to cover next JSCMD
    return i;
}


//Add for New Home Automation
int hacmd_func_sensor_unpair(JS_CONVERT *jsInfo)
{
    int i=0, j=0, maxArguNm=4;//MaxArgu
    u32 matched = 0;
    jsmntok_t *tmp_tok = jsInfo->js_tok;
    const char *strSubCmd[] = {
                "test1",//Mapping to real JS sub CMD of Curr HA CMD
                "test2",
                "test3",
                "test4"
            };


    for(i= jsInfo->curr_jstok+1;
        ((tmp_tok+i)->end < (tmp_tok+jsInfo->curr_jstok)->end) && i < jsInfo->max_jstok;
        i++)
    {
        for(j=0; j < maxArguNm; j++ )
        {
            if(((matched & FOUNDED_KEY(j)) == 0) &&//Bypass key if got it.
                (jsoneq(jsInfo->buf, tmp_tok+i, strSubCmd[j]) == 0)) //Must be equal, double confirm
            { //Get key
                switch(j)
                { //Translate value to argument
                    case 0:
                    {
                    //Argument translate, should mapping with strSubCmd
//                        sprintf(num_temp, "%.*s", t[i+1].end-t[i+1].start, cmdStr + t[i+1].start);
//                        sUID = strtol(num_temp, NULL, 10);
                        i++;//Got value, going to next key
                        matched |= FOUNDED_KEY(j);
                    }
                    break;
                }
            }
        }
    }

    //Fill return JS string here
    //Use the same buffer to APP
    //jsInfo->buf
    //Notice, if here have second JSCMD in one IOCMD, it passable to cover next JSCMD
    return i;
}


//Add for New Home Automation
int hacmd_func_sensor_list(JS_CONVERT *jsInfo)
{
    int i=0, j=0, maxArguNm=4;//MaxArgu
    u32 matched = 0;
    jsmntok_t *tmp_tok = jsInfo->js_tok;
    const char *strSubCmd[] = {
                "test1",//Mapping to real JS sub CMD of Curr HA CMD
                "test2",
                "test3",
                "test4"
            };


    for(i= jsInfo->curr_jstok+1;
        ((tmp_tok+i)->end < (tmp_tok+jsInfo->curr_jstok)->end) && i < jsInfo->max_jstok;
        i++)
    {
        for(j=0; j < maxArguNm; j++ )
        {
            if(((matched & FOUNDED_KEY(j)) == 0) &&//Bypass key if got it.
                (jsoneq(jsInfo->buf, tmp_tok+i, strSubCmd[j]) == 0)) //Must be equal, double confirm
            { //Get key
                switch(j)
                { //Translate value to argument
                    case 0:
                    {
                    //Argument translate, should mapping with strSubCmd
//                        sprintf(num_temp, "%.*s", t[i+1].end-t[i+1].start, cmdStr + t[i+1].start);
//                        sUID = strtol(num_temp, NULL, 10);
                        i++;//Got value, going to next key
                        matched |= FOUNDED_KEY(j);
                    }
                    break;
                }
            }
        }
    }

    //Fill return JS string here
    //Use the same buffer to APP
    //jsInfo->buf
    //Notice, if here have second JSCMD in one IOCMD, it passable to cover next JSCMD
    return i;
}


//Add for New Home Automation
int hacmd_func_sensor_log(JS_CONVERT *jsInfo)
{
    int i=0, j=0, maxArguNm=4;//MaxArgu
    u32 matched = 0;
    jsmntok_t *tmp_tok = jsInfo->js_tok;
    const char *strSubCmd[] = {
                "test1",//Mapping to real JS sub CMD of Curr HA CMD
                "test2",
                "test3",
                "test4"
            };


    for(i= jsInfo->curr_jstok+1;
        ((tmp_tok+i)->end < (tmp_tok+jsInfo->curr_jstok)->end) && i < jsInfo->max_jstok;
        i++)
    {
        for(j=0; j < maxArguNm; j++ )
        {
            if(((matched & FOUNDED_KEY(j)) == 0) &&//Bypass key if got it.
                (jsoneq(jsInfo->buf, tmp_tok+i, strSubCmd[j]) == 0)) //Must be equal, double confirm
            { //Get key
                switch(j)
                { //Translate value to argument
                    case 0:
                    {
                    //Argument translate, should mapping with strSubCmd
//                        sprintf(num_temp, "%.*s", t[i+1].end-t[i+1].start, cmdStr + t[i+1].start);
//                        sUID = strtol(num_temp, NULL, 10);
                        i++;//Got value, going to next key
                        matched |= FOUNDED_KEY(j);
                    }
                    break;
                }
            }
        }
    }

    //Fill return JS string here
    //Use the same buffer to APP
    //jsInfo->buf
    //Notice, if here have second JSCMD in one IOCMD, it passable to cover next JSCMD
    return i;
}


//Add for New Home Automation
int hacmd_func_sensor_info(JS_CONVERT *jsInfo)
{
    int i=0, j=0, maxArguNm=4;//MaxArgu
    u32 matched = 0;
    jsmntok_t *tmp_tok = jsInfo->js_tok;
    const char *strSubCmd[] = {
                "test1",//Mapping to real JS sub CMD of Curr HA CMD
                "test2",
                "test3",
                "test4"
            };


    for(i= jsInfo->curr_jstok+1;
        ((tmp_tok+i)->end < (tmp_tok+jsInfo->curr_jstok)->end) && i < jsInfo->max_jstok;
        i++)
    {
        for(j=0; j < maxArguNm; j++ )
        {
            if(((matched & FOUNDED_KEY(j)) == 0) &&//Bypass key if got it before.
                (jsoneq(jsInfo->buf, tmp_tok+i, strSubCmd[j]) == 0)) //Must be equal, double confirm
            { //Get key
                switch(j)
                { //Translate value to argument
                    case 0:
                    {
                    //Argument translate, should mapping with strSubCmd
//                        sprintf(num_temp, "%.*s", t[i+1].end-t[i+1].start, cmdStr + t[i+1].start);
//                        sUID = strtol(num_temp, NULL, 10);
                        i++;//Got value, going to next key
                        matched |= FOUNDED_KEY(j);
                    }
                    break;
                }
            }
        }
    }

    //Fill return JS string here
    //Use the same buffer to APP
    //jsInfo->buf
    //Notice, if here have second JSCMD in one IOCMD, it passable to cover next JSCMD
    return i;
}
#endif
